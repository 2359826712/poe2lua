package.path = package.path .. ';./path/to/module/?.lua'

-- 根据otherworld.json实现的完整行为树系统
package.path = package.path .. ';lualib/?.lua'
local behavior_tree = require 'script.lualib.behavior3.behavior_tree'
local bret = require 'script.lualib.behavior3.behavior_ret'
-- 加载基础节点类型
local base_nodes = require 'script.lualib.behavior3.sample_process'
local my_game_info = require 'script/my_game_info'

local script_path = debug.getinfo(1, "S").source:sub(2)
local path = script_path:gsub("/", "\\")
local script_dir = path:match("(.*\\)(.*)\\")
local json_path = script_dir .. "config.json"
local user_info_path = script_dir .. "config.ini"
local json = require 'script.lualib.json'

api_Log("清除 poe2api 模块的缓存")
package.loaded['script/poe2api'] = nil
package.loaded['json'] = nil

local poe2_api = require "script/poe2api"
local json = require 'script.lualib.json'

-- 自定义节点实现
local custom_nodes = {
    -- 获取用户配置信息
    Get_User_Config_Info = {
        run = function(self, env)
            poe2_api.print_log("获取用户配置信息...")
            local start_time = api_GetTickCount64() -- 开始时间
            if not env.user_config then
                local config = poe2_api.load_config(json_path)
                local user_info = poe2_api.load_ini(user_info_path)["UserInfo"]
                -- 玩法優先級
                local map_priority = config["刷圖設置"]["玩法優先級"]
                local map_sorted_items_sort = poe2_api.sort_map_by_key(map_priority)
                poe2_api.printTable(map_sorted_items_sort)
                if map_priority['是否開啟'] then
                    env.sorted_map = map_sorted_items_sort
                else
                    env.sorted_map = nil
                end
                poe2_api.dbgp("1111111111...")
                -- # 碑牌順序
                local play_priority = config["刷圖設置"]["碑牌優先級"]
                local sorted_keys = poe2_api.sort_map_by_key(play_priority)
                local result = {}
                for _, key in ipairs(sorted_keys) do
                    if my_game_info.map_type[key] then
                        table.insert(result, my_game_info.map_type[key])
                    end
                end         
                env.user_config = config
                env.user_info = user_info
                env.stone_order = result
                env.is_insert_stone = play_priority["是否開啟"]

                -- 检查是否需要售卖地图
                env.need_sale_map = config["全局設置"]["刷图通用設置"]["自动清理地图(个人仓库)"]
                
                local item_filters = config["物品過濾"] or {}  -- 获取物品过滤配置数组
                -- 两种独立的分类表
                local item_config_by_type = {}      -- 按【類型】分类
                local item_config_by_base_type = {} -- 按【基礎類型名】分类

                for _, filter in ipairs(item_filters) do
                    if not filter["不撿"] then
                        -- ========== 按【類型】分类 ==========
                        local item_type = filter["類型"] or "未分类"
                        if not item_config_by_type[item_type] then
                            item_config_by_type[item_type] = {}
                        end
                        table.insert(item_config_by_type[item_type], filter)  -- 直接引用原数据

                        -- ========== 按【基礎類型名】分类 ==========
                        local base_type = filter["基礎類型名"] or "全部物品"
                        if not item_config_by_base_type[base_type] then
                            item_config_by_base_type[base_type] = {}
                        end
                        table.insert(item_config_by_base_type[base_type], filter)  -- 直接引用原数据
                    end
                end

                env.item_config_name = item_config_by_base_type
                env.item_config_type = item_config_by_type

                -- 滴注操作
                local map_cfg = config['刷圖設置'] or {}
                poe2_api.process_void_maps(map_cfg)
                env.dist_ls = config["刷圖設置"]['異界地圖索引']["涂油设置"] or {}
                -- 更新地图相关设置（添加空值保护）
                env.user_map = (config["刷圖設置"] or {})["地圖鑰匙"] or ""
                -- poe2_api.printTable(env.user_map)
                -- api_Sleep(100000)
                env.not_use_map = (config['刷圖設置'] or {})["不打地圖詞綴"] or {}
                env.priority_map = (config["刷圖設置"] or {})["優先打地圖詞綴"] or {}
                env.not_enter_map = (config["刷圖設置"] or {})["不打地圖名"] or {}

                -- 处理怪物躲避设置（添加空值保护）
                local global_settings = config["全局設置"] or {}
                local common_settings = global_settings["刷图通用設置"] or {}
                local monster_avoid = common_settings["怪物近距離躲避"] or {}

                env.space = monster_avoid["是否開啟"] or false
                env.space_time = monster_avoid["閾值"] or 0
                env.space_config = monster_avoid

                local space_monster = {}

                -- 检查每种怪物类型是否存在，不存在则默认为false
                if monster_avoid["白"] then
                    table.insert(space_monster, 0)
                end
                if monster_avoid["藍"] then
                    table.insert(space_monster, 1)
                end
                if monster_avoid["黃"] then
                    table.insert(space_monster, 2)
                end
                if monster_avoid["Boss"] then
                    table.insert(space_monster, 3)
                end

                env.space_monster = space_monster

                env.is_bird = env.user_config["全局設置"]["刷图通用設置"]["是否骑鸟"] or false

                -- 处理保护设置
                local protection_cfg = config["全局設置"]["保護設置"] or {}
                
                -- 解析保护配置的辅助函数
                local function parse_protection(item_cfg)
                    item_cfg = item_cfg or {}
                    local enable_flag = item_cfg["是否開啟"]
                    
                    -- 处理启用标志
                    local enabled
                    if type(enable_flag) == "boolean" then
                        enabled = enable_flag
                    elseif type(enable_flag) == "string" then
                        enabled = (enable_flag:lower():gsub("%s+", "") == "true" or 
                                enable_flag == "1" or 
                                enable_flag:lower() == "yes")
                    else
                        enabled = false
                    end
                    
                    -- 处理数值
                    local function parse_number(value, default)
                        if value == nil then return default end
                        local num = tonumber(value)
                        return num or default
                    end
                    
                    return {
                        enable = enabled,
                        threshold = parse_number(item_cfg["閾值"], 0),
                        interval = parse_number(item_cfg["使用間隔"], 0)
                    }
                end
                
                -- 解析保护设置
                local protection_settings = {
                    health_recovery = parse_protection(protection_cfg["血少回血"]),
                    mana_recovery = parse_protection(protection_cfg["藍少回藍"]),
                    shield_recovery = parse_protection(protection_cfg["盾少回血"])
                }
                
                -- 解析紧急设置
                local emergency_settings = {
                    low_health = parse_protection(protection_cfg["血少逃跑"]),
                    low_mana = parse_protection(protection_cfg["藍少逃跑"]),
                    low_shield = parse_protection(protection_cfg["盾少逃跑"]),
                }
                
                -- 设置到黑板
                env.protection_settings = protection_settings
                env.emergency_settings = emergency_settings

                -- 查找最小攻击距离
                local skill_config = config["技能設置"]
                local min_distance = math.huge  -- 初始化为一个很大的数

                for _, v in pairs(skill_config) do 
                    -- if v["启用"] and v["技能屬性"] == "攻击技能" and (v["白怪"] or v["藍怪"] or v["黃怪"] or v["Boss"]) then
                    if v["启用"] and v["技能屬性"] == "攻击技能" and (v["白怪"] or v["藍怪"] or v["黃怪"]) then
                        if v["攻擊距離"] < min_distance then
                            min_distance = v["攻擊距離"]
                        end
                    end
                end

                -- 边走边释放技能
                -- env.walk_attack = env.user_config["全局設置"]["刷图通用設置"]["边走边释放技能"] or false

                -- 如果没有找到符合条件的技能，设置默认值
                if min_distance == math.huge then
                    min_distance = 100  -- 默认攻击距离
                    -- print("警告：未找到符合条件的攻击技能，使用默认攻击距离：" .. min_distance)
                end

                env.min_attack_dis = min_distance
                poe2_api.dbgp("env.min_attack_dis ==>>", env.min_attack_dis)
                -- api_Sleep(1000000)

                -- 加载躲避技能

                if not self.open_mos_skill then
                    self.open_mos_skill = true
                    local skills = config["全局設置"]["刷图通用設置"]["是否躲避技能"]
                    if skills then
                        -- 圆形
                        for _,k in ipairs(my_game_info.MonitoringSkills_Circle) do
                            -- poe2_api.dbgp(k[2])
                            api_RegisterCircle(k[2] , k[3])
                        end

                        -- 扇形
                        for _,k in ipairs(my_game_info.MonitoringSkills_Sector) do
                            -- poe2_api.dbgp(k[2])
                            api_RegisterSector(k[1] , 0, k[2], k[3])
                        end

                        -- 矩形
                        for _,k in ipairs(my_game_info.MonitoringSkills_Rect) do
                            -- poe2_api.dbgp(k[2])
                            api_RegisterRect(k[1] , k[2], k[3])
                        end
                    end
                    -- # 高傷害技能
                    for _,k in ipairs(my_game_info.High_Damage_Skill) do
                        api_RegisterCircle(k[2] , k[3], 2)
                    end
                end

                --  获取配置中的大号名字
                env.leader_name = config["全局設置"]["跟随设置"]["大号名称"] or nil
                env.follow_move = config["全局設置"]["跟随设置"]["是否開啟"] or false
            end
            poe2_api.time_p("Get_User_Config_Info... 耗时 --> ", api_GetTickCount64() - start_time)

            -- while true do
            --     Actors:Update() 
            --     api_Sleep(100)
            --     return bret.RUNNING
            -- end

            return bret.SUCCESS
        end
    },

    -- 判断游戏窗口 poe2_api.time_p("判断游戏窗口... 耗时 --> ", api_GetTickCount64() - current_time)
    Is_Game_Windows={
        run = function(self, env)
            poe2_api.print_log("判断游戏窗口")
            local current_time = api_GetTickCount64()

            if not env.user_info then
                local user_info = poe2_api.load_ini(user_info_path)["UserInfo"]
                env.user_info = user_info
            end
            local game_path = env.user_info["gamedir"]
            poe2_api.dbgp("game_path:"..game_path)
            local process_name = string.find(game_path:lower(), "steam.exe") and "PathOfExileSteam.exe" or "PathOfExile.exe"
            if not env.config_file then
                -- 获取文档目录路径
                env.documents_path = os.getenv('USERPROFILE') .. '\\Documents'
                -- 构建配置目录路径
                env.config_dir = env.documents_path .. '\\My Games\\Path of Exile 2'
                -- 构建配置文件路径
                env.config_file = env.config_dir .. '\\poe2_production_Config.ini'
            end
            

            -- local elapsed_ms = (api_GetTickCount64()) - start_time
            -- poe2_api.dbgp("构建配置文件路径:"..string.format( elapsed_ms))
            -- if env.hwrd_time ~=0 then
            --     poe2_api.dbgp("时间差值：:"..api_GetTickCount64() - env.hwrd_time)
            -- end
            poe2_api.dbgp("hwrd_time1:"..env.hwrd_time)
            if env.hwrd_time == 0 or os.time() - env.hwrd_time >= 60 then
                env.game_window = api_FindWindowByProcess("","Path of Exile 2",process_name,0)
                poe2_api.dbgp("game_window:"..env.game_window)
                env.hwrd_time = os.time()
                poe2_api.dbgp("------------------")
                poe2_api.dbgp("hwrd_time2:"..env.hwrd_time)
                -- api_Sleep(5000)
                -- elapsed_ms = (api_GetTickCount64()) - start_time
                -- poe2_api.dbgp("获取窗口句柄:"..string.format( elapsed_ms))
            end
            
            
            -- 判断游戏窗口
            if (not env.game_window or env.game_window == 0) and not env.error_kill then
                poe2_api.dbgp("窗口不存在==================================================")
                -- 判断游戏配置文件是否存在
                local file = io.open(env.config_file, "r")
                if file then
                    file:close()
                    if poe2_api.check_NCStorageLocalData_config(env.config_dir) then
                        poe2_api.print_log("游戏配置文件异常,替换配置文件")
                        poe2_api.set_NCStorageLocalData_config(env.config_file)
                        poe2_api.time_p("判断游戏窗口(RUNNING)... 耗时 --> ", api_GetTickCount64() - current_time)
                        return bret.RUNNING
                    end
                end
                env.is_set = false
                env.take_rest =false
                env.game_window = 0
                env.hwrd_time = 0
                -- error("窗口不存在=")
                -- api_Sleep(5000)
                -- elapsed_ms = (api_GetTickCount64()) - start_time
                -- poe2_api.dbgp("判断游戏窗口:"..string.format( elapsed_ms))
                poe2_api.time_p("判断游戏窗口(FAIL)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.FAIL
            end
            poe2_api.time_p("判断游戏窗口(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
            return bret.SUCCESS
        end
    },

    -- 加入游戏异界
    Join_Game_Otherworld = {
        run = function(self, env)
            poe2_api.print_log("加入异界游戏...")
            if not self.bool then
                self.config_exe = false
                self.bool = true
            end
            local start_time = api_GetTickCount64()  -- 转换为 ms

            local game_path = env.user_info["gamedir"]
            poe2_api.dbgp("game_path:"..game_path)
            local process_name = string.find(game_path:lower(), "steam.exe") and "PathOfExileSteam.exe" or "PathOfExile.exe"
            
            
            if env.time_out == 0 then
                env.time_out = os.time()
            end
            -- 判断是否关闭游戏
            if env.speel_ip_number >= 50 
            or env.error_kill 
            or env.is_set 
            or env.switching_lines>=120 
            or poe2_api.find_text({text = "This operation requires the account to be logged in.", UI_info = env.UI_info})
            or poe2_api.find_text({text = "> 已斷線: Unable to deserialise packet with pid", UI_info = env.UI_info,min_x = 0}) then
                poe2_api.dbgp("error_kill:", env.error_kill)
                poe2_api.dbgp("speel_ip_number:" , env.speel_ip_number)
                poe2_api.dbgp("is_set:", env.is_set)
                poe2_api.dbgp("switching_lines:", env.switching_lines)
                poe2_api.dbgp("find_test (to be logged in.):", poe2_api.find_text({text = "This operation requires the account to be logged in.", UI_info = env.UI_info}))
                poe2_api.dbgp("find_test (packet with pid):", poe2_api.find_text({text = "> 已斷線: Unable to deserialise packet with pid", UI_info = env.UI_info,min_x = 0}))
                env.is_game_exe = false
                env.login_state = nil
                env.speel_ip_number = 0
                env.switching_lines = 0
                env.account_state = nil
                env.time_out = 0
                env.error_kill = false
                
                env.hwrd_time = 0
                local pid = api_EnumProcess(process_name)
                
                if pid and next(pid) and pid[1]~=0 then
                    api_SetWindowState(env.game_window, 13)
                    env.game_window = 0
                    -- poe2_api.terminate_process(pid)
                    api_Sleep(10000)
                    return bret.RUNNING
                end
                
                -- error("关闭游戏===============")
                -- api_Sleep(5000)
                poe2_api.time_p("关闭游戏(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local elapsed_ms = (api_GetTickCount64()) - start_time
            poe2_api.dbgp("判断是否关闭游戏:"..string.format( elapsed_ms))
             -- 加载中
            if poe2_api.click_text_UI({UI_info = env.UI_info, text = "loading_screen_tip_label"}) then
                env.last_exp_check = api_GetTickCount64()
                env.last_exception_time = 0
                env.need_SmallRetreat = false
                env.need_ReturnToTown = false
                env.enter_map_click_counter = 0
                env.sacrificial_refresh = 0
                env.have_ritual = false
                env.find_path_failure = 0
                env.stuck_monsters = nil
                env.is_dizhu = false
                env.dizhu_end = false
                env.click_grid_pos = false
                env.need_item = nil
                env.interactive = nil
                env.not_items_buy = false
                env.open_map_UI = false -- 重置地图UI信息
                env.not_need_take = false --要不要拿油
                env.is_over = false 
                local current_time = api_GetTickCount64()
                env.last_exception_time_move = 0.0
                env.last_exp_check_move = current_time
                if env.player_info and env.player_info.grid_x ~=0 then
                    env.last_exp_value = env.player_info.currentExperience
                    env.last_exp_value_move = env.player_info.currentExperience
                end
                poe2_api.dbgp("已重置所有经验监控状态") 
                api_Sleep(2000)
                env.switching_lines =  env.switching_lines + 1
                poe2_api.time_p("加载中(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            -- if poe2_api.find_text({text = "選擇一種位移類型",UI_info = env.UI_info}) then
            --     poe2_api.find_text({text = "滑鼠",UI_info = env.UI_info, click = 2})
            --     poe2_api.time_p("Join_Game_Otherworld(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
            --     return bret.RUNNING
            -- end
            elapsed_ms = (api_GetTickCount64()) - start_time
            poe2_api.dbgp("判断文本:"..string.format( elapsed_ms))
            if poe2_api.click_text_UI({text = "life_orb",UI_info = env.UI_info})
             or poe2_api.click_text_UI({text = "resume_game",UI_info = env.UI_info})
              or poe2_api.find_text({text = "清單",UI_info = env.UI_info,min_x = 0,min_y = 0,max_x = 400}) then
                local player_info = env.player_info
                local changer_leader = env.changer_leader
                env.kill_process = true
                env.switching_lines = 0
                if not self.config_exe then
                    local file = io.open(env.config_file, "r")
                    if file then
                        file:close()
                        if poe2_api.check_NCStorageLocalData_config(env.config_dir) then
                            poe2_api.print_log("游戏配置文件异常,需要关闭游戏")
                            env.is_set = true
                            poe2_api.time_p("游戏配置文件异常,需要关闭游戏(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        else
                            self.config_exe = true
                        end
                    end
                end
                
                if player_info and next(player_info) then
                   if poe2_api.table_contains(player_info.current_map_name_utf8,{"MapAugury","MapAugury_NoBoss","MapAzmerianRanges_NoBoss","MapAzmerianRanges"}) then
                    -- 自动刷新屏障开关接口(缺失) 开
                    api_UpdateMapObstacles(100)
                    poe2_api.dbgp("自动刷新屏障开关接口(缺失) 开==================")
                --    else
                --     -- 自动刷新屏障开关接口(缺失) 关
                --     api_UpdateMapObstacles(false)
                   end
                end
                poe2_api.dbgp("已进入游戏")
                -- 计算当前 Tick 耗时（毫秒）
                poe2_api.time_p("已进入游戏耗时(SUCCESS)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local text_list = {"與副本連線失敗。","伺服器斷線。","> Steam：未連接到 Steam","Steam：未連接到 Steam","已斷線","操作逾時","由於在短時間內執行過多指令，因此被伺服器暫時切斷連線。"}
            if poe2_api.find_text({text = text_list,UI_info = env.UI_info,min_x = 0}) then
                poe2_api.find_text({text = "確定",UI_info = env.UI_info,min_x = 0,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            end
            if poe2_api.find_text({UI_info = env.UI_info,text = "此 IP 已被封鎖。有任何疑問請與客服中心聯繫。",min_x = 0}) then
                poe2_api.find_text({text = "確定",UI_info = env.UI_info,min_x = 0,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            end
            -- if poe2_api.find_text({text = "Steam：未連接到 Steam",UI_info = env.UI_info}) then
            --     poe2_api.find_text({text = "確定",UI_info = env.UI_info,min_x = 0,click = 2})
            --     api_Sleep(1000)
            --     return bret.RUNNING
            -- end

            if poe2_api.find_text({text = "伺服器關閉維修中，請稍後再試。",UI_info = env.UI_info,min_x = 0}) then
                api_Sleep(1000)
                error("服务器维护中,已停止运行")
            end
            if poe2_api.find_text({text = "Your account has been banned by an administrator.",UI_info = env.UI_info}) then
                api_Sleep(1000)
                error("封号!!!")
            end
            if poe2_api.find_text({text = "登入錯誤",UI_info = env.UI_info}) then
                api_Sleep(1000)
                error("账号或者密码错误")
            end
            if poe2_api.find_text({text = {"此帳號已被鎖定，請至信箱確認解鎖郵件中的解鎖碼並在此輸入。","重新寄送解鎖信"},UI_info = env.UI_info,min_x = 0}) then
                api_Sleep(1000)
                error("请手动处理邮箱验证")
            end
            if poe2_api.find_text({text = "此帳號已被其他使用者登入。",UI_info = env.UI_info}) then
                api_Sleep(1000)
                error("此帳號已被其他使用者登入。")
            end
            
            local text_list1 = {"Login Error","The operation timed out.","Entry to this league has closed.","Abnormal Disconnection","Disconnection","Disconnected","偵測到老舊的 GPU 驅動程式。請更新至最新版本。","你的帳號沒有《流亡黯道 2》的搶 先體驗資格。立即在我們的網站上領取搶先體驗金鑰或購買資格。","搶先體驗"}
            if poe2_api.find_text({text = text_list1,UI_info = env.UI_info}) then
                poe2_api.find_text({text = "確定",UI_info = env.UI_info,min_x = 0,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            end
            if poe2_api.find_text({text = "Your IP has been banned. Please contact support if you think this is a mistake.",UI_info = env.UI_info}) then
                env.speel_ip_number = env.speel_ip_number + 1
                poe2_api.find_text({text = "確定",UI_info = env.UI_info,min_x = 0,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING       
            end
            if poe2_api.find_text({text = "同意",UI_info = env.UI_info}) then
                poe2_api.find_text({text = "同意",UI_info = env.UI_info,min_x = 0,add_x = 150,click = 2,times = 500})
                poe2_api.find_text({text = "繼續",UI_info = env.UI_info,min_x = 800,min_y = 450,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            end
            if poe2_api.find_text({text = "建立帳號",UI_info = env.UI_info,min_x = 0,max_y = 790})
            or poe2_api.find_text({text = "若要使用 Steam 登入，你必須先建立一個 Steam 的《流亡黯道》帳號。",UI_info = env.UI_info,min_x = 0}) then
                poe2_api.find_text({text = "帳號名稱",UI_info = env.UI_info,min_x = 0,add_x = 161,click = 2,times = 500})
                api_Sleep(500)
                local text = poe2_api.generate_random_string(math.random(8, 10))
                
                poe2_api.paste_text(text)
                api_Sleep(500)
                poe2_api.find_text({text = "帳號名稱",UI_info = env.UI_info,min_x = 0,add_x = 110,add_y = 53,click = 2,times = 500})
                api_Sleep(500)
                return bret.RUNNING
            end
            local account = env.user_info["account"]
            local password = env.user_info["password"]
            if poe2_api.click_text_UI({text = "username_textbox",UI_info = env.UI_info}) and not poe2_api.find_text({text = account,UI_info = env.UI_info,min_x = 646,min_y = 572,max_x = 953,max_y = 609}) then
                poe2_api.click_text_UI({text = "username_textbox",UI_info = env.UI_info,click = 1})
                api_Sleep(500)
                poe2_api.paste_text(account)
                api_Sleep(500)
                return bret.RUNNING
            end
            if poe2_api.click_text_UI({text = "password_textbox",UI_info = env.UI_info}) and not poe2_api.find_text({text = password,UI_info = env.UI_info,min_x = 646,min_y = 623,max_x = 953,max_y = 660}) then
                poe2_api.click_text_UI({text = "password_textbox",UI_info = env.UI_info,click = 1})
                api_Sleep(500)
                poe2_api.paste_text(password)
                api_Sleep(500)
                return bret.RUNNING
            end
            if poe2_api.click_text_UI({text = "login_button",UI_info = env.UI_info}) then
                poe2_api.find_text({text = "登入",UI_info = env.UI_info,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            end
            if poe2_api.find_text({text = "已驗證。",UI_info = env.UI_info,min_x = 0})
            and poe2_api.find_text({text = "開始遊戲",UI_info = env.UI_info}) then
                poe2_api.dbgp1("dsgvfsdvsdzvdv")
                poe2_api.click_keyboard("space")
                return bret.RUNNING
            end
            if poe2_api.find_text({text = "Standard",UI_info = env.UI_info}) then
                poe2_api.find_text({text = "Standard",UI_info = env.UI_info,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            end
            local creat_new_role = env.creat_new_role
            if poe2_api.find_text({text = "開始遊戲",UI_info = env.UI_info}) 
            and not creat_new_role then
                poe2_api.find_text({text = "開始遊戲",UI_info = env.UI_info,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            else
                poe2_api.find_text({text = "建立角色",UI_info = env.UI_info,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            end 
            poe2_api.dbgp("UI未找到任何元素") 
            return bret.RUNNING 
        end
    },

    -- 官方加入游戏
    Official_Join_Game = {
        run = function(self, env)
            poe2_api.print_log("通过官方渠道加入游戏...")
            local current_time = api_GetTickCount64()

            local function launch_poe2(game_path, game_dir)
                --[[
                专门用于启动Path of Exile 2的函数
                
                参数:
                    game_path: PoE2主程序路径
                    game_dir: PoE2安装目录
                返回:
                    bool: 启动是否成功
                ]]--
                
                -- 检查文件和目录是否存在
                local file = io.open(game_path, "r")
                if not file then
                    poe2_api.dbgp(string.format("游戏程序未找到: %s", game_path))
                    return false
                end
                file:close()
                
                -- 检查目录是否存在
                local dir_handle = io.popen('cd "'..game_dir..'" 2>&1')
                local dir_result = dir_handle:read("*a")
                dir_handle:close()
                if dir_result:find("系统找不到指定的路径") or dir_result:find("cannot find the path") then
                    poe2_api.dbgp(string.format("游戏目录未找到: %s", game_dir))
                    return false
                end
                
                -- 启动游戏
                
                local command = string.format('start "" /D "%s" "%s"', game_dir, game_path)
                local launch_ok = os.execute(command)
                
                -- 检查启动结果
                if launch_ok then
                    poe2_api.print_log("游戏启动成功")
                    return true
                else
                    poe2_api.dbgp(string.format("游戏启动失败: %s", launch_ok))
                    return false
                end
            end
            local function get_dirname(path)
                -- 处理 Windows 路径分隔符
                path = path:gsub("/", "\\")
                -- 移除末尾的斜杠（如果有）
                path = path:gsub("[\\/]+$", "")
                -- 获取最后一个斜杠之前的部分
                local dir = path:match("^(.*)[\\/]") or "."
                return dir
            end
            local launch_timeout = env.launch_timeout
            local game_path = env.user_info["gamedir"]
            local is_steam_version = string.find(game_path:lower(), "steam.exe")
            -- 判断官方/steam
            if is_steam_version then
                poe2_api.print_log("steam版本============================================")
                return bret.FAIL
            end
            if launch_timeout ~= 0 and launch_timeout then
                if os.time() - launch_timeout > 120 then
                    poe2_api.print_log("官方游戏启动超时2分钟，重新启动")
                    local pid = api_EnumProcess("PathOfExile.exe")
                    local game_window = api_FindWindowByProcess("","Path of Exile 2","PathOfExile.exe",0)
                    if pid and next(pid) and pid[1] ~= 0 and game_window and game_window ~= 0 then
                        api_SetWindowState(game_window, 13)
                        -- poe2_api.terminate_process(pid)
                        env.game_window = 0
                        env.hwrd_time = 0
                        api_Sleep(10000)
                        return bret.RUNNING
                    end
                    env.kill_process=false
                    env.launch_timeout = 0
                    return bret.RUNNING
                else 
                    poe2_api.print_log("等待游戏窗口")
                    return bret.RUNNING
                end
            end
            -- 判断游戏窗口
            -- local pid = nil
            local pid1 = false

            local window_handlesteam = api_FindWindowByProcess("","Path of Exile 2","PathOfExileSteam.exe",0)
            if window_handlesteam and window_handlesteam ~= 0 then
                pid1 = true
                
            end

            local window_handle = api_FindWindowByProcess("","Path of Exile 2","PathOfExile.exe",0)
            if window_handle and window_handle ~= 0 then
                pid1 = true
                
            end
            if pid1 then
                poe2_api.print_log("第一次启动,清理游戏进程")
                if window_handlesteam and window_handlesteam ~= 0 then
                    api_SetWindowState(window_handlesteam, 13)
                    env.game_window = 0
                    env.hwrd_time = 0
                    api_Sleep(10000)
                    return bret.RUNNING
                end
                if window_handle and window_handle ~= 0 then
                    api_SetWindowState(window_handle, 13)
                    env.game_window = 0
                    env.hwrd_time = 0
                    api_Sleep(10000)
                    return bret.RUNNING
                end
                -- poe2_api.terminate_process(pid)
                
            end

            -- 启动游戏
            local game_dir = get_dirname(game_path)
            local launch_result = launch_poe2(game_path, game_dir)
            if launch_result then
                poe2_api.print_log("游戏启动成功")
                if launch_timeout == 0 then
                    env.launch_timeout = os.time()
                end
                api_Sleep(5000)
            else
                poe2_api.print_log("游戏启动失败")
            end
            return bret.RUNNING
        end
    },

    -- 通过Steam启动游戏
    Launch_Game_Steam = {
        
        run = function(self, env)
            poe2_api.print_log("通过Steam启动游戏...")
            -- local login_state = env.login_state
            local game_path = env.user_info["gamedir"]
            if not self.last_time then
                self.last_time = 0
                return bret.RUNNING
            end
            poe2_api.dbgp("login_state: "..tostring(env.login_state))
            if not env.login_state then
                poe2_api.print_log("清空数据")
                env.kill_process=false
                env.game_window = 0
                env.hwrd_time = 0
                poe2_api.delete_steam_account_history(game_path)
                local steam_pid = api_EnumProcess("steam.exe")
                poe2_api.dbgp(tostring(#steam_pid.."==========================="))
                poe2_api.dbgp(tostring(steam_pid[1].."==========================="))
                -- for k, v in pairs(steam_pid) do
                --     poe2_api.dbgp(tostring(k) .. tostring(v))
                -- end
                poe2_api.dbgp("steam_pid: "..tostring(steam_pid))
                if steam_pid and next(steam_pid) and steam_pid[1] ~= 0 then
                    poe2_api.exec_cmd("taskkill /f /im steam.exe")
                    api_Sleep(2000)
                    return bret.RUNNING
                end
                local steamwebhelper_pid = api_EnumProcess("steamwebhelper.exe")
                poe2_api.dbgp(tostring(#steamwebhelper_pid.."===========================1111"))
                if steamwebhelper_pid and next(steamwebhelper_pid) and  steamwebhelper_pid[1] ~= 0 then
                    poe2_api.exec_cmd("taskkill /f /im steamwebhelper.exe")
                    api_Sleep(2000)
                    return bret.RUNNING
                end
                env.login_state = "启动登录窗口"
                if self.last_time == 0 then
                    self.last_time = os.time()
                end
                return bret.RUNNING
            end
            if env.login_state == "启动登录窗口" then
                -- local start_path = string.format("%s -applaunch %d", game_path, 2694490)
                local start_cmd = string.format('start "" "%s" -applaunch %d', game_path, 2694490)
                local steam_pid = api_EnumProcess("steam.exe")
                if not steam_pid or not next(steam_pid) or steam_pid[1] == 0 then
                    poe2_api.exec_cmd(start_cmd)
                    poe2_api.dbgp("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
                    api_Sleep(5000)
                    env.login_state = "等待登录窗口"
                    self.last_time = os.time()
                    return bret.RUNNING
                end
            end
            if env.login_state == "等待登录窗口" then
                local steam_login_hwnd = api_FindWindow("SDL_app", "登录 Steam",0)
                if steam_login_hwnd and steam_login_hwnd ~= 0 then
                    env.login_state = "输入帳號"
                    self.last_time = os.time()
                    return bret.RUNNING
                end
                poe2_api.print_log("等待登录窗口")
                if os.time() - self.last_time > 120 then
                    poe2_api.print_log("等待登录窗口超时")
                    env.login_state = nil
                    self.last_time = 0
                    return bret.RUNNING
                end
                api_Sleep(2000)
                return bret.RUNNING
            end
            if env.login_state == "输入帳號" then
                local account = env.user_info["account"]
                local password = env.user_info["password"]
                -- local steam_login_hwnd = api_FindWindow("Chrome_RenderWidgetHostHWND","Chrome Legacy Window",0)
                local steam_login_hwnd = api_FindWindow("SDL_app", "登录 Steam",0)
                -- poe2_api.dbgp("111:",steam_login_hwnd)
                -- api_Sleep(10000000)
                if steam_login_hwnd and steam_login_hwnd ~= 0 then
                    api_SetWindowState(steam_login_hwnd, 8)
                    api_Sleep(1000)
                    -- api_SetWindowState(steam_login_hwnd, 9)
                    -- api_Sleep(1000)
                    local left, top, right, bottom = api_GetWindowRect(steam_login_hwnd)
                    api_ClickScreen(poe2_api.toInt(left + 345),poe2_api.toInt(top + 140) , 1)
                    api_Sleep(1000)
                    poe2_api.paste_text(account)
                    api_Sleep(1000)
                    api_ClickScreen(poe2_api.toInt(left + 345), poe2_api.toInt(top + 206) , 1)
                    api_Sleep(1000)
                    poe2_api.paste_text(password)
                    api_Sleep(1000)
                    poe2_api.click_keyboard("enter",0)     
                    env.login_state = "等待steam主窗口"
                    self.last_time = os.time()
                    return bret.RUNNING

                else
                    poe2_api.print_log("登录窗口不存在")
                    env.login_state = nil
                    self.last_time = 0
                    return bret.RUNNING
                end
                
                -- 根据窗口句柄 获取窗口坐标
                return bret.RUNNING
            end
            if env.login_state == "等待steam主窗口" then
                poe2_api.print_log("等待steam主窗口")
                local steam_login_hwnd = api_FindWindowByProcess("","Steam","steamwebhelper.exe",0)
                if steam_login_hwnd and steam_login_hwnd ~= 0 then
                    env.login_state = "等待游戏窗口"
                    self.last_time = os.time()
                    return bret.RUNNING
                end
                if os.time() - self.last_time > 120 then
                    poe2_api.print_log("等待steam主窗口超时")
                    env.login_state = nil
                    self.last_time = 0
                    return bret.RUNNING
                end
                api_Sleep(2000)
                return bret.RUNNING
            end
            if env.login_state == "等待游戏窗口" then
                poe2_api.print_log("等待steam游戏窗口")
                if os.time() - self.last_time > 120 then
                    poe2_api.print_log("等待steam游戏窗口超时")
                    env.login_state = nil
                    self.last_time = 0
                    return bret.RUNNING
                end
                api_Sleep(2000)
                return bret.RUNNING
            end
            return bret.RUNNING
        end
    },

    -- 获取UI信息
    Get_UI_Info = {
        run = function(self, env)
            poe2_api.print_log("获取UI信息...")
            local start_time = api_GetTickCount64() -- 开始时间
            env.UI_info = UiElements:Update()

            if #env.UI_info < 1 then
                api_Sleep(4000)
                return bret.RUNNING
            end
            -- poe2_api.dbgp("------------------")
            -- -- poe2_api.printTable(a)
            -- -- api_Sleep(4000)
            -- for _,k in ipairs(env.UI_info) do
            --     -- poe2_api.printTable(env.UI_info)
            --     -- if k.left > 977 
            --     if k.text_utf8 ~= "" then
            --         poe2_api.dbgp("------------------")
            --         poe2_api.dbgp(k.text_utf8)
            --         poe2_api.dbgp(k.left, k.right)
            --         poe2_api.dbgp(k.top, k.bottom)
            --     end
            -- end
            -- poe2_api.dbgp("------------------")
            poe2_api.time_p("Get_UI_Info... 耗时 --> ", api_GetTickCount64() - start_time)
            -- api_Sleep(4000)
            return bret.SUCCESS
        end
    },

    -- 获取信息
    Get_Info = {
        run = function(self, env)
            poe2_api.print_log("获取游戏信息...")
            local start_time = api_GetTickCount64() -- 开始时间

            local player_info_start_time = api_GetTickCount64()
            -- api_Log("+++++++++++++++++++++++++++++++++++++++++++++")
            env.player_info = api_GetLocalPlayer()
            local player_info_start_time = api_GetTickCount64()  -- 记录开始时间(毫秒)

            -- if not self.player_info_last_check then
            --     self.player_info_last_check = player_info_start_time
            -- end
            -- if player_info_start_time - self.player_info_last_check > 5 or not env.player_info then 
            --     env.player_info = api_GetLocalPlayer()
            --     self.player_info_last_check = player_info_start_time
            --     -- if #env.player_info < 1 then
            --         -- poe2_api.dbgp("等待获取周围对象信息...")
            --     --     return bret.RUNNING
            --     -- end
            --     -- poe2_api.time_p("    获取周围对象信息... 耗时 --> ", api_GetTickCount64() - range_info_start_time)
            -- end
            -- poe2_api.printTable(env.player_info)
            -- api_Sleep(10000)
            
            -- api_Log(env.player_info.grid_x)
            -- api_Log(env.player_info.grid_y)
            -- poe2_api.dbgp("player——pos ==>>", env.player_info.grid_x, env.player_info.grid_y)
            -- poe2_api.dbgp("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=")
            -- return bret.RUNNING
            if poe2_api.countTableItems(env.player_info) < 1 then
                poe2_api.dbgp("空人物信息")
                return bret.RUNNING
            end
            poe2_api.time_p("    获取人物信息... 耗时 --> ", api_GetTickCount64() - player_info_start_time)
            -- poe2_api.printTable(env.player_info)
            -- api_Sleep(10000000)
            -- bools = api_IsPointInAnyActive(env.player_info.grid_x, env.player_info.grid_y)
            -- poe2_api.dbgp("api_IsPointInAnyActive -->> ", bools)
            -- point = api_FindNearestSafeTile(env.player_info.grid_x, env.player_info.grid_y, 60)
            -- poe2_api.dbgp("api_FindNearestSafeTile -->> ", point.x, point.y)
            -- api_RegisterCircle("Metadata/Effects/Spells/monsters_effects/Act1_FOUR/FungalArtillery/ao/fungal_ground.ao", 20, 5)
            -- api_ClickMove(point.x, point.y, env.player_info.wolrd_z, 7)
            -- poe2_api.click_keyboard("space")
            -- if 0 < 1 then
            --     -- poe2_api.dbgp("")
            --     return bret.RUNNING
            -- end

            poe2_api.dbgp("死亡次数统计：", (env.death_times or 0))
            poe2_api.dbgp("开图次数统计：", (env.enter_map_times or 0))


            local range_info_start_time = api_GetTickCount64()  -- 记录开始时间(毫秒)
            if not self.last_check then
                self.last_check = range_info_start_time
            end
            if range_info_start_time - self.last_check > 5 or not env.range_info or #env.range_info < 1 then 
                env.range_info = Actors:Update()
                self.last_check = range_info_start_time
                if #env.range_info < 1 then
                    poe2_api.dbgp("等待获取周围对象信息...")
                    return bret.RUNNING
                end
                poe2_api.time_p("    获取周围对象信息... 耗时 --> ", api_GetTickCount64() - range_info_start_time)
            end
            
            -- api_GetMinimapActorInfo() - 获取小地图周围对象信息
            local current_map_info_start_time = api_GetTickCount64()
            env.current_map_info = api_GetMinimapActorInfo()
            if not env.current_map_info then
                poe2_api.dbgp("空小地图周围对象信息")
                return bret.RUNNING
            end
            -- for _,k in ipairs(env.current_map_info) do
            --     poe2_api.dbgp(k.name_utf8)
            --     poe2_api.dbgp(k.grid_x)
            --     poe2_api.dbgp(k.grid_y)
            --     poe2_api.dbgp(k.flagStatus)
            --     poe2_api.dbgp(k.flagStatus1)
            --     poe2_api.dbgp("==============================")
            -- end
            -- poe2_api.printTable(env.current_map_info)
            poe2_api.time_p("    获取小地图周围对象信息... 耗时 --> ", api_GetTickCount64() - current_map_info_start_time)

            -- 周围装备信息
            local range_items_start_time = api_GetTickCount64()
            env.range_items = WorldItems:Update()
            -- poe2_api.printTable(env.range_items)
            poe2_api.time_p("    获取周围装备信息... 耗时 --> ", api_GetTickCount64() - range_items_start_time)
            
            -- 背包信息（主背包）
            local bag_info_start_time = api_GetTickCount64()
            env.bag_info = api_Getinventorys(1,0)
            -- poe2_api.printTable(env.bag_info)
            -- api_Sleep(10000)
            poe2_api.time_p("    获取背包信息信息... 耗时 --> ", api_GetTickCount64() - bag_info_start_time)

            local team_info_data_start_time = api_GetTickCount64()
            env.team_info = api_GetTeamInfo()
            poe2_api.time_p("    获取队伍信息信息... 耗时 --> ", api_GetTickCount64() - team_info_data_start_time)

            -- api_GetTeleportationPoint() - 获取传送点信息
            -- if not env.waypoint then
            --     local waypoint_start_time = api_GetTickCount64()
            --     env.waypoint = api_GetTeleportationPoint()
            --     poe2_api.printTable(env.waypoint)
            --     poe2_api.time_p("    获取传送点信息... 耗时 --> ", api_GetTickCount64() - waypoint_start_time)
            --     api_Sleep(1000000)
            -- end
            
            -- 测试函数
            local function dumpInventory(inventory)
                local itemFields = {
                    "name_utf8", "baseType_utf8", "start_x", "start_y", "end_x", "end_y",
                    "not_identified", "category_utf8", "color", "world_x", "world_y", "grid_x", "grid_y",
                    "skillGemLevel", "skillStoneLevel", "isWearable", "DemandStrength", "DemandAgility",
                    "DemandWisdom", "DemandLevel", "obj", "contaminated", "id", "tribute",
                    "totalDeferredConsumption", "fixedSuffixCount", "mods_obj", "stackCount"
                }
                
                for _, item in ipairs(inventory) do
                    api_Log("==============================")
                    -- local Suffix = api_GetObjectSuffix(item.mods_obj)
                    -- local Suffix1 = api_GetObjectSuffix(item.obj)
                    -- poe2_api.printTable(item.fixedSuffixCount)
                    -- poe2_api.printTable(Suffix)
                    -- poe2_api.printTable(Suffix1)
                    -- api_Log("Suffix")
                    -- api_Log(Suffix)
                    -- api_Log("Suffix1")
                    -- api_Log(Suffix1)
                    -- 遍历预定义的属性列表，确保按固定顺序输出
                    poe2_api.printTable(item)
                    -- for _, field in ipairs(itemFields) do
                    --     local value = item[field]
                    --     api_Log(string.format("%-25s: %s", field, tostring(value)))
                    -- end
                    
                    api_Log("----------------------------------")
                end
                
                api_Sleep(1000000)  -- 暂停程序（注意：长时间暂停可能导致游戏无响应）
            end

            -- 测试函数
            local function dumprange(inventory)
                -- inventory = poe2_api.get_sorted_list(inventory, env.player_info)
                for _, item in ipairs(inventory) do
                    
                    if item.name_utf8 == "" or item.life == 0 or not item.isActive then
                        goto continue
                    end
                    -- if item.name_utf8 == "" or item.life == 0 then
                    --     goto continue
                    -- end
                    -- if item.life == 0 then
                    --     goto continue
                    -- end
                    -- if item.type ~= 1 then
                    --     goto continue
                    -- end
                    -- if item.name_utf8 == "" then
                    --     goto continue
                    -- end
                    api_Log("==============================")
                    -- 遍历预定义的属性列表，确保按固定顺序输出
                    -- for _, field in ipairs(itemFields) do
                    --     local value = item[field]
                    --     api_Log(string.format("%-25s: %s", field, tostring(value)))
                    -- end
                    poe2_api.printTable(item)
                    -- api_Log("====")
                    -- poe2_api.printTable(env.player_info)
                    dis1 = poe2_api.point_distance(item.grid_x, item.grid_y, {env.player_info.grid_x, env.player_info.grid_y})
                    api_ClickMove(item.grid_x, item.grid_y,0)
                    api_Log("dis-->>", dis1)
                    -- GameCore_CastSkill(2231369792, item.id, 0, 0, 0, 0)
                    -- api_CastSkill(2231369792, 0, env.player_info.grid_x, env.player_info.grid_y, item.grid_x, item.grid_y)
                    api_Sleep(1000)
                    
                    api_Log("----------------------------------")
                    ::continue::
                end
                
                -- api_Sleep(1000000)  -- 暂停程序（注意：长时间暂停可能导致游戏无响应）
            end
            -- local pages = api_GetRepositoryPages(0)
            -- api_GetSkillSlots
            -- poe2_api.printTable(api_GetSelectableSkillControls())
            -- poe2_api.printTable(api_GetSkillSlots())

            -- id, title, progress, is_completed, rewards
            -- for _,i in ipairs(api_GetQuestList(1)) do
            --     poe2_api.dbgp("------------------")
            --     poe2_api.dbgp(i.id)
            --     poe2_api.dbgp(i.title)
            --     poe2_api.dbgp(i.progress)
            --     poe2_api.dbgp(i.is_completed)
            --     poe2_api.dbgp(i.rewards)
            -- end
            -- poe2_api.printTable(api_GetTeamInfo())
            -- for _,i in ipairs(api_GetTeamInfo()) do
            --     poe2_api.dbgp("------------------")
            --     poe2_api.dbgp("i.roleStatus",i.roleStatus)
            --     poe2_api.dbgp("i.name_utf8",i.name_utf8)
            --     poe2_api.dbgp("i.current_map_name_utf8",i.current_map_name_utf8)
            -- end
            
            
            -- 调用函数
            -- dumpInventory(env.range_items)
            -- dumprange(env.range_info)
            -- poe2_api.dbgp("--=================================================----")
            -- poe2_api.dbgp("==================================")
            -- map_table = api_GetMapRepositoryItems(15,268,545,640)
            -- poe2_api.printTable(map_table)
            -- -- api_Sleep(500000)
            -- poe2_api.dbgp("==================================")
            -- -- api_Sleep(10000)
            -- while true do
            --     api_Sleep(1000)
            -- end

            if self.wear_items == nil then
                self.wear_items = true
            end
            -- 其他物品栏信息（批量处理）
            if self.wear_items then
                local inventory_sections = {
                    {2, "item2"}, {3, "item3"}, {4, "item4"},
                    {5, "item5"}, {6, "item6"}, {7, "item7"},
                    {8, "item8"}, {9, "item9"}, {0xa, "item0xa"}, {0xb, "item0xb"}
                }
                for _, section in ipairs(inventory_sections) do
                    local section_id = section[1]
                    local section_name = section[2]
                    if not env[section_name] then
                        local items = api_Getinventorys(section_id,0)
                        env[section_name] = items
                    end
                end
                self.wear_items = false
            end

            poe2_api.time_p("Get_Info... 总耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 清理
    Clear = {
        run = function(self, env)
            poe2_api.print_log("执行清理...")
            local start_time = api_GetTickCount64()
            if not self.time then
                self.bool =false
                self.time = os.time()
                poe2_api.dbgp("初始化")
            end
            local player_info = env.player_info
            if not player_info or not next(player_info) then 
                poe2_api.dbgp("人物信息为空")
                return bret.RUNNING
            end 
            local current_map_info = env.current_map_info
            local function is_map_device(obj_list)
                if not obj_list or #obj_list == 0 then
                    return false
                end
                for _, i in ipairs(obj_list) do
                    if i.name_utf8 == "MapDevice" then
                        return true
                    end
                end
                return false
            end
            local map_device = is_map_device(current_map_info)
            if not string.match(player_info.current_map_name_utf8,"town") 
            and (not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.hideout) or not map_device) then
                self.bool =false
                poe2_api.dbgp("不在城区")
                return bret.SUCCESS      
            end
            if not self.bool and  player_info.life ~= 0 and not poe2_api.click_text_UI({text="respawn_at_checkpoint_button",UI_info = env.UI_info,index = 1}) then
                if not poe2_api.find_text({UI_info = env.UI_info, text = "/clear",min_x = 0 }) then
                    api_ClickMove(poe2_api.toInt(player_info.grid_x), poe2_api.toInt(player_info.grid_y), poe2_api.toInt(player_info.world_z), 7)
                    api_Sleep(1000)
                    poe2_api.click_keyboard("enter",0)
                    api_Sleep(500)
                    poe2_api.paste_text("/clear")
                    api_Sleep(500)
                    poe2_api.click_keyboard("enter",0)
                    api_Sleep(500)
                    self.bool = true
                    return bret.RUNNING
                end
            end  
            poe2_api.dbgp("完成")
            local elapsed_ms = (api_GetTickCount64()) - start_time
            poe2_api.time_p("执行清理... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 休息控制
    RestController = {
        run = function(self, env)
            poe2_api.print_log("执行休息控制...")
            poe2_api.dbgp("执行休息控制...")
            local start_time = api_GetTickCount64() -- 开始时间
            
            -- 初始化检查
            if not self._is_initialized then
                poe2_api.dbgp("初始化休息控制器...")
                local config = env.user_config["全局設置"]["刷图通用設置"]["定時休息"] or {}
                
                -- 工作时间配置（单位：分钟→毫秒）
                local base_work = tonumber(config["運行時間"]) or 60  -- 默认60分钟
                local work_random_range = math.min(tonumber(config["工作時間隨機範圍"]) or 0.1, 0.3) -- 限制最大30%波动
                self.work_duration_ms = math.floor(base_work * 60 * 1000 * (1 + (math.random() * work_random_range * 2 - work_random_range)))
                
                -- 休息时间配置（单位：分钟→毫秒）
                local base_rest = tonumber(config["休息時間"]) or 10  -- 默认10分钟
                local rest_random_range = math.min(tonumber(config["休息時間隨機範圍"]) or 0.1, 0.3) -- 限制最大30%波动
                self.rest_duration_ms = math.floor(base_rest * 60 * 1000 * (1 + (math.random() * rest_random_range * 2 - rest_random_range)))

                -- 功能开关
                self.is_open = config["是否開啟"] or false
                self.is_kill_game = config["休息时是否关闭游戏"] or false
                
                -- 初始化状态（使用毫秒时间戳）
                local current_time_ms = api_GetTickCount64()
                self._is_resting = false
                self._next_state_change_time_ms = current_time_ms + self.work_duration_ms
                self._last_update_time_ms = current_time_ms
                self._is_initialized = true
                
                poe2_api.dbgp("初始化完成 - 工作时间:%d分钟 休息时间:%d分钟", self.work_duration_ms/(60*1000), self.rest_duration_ms/(60*1000))
                return bret.RUNNING
            end

            -- 功能关闭直接返回成功
            if not self.is_open then
                poe2_api.dbgp("休息功能未开启，直接返回SUCCESS")
                poe2_api.time_p("休息功能未开启... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            
            local current_time_ms = api_GetTickCount64()

            local function _perform_rest_actions()
                poe2_api.dbgp("执行休息操作...")
                if not (poe2_api.find_text({UI_info = env.UI_info, text = "回到角色選擇畫面"}) or poe2_api.click_text_UI({UI_info = env.UI_info, text = "exit_to_character_selection"})) then
                    if poe2_api.click_text_UI({UI_info = env.UI_info, text = "life_orb"}) and poe2_api.click_text_UI({UI_info = env.UI_info, text = "mana_orb"}) then
                        poe2_api.click_keyboard("esc")
                    end
                end
                api_Sleep(1000)
            end

            local function _handle_state_transition()
                self._is_resting = not self._is_resting
                local duration_ms = self._is_resting and self.rest_duration_ms or self.work_duration_ms
                self._next_state_change_time_ms = current_time_ms + duration_ms
                self._last_update_time_ms = current_time_ms
                
                -- 更新环境变量
                env.take_rest = self._is_resting
                
                if self._is_resting then
                    poe2_api.dbgp("切换到休息状态")
                    
                    local player_info = env.player_info
                    if not poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                        env.need_ReturnToTown = true
                        poe2_api.dbgp("不在藏身处，设置需要回城")
                        return bret.SUCCESS
                    end
                    
                    -- 进入休息状态
                    if self.is_kill_game then
                        env.error_kill = true
                        poe2_api.dbgp("设置需要关闭游戏")
                    end
                    poe2_api.dbgp(string.format("工作时间到，开始休息 (%d分钟)", math.floor(self.rest_duration_ms/(60*1000))))
                    -- _perform_rest_actions()
                    -- poe2_api.dbgp(string.format("工作时间到，开始休息 (%d分钟)", math.floor(self.rest_duration_ms/(60*1000))))
                    -- api_Sleep(11000000)
                    return bret.RUNNING
                else
                    -- 返回工作状态
                    env.error_kill = false
                    poe2_api.dbgp(string.format("休息结束，开始工作 (%d分钟)",  math.floor(self.work_duration_ms/(60*1000))))
                    self._is_initialized = false
                    return bret.SUCCESS
                end
            end

            local function _update_status()
                local time_remaining_ms = math.max(0, self._next_state_change_time_ms - current_time_ms)
                
                if self._is_resting then
                    poe2_api.dbgp("当前处于休息状态")
                    local player_info = env.player_info
                    if not poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                        env.need_ReturnToTown = true
                        poe2_api.dbgp("不在藏身处，设置需要回城")
                        return bret.SUCCESS
                    end
                    
                    -- 休息状态更新（每分钟60000毫秒）
                    if current_time_ms - self._last_update_time_ms >= 60000 then
                        self._last_update_time_ms = current_time_ms
                        local mins = math.floor(time_remaining_ms/(60*1000))
                        local secs = math.floor((time_remaining_ms%(60*1000))/1000)
                        poe2_api.print_log(string.format("休息中... 剩余时间: %02d分%02d秒", mins, secs))
                        env.take_rest = true
                        
                        if not (poe2_api.find_text({UI_info = env.UI_info, text = "回到角色選擇畫面"}) or 
                            poe2_api.click_text_UI({UI_info = env.UI_info, text = "exit_to_character_selection"})) and 
                            poe2_api.click_text_UI({UI_info = env.UI_info, text = "life_orb"}) and 
                            poe2_api.click_text_UI({UI_info = env.UI_info, text = "mana_orb"}) then
                            poe2_api.click_keyboard("esc")
                        end
                        api_Sleep(1000)
                    end
                    api_Sleep(2000)
                    return bret.RUNNING
                else
                    -- 工作状态更新（每5分钟300000毫秒）
                    if current_time_ms - self._last_update_time_ms >= 300000 then
                        self._last_update_time_ms = current_time_ms
                        local hours = math.floor(time_remaining_ms/(3600*1000))
                        local mins = math.floor((time_remaining_ms%(3600*1000))/(60*1000))
                        local secs = math.floor((time_remaining_ms%(60*1000))/1000)
                        poe2_api.print_log(string.format("工作中... 距离休息还有: %d小时%02d分钟%02d秒", hours, mins, secs))
                        env.take_rest = false
                    end
                    return bret.SUCCESS
                end
            end

            -- 状态切换检查（毫秒级比较）
            if current_time_ms >= self._next_state_change_time_ms then
                poe2_api.dbgp("检测到状态切换时间到达")
                poe2_api.time_p("检测到状态切换时间到达... 耗时 --> ", api_GetTickCount64() - start_time)
                return _handle_state_transition()
            end
                
            -- 状态更新
            poe2_api.dbgp("更新当前状态...")
            poe2_api.time_p("更新当前状态... 耗时 --> ", api_GetTickCount64() - start_time)
            return _update_status()
        end
    },

    -- 小撤退
    SmallRetreat = {
        run = function(self, env)
            local current_time = api_GetTickCount64()
            
            local player_info = env.player_info
            if not env.need_SmallRetreat then
                poe2_api.dbgp("小退条件不满足")   
                self.error_kill_start_time = nil
                poe2_api.time_p("SmallRetreat... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
            if self.last_action_time == nil then
                self.init = true
                poe2_api.dbgp("初始化小撤退")
                self.last_action_time = 0 -- 记录上次操作时间
                self.action_interval = 2 -- 操作间隔时间
                self.error_kill_start_time = nil -- 超时计时器
            end
            local function reset_states()
                -- 统一状态重置方法
                local current_time = api_GetTickCount64()
                env.last_exception_time = 0
                env.last_exp_check = current_time
                env.last_exp_value = player_info.currentExperience
                -- logger.dbgp("已重置所有监控状态")
            end

            if not self.error_kill_start_time then
                self.error_kill_start_time = api_GetTickCount64()
            end
            -- 超时判断（10次点击约15秒）
            if self.error_kill_start_time and (current_time - self.error_kill_start_time) > 30*1000 then
                -- print("小退超时")
                env.error_kill = true
                self.error_kill_start_time = nil  -- 重置计时器
                env.need_SmallRetreat = false
                
                return bret.RUNNING
            else
                env.error_kill = false
            end
            if env.need_SmallRetreat then
                poe2_api.print_log("清路径111")
                env.path_list = {}
                
                if current_time - self.last_action_time >= self.action_interval then
                    -- # 点击返回
                    if poe2_api.find_text({UI_info = env.UI_info, text = "回到角色選擇畫面", click=2}) then
                        if self.error_kill_start_time == nil then
                            self.error_kill_start_time = current_time  --# 开始计时
                        end
                        api_Sleep(6000)
                        return bret.RUNNING
                    elseif poe2_api.click_text_UI({UI_info = env.UI_info, text = "exit_to_character_selection", click=1 , index=1}) then
                        if self.error_kill_start_time == nil  then
                            self.error_kill_start_time = current_time
                        end
                        api_Sleep(6000)
                        return bret.RUNNING
                    end
                    -- # 打开选项菜单
                    if not (poe2_api.find_text({UI_info = env.UI_info,  text = "回到角色選擇畫面"}) or 
                           poe2_api.click_text_UI({UI_info = env.UI_info, text = "exit_to_character_selection"})) and 
                           poe2_api.click_text_UI({UI_info = env.UI_info, text = "life_orb"}) and 
                           poe2_api.click_text_UI({UI_info = env.UI_info, text = "mana_orb"}) then
                        if self.error_kill_start_time == nil then
                            self.error_kill_start_time = current_time
                        end
                        poe2_api.click_keyboard("esc")
                        api_Sleep(1000)
                        self.last_action_time = current_time + 2
                        return bret.RUNNING
                    end
                    -- # 成功执行后重置超时计时器
                    self.error_kill_start_time = false
                    env.last_exp_check = current_time
                    self.last_exception_time = 0
                    env.need_SmallRetreat = false
                    reset_states()
                    return bret.RUNNING
                else
                    return bret.RUNNING
                end
            end
            return bret.SUCCESS
        end
    },

    -- 返回城镇
    ReturnToTown = {
        run = function(self, env)
            poe2_api.print_log("执行返回城镇...")
            poe2_api.dbgp("开始执行返回城镇")
            local current_time = api_GetTickCount64()
            local player_info = env.player_info
             
            local find_path_failure = env.find_path_failure or 0
            if not env.need_ReturnToTown or player_info.life == 0 then

                poe2_api.dbgp("返回城镇条件不满足") 
                self.current_time = current_time
                poe2_api.time_p("ReturnToTown... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end  
            nomarl_monster = poe2_api.is_have_mos({range_info = env.range_info, player_info = player_info, stuck_monsters = env.stuck_monsters})
            poe2_api.dbgp("nomarl_monster -- > ", nomarl_monster)

            if nomarl_monster then
                poe2_api.dbgp("返回城镇条件不满足") 
                self.current_time = current_time
                poe2_api.time_p("ReturnToTown... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end

            -- 初始化时间
            self.timeout = 20 * 1000 -- 超时时间（秒）
            if self.current_time == nil and env.need_ReturnToTown then
                poe2_api.dbgp("初始化返回城镇") -- 初始化时间
                self.current_time = current_time
                return bret.RUNNING
            end
            local function reset_states()
                -- 统一状态重置方法
                local current_time = api_GetTickCount64()
                env.last_exception_time_move = 0
                env.last_exp_check_move = current_time
                env.last_exp_value_move = env.player_info.currentExperience
                -- logger.dbgp("已重置所有经验监控状态")
            end

            local spcify_monsters = function()
                if env.range_info then
                    for _, monster in ipairs(env.range_info) do
                        if monster.name_utf8 == '巨蛇女王．瑪娜莎' and monster.life > 0 then
                            return true
                        end
                    end
                end
                return false
            end
            -- 检查是否超时
            if (current_time - self.current_time) > self.timeout then
                poe2_api.dbgp("返回城镇超时")
                env.need_ReturnToTown = false
                env.need_SmallRetreat = true
                return bret.RUNNING
            end

            if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8)  then
                poe2_api.dbgp("已返回城镇")
                env.need_ReturnToTown = false
                env.find_path_failure = 0
                return bret.SUCCESS
            end

            
            if self.last_action_time == nil then
                self.last_action_time = api_GetTickCount64()
                self.action_interval = 1000
                self.false_times = 0
                self.is_wait = false
                self.dq = 0
                return bret.RUNNING
            end

            
            if env.need_ReturnToTown or find_path_failure > 10 then
                if current_time - self.last_action_time >= self.action_interval then
                    poe2_api.print_log("清路径222")
                    env.path_list = {}
                    if find_path_failure > 10 then
                        env.is_map_complete = true
                    end
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text = "你無法在遊戲暫停時使用該道具。", min_x = 0}) then
                        poe2_api.dbgp("发现暂停")
                        poe2_api.dbgp1("dsgvsgbbgtyjngn")
                        poe2_api.click_keyboard("space")
                        api_Sleep(500)
                        if not poe2_api.find_text({text = "/clear", UI_info = env.UI_info, min_x = 0}) then
                            poe2_api.click_keyboard("enter")
                            api_Sleep(500)
                            poe2_api.paste_text("/clear")
                            api_Sleep(500)
                            poe2_api.click_keyboard("enter")
                            api_Sleep(1000)
                            
                            return bret.RUNNING
                        end
                    end
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text = "恩賜之物", min_x = 0})  then
                        poe2_api.dbgp("发现恩賜之物")
                        poe2_api.find_text({UI_info = env.UI_info, text = "恩賜之物", min_x = 0, click = 2, add_x = 272})
                        return bret.RUNNING
                    end
                    
                    if player_info.isInBossBattle then
                        poe2_api.dbgp("在boss战")
                        env.need_ReturnToTown = false
                        env.need_SmallRetreat = true
                        
                        return bret.RUNNING
                    end
                    
                    if poe2_api.is_have_mos({range_info = env.range_info, player_info}) or spcify_monsters() then
                        poe2_api.dbgp("发现怪物")
                        return bret.SUCCESS
                    end
                    
                    if not string.find(player_info.current_map_name_utf8, "town") and not poe2_api.table_contains(my_game_info.hideout_CH, player_info.current_map_name_utf8) then
                        if poe2_api.find_text({UI_info = env.UI_info,  text = "傳送", min_x = 700, max_y = 40, max_x = 830}) then
                            poe2_api.dbgp("发现传送")
                            poe2_api.dbgp1("dsgvfsdvsyuijytjnedrhgwsegdzvdv")
                            poe2_api.click_keyboard("space")
                            return bret.RUNNING
                        end
                        poe2_api.dbgp("回城")
                        for _, k in ipairs(env.range_info) do
                            if k.name_utf8 ~= '' and k.type == 5 and poe2_api.table_contains(my_game_info.hideout_CH, k.name_utf8) then
                                if poe2_api.point_distance(k.grid_x, k.grid_y, player_info) < 25 then
                                    poe2_api.dbgp("发现城镇UI")
                                    if not poe2_api.find_text({UI_info = env.UI_info, text = k.name_utf8, click = 2}) then
                                        poe2_api.dbgp("点击城镇UI失败")
                                        api_ClickMove(poe2_api.toInt(k.grid_x), poe2_api.toInt(k.grid_y), poe2_api.toInt(k.world_z-100), 7)
                                    end
                                    return bret.RUNNING
                                end
                            end
                        end
                        
                        -- 点击传送
                        poe2_api.dbgp("点击传送")
                        api_ClickMove(poe2_api.toInt(player_info.grid_x), poe2_api.toInt(player_info.grid_y), poe2_api.toInt(player_info.world_z), 7)
                        api_Sleep(500)
                        api_ClickScreen(1230, 815,0)
                        api_Sleep(200)
                        api_ClickScreen(1230, 815,1)
                        self.last_action_time = current_time + 2000
                        return bret.RUNNING
                    else
                        local point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 50)
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), poe2_api.toInt(player_info.world_z - 70), 7)
                        end
                        
                        -- 仅在完全回城后重置状态
                        if string.find(player_info.current_map_name_utf8, "town") or my_game_info.hideout[player_info.current_map_name_utf8] then
                            env.last_exp_check = api_GetTickCount64()
                            env.last_exception_time = 0
                            env.need_ReturnToTown = false
                            reset_states()
                            
                            return bret.SUCCESS
                        end
                        return bret.RUNNING
                    end
                end
                return bret.RUNNING
            end
            return bret.SUCCESS
        end
    },

    -- 检查长时间未增长经验
    Check_LongTime_EXP_Add = {
        run = function(self, env)
            poe2_api.print_log("开始执行长时间经验检查...")

            if env.in_exchange then
                poe2_api.dbgp("通货兑换开启，跳过检测流程")
                return bret.SUCCESS
            end
            
            local current_time = api_GetTickCount64()
            local take_rest = env.take_rest
            local buy_items = env.buy_items
            local config = env.user_config
            local player_info = env.player_info
            
            --- 辅助函数
            -- 检查是否处于停滞移动状态
            local function _check_stagnant_movement()
                local current = env.player_info
                if not current then return false end
                
                local last_pos = env.last_position or {0, 0}
                local distance = poe2_api.point_distance(last_pos[1], last_pos[2], current)
                
                -- 更新位置记录
                env.last_position = {current.grid_x, current.grid_y}
                
                poe2_api.dbgp(string.format("移动距离检查: %.2f (阈值:15)", distance))
                return distance < 15
            end
            
            -- 检查至少有一个异常处理功能启用
            local function _check_feature_enabled()
                -- 经验相关功能
                local exp_town_enabled = config['全局設置']['異常處理']['沒有經驗回城']['是否開啟']
                local exp_retreat_enabled = config['全局設置']['異常處理']['沒有經驗小退']['是否開啟']
                
                -- 移动相关功能
                local move_town_enabled = config['全局設置']['異常處理']['不動回城']['是否開啟']
                local move_retreat_enabled = config['全局設置']['異常處理']['不動小退']['是否開啟']
                
                -- 任一功能启用即为true
                local enabled = exp_town_enabled or exp_retreat_enabled or move_town_enabled or move_retreat_enabled
                poe2_api.dbgp(string.format("功能启用检查 - 经验回城:%s, 经验小退:%s, 移动回城:%s, 移动小退:%s", 
                    tostring(exp_town_enabled), tostring(exp_retreat_enabled), 
                    tostring(move_town_enabled), tostring(move_retreat_enabled)))
                
                return enabled
            end

            -- 重置经验检查状态
            local function reset_states_exp()
                local current_time = api_GetTickCount64()
                local current = env.player_info
                env.last_exception_time = 0.0
                env.last_exp_check = current_time
                env.last_exp_value = env.player_info.currentExperience
                env.last_position = {current.grid_x, current.grid_y}
                poe2_api.dbgp("已重置所有经验监控状态")
            end

            -- 重置移动检查状态
            local function reset_states_move()
                local current_time = api_GetTickCount64()
                local current = env.player_info
                env.last_exception_time_move = 0.0
                env.last_exp_check_move = current_time
                env.last_exp_value_move = env.player_info.currentExperience
                env.last_position = {current.grid_x, current.grid_y}
                poe2_api.dbgp("已重置所有移动监控状态")
            end

            -- 获取可交互对象
            local function get_range()
                local valid_objects = {
                    "甕", "壺", "屍體", "巢穴", "籃子", "小雕像", "石塊",
                    "鬆動碎石", "瓶子", "盒子", "腐爛木材", "保險箱", "腐爛木材"
                }
                
                -- 对范围对象进行排序
                local sorted_range = poe2_api.get_sorted_list(env.range_info, env.player_info)
                if not sorted_range then
                    poe2_api.dbgp("警告: 无法获取排序后的范围列表")
                    return false
                end

                -- poe2_api.dbgp(string.format("检查 %d 个范围内的对象", #sorted_range))
                
                -- 遍历查找符合条件的对象
                for _, obj in ipairs(sorted_range) do
                    -- 调试输出当前对象信息
                    -- poe2_api.dbgp(string.format("检查对象: %s (类型: %s, 激活: %s, 可选: %s)", 
                    --     obj.name_utf8 or "无名", 
                    --     obj.type or "未知", 
                    --     tostring(obj.isActive), 
                    --     tostring(obj.is_selectable)))
                    
                    if obj.name_utf8 and 
                    poe2_api.table_contains(valid_objects, obj.name_utf8) and
                    obj.isActive and 
                    obj.is_selectable and
                    obj.grid_x and obj.grid_y then
                        
                        local distance = poe2_api.point_distance(obj.grid_x, obj.grid_y, player_info)
                        if distance then
                            poe2_api.dbgp(string.format("对象 %s 距离: %.2f", obj.name_utf8, distance))
                            
                            if distance <= 20 then
                                poe2_api.dbgp("找到符合条件的交互对象: ", obj.name_utf8)
                                return obj
                            end
                        end
                    end
                end
                
                poe2_api.dbgp("未找到符合条件的交互对象")
                return false
            end
            
            -- 节流控制
            if self.last_check and current_time - self.last_check < 500 then
                poe2_api.dbgp("节流控制: 检查间隔小于0.5秒，跳过")
                poe2_api.time_p("Check_LongTime_EXP_Add(节流控制)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end

            self.last_check = current_time
            
            if take_rest then
                poe2_api.dbgp("正在休息，跳过异常处理")
                return bret.SUCCESS
            end

            -- 每20秒按一次alt键
            if self.last_alt_press_time == nil or api_GetTickCount64() - self.last_alt_press_time >= 20000 and not poe2_api.find_text({UI_info = env.UI_info, text = "通貨交換", min_x = 0, max_y = 200}) then
                poe2_api.dbgp("执行ALT键检查")
                api_ClickScreen(100, 850, 0)
                poe2_api.click_keyboard("alt")
                api_Sleep(100)
                poe2_api.click_keyboard("alt", 2)
                api_Sleep(100)
                poe2_api.click_keyboard("alt", 2)
                self.last_alt_press_time = api_GetTickCount64()
            end

            -- 检查移动状态
            local is_moving = _check_stagnant_movement()
            poe2_api.dbgp("移动状态检查: ", is_moving and "未移动" or "移动中")

            -- 获取配置参数
            local no_exp_to_town = config['全局設置']['異常處理']['沒有經驗回城']['是否開啟']
            local no_exp_to_town_time = config['全局設置']['異常處理']['沒有經驗回城']['閾值'] * 60 * 1000
            if not no_exp_to_town then
                no_exp_to_town = true
                no_exp_to_town_time = 5 * 60 * 1000
            end

            local no_exp_to_change = config['全局設置']['異常處理']['沒有經驗小退']['是否開啟']
            local no_exp_to_change_time = config['全局設置']['異常處理']['沒有經驗小退']['閾值'] * 60 * 1000

            local no_move_to_town = config['全局設置']['異常處理']['不動回城']['是否開啟']
            local no_move_to_town_time = config['全局設置']['異常處理']['不動回城']['閾值'] * 1000
            if not no_move_to_town then
                no_move_to_town = true
                no_move_to_town_time = 3 * 60 * 1000
            end

            local no_move_to_change = config['全局設置']['異常處理']['不動小退']['是否開啟']
            local no_move_to_change_time = config['全局設置']['異常處理']['不動小退']['閾值'] * 1000



            -- 经验增长时重置状态
            if player_info.currentExperience ~= env.last_exp_value then
                poe2_api.dbgp("经验值变化，重置经验检查状态")
                reset_states_exp()
            end
            
            -- 移动状态变化时重置状态
            if not is_moving then
                poe2_api.dbgp("移动状态变化，重置移动检查状态")
                reset_states_move()
            end

            -- 初始化首次检查
            if env.last_exp_check == 0 or env.last_exp_check == nil then
                poe2_api.dbgp("初始化经验检查状态")
                env.last_exp_value = player_info.currentExperience
                env.last_exp_check = api_GetTickCount64()
                return bret.SUCCESS
            end

            -- 根据场景设置不同的超时时间
            local space_time = 8
            local map_strenght = env.strengthened_map_obj
            local return_town = env.return_town
            
            if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                if poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", min_x = 0}) then
                    return bret.SUCCESS
                end
                space_time = 60
            elseif map_strenght then
                space_time = 120
            elseif return_town then
                space_time = 15
            elseif buy_items then
                space_time = 30
            end

            -- 计算真实停滞时间
            local real_stagnation_time = current_time - (env.last_exp_check or 0)
            local real_stagnation_time_move = current_time - (env.last_exp_check_move or 0)
            
            poe2_api.dbgp(string.format("经验停滞时间: %.2f秒, 移动停滞时间: %.2f秒", real_stagnation_time / 1000, real_stagnation_time_move / 1000))

            -- 处理长时间未移动情况
            if is_moving and real_stagnation_time_move > space_time * 1000 then
                if env.boss_drop then
                    env.last_exp_check_move = api_GetTickCount64()
                    return bret.SUCCESS
                end
                poe2_api.dbgp(string.format("长时间未移动(%.2f秒 > %d秒)，执行恢复操作", 
                    real_stagnation_time_move / 1000, space_time))
                
                if not env.need_SmallRetreat and not env.need_ReturnToTown and not take_rest then
                    poe2_api.print_log("清路径333")
                    env.end_point = nil
                    env.target_point = nil
                    env.path_list = nil
                    env.is_arrive_end = true
                    poe2_api.dbgp1("sgewgbfdbgfdhn")
                    poe2_api.click_keyboard("space")
                    
                    if env.range_info and player_info then
                        local target = get_range()
                        if target then
                            api_ClickMove(poe2_api.toInt(target.grid_x), poe2_api.toInt(target.grid_y), poe2_api.toInt(target.world_z), 0)
                            api_Sleep(500)
                            api_ClickMove(poe2_api.toInt(target.grid_x), poe2_api.toInt(target.grid_y), poe2_api.toInt(target.world_z), 1)
                            api_Sleep(500)
                            poe2_api.find_text({UI_info = env.UI_info, text = target.name_utf8, click = 2, refresh = true, min_x = 0})
                            api_Sleep(500)
                        end
                        
                        local point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 50)
                        api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), poe2_api.toInt(player_info.world_z), 7)
                        api_Sleep(500)
                        poe2_api.dbgp1("fdgrgrfhfhdfhb")
                        poe2_api.click_keyboard("space")
                        api_Sleep(100)
                    end
                    
                    if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                        local point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 50)
                        api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), poe2_api.toInt(player_info.world_z), 7)
                        api_Sleep(500)
                        poe2_api.dbgp1("wrqafsdgsdgrehrhb")
                        poe2_api.click_keyboard("space")
                        api_Sleep(500)
                        poe2_api.dbgp1("hntrjhegdsgvcdbfd")
                        poe2_api.click_keyboard("space")
                    end
                    env.last_exp_check_move = api_GetTickCount64()
                    return bret.RUNNING
                end
            end

            -- 检查功能是否启用
            if not _check_feature_enabled() then
                poe2_api.dbgp("所有异常处理功能未启用，跳过检测流程")
                return bret.SUCCESS
            end

            -- 检查触发条件
            local trigger_town = nil
            local trigger_retreat = nil
            local trigger_town_move = nil
            local trigger_retreat_move = nil
            
            if no_exp_to_town then
                local town_th = no_exp_to_town_time or math.huge
                trigger_town = real_stagnation_time >= town_th
                poe2_api.dbgp(string.format("经验回城检查: %.2f >= %.2f = %s", 
                    real_stagnation_time, town_th, tostring(trigger_town)))
            end
            
            if no_exp_to_change then
                local retreat_th = no_exp_to_change_time or math.huge
                trigger_retreat = real_stagnation_time >= retreat_th
                poe2_api.dbgp(string.format("经验小退检查: %.2f >= %.2f = %s", 
                    real_stagnation_time, retreat_th, tostring(trigger_retreat)))
            end

            if no_move_to_town then
                local town_th_move = no_move_to_town_time or math.huge
                trigger_town_move = real_stagnation_time_move >= town_th_move
                poe2_api.dbgp(string.format("移动回城检查: %.2f >= %.2f = %s", 
                    real_stagnation_time_move, town_th_move, tostring(trigger_town_move)))
            end
            
            if no_move_to_change then
                local retreat_th_move = no_move_to_change_time or math.huge
                trigger_retreat_move = real_stagnation_time_move >= retreat_th_move
                poe2_api.dbgp(string.format("移动小退检查: %.2f >= %.2f = %s", 
                    real_stagnation_time_move, retreat_th_move, tostring(trigger_retreat_move)))
            end

            -- 处理触发条件
            if trigger_town or trigger_retreat or trigger_town_move or trigger_retreat_move then
                poe2_api.dbgp(string.format("触发异常处理条件 - 经验停滞:%.2f秒, 移动停滞:%.2f秒", 
                    real_stagnation_time, real_stagnation_time_move))
                
                -- 优先级：回城 > 小退
                -- if real_stagnation_time > no_exp_to_change_time and  then
                --     env.is_map_complete = true
                --     env.need_SmallRetreat = true
                --     poe2_api.dbgp("触发小退条件")
                    
                --     return bret.SUCCESS
                -- end
                
                if (trigger_town and no_exp_to_town) or (trigger_town_move and no_move_to_town) then
                    if not poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                        env.is_map_complete = true
                        env.need_ReturnToTown = true
                        poe2_api.dbgp("触发回城条件")
                    end
                    
                    return bret.SUCCESS
                elseif (trigger_retreat and no_exp_to_change) or (trigger_retreat_move and no_move_to_change) then
                    env.is_map_complete = true
                    env.need_SmallRetreat = true
                    poe2_api.dbgp("触发小退条件")
                    
                    return bret.SUCCESS
                end
            end
            
            poe2_api.time_p("Check_LongTime_EXP_Add(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
            return bret.SUCCESS
        end
    },

    -- 检查异界死亡
    Is_Deth_Otherworld = {
        run = function(self, env)
            poe2_api.print_log("死亡初始化(异界)")
            poe2_api.dbgp("死亡初始化(异界)")
            local start_time = api_GetTickCount64()
            local player_info = env.player_info
            
            if not self.respawn_wait_start then
                self.respawn_wait_start = 0
            end
            if not player_info then
                poe2_api.dbgp("玩家信息不存在，跳过死亡初始化")
                return bret.RUNNING
            end
            
            if player_info.life == 0 and 
            (poe2_api.find_text({UI_info = env.UI_info, text="在記錄點重生"}) or 
                poe2_api.find_text({UI_info = env.UI_info, text="在藏身處復活"}) or 
                poe2_api.find_text({UI_info = env.UI_info, text="在城鎮重生"}) or
                poe2_api.find_text({UI_info = env.UI_info, text="在開始地圖頭目遭遇之後復活，會移除區域 內所有其他遭遇和怪物"})) then
                
                if poe2_api.click_text_UI({UI_info = env.UI_info, text="respawn_at_checkpoint_button"}) then
                    poe2_api.dbgp1("rewyrejhgfdbnsdbvs")
                    poe2_api.click_keyboard("space")
                end
                poe2_api.dbgp("点击确认")
                poe2_api.find_text({UI_info = env.UI_info, text="確定",click=2, min_x=0})
                api_ClickScreen(915, 490,1)
                local relife_text = {"在記錄點重生","在藏身處復活","在城鎮重生"} 
                local point = poe2_api.find_text({UI_info = env.UI_info, text = relife_text, min_x = 0, click = 2})
                if not point then
                    poe2_api.time_p("Is_Deth_Otherworld(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                env.death_times = (env.death_times or 0) + 1
                -- api_ClickScreen(point[1], point[2], 0)
                -- api_Sleep(1000)
                -- api_ClickScreen(point[1], point[2], 1)
                
                env.teleport =  nil
                env.area_list = {}
                env.is_need_check = false
                env.stuck_monsters = nil
                env.item_name = nil
                env.item_pos = nil
                env.check_all_points = false
                env.empty_path = false
                env.map_name = nil
                env.interactive = nil
                env.item_move = false
                env.item_end_point = {0, 0}
                env.attack_move = false
                env.ok = false
                env.not_need_wear = false
                env.currency_check = false
                env.sell_end_point = {0, 0}
                env.is_better = false
                env.mos_out = 0
                env.is_arrive_end = false
                env.not_need_pick = false
                env.is_not_ui = false
                env.no_item_wear = false
                env.my_role = nil
                env.is_set = false
                env.end_point = nil
                env.path_list = nil
                env.run_point = nil
                env.teleport_area = nil
                env.teleport = nil
                env.follow_role = nil
                env.one_other_map = nil
                env.need_item = nil
                env.center_radius = 0
                env.center_point = {}
                
                if self.respawn_wait_start == 0 then
                    self.respawn_wait_start = api_GetTickCount64()
                    return bret.RUNNING
                elseif api_GetTickCount64() - self.respawn_wait_start < 2 then
                    return bret.RUNNING
                else
                    self.respawn_wait_start = 0
                end
            end
            poe2_api.time_p("Is_Deth_Otherworld... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 检查低血量/蓝量
    CheckLowHpMp_Otherworld = {
        run = function(self, env)
            local start_time = api_GetTickCount64()
            poe2_api.dbgp("开始执行蓝血检查:")
            
            local player = env.player_info
            local prot = env.protection_settings
            local emerg = env.emergency_settings
            
            -- 初始化计时器（如果不存在）
            if self.last_health_recovery_time == nil then
                self.last_health_recovery_time = api_GetTickCount64()
                self.last_mana_recovery_time = api_GetTickCount64()
                self.last_shield_recovery_time = api_GetTickCount64()
                self._emergency_cooldown = 0
                poe2_api.dbgp("初始化计时器完成")
            end
            
            -- 检查玩家信息
            if not player then
                poe2_api.dbgp("错误: 玩家信息为空")
                return bret.RUNNING
            end

            local function _handle_regular_recovery(player, prot, now)
                poe2_api.dbgp("开始处理常规恢复...")
                poe2_api.dbgp("当前生命值:", player.life, "/", player.max_life)
                poe2_api.dbgp("当前法力值:", player.mana, "/", player.max_mana)
                poe2_api.dbgp("当前护盾值:", player.shield, "/", player.max_shield)
                
                -- 血量恢复
                local hp_cfg = prot.health_recovery or {}
                if hp_cfg.enable then
                    local threshold = player.max_life * (hp_cfg.threshold / 100)
                    local interval = (hp_cfg.interval or 0) / 1000
                    
                    poe2_api.dbgp(string.format("血量检查: 当前 %.1f < 阈值 %.1f (%.1f%%) 且冷却 %.1fs >= 间隔 %.1fs", 
                        player.life, threshold, hp_cfg.threshold, 
                        start_time - self.last_health_recovery_time, interval))
                    
                    if player.life < threshold and now - self.last_health_recovery_time >= interval then
                        poe2_api.dbgp("触发血量恢复 - 按下1键")
                        poe2_api.click_keyboard("1")
                        self.last_health_recovery_time = now
                    end
                end
                
                -- 蓝量恢复
                local mp_cfg = prot.mana_recovery or {}
                if mp_cfg.enable then
                    local threshold = player.max_mana * (mp_cfg.threshold / 100)
                    local interval = (mp_cfg.interval or 0) / 1000
                    
                    poe2_api.dbgp(string.format("蓝量检查: 当前 %.1f < 阈值 %.1f (%.1f%%) 且冷却 %.1fs >= 间隔 %.1fs", 
                        player.mana, threshold, mp_cfg.threshold, 
                        now - self.last_mana_recovery_time, interval))
                    
                    if player.mana < threshold and now - self.last_mana_recovery_time >= interval then
                        poe2_api.dbgp("触发蓝量恢复 - 按下2键")
                        poe2_api.click_keyboard("2")
                        self.last_mana_recovery_time = now
                    end
                end
                
                -- 护盾恢复
                local shield_cfg = prot.shield_recovery or {}
                if shield_cfg.enable then
                    local threshold = player.max_shield * (shield_cfg.threshold / 100)
                    local interval = (shield_cfg.interval or 0) / 1000
                    
                    poe2_api.dbgp(string.format("护盾检查: 当前 %.1f < 阈值 %.1f (%.1f%%) 且冷却 %.1fs >= 间隔 %.1fs", 
                        player.shield, threshold, shield_cfg.threshold, 
                        now - self.last_shield_recovery_time, interval))
                    
                    if player.shield < threshold and now - self.last_shield_recovery_time >= interval then
                        poe2_api.dbgp("触发护盾恢复 - 按下1键")
                        poe2_api.click_keyboard("1")
                        self.last_shield_recovery_time = now
                    end
                end
                
                return bret.SUCCESS
            end
            
            -- 检查是否在安全区域
            if poe2_api.table_contains(my_game_info.hideout, player.current_map_name_utf8) or 
            string.find(player.current_map_name_utf8, "town") then
                poe2_api.dbgp("在安全区域，跳过检查")
                return bret.SUCCESS
            end
            
            -- 处理常规恢复
            local regular_status = _handle_regular_recovery(player, prot, start_time)
            if regular_status ~= bret.SUCCESS then
                poe2_api.dbgp("常规恢复处理返回:", regular_status)
                return regular_status
            end

            poe2_api.time_p("CheckLowHpMp_Otherworld... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 逃跑
    Escape = {
        run = function(self, env)
            poe2_api.print_log("开始执行逃跑检查...")
            poe2_api.dbgp("开始执行逃跑检查...")
            local current_time = api_GetTickCount64()
            local start_time = current_time
            local now = current_time
            local player_info = env.player_info
            
            local emerg = env.emergency_settings
            local run_point = env.run_point
            local valid_monsters = env.valid_monsters
            local afoot_altar = env.afoot_altar
            
            if not player_info then
                poe2_api.dbgp("错误: 玩家信息为空")
                return bret.RUNNING
            end
            
            if player_info.isInBossBattle or afoot_altar then
                poe2_api.dbgp("在Boss战或祭坛中，跳过逃跑检查")
                return bret.SUCCESS
            end

            -- 检查祭坛
            -- local is_altar = _get_altar(range_info)
            -- if is_altar then
            --     poe2_api.dbgp("发现祭坛，检查周围怪物...")
            --     api_UpdateAutomaticUpdateBarrier(false)
            --     local dis = poe2_api.point_distance(is_altar.grid_x, is_altar.grid_y, player_info)
            --     if dis < 96 and _is_monster(range_info, player_info, 60, is_altar) then
            --         poe2_api.dbgp("祭坛附近有怪物，不执行逃跑")
            --         return bret.SUCCESS
            --     end
            -- end

            local function _is_monster(mate, dis, objter)
                for _, i in ipairs(env.range_info) do
                    if i.type == 1 and not i.is_friendly and i.life > 0 and 
                    not poe2_api.table_contains(my_game_info.not_attact_mons_CN_name, i.name_utf8) and 
                    i.isActive and not string.find(i.name_utf8, "神殿") and 
                    i.hasLineOfSight and i.is_selectable then
                        local dist1 = poe2_api.point_distance(mate.grid_x, mate.grid_y, {i.grid_x, i.grid_y})
                        local dist2 = poe2_api.point_distance(objter.grid_x, objter.grid_y, {i.grid_x, i.grid_y})
                        if dist1 and dist2 and dist1 <= dis and (not objter or dist2 > 99) then
                            poe2_api.dbgp(string.format("发现怪物: %s, 距离: %.1f", i.name_utf8, dist))
                            return i
                        end
                    end
                end
                return false
            end
    
            -- function _get_altar(range_info)
            --     for _, i in ipairs(range_info) do
            --         if i.path_name_utf8 == "Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable" and 
            --         i.stateMachineList and i.stateMachineList.current_state == 2 and 
            --         i.stateMachineList.interaction_enabled == 0 then
            --             poe2_api.dbgp("发现祭坛")
            --             return i
            --         end
            --     end
            --     return nil
            -- end
    
            local function _handle_space_action(monster, space_time)
                poe2_api.dbgp("执行空格键躲避动作...")
                local player_info = api_GetLocalPlayer()
                if not player_info then
                    poe2_api.dbgp("错误: 获取玩家信息失败")
                    return
                end
                
                space_time = space_time or 1.5
                space_time = space_time / 1000
                
                if monster and api_GetTickCount64() - (self.last_space_time or 0) >= space_time and math.random() < 0.8 then
                    poe2_api.dbgp(string.format("躲避怪物: %s", monster.name_utf8))
                    local result = api_GetNextCirclePosition(
                        monster.grid_x, monster.grid_y, 
                        player_info.grid_x, player_info.grid_y, 80
                    )
                    api_ClickMove(result.x, result.y, player_info.world_z - 70, 0)
                    api_Sleep(100)
                    poe2_api.dbgp1("xzvxbsgaesgfgbhfbs")
                    poe2_api.click_keyboard("space")
                    self.last_space_time = api_GetTickCount64() + math.random(-0.05, 0.05)
                end
            end
    
            local function _handle_regular_space(player, prot, now, run_point, valid_monsters)
                poe2_api.dbgp("处理常规逃跑逻辑...")
                local point = {}
                local current_time = api_GetTickCount64()
                
                -- 血量逃跑
                local hp_cfg = prot.low_health or {}
                if hp_cfg.enable then
                    local threshold = player.max_life * (hp_cfg.threshold / 100)
                    poe2_api.dbgp(string.format("血量逃跑检查: 当前 %.1f/%.1f, 阈值 %.1f", 
                        player.life, player.max_life, threshold))
                    
                    if player.life < threshold then
                        if not run_point then
                            poe2_api.dbgp("血量过低，寻找安全区域...")
                            local ret = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 60, 10, 0, 0.5)
                            if ret and ret.x ~= -1 and ret.y ~= -1 then
                                point = {ret.x, ret.y}
                            end
                            
                            if next(point) ~= nil then
                                poe2_api.dbgp("找到安全点，设置逃跑路径")
                                env.run_point = point
                            else
                                poe2_api.dbgp("未找到安全点，执行躲避动作")
                                _handle_space_action(valid_monsters)
                                return bret.RUNNING
                            end
                        else
                            poe2_api.dbgp("已有逃跑路径，设置终点")
                            env.end_point = run_point
                            return bret.FAIL
                        end
                    else
                        env.run_point = nil
                    end
                end
    
                -- 蓝量逃跑
                local mp_cfg = prot.low_mana or {}
                if mp_cfg.enable then
                    local threshold = player.max_mana * (mp_cfg.threshold / 100)
                    poe2_api.dbgp(string.format("蓝量逃跑检查: 当前 %.1f/%.1f, 阈值 %.1f", 
                        player.mana, player.max_mana, threshold))
                    
                    if player.mana < threshold then
                        poe2_api.dbgp("蓝量过低，寻找安全区域...")
                        if not run_point then
                            local ret = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 60, 10, 0, 0.5)
                            if ret and ret.x ~= -1 and ret.y ~= -1 then
                                point = {ret.x, ret.y}
                            end
                            
                            if next(point) ~= nil then
                                poe2_api.dbgp("找到安全点，设置逃跑路径")
                                env.end_point = point
                                return bret.FAIL
                            else
                                poe2_api.dbgp("未找到安全点，执行躲避动作")
                                _handle_space_action(valid_monsters)
                            end
                        else
                            poe2_api.dbgp("已有逃跑路径，设置终点")
                            env.end_point = run_point
                            return bret.FAIL
                        end
                    else
                        env.run_point = nil
                    end
                end
    
                -- 护盾逃跑
                local shield_cfg = prot.low_shield or {}
                if shield_cfg.enable then
                    local threshold = player.max_shield * (shield_cfg.threshold / 100)
                    poe2_api.dbgp(string.format("护盾逃跑检查: 当前 %.1f/%.1f, 阈值 %.1f", 
                        player.shield, player.max_shield, threshold))
                    
                    if player.shield < threshold then
                        poe2_api.dbgp("护盾过低，寻找安全区域...")
                        if not run_point then
                            local ret = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 60, 10, 0, 0.5)
                            if ret and ret.x ~= -1 and ret.y ~= -1 then
                                point = {ret.x, ret.y}
                            end
                            
                            if next(point) ~= nil then
                                poe2_api.dbgp("找到安全点，设置逃跑路径")
                                env.run_point = point
                            else
                                poe2_api.dbgp("未找到安全点，执行躲避动作")
                                _handle_space_action(valid_monsters)
                            end
                        else
                            poe2_api.dbgp("已有逃跑路径，设置终点")
                            env.end_point = run_point
                            return bret.FAIL
                        end
                    else
                        env.run_point = nil
                    end
                end
    
                return bret.SUCCESS
            end

            -- 处理常规逃跑
            poe2_api.dbgp("处理常规逃跑")
            local status = _handle_regular_space(player_info, emerg, now, run_point, valid_monsters)
            poe2_api.dbgp("常规逃跑处理返回状态:", status)
            if status and status ~= bret.SUCCESS then
                poe2_api.dbgp("常规逃跑处理返回状态:", status)
                return status
            end
            poe2_api.time_p("Escape... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 检查是否在主页面
    Not_Main_Page_Otherworld = {
        run = function(self, env)
            poe2_api.print_log("检查是否在主页面...")
            local strat_time = api_GetTickCount64()

            local current_map_info = env.current_map_info
            local player_info = env.player_info

            
            -- if player_info then
            --     return bret.SUCCESS
            -- end
            
            if poe2_api.find_text{UI_info = env.UI_info, text = "繼續遊戲", add_x = 0, add_y = 0, click = 2} then
                return bret.RUNNING
            end

            if poe2_api.find_text{UI_info = env.UI_info, text = "已收到隊伍邀請"} then
                poe2_api.find_text{UI_info = env.UI_info, text = "拒絕", max_x = 1600, click = 2}
                return bret.RUNNING
            end

            local a = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 985,min_y = 5,max_x = 1034,max_y = 47})
            if poe2_api.find_text({UI_info = env.UI_info, text="記錄點", add_x = 213, max_y = 50}) and a and next(a) then
                poe2_api.find_text({UI_info = env.UI_info, text="記錄點", click=2, add_x = 213, max_y = 50})
                return bret.RUNNING
            end

            if player_info and poe2_api.table_contains(my_game_info.hideout,player_info.current_map_name_utf8) then
                local click_2 ={"接受任務" ,"繼續"}
                if poe2_api.find_text({UI_info = env.UI_info, text = click_2, click = 2}) then
                    api_Sleep(500)  -- Equivalent to time.sleep(0.5)
                    return bret.RUNNING
                end

                if poe2_api.find_text({UI_info = env.UI_info, text = "你無法將此道具丟置於此。請問要摧毀它嗎？", min_x = 0, min_y = 0}) then
                    poe2_api.find_text({UI_info = env.UI_info, text = "保留", min_x = 0, min_y = 0, click = 2})
                    return bret.RUNNING
                end

                local item = api_Getinventorys(0xd,0)
                if item and next(item) then
                    local width = item[1].end_x - item[1].start_x
                    local height = item[1].end_y - item[1].start_y
                    local item_category = {"One Hand Mace","Two Hand Mace","Warstaff","Wand","Staff","Crossbow","Sceptre","Bow",
                    "Body Armour","Helmet","Gloves","Boots","Shield","Quiver","Focus","Amulet","Belt","Ring","Spear","Buckler"}
                    if poe2_api.table_contains(item[1].category_utf8,item_category) then
                        poe2_api.dbgp("检测到物品，将执行点击操作111111")
                        local index_list ={2,3,4,5,6,7,8,9,0xa,0xb}
                        local point_list = {
                            [2] = {1320,250},
                            [3] = {1151,191},
                            [4] = {1493,191},
                            [5] = {1322,133},
                            [6] = {1410,201},
                            [7] = {1237,255},
                            [8] = {1410,255},
                            [9] = {1213,330},
                            [0xa] = {1431,330},
                            [0xb] = {1322,353},
                        }
                        local point = nil
                        for _, v in ipairs(index_list) do
                            if poe2_api.table_contains(v,{10,11}) then
                                v = string.format("0x%x", v)
                            end
                            local item_player = env["item"..v]
                            if item_player and next(item_player) then
                                if item[1].baseType_utf8 == item_player[1].baseType_utf8 
                                and item[1].DemandStrength == item_player[1].DemandStrength
                                and item[1].DemandAgility == item_player[1].DemandAgility
                                and item[1].DemandWisdom == item_player[1].DemandWisdom
                                and item[1].DemandLevel == item_player[1].DemandLevel
                                and item[1].not_identified == item_player[1].not_identified
                                and item[1].category_utf8 == item_player[1].category_utf8
                                and item[1].color == item_player[1].color then
                                    local current_item = api_Getinventorys(v,0)
                                    if current_item and next(current_item) then
                                        if current_item[1].baseType_utf8 == item_player[1].baseType_utf8 
                                        and current_item[1].DemandStrength == item_player[1].DemandStrength
                                        and current_item[1].DemandAgility == item_player[1].DemandAgility
                                        and current_item[1].DemandWisdom == item_player[1].DemandWisdom
                                        and current_item[1].DemandLevel == item_player[1].DemandLevel
                                        and current_item[1].not_identified == item_player[1].not_identified
                                        and current_item[1].category_utf8 == item_player[1].category_utf8
                                        and current_item[1].color == item_player[1].color then
                                        else
                                            point = point_list[v]
                                            break
                                        end
                                    else
                                        point = point_list[v]
                                        break
                                    end
                                end
                            else
                                point = point_list[v]
                                break
                            end
                        end
                        if point then
                            if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                                api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                                api_Sleep(500)
                                poe2_api.time_p("开背包,城区附着... 耗时 --> ", api_GetTickCount64() - strat_time)
                                return bret.RUNNING
                            else
                                poe2_api.dbgp("开背包,城区附着")
                                poe2_api.click_keyboard("i")
                                api_Sleep(300)
                                poe2_api.time_p("开背包,城区附着1... 耗时 --> ", api_GetTickCount64() - strat_time)
                                return bret.RUNNING
                            end
                        end
                    end
                    local point = poe2_api.get_space_point({width = width, height = height, info = env.bag_info})
                    
                    poe2_api.dbgp(string.format("物品尺寸: 宽%d, 高%d", width, height))
                    poe2_api.dbgp(point[1],point[2])
                    if point then
                        poe2_api.dbgp(string.format("获取到空间点: (%d, %d)", poe2_api.toInt(point[1]), poe2_api.toInt(point[2])))
                        
                        if poe2_api.find_text({UI_info = env.UI_info, text = "背包",min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                            poe2_api.dbgp("检测到背包文字，将执行点击操作")
                            api_ClickScreen(point[1], point[2])
                            api_Sleep(100)
                            api_ClickScreen(point[1], point[2],1)
                            api_Sleep(500)
                        else
                            poe2_api.dbgp("未检测到背包文字，将按I键打开背包")
                            poe2_api.click_keyboard("i")
                            api_Sleep(500)
                        end
                        return bret.RUNNING
                    else
                        poe2_api.dbgp("警告: 无法获取物品空间点")
                    end
                end


                local item = api_Getinventorys(0xd,0)
                if item and #item > 0 then
                    local point = poe2_api.get_space_point({width = item[1].end_x - item[1].start_x,height = item[1].end_y - item[1].start_y})
                    if point then
                        if poe2_api.find_text({UI_info = env.UI_info, text = "背包", min_x = 1020}) then
                            api_ClickScreen(poe2_api.toInt(point[1]), poe2_api.toInt(point[2]),1)
                            api_Sleep(500)
                            return bret.RUNNING
                        else
                            poe2_api.click_keyboard("i")
                            api_Sleep(500)
                            return bret.RUNNING
                        end
                    end
                end
            end

            poe2_api.time_p("Not_Main_Page_Otherworld 耗时 -->", api_GetTickCount64() - strat_time)
            return bret.SUCCESS
        end
    },

    Set_Base_Skill1 = {
        run = function(self, env)
            return bret.SUCCESS
        end
    },

    -- 设置基础技能
    Set_Base_Skill = {
        run = function(self, env)
            poe2_api.print_log("设置基础技能...")
            poe2_api.dbgp("设置基础技能...")
            local start_time = api_GetTickCount64()

            if not self.is_initialized then
                poe2_api.dbgp("初始化设置基础技能")
                self.bool = false  -- 初始化时间戳
                self.bool1 = false
                self.is_initialized = true
            end

            local skill_location = function(skill_name, skill_pos, selectable_skills)
                if not selectable_skills then
                    return false
                end
                -- 获取指定位置
                poe2_api.dbgp("skill_location", skill_name, skill_pos, selectable_skills)
                local point = my_game_info.skill_pos[skill_pos]
                -- 将所有 text_utf8 属性的值存储在一个集合中
                local skill_names = {}
                for _, skill_control in ipairs(selectable_skills) do
                    if skill_control.text_utf8 then
                        skill_names[skill_control.text_utf8] = true
                    end
                end
                
                -- 检查 skill_name 是否在集合中
                if not skill_names[skill_name] then
                    return false
                end
                
                -- 遍历所有可选择的技能控件
                for _, skill_control in ipairs(selectable_skills) do
                    if skill_name == skill_control.text_utf8 then
                        -- 计算中间位置
                        local center_x = (skill_control.left + skill_control.right) / 2
                        local center_y = (skill_control.top + skill_control.bottom) / 2
                        
                        -- 检查位置是否在指定范围内
                        if point[1] - 5 < center_x and center_x < point[1] + 5 and 
                        point[2] - 5 < center_y and center_y < point[2] + 5 then
                            return true
                        end
                    end
                end
                return false
            end

            local get_move_skill = function(selectable_skills)
                poe2_api.dbgp("get_move_skill", selectable_skills)
                if not skill_location("", "MIDDLE", selectable_skills) then
                    return false
                end
                return true
            end
            
            local set_pos = function(skill_name, rom_x, rom_y, selectable_skills)
                poe2_api.dbgp("set_pos", skill_name, rom_x, rom_y, selectable_skills)
                if not selectable_skills then
                    return false
                end
                for _, k in ipairs(selectable_skills) do
                    if 1104 <= k.left and k.left <= 1597 and k.bottom <= 770 and skill_name == k.text_utf8 then
                        local center_x = (k.left + k.right) / 2 + rom_x
                        local center_y = (k.top + k.bottom) / 2 + rom_y
                        api_ClickScreen(math.floor(center_x), math.floor(center_y),1)
                        api_Sleep(500)
                        return true
                    end
                end
                return false
            end
            
            local cancel_left_skill = function(selectable_skills)
                poe2_api.dbgp("cancel_left_skill", selectable_skills)
                if not selectable_skills then
                    return false
                end
                for _, k in ipairs(selectable_skills) do
                    if 1277 <= k.left and k.left <= 1285 and k.top > 790 and k.bottom <= 832 and k.right < 1316 then
                        return true
                    end
                end
                return false
            end

            if not env.mouse_check then
                poe2_api.dbgp("mouse_check", mouse_check)
                poe2_api.time_p("mouse_check... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end

            if poe2_api.find_text({UI_info = env.UI_info, text = "繼續遊戲", click = 2}) then
                poe2_api.dbgp("发现'繼續遊戲'文本，点击处理中...")
                return bret.RUNNING
            end

            if not (poe2_api.click_text_UI({UI_info = env.UI_info, text = "life_orb"})
             or poe2_api.click_text_UI({UI_info = env.UI_info, text = "resume_game"})
             or poe2_api.find_text({UI_info = env.UI_info, text = "清單",min_x = 0,min_y = 0,max_x = 400})) then
                poe2_api.print_log("未找到游戏界面")
                return bret.RUNNING
            end
            poe2_api.dbgp("获取技能")
            local selectable_skills = api_GetSelectableSkillControls()
            local allskill_info = api_GetAllSkill()
            local skill_slots = api_GetSkillSlots()
            -- poe2_api.dbgp("1111")
            -- poe2_api.printTable(selectable_skills)
            -- poe2_api.dbgp("2222")
            -- poe2_api.printTable(allskill_info)
            -- poe2_api.dbgp("3333")
            -- poe2_api.printTable(skill_slots)
            
            if not selectable_skills then
                poe2_api.print_log("获取可选技能技能控件信息失败")
                return bret.RUNNING
            end
            if not allskill_info then
                poe2_api.print_log("获取全部技能信息失败")
                return bret.RUNNING
            end
            if not skill_slots then
                poe2_api.print_log("获取快捷栏技能信息失败")
                return bret.RUNNING
            end
            self.bool = cancel_left_skill( selectable_skills)
            self.bool1 = get_move_skill(selectable_skills)
            poe2_api.print_log("self.bool",self.bool)
            if not self.bool1 then
                poe2_api.dbgp("未设鼠标中键")
                if not set_pos("", 0, 0, selectable_skills) then
                    local point = my_game_info.skill_pos["MIDDLE"]
                    api_ClickScreen(math.floor(point[1]), math.floor(point[2]),1)
                    api_Sleep(500)
                end
                return bret.RUNNING
            end
            
            if self.bool then
                poe2_api.dbgp("取消鼠标左键技能")
                if not set_pos('', 50, 0, selectable_skills) then
                    local point = my_game_info.skill_pos["P"]
                    api_ClickScreen(math.floor(point[1]), math.floor(point[2]),1)
                    api_Sleep(500)
                end
                return bret.RUNNING
            end
            poe2_api.time_p("检查基础技能... 耗时 --> ", api_GetTickCount64() - start_time)
            env.mouse_check = false
            return bret.SUCCESS
        end
    },


    -- 使用任务道具
    Use_Task_Props = {
        run = function(self, env)
            poe2_api.print_log("使用任务道具...")
            local start_time = api_GetTickCount64()
            local bag = env.bag_info
            local player_info = env.player_info
            -- local current_map_info = env.current_map_info
            if not next(player_info) then
                return bret.RUNNING
            end
           
            local function is_props(bag)
                local text_list = {"知識之書","知識之結晶核心"}
                for _, i in ipairs(bag) do
                    if i.category_utf8 == "QuestItem" then
                        for _, v in ipairs(text_list) do
                            if string.match(i.baseType_utf8,v) then
                                return i
                            end
                            
                        end
                    end
                end
                return false
            end
            
            if bag and next(bag) then
                local props = is_props(bag)
                if props then
                    if not poe2_api.find_text({text = "背包", min_x = 1020, min_y = 32, max_x = 1600, max_y = 81}) then
                        poe2_api.click_keyboard("i")
                        poe2_api.dbgp("关背包1")
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    local point = poe2_api.get_center_position({props.start_x,props.start_y},{props.end_x,props.end_y})
                    if point and next(point) then
                        poe2_api.right_click(point[1],point[2])
                        return bret.RUNNING 
                    end
                end
            end
            local elapsed_ms = (api_GetTickCount64()) - start_time
            poe2_api.dbgp("使用任务道具耗时:"..string.format( elapsed_ms))
            return bret.SUCCESS
        end
    },

    -- 对话分解NPC
    Dialogue_Break_Down_NPC = {
        run = function(self, env)
            poe2_api.dbgp("开始执行对话分解NPC...")
            local current_time = api_GetTickCount64()
            local bag_info = env.bag_info
            local player_info = env.player_info
            local config = env.user_config
            
            
            poe2_api.dbgp(string.format("当前地图: %s", player_info.current_map_name_utf8 or "未知"))
            poe2_api.dbgp(string.format("背包物品数量: %d", bag_info and #bag_info or 0))

            -- 不在藏身处直接返回
            if not poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                poe2_api.dbgp("不在藏身处，跳过分解流程")
                return bret.SUCCESS
            end
            
            local break_down = config["全局設置"]["刷图通用設置"]["是否分解暗金"]
            -- local break_down = fasle
            poe2_api.dbgp(string.format("分解暗金设置: %s", tostring(break_down)))
            
            -- 检查是否有可分解物品
            local function check_brak_items()
                poe2_api.dbgp("开始检查可分解物品...")
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        if poe2_api.table_contains(my_game_info.sell_list, item.category_utf8) and item.color ~= 0 then
                            poe2_api.dbgp(string.format("找到可分解物品: %s (类型: %s, 颜色: %d)", 
                                item.baseType_utf8 or "无名", item.category_utf8 or "无类型", item.color or -1))
                            return true
                        end
                    end
                end
                poe2_api.dbgp("未找到可分解物品")
                return false
            end
            
            
            poe2_api.dbgp("当前在藏身处")
            
            -- 获取物品配置信息
            local function get_items_config_info()
                poe2_api.dbgp("开始解析物品过滤配置...")
                local item_configs = config["物品過濾"] or {}
                local processed_configs = {}
                
                for i, cfg in ipairs(item_configs) do
                    -- poe2_api.dbgp(string.format("处理配置项 %d: 类型=%s, 基础类型=%s", 
                    --     i, cfg["類型"] or "无", cfg["基礎類型名"] or "无"))
                    
                    local processed = {
                        ["類型"] = cfg["類型"] and type(cfg["類型"]) == "table" and cfg["類型"] or {cfg["類型"]},
                        ["名稱模式"] = cfg["基礎類型名"] and cfg["基礎類型名"] == "全部物品" and "all" or "specific",
                        ["匹配名稱"] = cfg["基礎類型名"] and cfg["基礎類型名"] ~= "全部物品" and {cfg["基礎類型名"]} or {},
                        ["颜色"] = {}
                    }
                    
                    if cfg["白裝"] then table.insert(processed["颜色"], 0) end
                    if cfg["藍裝"] then table.insert(processed["颜色"], 1) end
                    if cfg["黃裝"] then table.insert(processed["颜色"], 2) end
                    if cfg["暗金"] then table.insert(processed["颜色"], 3) end
                    
                    processed["不撿"] = cfg["不撿"]
                    processed["等級"] = cfg["等級"]
                    
                    -- poe2_api.dbgp(string.format("配置项 %d 处理结果: 不捡=%s, 颜色条件=%s", 
                    --     i, tostring(processed["不撿"]), table.concat(processed["颜色"], ",")))
                    
                    table.insert(processed_configs, processed)
                end
                return processed_configs
            end
            
            local processed_configs = get_items_config_info()
            poe2_api.dbgp(string.format("共加载 %d 条物品过滤规则", #processed_configs))
            
            -- 提取等级
            local function extract_level(text)
                local level = string.match(text, "階級%s*(%d+)")
                poe2_api.dbgp(string.format("从文本 '%s' 中提取等级: %s", text, level or "无"))
                return level and tonumber(level) or nil
            end
            
            -- 匹配物品
            local function match_item(item, cfg)
                poe2_api.dbgp(string.format("开始匹配物品: %s (类型: %s)", item.baseType_utf8 or "无名", item.category_utf8 or "无类型"))
                
                if not cfg["類型"][1] or item.category_utf8 ~= my_game_info.type_conversion[cfg["類型"][1]] then
                    -- poe2_api.dbgp("类型不匹配，跳过")
                    return false
                end
                
                -- 名称匹配
                if cfg["名稱模式"] == "specific" then
                    if not cfg["匹配名稱"][1] or not poe2_api.table_contains(cfg["匹配名稱"], item.baseType_utf8) then
                        -- poe2_api.dbgp("名称不匹配，跳过")
                        return false
                    end
                end
                
                -- 等级检查
                local level = cfg["等級"]
                if level then
                    local item_type = level["type"]
                    poe2_api.dbgp(string.format("等级检查: 类型=%s", item_type))
                    
                    if item.category_utf8 == "Map" then
                        local map_level = extract_level(item.baseType_utf8)
                        if item_type == "exact" then
                            local item_level = level["value"]
                            if map_level and map_level < item_level - 3 then
                                poe2_api.dbgp(string.format("地图等级 %d 低于要求 %d，跳过", map_level, item_level))
                                return false
                            end
                        else
                            local min_level = level["min"]
                            local max_level = level["max"]
                            if map_level and (map_level < min_level or map_level > max_level) then
                                poe2_api.dbgp(string.format("地图等级 %d 不在范围 %d-%d 内，跳过", map_level, min_level, max_level))
                                return false
                            end
                        end
                    elseif poe2_api.table_contains({"UncutSkillGem", "UncutReservationGem", "UncutSupportGem"}, item.category_utf8) then
                        if item_type == "exact" then
                            local item_level = level["value"]
                            if item.skillGemLevel and (item.skillGemLevel < item_level or item.skillGemLevel > item_level) then
                                poe2_api.dbgp(string.format("宝石等级 %d 不符合要求 %d，跳过", item.skillGemLevel or 0, item_level))
                                return false
                            end
                        else
                            local min_level = level["min"]
                            local max_level = level["max"]
                            if item.skillGemLevel and (item.skillGemLevel < min_level or item.skillGemLevel > max_level) then
                                poe2_api.dbgp(string.format("宝石等级 %d 不在范围 %d-%d 内，跳过", item.skillGemLevel or 0, min_level, max_level))
                                return false
                            end
                        end
                    else
                        if item_type == "exact" then
                            local item_level = level["value"]
                            if item.DemandLevel and item.DemandLevel < item_level - 3 then
                                poe2_api.dbgp(string.format("物品需求等级 %d 低于要求 %d，跳过", item.DemandLevel or 0, item_level))
                                return false
                            end
                        else
                            local min_level = level["min"]
                            local max_level = level["max"]
                            if item.DemandLevel and min_level and max_level and (item.DemandLevel < min_level or item.DemandLevel > max_level) then
                                poe2_api.dbgp(string.format("物品需求等级 %d 不在范围 %d-%d 内，跳过", item.DemandLevel or 0, min_level, max_level))
                                return false
                            end
                        end
                    end
                end

                -- 通货排除黄金
                if item.category_utf8 == "StackableCurrency" and poe2_api.table_contains({"黃金", "金幣"}, item.baseType_utf8) then
                    poe2_api.dbgp("排除黄金货币，跳过")
                    return false
                end
                
                -- 颜色检查
                -- poe2_api.printTable(cfg["颜色"])
                -- 只有当颜色表存在且不为空时才检查
                if cfg["颜色"] and next(cfg["颜色"]) then
                    if not poe2_api.table_contains(cfg["颜色"], item.color) then
                        poe2_api.dbgp(string.format("颜色 %d 不符合条件 %s，跳过", item.color or -1, table.concat(cfg["颜色"], ",")))
                        return false
                    end
                else
                    poe2_api.dbgp("无颜色限制或颜色匹配")
                    return true
                end
                
                poe2_api.dbgp("物品匹配成功")
                return true
            end
            
            -- 检查是否不拾取
            local function is_do_without_pick_up(item)
                poe2_api.dbgp(string.format("检查物品 %s 是否设置为不拾取", item.baseType_utf8 or "无名"))
                
                local item_key = nil
                for k, v in pairs(my_game_info.type_conversion) do
                    if v == item.category_utf8 then
                        item_key = k
                        break
                    end
                end
                
                if item_key then
                    for _, cfg in ipairs(processed_configs) do
                        if cfg["類型"][1] == item_key then
                            if cfg["不撿"] and (cfg["基礎類型名"] == "全部物品" or item.baseType_utf8 == cfg["基礎類型名"]) then
                                poe2_api.dbgp("物品设置为不拾取")
                                return true
                            end
                        end
                    end
                end
                return false
            end
            
            -- 获取不需要的物品列表
            local function get_not_item(items)
                poe2_api.dbgp("开始筛选不需要的物品...")
                local break_list = {}
                
                local function get_not(item)
                    poe2_api.dbgp(string.format("检查物品: %s (类型: %s, 颜色: %d)", 
                        item.baseType_utf8 or "无名", item.category_utf8 or "无类型", item.color or -1))
                    
                    if item.category_utf8 == "QuestItem" and item.baseType_utf8 == "知識之書" then
                        poe2_api.dbgp("知识之书，保留")
                        return false
                    end
                    
                    if is_do_without_pick_up(item) then
                        return true
                    end
                    
                    for _, cfg in ipairs(processed_configs) do
                        if match_item(item, cfg) then
                            if cfg["不撿"] then
                                poe2_api.dbgp("配置标记为不捡")
                                return true
                            end

                            -- 如果没有颜色配置，则视为"三无物品"，直接返回true(分解)
                            if not cfg["颜色"] or not next(cfg["颜色"]) then
                                poe2_api.dbgp("三无物品，分解")
                                return true
                            end
                            
                            if item.baseType_utf8 == "知識卷軸" then
                                local index = {}
                                for _, i in ipairs(items) do
                                    if i.baseType_utf8 == "知識卷軸" then
                                        table.insert(index, i)
                                    end
                                end
                                if #index > 2 then
                                    -- poe2_api.dbgp("知识卷轴超过2个，标记为分解")
                                    return true
                                end
                            end
                            
                            if poe2_api.table_contains(my_game_info.equip_type, item.category_utf8) and item.color > 0 and not item.not_identified then
                                local suffixes = api_GetObjectSuffix(item.mods_obj)
                                if not suffixes then
                                    poe2_api.dbgp("无词缀物品，标记为分解")
                                    return {item}
                                end
                                if not poe2_api.filter_item(item, suffixes, config["物品過濾"] or {}) then
                                    poe2_api.dbgp("词缀不符合要求，标记为分解")
                                    return true
                                end
                            end
                            poe2_api.dbgp("物品符合保留条件")
                            return false
                        end
                    end
                    poe2_api.dbgp("无匹配配置，默认保留")
                    return true
                end
                
                if not items then
                    poe2_api.dbgp("无物品数据")
                    return false
                end
                
                for _, item in ipairs(items) do
                    if not poe2_api.table_contains(my_game_info.sell_list, item.category_utf8) and item.color ~= 3 then
                        poe2_api.dbgp(string.format("物品 %s 不在分解列表中，跳过", item.baseType_utf8 or "无名"))
                        goto continue
                    end
                    
                    if item.color == 0 then
                        poe2_api.dbgp("白色物品，跳过")
                        goto continue
                    end
                    
                    local is_dis = get_not(item)
                    if is_dis then
                        poe2_api.dbgp("添加到分解列表")
                        table.insert(break_list, item)
                    end
                    
                    ::continue::
                end
                
                poe2_api.dbgp(string.format("共找到 %d 件需要分解的物品", #break_list))
                return break_list
            end
            
            local break_list = nil
            if break_down and check_brak_items() then
                if bag_info then
                    break_list = get_not_item(bag_info)
                    if not break_list or #break_list == 0 then
                        poe2_api.dbgp("没有需要分解的物品")
                        return bret.SUCCESS
                    end
                end
                if current_time - (self.last_action_time or 0) >= (self.action_interval or 1) then
                    poe2_api.dbgp("检查UI界面...")
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text = "重鑄台", min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", min_x = 0}) then
                        poe2_api.dbgp("发现重铸台界面，按空格关闭")
                        poe2_api.dbgp1("dasvdbfhdsgaga")
                        poe2_api.click_keyboard("space")
                        self.last_action_time = current_time
                        return bret.RUNNING
                    end
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text = "重置天賦點數", min_x = 0, max_y = 200}) then
                        poe2_api.dbgp("发现天赋重置界面，按空格关闭")
                        poe2_api.dbgp1("qdsfvdsgvsdgbdfbd")
                        poe2_api.click_keyboard("space")
                        self.last_action_time = current_time
                        return bret.RUNNING
                    end
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text = "購買或販賣", min_x = 0, max_x = 800}) then
                        poe2_api.dbgp("发现商店界面，按空格关闭")
                        poe2_api.dbgp1("fnbfgnfgjhndfnbdfb")
                        poe2_api.click_keyboard("space")
                        self.last_action_time = current_time
                        return bret.RUNNING
                    end
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text = "重置天賦點數", min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = "返還輿圖天賦", min_x = 0}) then
                        poe2_api.dbgp("发现天赋重置确认界面，点击'再会'")
                        poe2_api.find_text({UI_info = env.UI_info, text = "再會", click = 2})
                        self.last_action_time = current_time
                        return bret.RUNNING
                    end

                    local interactive_npc = nil
                    local interactive_text = nil
                    -- if env.player_info.current_map_name_utf8 == "G_Endgame_Town" then
                    --     interactive_npc = "時間建造者．凱亞祖利"
                    --     interactive_text = "時間建造者．凱亞祖利 的物品"
                    -- else
                    interactive_npc = "佐林"
                    interactive_text = "佐林 的物品"
                    -- end

                    if not poe2_api.find_text({UI_info = env.UI_info, text = interactive_text, min_x = 0}) then
                        env.interactive = interactive_npc
                        map_obj = poe2_api.check_in_map(current_map_info,env.interactive)
                        range_obj = poe2_api.check_in_range(env.range_info, env.interactive)
                        target_obj = map_obj or range_obj or nil
                        poe2_api.dbgp(target_obj)
                        if target_obj then
                            distance = poe2_api.point_distance(target_obj.grid_x,target_obj.grid_y,player_info)
                            poe2_api.dbgp("distance",distance)
                            if distance and distance > 25 then
                                poe2_api.dbgp("交互",env.interactive)
                                return bret.FAIL
                            else
                                api_Sleep(1000)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = "祛魔物品"}) then
                                    poe2_api.find_text({UI_info = env.UI_info, text = interactive_npc,click=2, refresh = true})
                                    api_Sleep(500)
                                    return bret.RUNNING
                                else
                                    poe2_api.find_text({UI_info = env.UI_info, text = "祛魔物品", click = 2})
                                    api_Sleep(500)
                                    -- api_Sleep(50000)
                                    return bret.RUNNING
                                end
                            end
                        else
                            poe2_api.dbgp("当前没有分解NPC")
                            return bret.FAIL
                        end
                    else
                        if break_list and #break_list > 0 then
                            poe2_api.dbgp("开始分解物品...")
                            for _, item in ipairs(break_list) do
                                poe2_api.dbgp(string.format("分解物品: %s", item.baseType_utf8 or "无名"))
                                poe2_api.ctrl_left_click_bag_items(item.obj, bag_info)
                                api_Sleep(200)
                            end
                            poe2_api.dbgp("点击确认分解")
                            poe2_api.find_text({UI_info = env.UI_info, text = "接受", min_x = 315, min_y = 719, max_x = 443, max_y = 752, click = 2})
                            api_Sleep(200)
                        end
                    end
                else
                    poe2_api.dbgp(string.format("操作冷却中，剩余时间: %.1f秒", 
                        (self.action_interval or 1) - (current_time - (self.last_action_time or 0))))
                end
                return bret.RUNNING
            else
                if poe2_api.find_text({UI_info = env.UI_info, text = "祛魔物品"}) and not env.is_shop and not env.full_map then
                    poe2_api.dbgp("发现祛魔物品界面且不在商店，点击关闭")
                    poe2_api.find_text({UI_info = env.UI_info, text = "再會", click = 2})
                    api_Sleep(100)
                    return bret.RUNNING
                end
                poe2_api.dbgp("无需分解操作")
                poe2_api.time_p("分解... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
        end
    },

    -- 检查是否获得牌匾
    Is_Get_Plaque = {
        run = function(self, env)
            poe2_api.print_log("检查是否获得牌匾...")
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.wait = false
                self.dq_time = nil
                self.index = 1
                self.bool = true
                poe2_api.time_p("检查是否获得牌匾初始化（RUNNING）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            
            local function is_get_plaque(bag_info)
                if not bag_info or #bag_info == 0 then
                    return false
                end
                -- 需要查找的碑牌名称集合
                local required_plaques = {"祭祀碑牌", "先行者碑牌", "譫妄碑牌", "裂痕碑牌", "總督的先行者碑牌","探險碑牌"}
                -- 从bag_info中提取所有碑牌名称
                local found_plaques = {}
                for _, item in ipairs(bag_info) do
                    if item.baseType_utf8 then
                        found_plaques[item.baseType_utf8] = true
                    end
                end
                -- 检查是否包含所有required_plaques
                for plaque, _ in pairs(required_plaques) do
                    if not found_plaques[plaque] then
                        return false
                    end
                end
            end
            local function plaque_bag(bag_info)
                if not bag_info or #bag_info == 0 then
                    return false
                end
                local plaque_index = 0
                for _, v in pairs(bag_info) do
                    if v.category_utf8 == "TowerAugmentation" then
                        plaque_index = plaque_index + 1
                    end
                end
                if plaque_index > 0 then
                    return plaque_index
                end
                return false
            end
            local function deep_equal_unordered(a, b)
                if type(a) ~= type(b) then return false end
                if type(a) ~= "table" then return a == b end
                if #a ~= #b then return false end
                
                -- 统计 a 的元素（支持嵌套 table）
                local count = {}
                for _, v in ipairs(a) do
                    local key = type(v) == "table" and table.concat(v, ",") or tostring(v)
                    count[key] = (count[key] or 0) + 1
                end
            
                -- 检查 b 的元素
                for _, v in ipairs(b) do
                    local key = type(v) == "table" and table.concat(v, ",") or tostring(v)
                    if not count[key] then return false end
                    count[key] = count[key] - 1
                end
            
                return true
            end
            local function get_warehouse_type(items_list)
                local warehouse_type = nil
                for _, v in ipairs(items_list) do
                    if v["類型"] == "碑牌" and v["存倉頁名"] and v["存倉頁名"] ~= "" and (v["白裝"] or v["藍裝"] or v["黃裝"]) and not v["工會倉庫"] and not v["不撿"]then
                        warehouse_type = "个仓"
                    end
                end
                if not warehouse_type then
                    for _, v in ipairs(items_list) do
                        if v["類型"] == "碑牌" and v["存倉頁名"] and v["存倉頁名"] ~= "" and (v["白裝"] or v["藍裝"] or v["黃裝"]) and v["工會倉庫"] and not v["不撿"]then
                            warehouse_type = "公仓"
                        end
                    end
                end
                return warehouse_type
                
            end
            local player_info = env.player_info
            local bag_info = env.bag_info
            
            if not next(player_info) then
                return bret.RUNNING
            end
            -- local current_map_info = env.current_map_info
            local not_exist_stone = env.not_exist_stone
            local pick_up_number = env.pick_up_number
            
            if not env.is_insert_stone then
                poe2_api.dbgp("不需要茶杯")
                poe2_api.time_p("检查是否获得牌匾（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not env.is_get_plaque then
                poe2_api.dbgp("不需要去呗")
                poe2_api.time_p("检查是否获得牌匾（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not env.is_get_plaque_node then
                poe2_api.dbgp("不需要公仓去呗")
                poe2_api.time_p("检查是否获得牌匾（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if is_get_plaque(bag_info) then
                env.is_get_plaque_node = false
                poe2_api.dbgp("不需要公仓去呗1")
                -- api_Sleep(10000000)
                poe2_api.time_p("检查是否获得牌匾（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local plaque_index = plaque_bag(bag_info)
            if pick_up_number ~= 0 and plaque_index and plaque_index == pick_up_number then
                env.is_get_plaque_node = false
                poe2_api.dbgp("不需要公仓去呗2")
                -- api_Sleep(10000000)
                poe2_api.time_p("检查是否获得牌匾（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if deep_equal_unordered(env.stone_order,env.not_exist_stone) then
                -- poe2_api.printTable(env.stone_order)
                poe2_api.dbgp("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$")
                -- poe2_api.printTable(env.not_exist_stone)
                env.is_get_plaque_node = false
                poe2_api.dbgp("不需要公仓去呗3")
                -- api_Sleep(10000000)
                poe2_api.time_p("检查是否获得牌匾（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local items_info = poe2_api.get_items_config_info(env.user_config)
            local warehouse_type = get_warehouse_type(items_info)
            if not warehouse_type then
                env.is_get_plaque_node = false
                poe2_api.dbgp("不需要公仓去呗4")
                -- api_Sleep(10000000)
                poe2_api.time_p("检查是否获得牌匾（SUCCESS7）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            env.warehouse_type_interactive = warehouse_type
            poe2_api.time_p("检查是否获得牌匾（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end
    },

    -- 取碑牌
    Take_The_Stele = {
        run = function(self, env)
            poe2_api.print_log("取碑牌...")
            local start_time = api_GetTickCount64()
            local text = ""
            if env.warehouse_type_interactive == "个仓" then
                text = "倉庫"
                if poe2_api.find_text({text = "強調物品",UI_info = env.UI_info,min_x = 250,min_y = 700}) 
                and poe2_api.find_text({text = "公會倉庫",UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=81}) then
                    -- poe2_api.click_keyboard("space")
                    poe2_api.find_text({UI_info = env.UI_info, text = "公會倉庫", min_x = 0, click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("取碑牌（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            elseif env.warehouse_type_interactive == "公仓" then
                text = "公會倉庫"
                if poe2_api.find_text({text = "強調物品",UI_info = env.UI_info,min_x = 250,min_y = 700}) 
                and poe2_api.find_text({text = "倉庫",UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=81}) then
                    poe2_api.find_text({text = "倉庫",UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=81,add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("取碑牌（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            else
                error("碑牌未知的仓库类型")
            end
            if not poe2_api.find_text({text = "強調物品",UI_info = env.UI_info,min_x = 250,min_y = 700})  then
            -- and poe2_api.find_text({text = text,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=81}) then
                poe2_api.time_p("取碑牌（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            poe2_api.dbgp("去呗，到达仓库")
            if not self.bool then
                self.is_wait = false
                self.wait_item = nil
                self.type = nil
                self.current = 0
                self.bool = true
            end
            if self.current == 0 then
                self.current = api_GetTickCount64()
            end
            if api_GetTickCount64() - self.current > 5000 then
                self.type = nil
                self.current = 0
            end
            local config = env.user_config
            local stone_order = env.stone_order
            -- 获取碑牌影响数量
            local function get_number_after_text(text, target)
                -- 获取指定文本后面的数字
                -- @param text: 完整文本（table数组）
                -- @param target: 要查找的目标文本
                -- @return: 数字或nil
                
                if not text or not next(text) then
                    return nil
                end
                poe2_api.dbgp("vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv")
                -- poe2_api.printTable(text)
                for _, item in ipairs(text) do
                    -- 检查是否包含目标文本
                    if item.name_utf8 and string.find(item.name_utf8, target) then
                        -- 返回第一个value_list的值（假设是数字）
                        if next(item.value_list) and #item.value_list > 0 then
                            return item.value_list[1]
                        end
                    end
                end
                
                return nil
            end
            -- 判断仓库有无指定物品
            local function get_currency(currency_info,items)
                for _,item in ipairs(items) do
                    local plaque_list = {}
                    for _, v in ipairs(currency_info) do
                        if v.baseType_utf8 == item and v.color < 3 then
                            table.insert(plaque_list,v)
                        end
                    end
                    poe2_api.dbgp("plaque_list:",#plaque_list)
                    if #plaque_list > 0 then
                        if #plaque_list > 1 then
                            local max_plaque = nil
                            local max_index = nil
                            local index = nil
                            for _, v1 in ipairs(plaque_list) do
                                poe2_api.dbgp("ddddddddddddddddddddddddddddddddddddddddddddddd")
                                if string.find(item,"總督的先行者碑牌") then
                                    index = get_number_after_text(api_GetObjectSuffix(v1.mods_obj),"範圍內最多")
                                else
                                    index = get_number_after_text(api_GetObjectSuffix(v1.mods_obj),"範圍內")
                                end
                                poe2_api.dbgp("index:",index)
                                -- api_Sleep(1000000)
                                if index then
                                    if not max_index or index > max_index then
                                        max_index = index
                                        max_plaque = v1
                                    end
                                end  
                            end
                            if max_plaque then
                                poe2_api.dbgp("max_plaque:",max_plaque.baseType_utf8)
                                -- api_Sleep(1000000)
                                return max_plaque
                            end
                        else
                            poe2_api.dbgp("max_plaque:",plaque_list[1].baseType_utf8)
                            -- api_Sleep(1000000)
                            return plaque_list[1]
                        end
                    end
                end
                return false
            end
            -- 获取背包中不存在的碑牌
            -- @param bag_info: 背包物品信息表
            -- @return: 缺失的碑牌名称表
            local function get_not_plaque(bag_info)
                -- 需要查找的碑牌名称集合
                local required_plaques = {
                    "祭祀碑牌", "先行者碑牌", "譫妄碑牌", 
                    "裂痕碑牌", "總督的先行者碑牌", "探險碑牌"
                }
                
                -- 结果表
                local missing_plaques = {}
                
                if bag_info and next(bag_info) then
                    -- 从bag_info中提取所有碑牌名称
                    local found_plaques = {}
                    for _, item in ipairs(bag_info) do
                        if item.category_utf8 == "TowerAugmentation" and item.baseType_utf8 then
                            found_plaques[item.baseType_utf8] = true
                        end
                    end
                    
                    -- 检查哪些required_plaques不在found_plaques中
                    for _, plaque in ipairs(required_plaques) do
                        if not found_plaques[plaque] then
                            table.insert(missing_plaques, plaque)
                        end
                    end
                else
                    -- 如果bag_info为空，返回所有required_plaques
                    missing_plaques = required_plaques
                end
                return missing_plaques
            end
            -- 获取对应配置仓库页
            local function get_config_warehouse_page(items_info,warehouse_type)
                local page_list = {}
                for _, v in ipairs(items_info) do
                    if string.find(v["類型"],"碑牌") and (v["白裝"] or v["藍裝"] or v["黃裝"]) and not v["不撿"] then
                        if warehouse_type == "个仓" and not v["工會倉庫"] then
                            table.insert(page_list,v["存倉頁名"])
                        elseif warehouse_type == "公仓" and v["工會倉庫"] then
                            table.insert(page_list,v["存倉頁名"])
                        end
                    end
                end
                return page_list
            end
            -- 获取对应仓库页数据
            local function get_warehouse(page,godown_info)
                for _, v in ipairs(godown_info) do
                    if v.name_utf8 == page[1] then
                        return v
                    end
                end
                return false
            end
            
                 
            local function removeDuplicates(arr)
                local hash = {}
                -- local res = {}
                for _, v in ipairs(arr) do
                    if not hash[v] then
                        table.insert(env.not_exist_stone, v)
                        hash[v] = true
                    end
                end
                -- return res
            end
            
            local items_info = poe2_api.get_items_config_info(config)
            local index = 0
            local warehouse_type_interactive = env.warehouse_type_interactive
            local godown_info = nil
            if warehouse_type_interactive == "个仓" then
                godown_info = api_GetRepositoryPages(0)
                index = 0
            else
                godown_info = api_GetRepositoryPages(1)
                index = 2
            end
            if not godown_info or not next(godown_info) then
                poe2_api.print_log("仓库数组数据异常......")
                poe2_api.time_p("取碑牌仓库数组数据异常（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local page = get_config_warehouse_page(items_info,warehouse_type_interactive)
            if page and next(page) then
                for _, v in ipairs(page) do
                    poe2_api.dbgp(v)
                end
            end
            
            local bag_info = env.bag_info
            if self.wait then
                if api_GetTickCount64() - self.current < self.wait_item then
                    poe2_api.dbgp("等待间隔时间到达")
                    return bret.RUNNING
                end
                self.wait = false
            end
            if not poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                poe2_api.click_keyboard("i")
                api_Sleep(500)
                poe2_api.dbgp("开背包2")
                self.wait = true
                self.current = api_GetTickCount64()
                self.wait_item = 1000
                poe2_api.time_p("取碑牌开背包2（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local tab_list_button = poe2_api.click_text_UI({text = "tab_list_button", UI_info = env.UI_info,ret_data = true})
            local precut_page = get_warehouse(page,godown_info)
            -- 背包操作
            local function bag_operate(data)
                if not precut_page then
                    error("未找到预设存仓页 ->", page[1], "<-,请检查预设存仓页与游戏仓库页是否一致")
                end
                poe2_api.dbgp("-=-=-=-=-=-=-=-=-=-==-=-=-==-=-=-=-=-=-=")
                poe2_api.dbgp("操作页：",page[1]," | 预设页: ",precut_page.name_utf8)
                poe2_api.dbgp("manage_index:",precut_page.manage_index)
                if precut_page.manage_index == 0 then
                    if poe2_api.find_text({text = page[1],UI_info = env.UI_info,max_y=data.max_y,min_x=data.min_x,max_x=data.max_x,min_y=data.min_y,click = 2}) then
                        self.is_wait = true
                        self.current = api_GetTickCount64()
                        self.wait_item = 500 
                        self.type =page[1]
                    end 
                    return false
                end
                poe2_api.dbgp("type:",self.type)
                local currency = api_Getinventorys(precut_page.manage_index,index)
                if currency and next(currency) then
                    poe2_api.dbgp("llllllllllllllllllllllllllllllllllllllllllllllllll")
                    if self.type ~= page[1] then
                        poe2_api.dbgp("type:",type(self.type))
                        poe2_api.dbgp("type:",type(page[1]))
                        poe2_api.dbgp("uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu")
                        if poe2_api.find_text({text = page[1],UI_info = env.UI_info,max_y=data.max_y,min_x=data.min_x,max_x=data.max_x,min_y=data.min_y,click = 2}) then
                            self.is_wait = true
                            self.current = api_GetTickCount64()
                            self.wait_item = 500 
                            self.type =page[1]
                        end
                        return false 
                    end
                    poe2_api.dbgp("ggggggggggggggggggggggggggggggggggggggggggggggggggggggs")
                    local get_index = false
                    -- poe2_api.printTable(stone_order)
                    for _, v in ipairs(stone_order) do
                        local stele_number = 0
                        for _, v1 in ipairs(api_Getinventorys(1,0)) do
                            if v1.category_utf8 == "TowerAugmentation" then
                                stele_number = stele_number + 1
                            end
                        end
                        poe2_api.dbgp("数量： ",env.pick_up_number)
                        if stele_number >= env.pick_up_number then
                            env.is_get_plaque_node = false
                            -- poe2_api.dbgp("数量================")
                            -- api_Sleep(1000000000000000000)
                            return true
                        end
                        local item = get_currency(currency,{v})
                        poe2_api.dbgp("item:",item)
                        if item then
                            poe2_api.dbgp("cccccccccccccccccccccccccccccccccccc")
                            -- api_Sleep(10000000)
                            local point = {}
                            local a = poe2_api.table_contains(precut_page.type,{0,1})
                            -- poe2_api.dbgp("a:",tostring(a))
                            -- api_Sleep(10000000)
                            if poe2_api.table_contains(precut_page.type,{0,1}) then
                                local point1 = poe2_api.get_center_position_store({item.start_x,item.start_y},{item.end_x,item.end_y})
                                poe2_api.dbgp("point1:",tostring(point1))
                                poe2_api.dbgp("point1:",point1[1])
                                poe2_api.dbgp("point1:",point[2])
                                if point1 and next(point1) then
                                    point = point1
                                end
                            -- elseif precut_page.type == 3 then
                            --     local key = item.start_x..","..item.start_y
                            --     point = my_game_info.currency_page[key]
                            elseif precut_page.type == 7 then
                                point = poe2_api.get_center_position_store_max({item.start_x,item.start_y},{item.end_x,item.end_y})
                            end
                            poe2_api.ctrl_left_click(point[1],point[2])
                            if index == 2 then
                                api_Sleep(1000)
                            else
                                api_Sleep(1000)
                            end
                            get_index = true
                            -- return false
                            -- table.insert(env.not_exist_stone,item)
                        else
                            removeDuplicates(v)
                            -- table.insert(env.not_exist_stone,v)
                            -- return false
                        end
                    end
                    if not get_index then
                        env.not_exist_stone = stone_order
                        return false
                    end
                else
                    env.not_exist_stone = stone_order
                    return false
                end
            end
            if not tab_list_button then
                if not bag_operate({godown_info=godown_info,max_y=90,min_x=0,max_x=500,min_y=0})then
                    poe2_api.time_p("取碑牌（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                poe2_api.time_p("取碑牌（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            else
                local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
                local lock_button = {}
                for _,v in ipairs(lock) do
                    if v.name_utf8 == "" and v.text_utf8 == "" then
                        table.insert(lock_button,v)
                    end
                end
                if not lock_button or not next(lock_button) then
                    api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                    api_Sleep(2000)
                    api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),1)
                    api_Sleep(1000)
                    poe2_api.time_p("取碑牌（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if not bag_operate({godown_info=godown_info,max_y=800,min_x=556,min_y=20,max_x=851})then
                    poe2_api.time_p("取碑牌（RUNNING8）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                poe2_api.time_p("取碑牌（RUNNING9）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            poe2_api.time_p("取碑牌（RUNNING10）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.RUNNING
        end
    },

    -- 是否要滴注
    Is_Need_Instill = {
        run = function(self, env)
            poe2_api.print_log("是否要滴注")
            local start_time = api_GetTickCount64()
            local dist_ls = env.dist_ls
            local bag_info = env.bag_info
            local not_use_map = env.not_use_map
            -- 精炼表
            local formula_list = {}
            local warehouse_type = env.warehouse_type
            local player_info = env.player_info
            local user_map = env.user_map
            local priority_map = env.priority_map
            local is_dizhu = env.is_dizhu

            -- 非藏身处不滴注
            if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.hideout)then
                env.dizhu_end = false
                poe2_api.time_p("是否要滴注... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end

            if env.one_other_map then
                return bret.SUCCESS
            end

            local function shut_down_pages()
                if poe2_api.find_text({UI_info = env.UI_info, text="滴注中",min_x=200,max_x=1050,max_y=300})then
                    local re_instill = api_Getinventorys(0x25,0)
                    local re_map = api_Getinventorys(0x26,0)
                    if next(re_map) or next(re_instill) then
                        if not poe2_api.find_text({UI_info = env.UI_info, text="背包", min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                            poe2_api.dbgp("打开背包页面")
                            poe2_api.click_keyboard("i")
                            api_Sleep(100)
                            return bret.RUNNING
                        end
                        -- 取出地图
                        if next(re_map)then
                            poe2_api.dbgp("取出地图")
                            poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_y = 134,min_x = 0,click = 4, refresh = true})
                            api_Sleep(300)
                            return bret.RUNNING
                        end
                        -- 取出液態
                        if next(re_instill) then
                            poe2_api.dbgp("取出液態")
                            for _,k in ipairs(re_instill) do
                                if k.start_x == 0 then
                                    poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_x=-73,add_y=246,min_x=0,click=4})
                                end
                                if k.start_x == 1 then
                                    poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_y=246,min_x=0,click=4})
                                end
                                if k.start_x == 2 then
                                    poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_x=73,add_y=246,min_x=0,click=4})
                                end
                            end
                            api_Sleep(300)
                            return bret.RUNNING
                        end
                    end
                    poe2_api.dbgp("关闭滴注页面")
                    poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",min_x=200,max_x=1050,max_y=300,click=2,add_y=-10,add_x=156})
                    return bret.RUNNING
                end
                return bret.SUCCESS
            end

            -- 检查是否滴注过
            local function check_item_in_bag(bag_info, name, obj)
                if obj then
                    if obj.color == 0 then
                        poe2_api.dbgp("白色钥匙,不滴注")
                        return true
                    end
                    local suffixes = api_GetObjectSuffix(obj.mods_obj)
                    if suffixes then
                        -- 是否有【譫妄】
                        for _, s in ipairs(suffixes) do
                            if string.find(s.name_utf8, "譫妄") then
                                -- 有词条，被滴注过
                                return true
                            end
                        end
                        -- 有词条，没滴注过
                        return false
                    end
                end

                for _, item in ipairs(bag_info) do
                    if item.baseType_utf8 == name then
                        if item.color == 0 then
                            goto continue
                        end

                        local suffixes = api_GetObjectSuffix(item.mods_obj)
                        if suffixes then
                            -- 是否有【譫妄】
                            local b = false
                            for _, s in ipairs(suffixes) do
                                if string.find(s.name_utf8, "譫妄") then
                                    -- 有词条，被滴注过
                                    b = true
                                    break
                                end
                            end
                            -- 有词条，没滴注过
                            if not b then return item end
                        else
                            -- 没词条
                            if item.color ~= 0 then
                                -- 不是白色钥匙
                                -- 开背包
                                for i = 1, 10 do
                                    if poe2_api.find_text({UI_info = env.UI_info, min_x = 1020, min_y = 46, max_x = 1090, max_y = 70, text = "背包" }) then
                                        break
                                    end
                                    poe2_api.click_keyboard("i")
                                    api_Sleep(300)
                                end

                                local b = false
                                local pos = poe2_api.get_center_position(
                                    {item.start_x, item.start_y},
                                    {item.end_x, item.end_y}
                                )
                                if pos then
                                    api_ClickScreen(pos[1], pos[2], 0)
                                    api_Sleep(1000)
                                    -- 再判断一次
                                    local suffixes = api_GetObjectSuffix(item.mods_obj)
                                    if suffixes then
                                        for _, s in ipairs(suffixes) do
                                            if string.find(s.name_utf8, "譫妄") then
                                                -- 有词条，被滴注过
                                                b = true
                                                break
                                            end
                                        end
                                        if not b then return item end
                                    end
                                end
                                if b then break end
                            end
                        end
                    end
                    ::continue::
                end
                return false
            end

            -- 获取背包中不打词条的地图钥匙
            local function get_map_not_entry(map)
                -- 词条过滤
                local function match_item_suffixes(item_suffixes, config_suffixes)
                    if not item_suffixes or not next(item_suffixes) then
                        return false
                    end
                    if not config_suffixes or not next(config_suffixes) then
                        return false
                    end
                    for _, v in ipairs(item_suffixes) do
                        for _, v1 in ipairs(config_suffixes) do
                            if v.name_utf8 == v1 then
                                return true
                            end
                        end
                    end
                    return false
                end
                if map then
                    if map.color > 0 and not map.not_identified and match_item_suffixes(api_GetObjectSuffix(map.mods_obj),not_use_map) then
                        return true
                    end
                end
                return false
            end

            -- # 无精炼
            if env.dizhu_end or is_dizhu then
                return shut_down_pages()
            end

            -- poe2_api.printTable(formula_list)

            for k, dist in pairs(dist_ls) do
                -- 是否滴注
                if not dist["是否塗油"] or dist["是否塗油"] == false then
                    return shut_down_pages()
                end
                
                local level = string.gsub("地圖鑰匙（階級 1）", "1", tostring(k))
                if not poe2_api.check_item_in_inventory(level, bag_info ) then
                    goto continue
                end
                local map_level = poe2_api.select_best_map_key(
                {   
                    inventory = bag_info,
                    key_level_threshold = user_map,
                    not_use_map = not_use_map,
                    priority_map = priority_map,
                    vall = true,
                    instill = true
                })
                -- poe2_api.printTable(map_level)
                -- poe2_api.printTable(api_GetObjectSuffix(map_level.mods_obj))
                -- api_Sleep(10000000)
                -- 是否滴注过 【譫妄】
                if map_level then
                    if get_map_not_entry(map_level) then
                        return bret.SUCCESS
                    end
                    if check_item_in_bag(bag_info, 1, map_level) then
                        poe2_api.dbgp("地图钥匙已滴注过")
                        return shut_down_pages()
                    end
                else
                    env.is_dizhu = true
                    poe2_api.dbgp("-- 无精炼")
                    return bret.SUCCESS
                end
                -- 钥匙存在，没滴注过
                
                for _, s in ipairs(dist["配方"]) do
                    if s ~= "无" then
                        table.insert(formula_list, s)
                    end
                end
                if #formula_list == 0 then
                    -- 钥匙符合条件，但未设置 配方
                    goto continue
                end
                -- 解析 倉庫類型
                local warehouse_type = dist['倉庫類型']
                env.warehouse_type = warehouse_type
                if warehouse_type == "倉庫" then
                    env.warehouse_type_interactive = "个仓"
                else
                    
                    local function get_object(name,data_list)
                        for _, v in ipairs(data_list) do
                            if v.name_utf8 == name and v.grid_x ~= 0 and v.grid_y ~= 0 then
                                if v.flagStatus and v.flagStatus == 0 and v.flagStatus1 == 1 then
                                    poe2_api.dbgp("get_object 找到匹配对象(flagStatus):", v)
                                    return v
                                end
                                if v.life and v.is_selectable then
                                    poe2_api.dbgp("get_object 找到匹配对象(life):", v)
                                    return v
                                end
                            end
                        end
                        poe2_api.dbgp("get_object: 未找到匹配对象")
                        return false
                    end
                    local warehouse_obj = get_object("StashGuild", env.current_map_info)
                    local warehouse_obj1 = get_object("公會倉庫",env.range_info)
                    if not warehouse_obj and not warehouse_obj1 then
                        poe2_api.dbgp("错误: 找不到仓库对象")
                        error("滴注找不到公会仓库")
                    end

                    env.warehouse_type_interactive = "公仓"

                    local pages = api_GetRepositoryPages(1)
                    local warehouse_page = nil
                    if #pages > 0 then
                        for _, page in ipairs(pages) do
                            if page.manage_index ~= 0 or page.name_utf8 ~= "" or page.page_index ~=0 or page.type  ~= 22 then
                                warehouse_page = true
                            end
                        end
                    end
                    if not warehouse_page then
                        poe2_api.print_log("公会仓库无仓库页")
                        env.is_dizhu = true
                        return bret.SUCCESS
                    end
                end
                -- 地图钥匙等级
                local key_level = k
                env.key_level = key_level
                break
                ::continue::
            end

            -- # 是否操作过滴注
            if env.is_dizhu then
                return shut_down_pages()
            end

            -- poe2_api.printTable(formula_list)
            -- # 是否有精炼表
            if next(formula_list) then
                env.refining_list = formula_list
                if not env.is_over then
                    return bret.FAIL
                else
                    return bret.SUCCESS
                end
            else
                return shut_down_pages()
            end
        end
    },

    -- 检查背包
    Check_Bag = {
        run = function(self, env)
            poe2_api.print_log("检查背包")

            -- # 所需的精炼
            local need_refining = env.refining_list
            local refining_list_copy = poe2_api.deepCopy(env.refining_list)
            -- 自定义补充精炼 优先级列表
            local Custom_refining_list = {
                "濃縮液態孤立",
                "濃縮液態苦難",
                "濃縮液態恐懼",
                "液態絕望",
                "液態厭惡",
                "液態忌妒",
                "液態偏執",
                "稀釋的液態貪婪",
                "稀釋的液態罪惡",
                "稀釋的液態憤怒"
            }
            -- 检查背包中物品
            local function Custom_refining(bag_info,list)
                local tab = Custom_refining_list
                if list then
                    tab = list
                end
                -- 检视背包
                for _, refining in ipairs(tab) do
                    for _, item in ipairs(bag_info) do
                        if refining == item.baseType_utf8 then
                            -- 背包有精炼
                            return refining
                        end
                    end
                end
                -- 如果没有找到匹配项，可以返回 nil 或其他默认值
                return nil
            end

            
            local missing_refinement = {}
            -- # 刷新背包信息
            -- env.bag_info = api_Getinventorys(1,0)
            -- # 指定等级 地图钥匙 检查
            local key_level = env.key_level
            -- 生成格式化字符串（替换 "1" 为 key_level）
            local key = string.gsub("地圖鑰匙（階級 1）", "1", tostring(key_level))
            if not env.check_map_key then
                if poe2_api.check_item_in_inventory(key,env.bag_info) then
                    env.exists_key = true
                else
                    -- # 背包中没有指定钥匙，选择最优钥匙
                    env.exists_key = false
                end
            end

            env.map_key_name = key
            -- 调用精炼检查逻辑
            for k, refining in ipairs(need_refining) do
                if refining == nil then
                    local c_refining = Custom_refining(env.bag_info)
                    if c_refining then
                        refining = c_refining
                        need_refining[k] = c_refining
                    end
                end

                if not refining or not poe2_api.check_item_in_inventory(refining,env.bag_info) then
                    table.insert(missing_refinement, refining)
                end
            end

            -- 是否少油：是,仓库取
            if #missing_refinement > 0 and not env.not_need_take then
                poe2_api.dbgp("是否少油：是,仓库取")
                if #missing_refinement == #need_refining then
                    env.is_refinement = false
                    env.missing_refinement = missing_refinement
                    poe2_api.dbgp("SUCCESS111")
                    return bret.SUCCESS
                end

                local a = {}
                for _, x in ipairs(need_refining) do
                    local found = false
                    for _, m in ipairs(missing_refinement) do
                        if x == m then
                            found = true
                            break
                        end
                    end
                    if not found then
                        table.insert(a, x)
                    end
                end

                env.missing_refinement = missing_refinement
                env.is_refinement = a[1]
                poe2_api.dbgp("SUCCES11112")
                return bret.SUCCESS
            end
            poe2_api.dbgp("是否少油：否")
            local c_refining = Custom_refining(env.bag_info, refining_list_copy)
            if not c_refining and env.not_need_take then
                poe2_api.dbgp("SUCCES22222")
                env.dizhu_end = true
                return bret.RUNNING
            end
            env.is_refinement = c_refining
            return bret.FAIL
        end
    },

    -- 打开仓库(warehouse_type_interactive 为空情况在调用之前，提前处理)
    Open_Warehouse = {
        run = function(self, env)
            poe2_api.print_log("开始执行 Open_Warehouse")
            local start_time = api_GetTickCount64()
            if poe2_api.find_text({text="購買或販賣",UI_info=env.UI_info,min_x=0,max_x=800}) then
                poe2_api.click_keyboard('space')
                api_Sleep(500)
                poe2_api.time_p("打开仓库（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if poe2_api.find_text({text="重組",UI_info=env.UI_info,min_x=200,max_x=1200}) then
                poe2_api.click_keyboard('space')
                api_Sleep(500)
                poe2_api.time_p("打开仓库（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if poe2_api.find_text({text="回收具有品質或插槽的裝備，以獲得品質通貨和工匠碎片",UI_info=env.UI_info,min_x=200,max_x=1200}) then
                poe2_api.click_keyboard('space')
                api_Sleep(500)
                poe2_api.time_p("打开仓库（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            poe2_api.find_text({text = "再會",UI_info = env.UI_info,click =2,min_x=0})
            if poe2_api.find_text({text = {'重鑄台'}, UI_info=env.UI_info,min_x=0}) and poe2_api.find_text({text = '摧毀三個相似的物品，重鑄為一個新的物品', UI_info=env.UI_info,min_x=0}) then
                poe2_api.click_keyboard('space')
                api_Sleep(500)
                poe2_api.time_p("打开仓库（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            -- if poe2_api.find_text({text = {'世界地圖',"購買或販賣物品"}, UI_info=env.UI_info,min_x=0}) then
            if poe2_api.find_text({text = {'世界地圖'}, UI_info=env.UI_info,min_x=0}) then
                -- poe2_api.dbgp("999999999999999999999999999999999999999999")
                poe2_api.click_keyboard('space')
                api_Sleep(500)
                poe2_api.time_p("是否存储物品（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if not self.nubmer_index then
                self.nubmer_index = 0
                poe2_api.dbgp("初始化完成，设置 nubmer_index = 0")
                poe2_api.time_p("打开仓库（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            
            -- poe2_api.dbgp("打开仓库...")
            local obj = nil
            local text = nil 
            local warehouse = nil
            local current_map_info = env.current_map_info
            
            local player_info = env.player_info
            local warehouse_type_interactive = env.warehouse_type_interactive
            
            poe2_api.dbgp("环境变量检查:", {
                warehouse_type_interactive = warehouse_type_interactive,
                current_map_info = current_map_info and #current_map_info or "nil",
                player_info = player_info and "exists" or "nil"
            })

            local function get_object(name,data_list)
                for _, v in ipairs(data_list) do
                    if v.name_utf8 == name and v.grid_x ~= 0 and v.grid_y ~= 0 then
                        if v.flagStatus and v.flagStatus == 0 and v.flagStatus1 == 1 then
                            poe2_api.dbgp("get_object 找到匹配对象(flagStatus):", v)
                            return v
                        end
                        if v.life and v.is_selectable then
                            poe2_api.dbgp("get_object 找到匹配对象(life):", v)
                            return v
                        end
                    end
                end
                poe2_api.dbgp("get_object: 未找到匹配对象")
                return false
            end

            poe2_api.dbgp("仓库类型:", warehouse_type_interactive)
            
            if warehouse_type_interactive == "个仓" then
                poe2_api.dbgp("查找个人仓库...")
                local warehouse_obj = get_object("StashPlayer", current_map_info)
                if warehouse_obj then
                    obj = 'StashPlayer'
                    text = "倉庫"
                    warehouse = warehouse_obj
                    poe2_api.dbgp("找到 StashPlayer 仓库:", warehouse_obj)
                else
                    local warehouse_obj1 = get_object("倉庫",env.range_info)
                    if warehouse_obj1 then
                        obj = '倉庫'
                        text = "倉庫"
                        warehouse = warehouse_obj1
                        poe2_api.dbgp("找到 倉庫 (备用):", warehouse_obj1)
                    end
                end
            elseif warehouse_type_interactive == "公仓" then
                poe2_api.dbgp("查找公会仓库...")
                local warehouse_obj = get_object("StashGuild", current_map_info)
                if warehouse_obj then
                    obj = 'StashGuild'
                    text = "公會倉庫"
                    warehouse = warehouse_obj
                    poe2_api.dbgp("找到 StashGuild 仓库:", warehouse_obj)
                else
                    local warehouse_obj1 = get_object("公會倉庫",env.range_info)
                    if warehouse_obj1 then
                        obj = '公會倉庫'
                        text = "公會倉庫"
                        warehouse = warehouse_obj1
                        poe2_api.dbgp("找到 公會倉庫 (备用):", warehouse_obj1)
                    end
                end
            else
                poe2_api.dbgp("错误: 仓库类型未配置", warehouse_type_interactive)
                error("在配置物品过滤中,有物品的存仓页未配置")
            end

            if not warehouse then
                poe2_api.dbgp("错误: 找不到仓库对象")
                error("找不到仓库或者公会仓库")
            end

            poe2_api.dbgp("最终仓库对象:", 
                obj ,
                text,
                warehouse
            )
            if text == "公會倉庫" then
                
                local pages = api_GetRepositoryPages(1)
                local warehouse_page = nil
                if #pages > 0 then
                    for _, page in ipairs(pages) do
                        if page.manage_index ~= 0 or page.name_utf8 ~= "" or page.page_index ~=0 or page.type  ~= 22 then
                            warehouse_page = true
                        end
                    end
                end
                if not warehouse_page then
                    error("公會倉庫内无仓库页，请修改相关配置！！！")
                    api_Sleep(1000)
                    return bret.RUNNING
                end
            end
            -- 检查是否已经打开仓库界面
            local emphasize_text = poe2_api.find_text({UI_info = env.UI_info, text = "強調物品", min_x = 250, min_y = 700})
            local warehouse_text = poe2_api.find_text({UI_info = env.UI_info, text = text, min_x=0, min_y=32, max_x=381, max_y=81})
            
            poe2_api.dbgp("界面检查结果:", {
                emphasize_text = emphasize_text and "found" or "not found",
                warehouse_text = warehouse_text and "found" or "not found"
            })
            
            if emphasize_text and warehouse_text then
                poe2_api.dbgp("仓库界面已打开，返回SUCCESS")
                poe2_api.time_p("打开仓库（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end

            local distance = poe2_api.point_distance(warehouse.grid_x, warehouse.grid_y, player_info)
            poe2_api.dbgp("与仓库的距离:", distance)

            if distance > 25 then
                poe2_api.dbgp("距离仓库太远(", distance, ")，返回FAIL")
                env.interactive = obj
                poe2_api.time_p("打开仓库（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            else
                local continue_game = poe2_api.find_text({UI_info = env.UI_info, text = "繼續遊戲", click = 2})
                if continue_game then
                    poe2_api.dbgp("发现'繼續遊戲'文本，返回RUNNING")
                    poe2_api.time_p("打开仓库（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end

                poe2_api.dbgp("尝试移动到仓库位置:", warehouse.grid_x, warehouse.grid_y)

                -- api_ClickMove(poe2_api.toInt(warehouse.grid_x), poe2_api.toInt(warehouse.grid_y), poe2_api.toInt(player_info.world_z), 1)
                poe2_api.find_text({text = text, UI_info = env.UI_info, min_x=200,max_y=750,max_x=1200,sorted = true, click=2})

                if self.nubmer_index >= 10 then
                    poe2_api.dbgp("尝试次数超过10次(", self.nubmer_index, ")，执行ESC并重置计数器")
                    poe2_api.click_keyboard("space")
                    api_Sleep(500)
                    self.nubmer_index = 0
                end 
                
                self.nubmer_index = self.nubmer_index + 1
                poe2_api.dbgp("当前尝试次数:", self.nubmer_index)
                
                api_Sleep(500)
                poe2_api.time_p("打开仓库（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
        end
    },

    -- 仓库取物品
    Warehouse_pickup_items = {
        run = function(self, env)
            poe2_api.print_log("仓库取物品...")
            local text = ""
            if env.warehouse_type == "倉庫" then
                text = "倉庫"
            else
                text = "公會倉庫"
            end
            -- 确认打开仓库
            if not (poe2_api.find_text({UI_info = env.UI_info, text = "強調物品",min_x = 250,min_y = 700}) and poe2_api.find_text({UI_info = env.UI_info, text = text,min_x=0,min_y=32,max_x=381,max_y=81})) then
                return bret.SUCCESS
            end
            local all_refinement_list = {}
            local refinement_pos = {
                ["濃縮液態恐懼"] = {274, 331},
                ["液態厭惡"] = {160, 330},
                ["液態絕望"] = {218, 329},
                ["液態偏執"] = {331, 269},
                ["稀釋的液態憤怒"] = {161, 271},
                ["稀釋的液態罪惡"] = {218, 272},
                ["濃縮液態苦難"] = {335, 333},
                ["液態忌妒"] = {392, 272},
                ["稀釋的液態貪婪"] = {275, 275},
                ["濃縮液態孤立"] = {390, 330}
            }
            local missing_refinement = env.missing_refinement
            local refining_list = env.refining_list
            local bag_info = env.bag_info
            
            local config = env.user_config
            local check_res = false
            -- # 重置 背包 精煉
            local function reset_backpack_refinement(bag_info)
                for _, item in ipairs(bag_info) do
                    if string.find(item.baseType_utf8, "精煉") and not poe2_api.table_contains(refining_list, item.baseType_utf8) then
                        poe2_api.ctrl_left_click_bag_items(item.baseType_utf8, bag_info)
                    end
                end
            end
            
            -- 寻找背包中的精炼
            local function look_for_refinement_in_backpack(bag_info,page_type,page_name)
                for _, item in ipairs(bag_info) do
                    -- 寻找指定的精炼
                    if poe2_api.table_contains(missing_refinement, item.baseType_utf8) then
                        local pos= poe2_api.get_center_position_store({item.start_x, item.start_y}, {item.end_x, item.end_y})
                        local all_refinement = {
                            ["仓库页"] = page_name,
                            ["精煉"] = item.baseType_utf8,
                            ["坐标"] = {pos[1], pos[2]}
                        }
                        if page_type == 15 then
                            all_refinement["坐标"] = refinement_pos[item.baseType_utf8]
                        -- elseif page_type == 3 then
                        --     -- 通貨頁
                        --     local point = my_game_info.currency_page[{item.start_x, item.start_y}]
                        --     all_refinement["坐标"] = point
                        elseif page_type == 7 then
                            local point = poe2_api.get_center_position_store_max({item.start_x,item.start_y},{item.end_x,item.end_y})
                            all_refinement["坐标"] = point
                        end
                        table.insert(all_refinement_list, all_refinement)
                        return true
                    end
                end
                return false
            end

            -- 从背包中拿出精炼
            local function out_of_refinement_in_backpack()
                for _,aj in ipairs(all_refinement_list) do
                    if poe2_api.table_contains(missing_refinement, aj["精煉"]) then
                        if not aj["坐标"] then
                            poe2_api.dbgp("坐标未找到")
                            return false
                        end
                        -- 查找仓库页文本并点击
                        if poe2_api.find_text({UI_info = env.UI_info, text = aj["仓库页"], max_y = 90, min_x = 0, max_x = 500, min_y = 0, click = 2}) then
                            api_Sleep(200)
                        elseif poe2_api.find_text({UI_info = env.UI_info, text = aj["仓库页"], max_y = 469, min_x = 556, min_y = 20, max_x = 851, click = 2}) then
                            api_Sleep(200)
                        else
                            return false
                        end
                        poe2_api.ctrl_left_click(aj["坐标"][1],aj["坐标"][2])
                        api_Sleep(500)
                        local filtered = {}
                        for _, x in ipairs(missing_refinement) do
                            if x ~= aj["精煉"] then
                                table.insert(filtered, x)
                            end
                        end
                        env.missing_refinement = filtered
                    end
                end
            end
            reset_backpack_refinement(bag_info)
            -- # 仓库类型
            local pages = {}
            if env.warehouse_type == "倉庫" then
                local items_info = poe2_api.get_items_config_info(config)
                local unique_storage_pages = {}
                for _, item in ipairs(items_info) do
                    if item["類型"] == "精煉" and item['存倉頁名'] and not item["不撿"] and item["基礎類型名"] == "全部物品" and not item["工會倉庫"] then
                        unique_storage_pages[item['存倉頁名']] = true
                    end
                end
                if next(unique_storage_pages) ~= nil then
                    local pages_list = api_GetRepositoryPages(0)
                    for _, i in ipairs(pages_list) do
                        if unique_storage_pages[i.name_utf8] then
                            table.insert(pages, i)
                        end
                    end
                else
                    -- 仓库页
                    pages = api_GetRepositoryPages(0)
                end
            elseif env.warehouse_type == "工會倉庫" then
                local items_info = poe2_api.get_items_config_info(config)
                local unique_storage_pages = {}
                for _, item in ipairs(items_info) do
                    if item["類型"] == "精煉" and item['存倉頁名'] and not item["不撿"] and item["基礎類型名"] == "全部物品" and item["工會倉庫"] then
                        unique_storage_pages[item['存倉頁名']] = true
                    end
                end
                if next(unique_storage_pages) ~= nil then
                    local pages_list = api_GetRepositoryPages(1)
                    for _, i in ipairs(pages_list) do
                        if unique_storage_pages[i.name_utf8] then
                            table.insert(pages, i)
                        end
                    end
                else
                    -- 工会仓库页
                    pages = api_GetRepositoryPages(1)
                end
            else
                -- poe2_api.api_print("【倉庫類型】 错误！")
                return bret.FAIL
            end
            
            -- 獲取列表按鈕
            local tab_list_button = poe2_api.click_text_UI({UI_info = env.UI_info, text = "tab_list_button",ret_data = true})

            -- 獲取鎖定按鈕
            local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
            local lock_button = {}
            for _,v in ipairs(lock) do
                if v.name_utf8 == "" and v.text_utf8 == "" then
                    table.insert(lock_button,v)
                end
            end
            if next(missing_refinement) ~= nil then
                local old_page = {}
                local warehouse_text = nil
                if env.warehouse_type == "倉庫" then
                    warehouse_text = "倉庫"
                else
                    warehouse_text = "公會倉庫"
                end

                for _, page in ipairs(pages) do
                    -- 缺少的精炼已全部取出
                    if not next(env.missing_refinement) then
                        break
                        -- goto continue
                    end
            
                    -- 仓库页去重
                    if old_page[page.name_utf8] then
                        goto continue
                    else
                        old_page[page.name_utf8] = true
                    end
            
                    -- 跳過地图页
                    local skip_types = {3, 4, 5, 8, 17, 18}
                    if poe2_api.table_contains(skip_types, page.type) then
                        goto continue
                    end
                    
                    if not tab_list_button then
                        if page.manage_index == 0 then
                            if poe2_api.find_text({UI_info = env.UI_info, text=page.name_utf8, max_y=90, min_x=0, max_x=500, min_y=0, click=2}) then
                                api_Sleep(500)
                            end
                            return bret.RUNNING
                        end
                    else
                        if not lock_button or not next(lock_button) then
                            api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                            api_Sleep(2000)
                            api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2 + 30),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2 - 30),1)
                            api_Sleep(5000)
                            return bret.RUNNING
                        end
                        if page.manage_index == 0 then
                            if poe2_api.find_text({UI_info = env.UI_info, text=page.name_utf8, max_y=800, min_x=556, min_y=20, max_x=851, click=2}) then
                                api_Sleep(500)
                            end
                            return bret.RUNNING
                        end
                    end

                    -- 检查仓库类型
                    if not poe2_api.find_text({UI_info = env.UI_info, text = warehouse_text, min_x = 0, min_y = 32, max_x = 381, max_y = 81}) then
                        api_ClickScreen(523, 57,1)
                        return bret.RUNNING
                    end
                    
                    -- 检查仓库页
                    local bag_ls = {}
                    if warehouse_text == "倉庫" then
                        bag_ls = api_Getinventorys(page.manage_index,0)
                    else
                        bag_ls = api_Getinventorys(page.manage_index,2)
                    end
                    -- poe2_api.printTable(bag_ls)
                    if next(bag_ls) == nil then
                        goto continue
                    end

                    check_res = look_for_refinement_in_backpack(bag_ls, page.type, page.name_utf8)
        
                    if not check_res then
                        -- 该仓库没有精炼
                        goto continue
                    end

                    local click = nil
                    if not tab_list_button then
                        click = poe2_api.find_text({UI_info = env.UI_info, text=page.name_utf8, max_y=90, min_x=0, max_x=500, min_y=0, click=2})
                    else
                        click = poe2_api.find_text({UI_info = env.UI_info, text=page.name_utf8, max_y=800, min_x=556, min_y=20, max_x=851, click=2})
                    end
                    
                    if not click then
                        goto continue
                    end
        
                    if check_res then
                        -- 有 指定精炼
                        out_of_refinement_in_backpack()
                    end

                    ::continue::
                end
            end
            poe2_api.dbgp("【倉庫類型】 已经處理完畢----------------")
            if env.missing_refinement then
                local refining_list = env.refining_list or {}
                local missing_refinement = env.missing_refinement or {}
                local new_refining_list = {}
                for _,refining in ipairs(refining_list) do
                    local found = false
                    for _,not_refining in ipairs(missing_refinement) do
                        if refining == not_refining then
                            found = true
                            break
                        end
                    end
                    if not found then
                        table.insert(new_refining_list, refining)
                    end
                end
                env.refining_list = new_refining_list
            end
            -- 检查精炼列表是否为空
            if not env.refining_list or #env.refining_list == 0 then
                env.dizhu_end = true
                return bret.RUNNING
            end
            env.not_need_take = true 
            return bret.RUNNING
        end
    },

    -- 检查滴注页面
    Check_the_drip_page = {
        run = function(self, env)
            poe2_api.print_log("检查滴注页面")

            if not poe2_api.find_text({UI_info = env.UI_info, text = "背包" , min_x = 1020, min_y = 46, max_x = 1090, max_y = 70}) then
                poe2_api.click_keyboard("i",0)
                api_Sleep(500)
                return bret.RUNNING
            end
            if poe2_api.find_text({UI_info = env.UI_info, text ="強調物品" , min_x = 280,min_y = 730, max_x = 342, max_y = 758}) and poe2_api.find_text({UI_info = env.UI_info, text = {"倉庫", "公會倉庫"},min_x=0,min_y=32,max_x=381,max_y=81}) then
                poe2_api.find_text({UI_info = env.UI_info, text = {"倉庫", "公會倉庫"},min_x=0,min_y=32,max_x=381,max_y=81, add_x = 247,add_y = -5, click = 2})
                return bret.RUNNING
            end

            if poe2_api.find_text({UI_info = env.UI_info, text = "滴注中", min_x = 200, refresh = true}) then
                poe2_api.dbgp("在滴注页面")
                local function check_refinement()
                    for _, item in ipairs(env.bag_info) do
                        if string.find(item.baseType_utf8, "精煉") then
                            return item
                        end
                    end
                    return false
                end
                local it = check_refinement()
                -- poe2_api.printTable(it)
                -- api_Sleep(50000)
                if it then
                    
                    -- 清除多余页面
                    if poe2_api.find_text({UI_info = env.UI_info, text ="強調物品" , min_x = 280,min_y = 730, max_x = 342, max_y = 758}) then
                        poe2_api.ctrl_left_click_bag_items(it.obj, env.bag_info, 1)
                        api_Sleep(500)
                    end
                    poe2_api.ctrl_left_click_bag_items(it.obj,env.bag_info,1)
                    api_Sleep(500)
    
                    -- 取出地图
                    if next(api_Getinventorys(0x26,0)) then
                        poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_y = 134,min_x = 0,click = 4, refresh = true})
                        api_Sleep(300)
                        return bret.RUNNING
                    end
                
                    -- 取出精煉
                    local re_refining = api_Getinventorys(0x25, 0)
                    if next(re_refining) then
                        for _,k in ipairs(re_refining) do
                            if k.start_x == 0 then
                                poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_x=-73,add_y=246,min_x=0,click=4})
                            end
                            if k.start_x == 1 then
                                poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_y=246,min_x=0,click=4})
                            end
                            if k.start_x == 2 then
                                poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_x=73,add_y=246,min_x=0,click=4})
                            end
                        end
                        api_Sleep(300)
                        return bret.RUNNING
                    end
                    env.is_refinement = it.baseType_utf8
                end
                return bret.FAIL
            else
                poe2_api.print_log("打开滴注")
                if env.is_refinement then
                    poe2_api.ctrl_left_click_bag_items(env.is_refinement,env.bag_info,1)
                    api_Sleep(800)
                end
                return bret.RUNNING
            end
        end
    },

    -- 放置钥匙
    Place_And_Instill = {
        run = function(self, env)
            poe2_api.print_log("放置地图钥匙")
            local bag_info = env.bag_info
            local key = env.map_key
            local key_ok = env.key_ok
            local user_map = env.user_map
            local priority_map = env.priority_map

            local not_use_map = poe2_api.deepCopy(env.not_use_map)
            table.insert(not_use_map, "區域中玩家的[Delirious|譫妄]為{0}%")
            -- poe2_api.printTable(not_use_map)  -- 新表
            -- poe2_api.printTable(env.not_use_map)  -- 原表不变

            -- 選擇最佳地圖
            local map_level = poe2_api.select_best_map_key(
                {
                    inventory  = bag_info,
                    key_level_threshold = user_map,
                    not_use_map = not_use_map,
                    priority_map = priority_map,
                    vall = true
                }
            )

            if map_level then
                -- 點擊地圖物品
                poe2_api.ctrl_left_click_bag_items(
                    map_level.obj,
                    bag_info,
                    2
                )
                api_Sleep(200)
            end
            env.key_ok = key_ok
            api_Sleep(500)
            env.check_map_key = true
            poe2_api.print_log("放置精炼")
            local refining_list = env.refining_list
            local re_refining = api_Getinventorys(0x25, 0)
            if next(re_refining) then
                for _,k in ipairs(re_refining) do
                    if k.start_x == 0 then
                        poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_x=-73,add_y=246,min_x=0,click=4})
                    end
                    if k.start_x == 1 then
                        poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_y=246,min_x=0,click=4})
                    end
                    if k.start_x == 2 then
                        poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_x=73,add_y=246,min_x=0,click=4})
                    end
                end
                api_Sleep(300)
                return bret.RUNNING
            end
            local in_refining = {}
            for _,i in ipairs(refining_list) do
                for _,bag in ipairs(api_Getinventorys(1,0)) do
                    if bag.baseType_utf8 == i then
                        table.insert(in_refining,i)
                        break
                    end
                end
            end
            for k , in_refining in ipairs(in_refining) do
                poe2_api.ctrl_left_click_bag_items(in_refining,api_Getinventorys(1,0))
                api_Sleep(300)
            end

            -- 检查
            if next(re_refining) then
                for k,instill in ipairs(re_refining) do
                    if instill.baseType_utf8 ~= in_refining[k] then
                        -- 放回背包
                        if instill.start_x == 0 then
                            poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_x=-73,add_y=246,min_x=0,click=4})
                        end
                        if instill.start_x == 1 then
                            poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_y=246,min_x=0,click=4})
                        end
                        if instill.start_x == 2 then
                            poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_x=73,add_y=246,min_x=0,click=4})
                        end
                        api_Sleep(300)
                        poe2_api.ctrl_left_click_bag_items(instill,api_Getinventorys(1,0))
                        api_Sleep(300)
                    end
                end
            end
            poe2_api.ctrl_left_click(525,701)
            api_Sleep(300)
            
            -- 取出地图
            if next(api_Getinventorys(0x26,0))then
                poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_y = 134,min_x = 0,click = 4, refresh = true})
                api_Sleep(300)
                return bret.RUNNING
            end
        
            -- 取出精煉
            if next(re_refining) then
                for _,k in ipairs(re_refining) do
                    if k.start_x == 0 then
                        poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_x=-73,add_y=246,min_x=0,click=4})
                    end
                    if k.start_x == 1 then
                        poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_y=246,min_x=0,click=4})
                    end
                    if k.start_x == 2 then
                        poe2_api.find_text({UI_info = env.UI_info, text = "滴注中",add_x=73,add_y=246,min_x=0,click=4})
                    end
                end
                api_Sleep(300)
                return bret.RUNNING
            end

            local ui_esc = {"滴注","背包"}
            for _,ui in ipairs(ui_esc) do
                if poe2_api.find_text({UI_info = env.UI_info, text = ui}) then
                    poe2_api.dbgp1("bhjftjrftjuertdhesdghsdg")
                    poe2_api.click_keyboard("space")
                    api_Sleep(300)
                end
            end

            -- 结束
            env.is_over = true
            return bret.RUNNING
        end
    },

    -- 是否存储物品
    Is_Store_Items = {
        run = function(self, env)
            poe2_api.print_log("是否存储...")
            local start_time = api_GetTickCount64()
            local config = env.user_config
            local map_config = config['刷圖設置']["地圖鑰匙"]
            local altar_shop_config = config['刷圖設置']["祭祀購買"]
            -- local dist_ls = config['刷圖設置']['異界地圖']['涂油设置']
            local not_use_map = env.not_use_map
            local user_map = env.user_map
            local priority_map = env.priority_map
            local items_info = poe2_api.get_items_config_info(config)
            
            
            -- 判断两个键值对表是否相等
            local function deep_equal_unordered_full(a, b)
                if type(a) ~= type(b) then return false end
                if type(a) ~= "table" then return a == b end
            
                -- 检查所有键值对（包括非数字键）
                local visited = {}
                for k, v in pairs(a) do
                    if not deep_equal_unordered_full(v, b[k]) then
                        return false
                    end
                    visited[k] = true
                end
            
                -- 检查 b 中有没有 a 没有的键
                for k, _ in pairs(b) do
                    if not visited[k] then
                        return false
                    end
                end
            
                return true
            end
            
            -- 词条过滤
            local function match_item_suffixes(item_suffixes, config_suffixes)
                if not item_suffixes or not next(item_suffixes) then
                    return false
                end
                if not config_suffixes or not next(config_suffixes) then
                    return false
                end
                for _, v in ipairs(item_suffixes) do
                    for _, v1 in ipairs(config_suffixes) do
                        if v.name_utf8 == v1 then
                            return true
                        end
                    end
                end
                return false
            end
            -- 祭祀购买是否配置了存储页
            local function is_not_altar_shop(item)
                local text = poe2_api.get_item_type(item)
                poe2_api.print_log("祭祀购买物品类型:"..text)
                local item_key = ""
                if text ~= "" then
                    item_key = text
                else
                    poe2_api.dbgp("999999999999999999")
                    poe2_api.dbgp("item.category_utf8:"..item.category_utf8)
                    for k, v in pairs(my_game_info.type_conversion) do
                        -- poe2_api.dbgp("k:"..k.." v:"..v)
                        if item.category_utf8 == v then
                            item_key = k
                            break
                        end
                    end
                end
                poe2_api.dbgp("item_key:"..type(item_key))
                if item_key and item_key ~= "" then
                    local item_type_list = {}
                    for _, v in ipairs(items_info) do
                        poe2_api.dbgp("type(v):"..v['類型'])
                        
                        if v['類型'] == item_key then
                            poe2_api.dbgp("10101010101")
                            table.insert(item_type_list,v)
                        end
                    end
                    
                    if item_type_list and next(item_type_list) then
                        
                        for _, v in ipairs(item_type_list) do
                            if not v["不撿"] then
                                if v['基礎類型名'] == "全部物品" or string.find(v['基礎類型名'],item.baseType_utf8) then
                                    return true
                                end
                            end
                        end
                    end
                else
                    error("物品名称:"..item.name_utf8.."新物品类型:"..item.category_utf8.."请联系我们添加，感谢您的支持")
                end
                return false

            end
            -- 背包排序
            local function get_store_bag_info(bag)
                local function item_save_as1(goods,cfg_object)
                    local satisfy = {}
                    for _, v in ipairs(items_info) do
                        if not v["不撿"] and v["存倉頁名"] and v["存倉頁名"] ~= "" and string.find(v["基礎類型名"],goods.baseType_utf8) then
                            table.insert(satisfy,v)
                        end
                    end
                    if next(satisfy) then
                        for _, v in ipairs(satisfy) do
                            if not deep_equal_unordered_full(v,cfg_object) then
                                if v["工會倉庫"] then
                                    return 1
                                else
                                    return 2
                                end
                            end
                        end
                    
                    end
                    return false
                end
                local store_bag = {}
                local store_bag1 = {}
                local store_bag2 = {}
                for _,v in ipairs(bag) do
                    
                    for _, item in ipairs(items_info) do
                        if poe2_api.match_item(v,item) and not item["工會倉庫"] and not item["不撿"] then
                            local a = item_save_as1(v,item)
                            if a then
                                if a == 1 then
                                    table.insert(store_bag2,v)
                                    break
                                end
                            end
                            table.insert(store_bag1,v)
                        elseif poe2_api.match_item(v,item) and item["工會倉庫"] and not item["不撿"] then
                            local a = item_save_as1(v,item)
                            if a then
                                if a == 2 then
                                    table.insert(store_bag1,v)
                                    break
                                end
                            end
                            table.insert(store_bag2,v)
                        end
                    end
                end
                poe2_api.dbgp("store_bag1:"..#store_bag1)
                poe2_api.dbgp("store_bag2:"..#store_bag2)
                for _, v in ipairs(store_bag1) do
                    table.insert(store_bag, v)
                end
                
                for _, v in ipairs(store_bag2) do
                    table.insert(store_bag, v)
                end
               
                return store_bag
                
            end
            -- 判断是否需要存储
            local function get_store_item(bag,is_insert_stone,unique_storage_pages,public_warehouse_pages,map_ys_level_min)
                 
                -- 获取背包中的地图钥匙
                local function get_map_number()
                    local items = {}
                    for _, item in ipairs(bag) do
                        if item.category_utf8 == "Map" then
                            table.insert(items,item)
                        end
                    end
                    if items and next(items) then
                        return items
                    end
                    return false
                end
                -- 获取背包地图数量
                local function map_index()
                    local number = get_map_number()
                    if number and #number >= 4 then
                        return true
                    end
                    return false
                    
                end
                
                -- 获取背包中不打等级的地图钥匙
                local function get_map_not_level()
                    local map = get_map_number()
                    if map then
                        local tiers = {}
                        for _, v in ipairs(map_config) do
                            table.insert(tiers,tonumber(v["階級"]))
                        end
                        if tiers and next(tiers) then
                            for _, v1 in ipairs(map) do
                               if not poe2_api.table_contains(poe2_api.extract_level(v1.baseType_utf8),tiers) then
                                    return v1
                               end
                            end
                        end 
                    end
                    return false
                end
                -- 获取背包中不打词条的地图钥匙
                local function get_map_not_entry()
                    local map = get_map_number()
                    if map then
                        for _,item in ipairs(map) do
                            if item.color > 0 and not item.not_identified and match_item_suffixes(api_GetObjectSuffix(item.mods_obj),not_use_map) then
                                return item
                            end
                        end
                    end
                    return false
                end
                -- 找不是疯癫的地图
                local function get_map_not_crazy()
                    local map = get_map_number()
                    local max_map = poe2_api.select_best_map_key({inventory=bag,key_level_threshold=user_map,not_use_map = not_use_map,priority_map = priority_map})
                    if max_map then
                        local max_map_level = poe2_api.extract_level(max_map.baseType_utf8)
                        local is_oiled = nil
                        for _,v in ipairs(map_config) do
                            if v["階級"] == max_map_level then
                                if v["塗油設置"]  then
                                    is_oiled = v["塗油設置"]["是否塗油"]
                                end
                            end
                        end
                        if is_oiled then
                            local function is_crazy(item)
                                local item_entry = api_GetObjectSuffix(item.mods_obj)
                                if item_entry and next(item_entry) then
                                    for _, entry in ipairs(item_entry) do
                                        if string.find(entry.name_utf8,"譫妄") then
                                            -- table.insert()
                                            return true
                                        end
                                    end
                                end
                            end
                            for _, v in ipairs(map) do
                                if not is_crazy(v) then
                                    if v.obj ~= max_map.obj then
                                        return v
                                    end
                                end
                            end
                        end
                    end
                    return false
                end
                
                -- 是否另存为
                local function item_save_as(goods,cfg_object)
                    local satisfy = {}
                    for _, v in ipairs(items_info) do
                        if not v["不撿"] and v["存倉頁名"] and v["存倉頁名"] ~= "" and string.find(v["基礎類型名"],goods.baseType_utf8) then
                            local color = goods.color or -1
                            if  v['颜色'] and next(v['颜色']) and poe2_api.table_contains(color,v['颜色']) then
                                table.insert(satisfy,v)
                            end
                            
                        end
                    end
                    if satisfy and next(satisfy) then
                        for _, v in ipairs(satisfy) do
                            if not deep_equal_unordered_full(v,cfg_object) then
                                if v["工會倉庫"] then
                                    return {goods,v["存倉頁名"],1}
                                else
                                    return {goods,v["存倉頁名"],0}
                                end
                            end
                        end
                    end
                    return false
                end
                -- 判断是否设置了词缀
                local function is_valid_affix(affix)
                    return affix and (affix["name"] and affix.name ~= "")         
                end
                local function get_ct_config(object_cfg)
                    local affixes = object_cfg["物品詞綴"] or {}
                    for _, affix_group in pairs(affixes) do
                        if affix_group and type(affix_group) == "table" then
                            local affix_list = affix_group["詞綴"]
                            if affix_list then
                                for _, affix in ipairs(affix_list) do
                                    if is_valid_affix(affix) then
                                        -- poe2_api.dbgp("找到有效詞綴："..affix.name)
                                        return true
                                    end
                                end
                            end
                        end
                    end
                    return false
                end
                local min_map = poe2_api.select_best_map_key({inventory=bag,index = 1,no_categorize_suffixes = 1,min_level=map_ys_level_min,trashest=true})
                
                if unique_storage_pages and next(unique_storage_pages) then
                    for _, i in ipairs(unique_storage_pages) do
                        for _, b in ipairs(bag) do
                            -- poe2_api.dbgp("b.baseType_utf8:"..b.baseType_utf8)
                            for _, item in ipairs(items_info) do
                                if poe2_api.match_item(b,item) and item["存倉頁名"] == i and not item["工會倉庫"] and not item["不撿"] then
                                    if ((item["名稱"] and item["名稱"] ~= "" and item["名稱"] ~= "全部物品") or get_ct_config(item)) and b.not_identified then
                                        poe2_api.dbgp("1")
                                        break
                                    end
                                    if b.baseType_utf8 == "知識卷軸" then
                                        break
                                    end
                                    if b.category_utf8 ~= "StackableCurrency" and poe2_api.is_do_without_pick_up(b,items_info) then
                                        poe2_api.dbgp("2")
                                        break
                                    end
                                    if b.category_utf8 == "QuestItem" then
                                        poe2_api.dbgp("3")
                                        break
                                    end
                                    if b.category_utf8 == "Map" then
                                        local map_not_level = get_map_not_level()
                                        if map_not_level then
                                            env.store_item = {map_not_level,i,0}
                                            poe2_api.dbgp("4")
                                            return true
                                        end
                                        if b.color > 0 then
                                            if not_use_map then
                                                local not_entry = get_map_not_entry()
                                                if not_entry then
                                                    env.store_item = {not_entry,i,0}
                                                    poe2_api.dbgp("5")
                                                    return true
                                                end    
                                            end   
                                        end
                                        if not map_index() then
                                            poe2_api.dbgp("6")
                                            break
                                        end
                                        local crazy = get_map_not_crazy()
                                        if crazy then
                                            env.store_item = {crazy,i,0}
                                            poe2_api.dbgp("7")
                                            return true
                                        end
                                        if min_map and b.obj ~= min_map.obj then
                                            poe2_api.dbgp("8")
                                            break
                                        end 
                                    end
                                    if is_insert_stone then
                                        if b.category_utf8 == "TowerAugmentation" and env.is_get_plaque then
                                            poe2_api.dbgp("9")
                                            break
                                        end
                                    end
                                    local item_entry = item["物品詞綴"] or {}
                                    if item_entry and next(item_entry) then
                                        local function get_cfg_entry(entry_list)
                                            for k, v in pairs(entry_list) do
                                                if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                                    if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                        return true
                                                    end
                                                end
                                            end
                                            return false
                                        end
                                        if get_cfg_entry(item_entry) then
                                            if poe2_api.table_contains(b.category_utf8,my_game_info.equip_type) and not b.not_identified then
                                                local suffixes = api_GetObjectSuffix(b.mods_obj)
                                                if suffixes and next(suffixes) and not poe2_api.filter_item(b,suffixes,config["物品過濾"]) then
                                                    break
                                                end
                                            end
                                        end
                                    end
                                    -- if poe2_api.table_contains(b.category_utf8,my_game_info.equip_type) and not b.not_identified then
                                    --     local suffixes = api_GetObjectSuffix(b.mods_obj)
                                    --     if suffixes and next(suffixes) and not poe2_api.filter_item(b,suffixes,config["物品過濾"]) then
                                    --         poe2_api.dbgp("10")
                                    --         break
                                    --     end
                                    -- end
                                    local save_as = item_save_as(b,item)
                                    if save_as and next(save_as) then
                                        env.store_item  = save_as
                                        poe2_api.dbgp("11")
                                        return true
                                    end
                                    env.store_item = {b,i,0}
                                    return true
                                end
                            end
                        end
                    end
                end
                if public_warehouse_pages and next(public_warehouse_pages) then
                    for _, i in ipairs(public_warehouse_pages) do
                        for _, b in ipairs(bag) do
                            for _, item in ipairs(items_info) do
                                if poe2_api.match_item(b,item) and item["存倉頁名"] == i and item["工會倉庫"] and not item["不撿"] then
                                    if ((item["名稱"] and item["名稱"] ~= "" and item["名稱"] ~= "全部物品") or get_ct_config(item)) and b.not_identified then
                                        break
                                    end
                                    if b.baseType_utf8 == "知識卷軸" then
                                        break
                                    end
                                    if b.category_utf8 ~= "StackableCurrency" and poe2_api.is_do_without_pick_up(b,items_info) then
                                        break
                                    end
                                    if b.category_utf8 == "QuestItem" then
                                        break
                                    end
                                    if b.category_utf8 == "Map" then
                                        local map_not_level = get_map_not_level()
                                        if map_not_level then
                                            env.store_item = {map_not_level,i,1}
                                            return true
                                        end
                                        if b.color > 0 then
                                            if not_use_map then
                                                local not_entry = get_map_not_entry()
                                                if not_entry then
                                                    env.store_item = {not_entry,i,1}
                                                    return true
                                                end    
                                            end   
                                        end
                                        if not map_index() then
                                            break
                                        end
                                        local crazy = get_map_not_crazy()
                                        if crazy then
                                            env.store_item = {crazy,i,1}
                                            return true
                                        end
                                        if min_map and b.obj ~= min_map.obj then
                                            break
                                        end 
                                    end
                                    if is_insert_stone then
                                        if b.category_utf8 == "TowerAugmentation" and env.is_get_plaque then
                                            break
                                        end
                                    end
                                    local item_entry = item["物品詞綴"] or {}
                                    if item_entry and next(item_entry) then
                                        local function get_cfg_entry(entry_list)
                                            for k, v in pairs(entry_list) do
                                                if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                                    if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                        return true
                                                    end
                                                end
                                            end
                                            return false
                                        end
                                        if get_cfg_entry(item_entry) then
                                            if poe2_api.table_contains(b.category_utf8,my_game_info.equip_type) and not b.not_identified then
                                                local suffixes = api_GetObjectSuffix(b.mods_obj)
                                                if suffixes and next(suffixes) and not poe2_api.filter_item(b,suffixes,config["物品過濾"]) then
                                                    break
                                                end
                                            end
                                        end
                                    end
                                    -- if poe2_api.table_contains(b.category_utf8,my_game_info.equip_type) and not b.not_identified then
                                    --     local suffixes = api_GetObjectSuffix(b.mods_obj)
                                    --     if suffixes and next(suffixes) and not poe2_api.filter_item(b,suffixes,config["物品過濾"]) then
                                    --         break
                                    --     end
                                    -- end
                                    local save_as = item_save_as(b,item)
                                    if save_as and next(save_as) then
                                        env.store_item  = save_as
                                        return true
                                    end
                                    env.store_item = {b,i,1}
                                    return true
                                end
                            end
                        end
                    end
                end
                return false
            end
            local player_info = env.player_info
            local bag_info = env.bag_info
            -- local current_map_info = env.current_map_info
            -- 没有人物信息
            if not next(player_info) then
                poe2_api.time_p("是否存储物品（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            
            -- 是否需要合成
            if env.is_need_strengthen then
                poe2_api.time_p("是否存储物品（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            -- 背包为空
            if not bag_info or not next(bag_info) then
                poe2_api.time_p("是否存储物品（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local point = poe2_api.get_space_point({width=1,height=1,info=env.bag_info})
            if not point then
                env.is_public_warehouse = true
                env.is_public_warehouse_plaque = true
                -- poe2_api.time_p("是否存储物品（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                -- return bret.RUNNING
            end
            -- 是否需要点金
            if not env.is_public_warehouse then
                poe2_api.time_p("是否存储物品（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            -- 碑牌是否需要点金
            if not env.is_public_warehouse_plaque then
                poe2_api.time_p("是否存储物品（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local items_info = poe2_api.get_items_config_info(config)
            local unique_storage_pages = {}
            for _, v in ipairs(items_info) do
                if v['存倉頁名'] and v['存倉頁名'] ~= "" and not v['工會倉庫'] and not v["不撿"] then
                    table.insert(unique_storage_pages,v['存倉頁名'])
                end
            end
            
            local public_warehouse_pages = {}
            for _, v in ipairs(items_info) do
                if v['存倉頁名'] and v['存倉頁名'] ~= "" and v['工會倉庫'] and not v["不撿"] then
                    table.insert(public_warehouse_pages,v['存倉頁名'])
                end
            end
            -- 未配置物品过滤
            if (not unique_storage_pages or not next(unique_storage_pages)) and (not public_warehouse_pages or not next(public_warehouse_pages)) then
                poe2_api.time_p("是否存储物品（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local map_level_type = {}
            local map_ys_level_min = 0
            for _, v in ipairs(items_info) do
                if string.find(v["類型"],"地圖鑰匙") and not v["不撿"] then
                    table.insert(map_level_type,v['等級'])
                end
            end
            if next(map_level_type) then
                local map_type = map_level_type[1]["type"]
                if map_type == "exact" then
                    local item_level = map_level_type[1]["value"]
                    map_ys_level_min = item_level-3
                else
                    local min_level = map_level_type[1]["min"]
                    map_ys_level_min = min_level
                end
            end
            -- 是否需要插入碑牌
            local is_insert_stone = env.is_insert_stone
            local bag_store_info = get_store_bag_info(bag_info)
            -- poe2_api.dbgp("bag_store_info",type(bag_store_info),#bag_store_info)
            local store = get_store_item(bag_store_info,is_insert_stone,unique_storage_pages,public_warehouse_pages,map_ys_level_min)
            
            if not store then
                -- poe2_api.dbgp("ooooooooooooooo")
                local not_config_altar_item = nil
                for _, v in ipairs(bag_info) do
                    if poe2_api.table_contains(altar_shop_config,v.baseType_utf8) then
                        not_config_altar_item = v
                    end
                end
                if not_config_altar_item then
                    if not is_not_altar_shop(not_config_altar_item) then
                        local text = poe2_api.get_item_type(not_config_altar_item)
                        local item_key = ""
                        if text ~= "" then
                            item_key = text
                        else
                            for k, v in ipairs(my_game_info.type_conversion) do
                                if not_config_altar_item.category_utf8 == v then
                                    item_key = k
                                    break
                                end
                            end
                        end
                        error("未配置购物祭祀物品：->"..not_config_altar_item.name_utf8 .."<-,物品类型为:->".. item_key .."<-,相关存储页请在物品配置中添加")
                    end
                end
                env.exchange_status = false
                poe2_api.time_p("是否存储物品（SUCCESS8）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            
            local store_item = env.store_item
            poe2_api.dbgp("store_item",store_item[1].baseType_utf8,store_item[3])
            -- api_Sleep(5000)
            if store_item[3] == 0 then
                if poe2_api.find_text({UI_info=env.UI_info,text="強調物品",min_y=700,min_x=250}) and poe2_api.find_text({UI_info=env.UI_info,text="公會倉庫",min_x=0,min_y=32,max_x=381,max_y=81}) then
                    -- poe2_api.click_keyboard('space')
                    poe2_api.find_text({UI_info = env.UI_info, text = "公會倉庫", min_x = 0, click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("是否存储物品（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            elseif store_item[3] == 1 then
                poe2_api.dbgp("公仓")
                if poe2_api.find_text({UI_info=env.UI_info,text="強調物品",min_y=700,min_x=250}) and poe2_api.find_text({UI_info=env.UI_info,text="倉庫",min_x=0,min_y=32,max_x=381,max_y=81}) then
                    -- poe2_api.click_keyboard('space')
                    poe2_api.find_text({UI_info = env.UI_info, text = "倉庫", min_x = 0, click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("是否存储物品（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            if env.store_item[3] == 0 then
                env.warehouse_type_interactive = "个仓"
            else
                env.warehouse_type_interactive = "公仓"
            end
            poe2_api.dbgp("存仓-----------------------------------------------1010101")
            poe2_api.time_p("是否存储物品（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
            
        end
    },


    -- 存储动作
    Store_Items = {
        run = function(self, env)
            poe2_api.print_log("存储行为...")
            local start_time = api_GetTickCount64()
            poe2_api.dbgp("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
            local text = ""
            if env.warehouse_type_interactive == "个仓" then
                text = "倉庫"
                if poe2_api.find_text({text = "強調物品",UI_info = env.UI_info,min_x = 250,min_y = 700}) 
                and poe2_api.find_text({text = "公會倉庫",UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=81}) then
                    -- poe2_api.click_keyboard("space")
                    poe2_api.find_text({UI_info = env.UI_info, text = "公會倉庫", min_x = 0, click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("存储动作（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            elseif env.warehouse_type_interactive == "公仓" then
                text = "公會倉庫"
                if poe2_api.find_text({text = "強調物品",UI_info = env.UI_info,min_x = 250,min_y = 700}) 
                and poe2_api.find_text({text = "倉庫",UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=81}) then
                    poe2_api.find_text({text = "倉庫",UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=81, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("存储动作（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            else
                error("未知的仓库类型")
            end
            if not poe2_api.find_text({text = "強調物品",UI_info = env.UI_info,min_x = 250,min_y = 700}) then
            -- and poe2_api.find_text({text = text,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=81}) then
                poe2_api.dbgp("存仓11111-----------------------------------------------1010101")
                poe2_api.time_p("存储动作（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            
            if not self.bool then
                self.type = 0
                self.timeout = 0
                self.is_wait = false
                self.wait_item = nil
                self.current = nil
                self.obj = nil
                self.num = 0
                self.bool = true
                poe2_api.time_p("存储动作（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local store_item = env.store_item
            local bag_info = env.bag_info
            local current_map_info = env.current_map_info
            local config = env.user_config
            local map_config = config['刷圖設置']["地圖鑰匙"]
            local currency_exchange_is_opens = config['刷圖設置']["通貨交換設置"]
            local godown_info = api_GetRepositoryPages(store_item[3])
            if next(env.page_full_list) and poe2_api.table_contains(env.page_full_list,tostring(store_item[2])) then
                for _, v in ipairs(godown_info) do
                    -- poe2_api.dbgp(v.name_utf8)
                    if v.name_utf8 ~= "" and v.name_utf8 ~= tostring(store_item[2]) and not poe2_api.table_contains(env.page_full_list,v.name_utf8) then
                        store_item[2] = v.name_utf8
                        break
                    end
                end
            end
            local function is_everything_liquidated()
                if not next(env.page_full_list) then
                    return true
                end
                for _, v in pairs(godown_info) do
                    if v.name_utf8 ~= "" and not poe2_api.table_contains(env.page_full_list,v.name_utf8) then
                        return true
                    end
                end
                return false
            end
            local a = is_everything_liquidated()
            poe2_api.dbgp("is_everything_liquidated:",a)
            poe2_api.dbgp("store_item[2]:",store_item[2])
            -- return bret.SUCCESS
            local function map_color()
                local color_map = {}
                if not map_config or not next(map_config) then
                    return false
                end
                for _, i in ipairs(map_config) do
                    local color = {}
                    if i["白"] then table.insert(color, 0) end
                    if i["藍"] then table.insert(color, 1) end
                    if i["黃"] then table.insert(color, 2) end
                    color_map[i["階級"]] = color
                end
                return color_map
            end
            local function is_get_map_color(map_info,map)
                if not map_info or not next(map_info) then
                    return false
                end
                for k, v in ipairs(map_info) do
                    if poe2_api.extract_level(map.baseType_utf8) == k then
                        if v then
                            if poe2_api.table_contains(map.color,v) then
                                return true
                            end
                        end
                    end
                end
                return false
            end
            local map_color_info = map_color()
            -- 检测某物品是否超过三
            local function has_three_duplicates(lst)
                local counter = {}
                for _, v in ipairs(lst) do
                    counter[v] = (counter[v] or 0) + 1
                end
                for _, count in pairs(counter) do
                    if count >= 3 then
                        return true
                    end
                end
                return false
            end
            local items_info = poe2_api.get_items_config_info(config)
            
            local page = {}
            local index = 0
            if store_item[3] == 0 then
                for _, item in ipairs(items_info) do
                    if not item["不撿"] and string.find(item["類型"],"地圖鑰匙") and not item["工會倉庫"] then
                        table.insert(page,item["存倉頁名"])
                        index = 0
                    end  
                end
            else
                for _, item in ipairs(items_info) do
                    if not item["不撿"] and string.find(item["類型"],"地圖鑰匙") and item["工會倉庫"] then
                        table.insert(page,item["存倉頁名"])
                        index = 2
                    end  
                end
            end
            if self.timeout == 0 then
                self.timeout = api_GetTickCount64()
            end
            if api_GetTickCount64() - self.timeout > 5000 then
                self.type = 0
                self.timeout = 0
            end
            if next(env.page_full_list) and not is_everything_liquidated() then
                if store_item[3] == 1 then
                    error("仓库已满，手动清理1111")
                else
                    currency_exchange_is_opens = currency_exchange_is_opens["是否自動對換"] or false
                    if currency_exchange_is_opens then
                        if env.exchange_status then
                            error("仓库已满，手动清理1111")
                        end
                        if env.warehouse_full and not poe2_api.get_space_point({width=2,height=4,info=bag_info}) then
                            error("仓库已满，手动清理1111")
                        end
                        env.warehouse_full = store_item[2]
                        self.num = 0
                        poe2_api.time_p("存储动作（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    else
                        error("仓库已满，手动清理1111")
                    end
                end
            end
            if store_item[3] == 1 then
                if self.num > 16 and is_everything_liquidated() then
                    table.insert(env.page_full_list,tostring(store_item[2]))
                    self.num = 0
                    poe2_api.time_p("存储动作（RUNNING17）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                    -- error("仓库已满，手动清理1111")
                end
            else
                if self.num > 8 and is_everything_liquidated() then
                    table.insert(env.page_full_list,tostring(store_item[2]))
                    self.num = 0
                    poe2_api.time_p("存储动作（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                    -- currency_exchange_is_opens = currency_exchange_is_opens["是否自動對換"] or false
                    -- if currency_exchange_is_opens then
                    --     if env.exchange_status then
                    --         error("仓库已满，手动清理1111")
                    --     end
                    --     if env.warehouse_full and not poe2_api.get_space_point({width=2,height=4,info=bag_info}) then
                    --         error("仓库已满，手动清理1111")
                    --     end
                    --     env.warehouse_full = store_item[2]
                    --     self.num = 0
                    --     poe2_api.time_p("存储动作（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    --     return bret.RUNNING
                    -- else
                    --     error("仓库已满，手动清理1111")
                    -- end
                end
            end
            if self.is_wait then
                if api_GetTickCount64() - self.current < self.wait_item then
                    poe2_api.print_log("等待间隔时间到达")
                    poe2_api.time_p("存储动作（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            if not poe2_api.find_text({text="背包",UI_info=env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                poe2_api.click_keyboard("i")
                api_Sleep(500)
                poe2_api.dbgp("开背包5")
                self.is_wait = true
                self.current = api_GetTickCount64()
                self.wait_item = 1000
                poe2_api.time_p("存储动作（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            self.is_wait = false
            local tab_list_button = poe2_api.click_text_UI({text = "tab_list_button", UI_info = env.UI_info,ret_data = true})
            
            local precut_page = nil
            -- poe2_api.dbgp(store_item[1].name_utf8)
            for _, v in ipairs(godown_info) do
                -- poe2_api.dbgp(v.name_utf8)
                if v.name_utf8 ~= "" then
                    if v.name_utf8 == tostring(store_item[2]) then
                        precut_page = v
                        break
                    end
                end
            end
            if not precut_page then
                poe2_api.print_log("找不到仓库页2222 ->"..store_item[2].."<-")
                api_Sleep(1000)
                poe2_api.time_p("存储动作（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if not tab_list_button then
                
                if self.type ~= store_item[2] or precut_page.manage_index == 0 then
                    if poe2_api.find_text({text=store_item[2],UI_info=env.UI_info,max_y=90,min_x=0,max_x=500,click = 2}) then
                        poe2_api.find_text({text=store_item[2],UI_info=env.UI_info,max_y=90,min_x=0,max_x=500,click = 2})
                        self.is_wait = true
                        self.current = api_GetTickCount64()
                        self.wait_item = 500
                        self.type = store_item[2]
                        poe2_api.time_p("存储动作（RUNNING8）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    
                    else
                        poe2_api.print_log("找不到仓库页333 ->"..store_item[2].."<-")
                        api_Sleep(1000)
                        poe2_api.time_p("存储动作（RUNNING9）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                end
            else
                local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
                local lock_button = {}
                for _,v in ipairs(lock) do
                    if v.name_utf8 == "" and v.text_utf8 == "" then
                        table.insert(lock_button,v)
                    end
                end
                if not lock_button or not next(lock_button) then
                    api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                    api_Sleep(2000)
                    api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),1)
                    api_Sleep(1000)
                    poe2_api.time_p("存储动作（RUNNING10）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                -- poe2_api.dbgp("self.type1111:",self.type)
                -- poe2_api.dbgp("store_item:",store_item[2])
                -- poe2_api.dbgp("precut_page:",precut_page)
                -- poe2_api.dbgp("precut_pagemanage_index:",precut_page.manage_index)
                -- -- poe2_api.printTable(godown_info)
                -- for _, v in ipairs(godown_info) do
                --     if v.name_utf8 == tostring(store_item[2]) then
                --     -- self.manage_index,     # 管理器索引
                --     -- self.page_index,       # 頁的索引，例如在第幾頁
                --     -- self.type,             # 页的类型
                --     -- self.name_utf8,        # 页名
                --         poe2_api.dbgp("name_utf8",v.name_utf8)
                --         poe2_api.dbgp("manage_index",v.manage_index)
                --         poe2_api.dbgp("page_index",v.name_utf8)
                --         poe2_api.dbgp("type",v.manage_index)

                --         -- poe2_api.dbgp(v.name)
                --         poe2_api.dbgp("--------")
                --     end
                -- end
                -- poe2_api.dbgp("=================================")
                if self.type ~= store_item[2] or precut_page.manage_index == 0 then
                    if poe2_api.find_text({text=store_item[2],UI_info=env.UI_info,max_y=800,min_x=556,min_y=20,max_x=851,click = 2}) then
                        poe2_api.find_text({text=store_item[2],UI_info=env.UI_info,max_y=800,min_x=556,min_y=20,max_x=851,click = 2})
                        self.is_wait = true
                        self.current = api_GetTickCount64()
                        self.wait_item = 500
                        self.type = store_item[2]
                        poe2_api.time_p("存储动作（RUNNING11）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    else
                        poe2_api.print_log("找不到仓库页1111 ->"..store_item[2].."<-")
                        api_Sleep(1000)
                        poe2_api.time_p("存储动作（RUNNING12）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                end
            end
            local need_synthesis = config["全局設置"]["刷图通用設置"]["自動合成地圖"]
            if need_synthesis then
                local is_czt = nil
                for _, v in ipairs(current_map_info) do
                    if v.name_utf8 == "TreasureVaultHammerActive" and v.flagStatus1 == 1 then
                        is_czt = v
                        break
                    end
                end
                if is_czt and page and next(page) and self.type == page[1] then
                    local warehouse = api_Getinventorys(precut_page.manage_index,index)
                    if warehouse and next(warehouse) then
                        local a = {}
                        for _, v in ipairs(warehouse) do
                            if v.category_utf8 == "Map" and not v.contaminated and poe2_api.extract_level(v.baseType_utf8)<15 and is_get_map_color(map_color_info,v) then
                                table.insert(a,v.baseType_utf8)
                            end
                        end
                        if a and next(a) then
                            if has_three_duplicates(a) then 
                                env.is_need_strengthen = true
                                poe2_api.time_p("存储动作（RUNNING13）... 耗时 --> ", api_GetTickCount64() - start_time)
                                return bret.RUNNING
                            else
                                env.is_need_strengthen = false
                            end
                        else
                            env.is_need_strengthen = false
                        end
                    end
                end
            end
            if poe2_api.table_contains(precut_page.type,{0,1}) then
                local warehouse = api_Getinventorys(precut_page.manage_index,index)
                if warehouse and next(warehouse) then
                    if env.need_sale_map and store_item[1].category_utf8 == "Map" then
                        local count = poe2_api.get_space_point({width=1,height=1,w=12,h=12,gox=14,goy=99,info=warehouse,ret_number = true})
                        if count == 0 then
                            env.map_page_full = store_item[1].category_utf8
                            poe2_api.time_p("存储动作（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        end
                        local bag_map_count = 0
                        for _, v in ipairs(bag_info) do
                            if v.category_utf8 == "Map" then
                                bag_map_count = bag_map_count + 1
                            end
                        end
                        poe2_api.dbgp("bag_map_count:",bag_map_count)
                        poe2_api.dbgp("count:",count)
                        -- api_Sleep(100000)
                        if count <= bag_map_count - 3 then
                            env.map_page_full = store_item[1].category_utf8
                            poe2_api.dbgp("map_page_full:",env.map_page_full)
                            -- api_Sleep(3000)
                            poe2_api.time_p("存储动作（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        end
                    end
                    local w = store_item[1].end_x - store_item[1].start_x
                    local h = store_item[1].end_y - store_item[1].start_y
                    local point = poe2_api.get_space_point({width=w,height=h,w=12,h=12,gox=14,goy=99,info=warehouse})
                    if not point and is_everything_liquidated() then 
                        table.insert(env.page_full_list,tostring(store_item[2]))
                        self.num = 0
                        poe2_api.time_p("存储动作（RUNNING18）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                        -- currency_exchange_is_opens = currency_exchange_is_opens["是否自動對換"] or false
                        -- if currency_exchange_is_opens then
                        --     if env.exchange_status then
                        --         error("仓库已满，手动清理2222")
                        --     end
                        --     if env.warehouse_full and not poe2_api.get_space_point({width=2,height=4,info=bag_info}) then
                        --         error("仓库已满，手动清理2222")
                        --     end
                        --     if store_item[3] == 0 then
                        --         env.warehouse_full = store_item[2]
                        --         poe2_api.time_p("存储动作（RUNNING14）... 耗时 --> ", api_GetTickCount64() - start_time)
                        --         return bret.RUNNING
                        --     else
                        --         error("仓库已满，手动清理2222")
                        --     end
                        -- else
                        --     error("仓库已满，手动清理2222")
                        -- end
                    end
                end
            elseif precut_page.type == 7 then
                local warehouse = api_Getinventorys(precut_page.manage_index,index)
                if warehouse and next(warehouse) then
                    if env.need_sale_map and store_item[1].category_utf8 == "Map" then
                        local count = poe2_api.get_space_point({width=1,height=1,w=24,h=24,gox=14,goy=99,info=warehouse,ret_number = true})
                        if count == 0 then
                            env.map_page_full = store_item[1].category_utf8
                            poe2_api.time_p("存储动作（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        end
                        local bag_map_count = 0
                        for _, v in ipairs(bag_info) do
                            if v.category_utf8 == "Map" then
                                bag_map_count = bag_map_count + 1
                            end
                        end
                        poe2_api.dbgp("bag_map_count:",bag_map_count)
                        poe2_api.dbgp("count:",count)
                        -- api_Sleep(100000)
                        if count <= bag_map_count - 3 then
                            env.map_page_full = store_item[1].category_utf8
                            poe2_api.dbgp("map_page_full:",env.map_page_full)
                            -- api_Sleep(3000)
                            poe2_api.time_p("存储动作（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        end
                    end
                    local w = store_item[1].end_x - store_item[1].start_x
                    local h = store_item[1].end_y - store_item[1].start_y
                    local point = poe2_api.get_space_point({width=w,height=h,w=24,h=24,gox=15,goy=100,grid_x=22,grid_y=22,info=warehouse})
                    if not point and is_everything_liquidated() then 
                        table.insert(env.page_full_list,tostring(store_item[2]))
                        self.num = 0
                        poe2_api.time_p("存储动作（RUNNING17）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                        -- currency_exchange_is_opens = currency_exchange_is_opens["是否自動對換"] or false
                        -- if currency_exchange_is_opens then
                        --     if env.exchange_status then
                        --         error("仓库已满，手动清理3333")
                        --     end
                        --     if env.warehouse_full and not poe2_api.get_space_point({width=2,height=4,info=bag_info}) then
                        --         error("仓库已满，手动清理3333")
                        --     end
                        --     if store_item[3] == 0 then
                        --         env.warehouse_full = store_item[2]
                        --         poe2_api.time_p("存储动作（RUNNING15）... 耗时 --> ", api_GetTickCount64() - start_time)
                        --         return bret.RUNNING
                        --     else
                        --         error("仓库已满，手动清理3333")
                        --     end
                            
                        -- else
                        --     error("仓库已满，手动清理3333")
                        -- end
                    end
                end
            end
            if self.obj and self.obj == store_item[1].obj then
                self.num = self.num + 1
            end
            if not self.obj then
                self.obj = store_item[1].obj
            end
            if self.obj ~= store_item[1].obj then
                self.obj = store_item[1].obj
                self.num = 0
            end
            if self.num and self.num ~= 0 and self.num % 3 == 0 then
                local x = math.random(100, 1500)
                local y = math.random(50, 100)
                api_ClickScreen(poe2_api.toInt(x),poe2_api.toInt(y),0)
                api_Sleep(300)
                poe2_api.click_keyboard('alt')
                api_Sleep(300)
                if poe2_api.find_text({text="私訊",UI_info=env.UI_info,min_x=0,min_y=0,max_x=1000}) then
                    poe2_api.click_keyboard("enter")
                    api_Sleep(300)
                end
            end
            
            poe2_api.ctrl_left_click_bag_items(store_item[1].obj,bag_info,3)
            api_Sleep(300)
            poe2_api.time_p("存储动作（RUNNING16）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.RUNNING
        end
    },

    -- 是否购买地图
    Is_Shopping_Map = {
        run = function(self, env)
            poe2_api.print_log("是否购买地图...")
            local start_time = api_GetTickCount64()
            if not env.is_shop then
                poe2_api.time_p("是否购买地图（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local player_info = env.player_info
            local bag_info = env.bag_info
            poe2_api.printTable(bag_info)
            if not next(player_info) then
                poe2_api.time_p("是否购买地图（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local config = env.user_config
            local map_config = config['刷圖設置']["地圖鑰匙"]
            local not_use_map = env.not_use_map
            -- 词条过滤
            local function match_item_suffixes(item_suffixes, config_suffixes)
                if not item_suffixes or not next(item_suffixes) then
                    return false
                end
                if not config_suffixes or not next(config_suffixes) then
                    return false
                end
                for _, v in ipairs(item_suffixes) do
                    for _, v1 in ipairs(config_suffixes) do
                        if v.name_utf8 == v1 then
                            return true
                        end
                    end
                end
                return false
            end
            local function get_map_len(bag_info)
                local tiers = {}
                for _, v in ipairs(map_config) do
                    table.insert(tiers,v["階級"])
                end
                local function number_map()
                    if not tiers or not next(tiers) then
                        return false
                    end
                    local map_count = 0
                    poe2_api.printTable(tiers)
                    for _, v in ipairs(bag_info) do
                        if v.category_utf8 == "Map" and poe2_api.table_contains(poe2_api.extract_level(v.baseType_utf8),tiers) and not match_item_suffixes(api_GetObjectSuffix(v.mods_obj),not_use_map) then
                            map_count = map_count + 1
                        end
                    end
                    if map_count < 1 then
                        return true
                    end
                    return false
                end
                if not bag_info or not next(bag_info) or number_map() then
                    return true
                end
                return false
            end
            local a = get_map_len(bag_info)
            poe2_api.dbgp("a------------------------------------------------------------------------:",tostring(a))
            if not  a then
                env.is_shop = false
                poe2_api.time_p("是否购买地图（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            poe2_api.time_p("是否购买地图（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end
    },

    -- 打开商店
    Open_Shop = {
        run = function(self, env)
            poe2_api.print_log("打开商店...")
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.index = 0
                self.bool = true
            end
            local player_info = env.player_info
            local current_map_info = env.current_map_info
            -- local range_info = env.range_info
            local warehouse = nil
            if (not current_map_info or not next(current_map_info)) and (not env.range_info or not next(env.range_info)) then
                poe2_api.dbgp("小地图信息和周围对象信息都为空")
                api_Sleep(1000)
                poe2_api.time_p("打开商店（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local warehouse1 = nil
            local warehouse2 = nil
            for _, v in ipairs(current_map_info) do
                if v.name_utf8 == "多里亞尼" and v.flagStatus == 0 and v.flagStatus1 == 1 then
                    warehouse1 = v
                end
            end
            if not warehouse1 then
                for _, v in ipairs(env.range_info) do
                    if v.name_utf8 == "多里亞尼" and v.is_selectable then
                        warehouse2 = v
                    end
                end
                if warehouse2 then
                    warehouse = warehouse2
                end
            else
                warehouse = warehouse1
            end

            if warehouse then
                local distance = poe2_api.point_distance(warehouse.grid_x,warehouse.grid_y,player_info)
                if poe2_api.find_text({text="購買或販賣",UI_info=env.UI_info,min_x=0,max_x=800}) and distance <=25 then
                    self.index = 0
                    poe2_api.time_p("打开商店（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
                if poe2_api.find_text({text="Buy or Sell items",UI_info=env.UI_info,min_x=0,max_x=1600,click=2}) and distance <=25 then
                    api_Sleep(500)
                    poe2_api.time_p("打开商店（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if poe2_api.find_text({text="購買或販賣物品",UI_info=env.UI_info,min_x=0,max_x=1600,click=2}) and distance <=25 then
                    api_Sleep(500)
                    poe2_api.time_p("打开商店（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if distance and distance > 25 then
                    env.interactive = "多里亞尼"
                    poe2_api.time_p("打开商店（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                else
                    api_ClickMove(poe2_api.toInt(warehouse.grid_x),poe2_api.toInt(warehouse.grid_y),poe2_api.toInt(player_info.world_z),1)
                    api_Sleep(500)
                    if self.index >= 10 then
                        poe2_api.dbgp1("111111111111111111111111111111111")
                        poe2_api.click_keyboard("space")
                        api_Sleep(200)
                        self.index = 0
                    end
                    self.index = self.index + 1
                    api_Sleep(200)
                    poe2_api.time_p("打开商店（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            else
                poe2_api.dbgp("找不到多里亞尼")
                poe2_api.time_p("打开商店（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            poe2_api.time_p("打开商店（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 购买地图动作
    Shopping_Map = {
        run = function(self, env)
            poe2_api.print_log("购买地图动作...")
            local start_time = api_GetTickCount64()
            local player_info = env.player_info
            local current_map_info = env.current_map_info
            -- local range_info = env.range_info
            local warehouse = nil
            if (not current_map_info or not next(current_map_info)) and (not env.range_info or not next(env.range_info)) then
                poe2_api.dbgp("小地图信息和周围对象信息都为空")
                api_Sleep(1000)
                poe2_api.time_p("购买地图动作（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local warehouse1 = nil
            local warehouse2 = nil
            for _, v in ipairs(current_map_info) do
                if v.name_utf8 == "多里亞尼" and v.flagStatus == 0 and v.flagStatus1 == 1 then
                    warehouse1 = v
                end
            end
            if not warehouse1 then
                for _, v in ipairs(env.range_info) do
                    if v.name_utf8 == "多里亞尼" and v.is_selectable then
                        warehouse2 = v
                    end
                end
                if warehouse2 then
                    warehouse = warehouse2
                end
            else
                warehouse = warehouse1
            end
            if warehouse then
                local distance = poe2_api.point_distance(warehouse.grid_x,warehouse.grid_y,player_info)
                poe2_api.print_log("多里亞尼距离: "..distance)
                if distance and distance > 25 then
                    poe2_api.time_p("购买地图动作（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                end
                if not poe2_api.find_text({text="購買或販賣",UI_info=env.UI_info,min_x=0,max_x=800}) then
                    -- self.index = 0
                    poe2_api.time_p("购买地图动作（FAIL2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                end
            else
                poe2_api.dbgp("小地图和周围对象找不到多里亞尼")
                poe2_api.time_p("购买地图动作（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local config = env.user_config
            local map_config = config['刷圖設置']["地圖鑰匙"]
            local tiers = {}
            for _, v in ipairs(map_config) do
                table.insert(tiers,v["階級"])
            end
            local map = api_GetItemsInUiRectangle(238,215,563,508,1)
            if map and next(map) then
                local function get_max_level(map_shop)
                    local index = nil
                    for _, v in ipairs(map_shop) do
                        if v.category_utf8 == "Map" and poe2_api.table_contains(poe2_api.extract_level(v.baseType_utf8),tiers) then
                            index = v
                            break
                        end
                    end
                    if index then
                        return index
                    end
                    return false
                end
                local max_map = get_max_level(map)
                if max_map then
                    local function get_point(start_cell,end_cell)
                        local center_x = 259 + (((start_cell[1] + start_cell[2]) / 2) * 43.81)
                        local center_y = 230 + (((end_cell[1] + end_cell[2]) / 2) * 43.81)
                        return {center_x,center_y}
                    end
                    local point = get_point({max_map.start_x, max_map.end_x},{max_map.start_y,max_map.end_y})
                    poe2_api.ctrl_left_click(point[1],point[2])
                    return bret.RUNNING
                end
            end
            error("商城已无地图或者没有你想要打的等级地图，请手动购买")
            -- return bret.SUCCESS
        end
    },

    -- 更新地图石
    Update_Map_Stone = {
        run = function(self, env)
            poe2_api.print_log("更新地图石...")
            return bret.SUCCESS
        end
    },

    -- 售卖地图
    Selling_Map = {
        run = function(self, env)
            poe2_api.print_log("售卖地图动作...")
            poe2_api.dbgp("售卖地图动作...")
            local player_info = env.player_info
            local current_map_info = env.current_map_info
            local bag_info = env.bag_info
            local warehouse = nil

            if not env.full_map then
                return bret.SUCCESS
            end

            if (not current_map_info or not next(current_map_info)) and (not env.range_info or not next(env.range_info)) then
                poe2_api.dbgp("小地图信息和周围对象信息都为空")
                api_Sleep(1000)
                return bret.RUNNING
            end
            local function get_bag_map(items)
                for _,v in ipairs(items) do
                    if v.category_utf8 == "Map" then
                        return v
                    end
                end
                return false
            end
            local function count_bag_map(items)
                local count = 0
                for _,v in ipairs(items) do
                    if v.category_utf8 == "Map" then
                        count = count + 1
                    end
                end
                return count
            end
            if count_bag_map(bag_info) <= 2 then
                env.full_map = false
                env.map_page_full = nil
                return bret.RUNNING
            end 
            local warehouse1 = nil
            local warehouse2 = nil
            for _, v in ipairs(current_map_info) do
                if v.name_utf8 == "多里亞尼" and v.flagStatus == 0 and v.flagStatus1 == 1 then
                    warehouse1 = v
                end
            end
            if not warehouse1 then
                for _, v in ipairs(env.range_info) do
                    if v.name_utf8 == "多里亞尼" and v.is_selectable then
                        warehouse2 = v
                    end
                end
                if warehouse2 then
                    warehouse = warehouse2
                end
            else
                warehouse = warehouse1
            end
            if warehouse then
                local distance = poe2_api.point_distance(warehouse.grid_x,warehouse.grid_y,player_info)
                poe2_api.print_log("多里亞尼距离: "..distance)
                if distance and distance > 25 then
                    return bret.FAIL
                end
                if not poe2_api.find_text({text="購買或販賣",UI_info=env.UI_info,min_x=0,max_x=800}) then
                    -- self.index = 0
                    poe2_api.dbgp("没有检测到购买和出售按钮")
                    return bret.FAIL
                end
            else
                poe2_api.dbgp("小地图和周围对象找不到多里亞尼")
                return bret.RUNNING
            end
            local selling_map = get_bag_map(bag_info)
            if type(selling_map) == "table" then
                local point = poe2_api.get_center_position({selling_map.start_x,selling_map.start_y},{selling_map.end_x,selling_map.end_y})
                poe2_api.ctrl_left_click(point[1],point[2])
                api_Sleep(100)
                return bret.RUNNING
            end
            return bret.RUNNING
        end
    },

    -- 检查是否需要拿地图
    Is_Need_Take_Map = {
        run = function(self, env)
            poe2_api.print_log("检查是否需要拿地图...")
            poe2_api.dbgp("开始执行 Is_Need_Take_Map 检查")
            
            local current_time = api_GetTickCount64()
            local bag_info = env.bag_info
            local player_info = env.player_info
            
            local is_map_complete = env.is_map_complete
            local user_map = env.user_map
            local not_use_map = env.not_use_map
            local is_have_map = env.is_have_map
            local current_map_info = env.current_map_info
            local one_other_map = env.one_other_map
            local config = env.user_config
            local entry_length_take_map = env.entry_length_take_map

            -- poe2_api.dbgp("环境变量检查:", {
            --     bag_info = bag_info and #bag_info or "nil",
            --     player_info = player_info and "exists" or "nil",
            --     range_info = range_info and #range_info or "nil",
            --     is_map_complete = is_map_complete,
            --     user_map = user_map,
            --     not_use_map = not_use_map,
            --     is_have_map = is_have_map,
            --     config = config and "exists" or "nil"
            -- })

            if not player_info then
                return bret.RUNNING
            end
        
            -- 检查背包中是否有地图
            local function check_map_in_bag(bag_info, return_count)
                return_count = return_count or true
                local matches = {}
                
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        if item.baseType_utf8 and string.find(item.baseType_utf8, "地圖鑰匙") then
                            table.insert(matches, item)
                        end
                    end
                end
                
                if return_count then
                    return #matches > 0 and #matches or false
                else
                    return #matches > 0 and matches or false
                end
            end
        
            -- 检查当前是否在城镇或藏身处
            local function is_in_town_or_hideout()
                local result = false
                if string.find(player_info.current_map_name_utf8 or "", "town") then
                    result = true
                end
                
                if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                    result = true
                end
                
                -- poe2_api.dbgp("is_in_town_or_hideout 检查:", {
                --     current_map = player_info.current_map_name_utf8,
                --     result = result
                -- })
                return result
            end
        
            -- 获取非地图物品（传送点/异界之门除外）
            local function get_not_map()
                local result = false
                for _, item in ipairs(env.range_info) do
                    if item.type == 5 and item.name_utf8 ~= '' and 
                    item.name_utf8 ~= "傳送點" and item.name_utf8 ~= '異界之門' then
                        result = item
                        break
                    end
                end
                
                -- poe2_api.dbgp("get_not_map 结果:", result)
                return result
            end
        
            -- 主逻辑
            if not is_in_town_or_hideout() then
                poe2_api.dbgp("不在城镇或藏身处，直接返回SUCCESS")
                poe2_api.time_p("Is_Need_Take_Map... 耗时 --> ", api_GetTickCount64() - current_time)
                env.is_shop = false
                env.take_map_times = 0
                return bret.SUCCESS
            end

            -- 如果在藏身处且有可交互的非地图物品
            if is_in_town_or_hideout() then
                local not_map = get_not_map()
                -- poe2_api.dbgp("藏身处非地图物品检查:", not_map)
                
                if not_map and not is_map_complete then
                    -- if poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", min_x = 0}) then
                        -- poe2_api.dbgp("发现世界地图文本，执行ESC")
                        -- poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", min_x = 0})
                    --     poe2_api.click_keyboard('esc')
                    -- end
                    env.is_shop = false
                    env.take_map_times = 0
                    return bret.SUCCESS
                end
            end

            if poe2_api.find_text({text = "購買或販賣", UI_info = env.UI_info,min_x=0}) then
                -- poe2_api.dbgp("999999999999999999999999999999999999999999")
                poe2_api.click_keyboard('space')
                api_Sleep(500)
                poe2_api.time_p("是否存储物品（RUNNING3）... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.RUNNING
            end
        
            -- 如果已经在世界地图界面，直接返回成功
            local world_map_text = poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", max_y = 100, min_x = 250})
            if world_map_text then
                poe2_api.dbgp("已在世界地图界面，返回SUCCESS")
                env.is_shop = false
                env.take_map_times = 0
                return bret.SUCCESS
            end
        
            -- 检查是否需要合成地图
            local need_synthesis = config["全局設置"]["刷图通用設置"]["自動合成地圖"]
            poe2_api.dbgp("自动合成地图设置:", need_synthesis)
            poe2_api.dbgp("env.is_need_strengthen:", env.is_need_strengthen)
            
            if env.is_need_strengthen and need_synthesis then
                poe2_api.dbgp("需要强化地图，返回FAIL")
                return bret.FAIL
            end
        
            -- 检查背包中的地图
            local map_count = check_map_in_bag(bag_info)
            local best_map = poe2_api.select_best_map_key({
                inventory = bag_info, 
                key_level_threshold = user_map,
                not_use_map = not_use_map
            })

            -- poe2_api.dbgp("背包地图检查结果:", {
            --     map_count = map_count,
            --     best_map = best_map and "exists" or "nil"
            -- })
        
            poe2_api.dbgp("背包地图数量: ", (map_count or 0))

            if env.need_sale_map and env.map_page_full == "Map" then
                poe2_api.dbgp("------------------>仓库地图已满，需要出售地图",env.need_sale_map,env.map_page_full)
                env.full_map = true
                return bret.FAIL
            else
                env.full_map = false
            end
        
            if (not map_count or map_count < 1 or not best_map) or env.full_map then
                -- poe2_api.dbgp("背包没有符合条件的地图")
                return bret.FAIL
            end
        
            -- poe2_api.dbgp("Is_Need_Take_Map 检查完成，返回SUCCESS")
            env.is_shop = false
            env.take_map_times = 0
            return bret.SUCCESS
        end
    },

    -- 取地图
    Take_Map1 = {
        run = function(self, env)
            poe2_api.print_log("从仓库拿地图...")
            poe2_api.dbgp("开始执行取地图 - 环境变量:", env)
            
            local current_time = api_GetTickCount64()
            local bag_info = env.bag_info
            local user_map = env.user_map
            local current_map_info = env.current_map_info
            local not_use_map = env.not_use_map
            -- poe2_api.printTable(env.user_map)
            local config = env.user_config
            local need_synthesis = config["全局設置"]["刷图通用設置"]["自動合成地圖"]
            local player_info = env.player_info
            local entry_length_take_map = env.entry_length_take_map
            local map_update_to = env.map_update_to
            
            local full_map = (env.need_sale_map and env.map_page_full == "Map") or false

            -- 获取所有地图仓库页配置
            local storage_pages = {}
            for _, item in ipairs(poe2_api.get_items_config_info(config)) do
                if item["類型"] and item["類型"] == "地圖鑰匙" and item["存倉頁名"] then
                    table.insert(storage_pages, {
                        name = item["存倉頁名"],
                        is_guild = item["工會倉庫"] or false,
                        priority = item["優先級"] or 1  -- 默认优先级为1
                    })
                end
            end

            -- 按优先级排序仓库页
            table.sort(storage_pages, function(a, b) return a.priority > b.priority end)

            -- 检查仓库是否打开
            local function check_warehouse_opened(warehouse_type)
                local emphasize_text = poe2_api.find_text({UI_info = env.UI_info, text = "強調物品", min_x = 250, min_y = 700})
                local warehouse_text = poe2_api.find_text({UI_info = env.UI_info, text = warehouse_type, min_x=0, min_y=32, max_x=381, max_y=81})
                return emphasize_text and warehouse_text
            end

            -- 打开指定类型的仓库
            local function open_warehouse(is_guild)
                local warehouse_type = is_guild and "公會倉庫" or "倉庫"
                poe2_api.dbgp("尝试打开仓库:", warehouse_type)
                
                -- 先确保仓库界面已打开
                if not check_warehouse_opened(warehouse_type) then
                    if warehouse_type == "公會倉庫" then
                        env.warehouse_type_interactive = "公仓"
                    else
                        env.warehouse_type_interactive = "个仓"
                    end
                    poe2_api.dbgp("仓库界面未打开，返回FAIL进入其他节点")
                    return bret.FAIL  -- 返回FAIL让主逻辑可以进入其他节点处理
                end
                
                -- 检查当前仓库类型
                local current_type_text = poe2_api.find_text({UI_info = env.UI_info, text = "倉庫", min_x=0, min_y=32, max_x=381, max_y=81}) and "倉庫" or
                                        poe2_api.find_text({UI_info = env.UI_info, text = "公會倉庫", min_x=0, min_y=32, max_x=381, max_y=81}) and "公會倉庫" or nil
                
                -- 如果需要切换仓库类型
                if current_type_text ~= warehouse_type then
                    local switch_button = poe2_api.find_text({UI_info = env.UI_info, 
                        text = warehouse_type, 
                        min_x=0, min_y=32, max_x=381, max_y=81,
                        add_x = 250, 
                        click = 2
                    })
                    
                    if switch_button then
                        api_Sleep(1500)
                        return true
                    end
                    return false
                end
                return true
            end

            -- 切换到指定仓库页
            local function switch_to_storage_page(page_name, is_guild)
                poe2_api.dbgp("尝试切换到仓库页:", page_name, "类型:", is_guild and "公会" or "个人")
                
                -- 先确保打开正确的仓库类型
                if not open_warehouse(is_guild) then
                    return false
                end
                
                -- 检查标签列表是否展开
                local tab_list_button = poe2_api.click_text_UI({UI_info = env.UI_info, text = "tab_list_button", ret_data = true})
                
                if tab_list_button then
                    local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
                    -- poe2_api.printTable(lock)
                    -- api_Sleep()
                    local lock_button = {}
                    for _,v in ipairs(lock) do
                        if v.name_utf8 == "" and v.text_utf8 == "" then
                            table.insert(lock_button,v)
                        end
                    end
                    if not lock_button or not next(lock_button) then
                        api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                        api_Sleep(2000)
                        api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),1)
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    -- 已展开标签列表的情况
                    return poe2_api.find_text({UI_info = env.UI_info, 
                        text = page_name, 
                        max_y = 469, min_x = 556, min_y = 20, max_x = 851, 
                        click = 2
                    })
                else
                    -- 未展开标签列表的情况
                    return poe2_api.find_text({UI_info = env.UI_info, 
                        text = page_name, 
                        max_y = 90, min_x = 0, max_x = 500, min_y = 0, 
                        click = 2
                    })
                end
            end

            -- 检查背包中的地图
            local function check_map_in_bag(bag_info)
                local count = 0  -- 初始化计数器为0
                
                poe2_api.dbgp("检查背包中的地图 - 背包信息:", bag_info)
                
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        -- 查找包含“地圖鑰匙”的物品
                        if item.baseType_utf8 and string.find(item.baseType_utf8, "地圖鑰匙") then
                            count = count + 1  -- 找到则计数+1
                        end
                    end
                end
                
                poe2_api.dbgp("检查背包地图结果（数量）:", count)
                return count or 0  -- 直接返回数量，无匹配时自然为0
            end
            
            -- 检查相同地图是否超过3个
            local function check_same_map_over_3(bag_info)
                poe2_api.dbgp("检查相同地图是否超过3个 - 背包信息:", bag_info)
                
                local item_counts = {}
                if bag_info then
                    for _, actor in ipairs(bag_info) do
                        if actor.baseType_utf8 and string.find(actor.baseType_utf8, "地圖鑰匙") and not actor.contaminated and not actor.not_identified and actor.baseType_utf8 ~= "地圖鑰匙（階級 15）" and actor.baseType_utf8 ~= "地圖鑰匙（階級 16）" then
                            item_counts[actor.baseType_utf8] = (item_counts[actor.baseType_utf8] or 0) + 1
                        end
                    end
                else
                    poe2_api.dbgp("背包没有地图")
                    poe2_api.dbgp("检查相同地图结果:", false)
                    return false
                end
                
                -- 检查是否有至少3个相同的物品
                local synthesis_possible = false
                for _, count in pairs(item_counts) do
                    if count >= 3 then
                        synthesis_possible = true
                        break
                    end
                end
                
                poe2_api.dbgp("检查相同地图结果 - 物品计数:", item_counts, "是否可以合成:", synthesis_possible)
                return synthesis_possible
            end

            -- 统计所有名称包含"地圖鑰匙"的物品数量
            local function count_all_maps(bag_info)
                poe2_api.dbgp("开始统计所有地图钥匙数量 - 背包信息:", bag_info)
                
                local total_count = 0
                
                if bag_info then
                    for _, actor in ipairs(bag_info) do
                        if actor.baseType_utf8 and string.find(actor.baseType_utf8, "地圖鑰匙") then
                            total_count = total_count + 1
                        end
                    end
                end
                
                poe2_api.dbgp("地图钥匙总数:", total_count)
                return total_count
            end

            local function check_map_test(max_y, min_x, max_x, min_y, map_num, page, is_guild)
                -- 初始化变量
                local map_page = false
                local page_index = 0
                local user_map = env.user_map
                local not_use_map = env.not_use_map
                local map_update_to = env.map_update_to
                local need_synthesis = env.need_synthesis
                local bag_info = env.bag_info
                
                -- 调试输出初始参数
                poe2_api.dbgp("开始执行check_map_test - 参数:", 
                    "max_y" , max_y,
                    "min_x" , min_x,
                    "max_x" , max_x,
                    "min_y" , min_y,
                    "map_num" , map_num,
                    "page", page,
                    "is_guild", is_guild
                )
                
                -- 获取仓库页面
                local repositoryPages
                if is_guild then
                    repositoryPages = api_GetRepositoryPages(1)
                    poe2_api.dbgp("获取公会仓库页面 - 结果:", repositoryPages and #repositoryPages or 0)
                else
                    repositoryPages = api_GetRepositoryPages(0)
                    poe2_api.dbgp("获取普通仓库页面 - 结果:", repositoryPages and #repositoryPages or 0)
                end
                
                -- 检查是否为地图页
                if repositoryPages then
                    poe2_api.dbgp("开始检查仓库页面 - 总页数:", #repositoryPages)
                    for i, page_info in ipairs(repositoryPages) do
                        poe2_api.dbgp("检查页面#"..i.." - 名称:", page_info.name_utf8, "类型:", page_info.type)
                        if page_info.name_utf8 == page and page_info.type == 5 then
                            map_page = true
                            poe2_api.dbgp("找到匹配的地图页 - 索引:", i)
                            break
                        end
                    end
                end
                
                -- 选择最佳地图
                local best_map = poe2_api.select_best_map_key({
                    inventory = bag_info,
                    key_level_threshold = user_map,
                    not_use_map = not_use_map,
                    entry_length = map_update_to
                })
                poe2_api.dbgp("选择最佳地图 - 结果:", best_map ~= nil)
                
                
                -- 处理地图页
                if map_page then
                    poe2_api.dbgp("开始处理地图页 - 页面名称:", page)
                    
                    if poe2_api.find_text({UI_info = env.UI_info, 
                        text = page,
                        max_y = max_y,
                        min_x = min_x,
                        max_x = max_x,
                        min_y = min_y,
                        click = 2
                    }) then
                        api_Sleep(500)
                    end
                    
                    -- 初始化颜色和等级列表
                    local white, blue, gold, valls, level = {}, {}, {}, {}, {}
                    if user_map then
                        poe2_api.dbgp("开始解析用户地图配置 - 配置数量:", #user_map)
                        for _, config in ipairs(user_map) do
                            local levels = tonumber(config["階級"]) or 0
                            table.insert(level, levels)
                            
                            poe2_api.dbgp("配置项 - 等级:", levels, 
                                         "白图:", config["白"], 
                                         "蓝图:", config["藍"], 
                                         "黄图:", config["黃"], 
                                         "污染:", config["已污染"])
                            
                            if config["白"] and not poe2_api.table_contains(white, levels) then
                                table.insert(white, levels)
                            end
                            if config["藍"] and not poe2_api.table_contains(blue, levels) then
                                table.insert(blue, levels)
                            end
                            if config["黃"] and not poe2_api.table_contains(gold, levels) then
                                table.insert(gold, levels)
                            end
                            if config["已污染"] and not poe2_api.table_contains(valls, levels) then
                                table.insert(valls, levels)
                            end
                        end
                    end
                    
                    -- 罗马数字映射
                    local ROMAN_NUMERALS = {
                        [1] = "I", [2] = "II", [3] = "III", [4] = "IV", [5] = "V",
                        [6] = "VI", [7] = "VII", [8] = "VIII", [9] = "IX", [10] = "X",
                        [11] = "XI", [12] = "XII", [13] = "XIII", [14] = "XIV", [15] = "XV", [16] = "XVI"
                    }
                    
                    local the_maps_num = 0
                    local click_positions = {152, 202, 252, 302, 352, 402}
                    
                    -- 按等级降序查找
                    table.sort(level, function(a, b) return a > b end)
                    poe2_api.dbgp("排序后的等级列表 - 内容:", table.concat(level, ","))
                    
                    for _, num in ipairs(level) do
                        poe2_api.dbgp("处理等级 - 当前等级:", num)
                        if num >= 1 and num <= 16 then
                            local roman_num = ROMAN_NUMERALS[num]
                            poe2_api.dbgp("转换罗马数字 - 数字:", num, "罗马数字:", roman_num)
                            
                            local a = poe2_api.find_text({UI_info = env.UI_info, 
                                refresh = true,
                                text = roman_num,
                                max_y = 242,
                                min_x = 0,
                                max_x = 544,
                                min_y = 0,
                                position = 1
                            })
                            
                            if a then
                                poe2_api.dbgp("找到罗马数字 - 位置X:", a[1], "位置Y:", a[2])
                                
                                local min_x = a[1] - 48
                                local min_y = a[2] - 48
                                local max_x = a[1] + 48
                                local max_y = a[2] + 48
                                
                                the_maps_num = poe2_api.find_text_position({UI_info = env.UI_info, 
                                    refresh = true,
                                    min_x = min_x,
                                    min_y = min_y,
                                    max_x = max_x,
                                    max_y = max_y,
                                    lens = 0
                                })
                                -- api_Sleep(100000)
                                -- poe2_api.dbgp("the_maps_num: ",the_maps_num)
                                the_maps_num = tonumber(the_maps_num) or 0
                                poe2_api.dbgp("地图数量检测 - 数量:", the_maps_num)
                                
                                if the_maps_num == 0 then
                                    poe2_api.dbgp("跳过空地图 - 罗马数字:", roman_num)
                                    goto continue
                                end
                                
                                if poe2_api.find_text({UI_info = env.UI_info, 
                                    refresh = true,
                                    text = roman_num,
                                    max_y = 242,
                                    min_x = 0,
                                    max_x = 544,
                                    min_y = 0,
                                    click = 2
                                }) then
                                    api_Sleep(500)
                                    
                                    local c = poe2_api.find_text_position({UI_info = env.UI_info, 
                                        refresh = true,
                                        min_x = 13,
                                        min_y = 263,
                                        max_x = 544,
                                        max_y = 622,
                                        num = 1,
                                        text = roman_num,
                                        click_times = 2,
                                        lens = 0
                                    })
                                    
                                    local b = poe2_api.select_best_map_key({
                                        inventory = api_Getinventorys(1, 0),
                                        key_level_threshold = user_map,
                                        not_use_map = not_use_map,
                                        entry_length = map_update_to
                                    })
                                    poe2_api.dbgp("背包地图检查 - 最佳地图:", b ~= nil)

                                    if full_map then
                                        if not poe2_api.get_space_point({width = 1, height = 1}) then
                                            poe2_api.dbgp("满地图 - 返回成功")
                                            return true
                                        end
                                    else
                                        if map_num then
                                            local current_map_count = check_map_in_bag(api_Getinventorys(1, 0))
                                            poe2_api.dbgp("地图数量验证 - 当前:", current_map_count, "需要:", map_num + 3)
                                            
                                            if current_map_count >= map_num + 3 and b then
                                                poe2_api.dbgp("满足地图数量要求 - 返回成功")
                                                return true
                                            end
                                        end
                                    end
                                    
                                    if c == 0 then
                                        poe2_api.dbgp("开始尝试点击不同位置 - 位置列表:", table.concat(click_positions, ","))
                                        
                                        for _, k in ipairs(click_positions) do
                                            poe2_api.dbgp("尝试位置 - X坐标:", k)
                                            local b = poe2_api.select_best_map_key({
                                                inventory = api_Getinventorys(1, 0),
                                                key_level_threshold = user_map,
                                                not_use_map = not_use_map,
                                                entry_length = map_update_to
                                            })
                                            
                                            if map_num then
                                                local map_num1 = check_map_in_bag(api_Getinventorys(1, 0))
                                                poe2_api.dbgp("地图数量检查 - 当前:", map_num1, "需要:", map_num)
                                                
                                                if map_num1 >= map_num and b then
                                                    poe2_api.dbgp("满足最低数量要求 - 返回成功")
                                                    return true
                                                end
                                            end
                                            
                                            api_ClickScreen(k, 258, 1)
                                            api_Sleep(1000)
    
                                            c = poe2_api.find_text_position({UI_info = env.UI_info, 
                                                refresh = true,
                                                min_x = 13,
                                                min_y = 263,
                                                max_x = 544,
                                                max_y = 622,
                                                num = 1,
                                                text = roman_num,
                                                click_times = 2,
                                                lens = 0
                                            })
                                            poe2_api.dbgp("点击后查找结果 - 找到数量:", c)
                                            
                                            if c then
                                                poe2_api.dbgp("位置点击成功 - 返回成功")
                                                return true
                                            end

                                        end
                                        goto continue
                                    end
                                    
                                    poe2_api.dbgp("成功点击罗马数字 ", roman_num, " (对应等级 ", num, ")")
                                    return true
                                end
                            else
                                poe2_api.dbgp("未找到罗马数字 - 跳过")
                            end
                        else
                            poe2_api.dbgp("无效等级 - 跳过")
                        end
                        ::continue::
                    end
                    return false
                end
                
                -- 非地图页处理
                poe2_api.dbgp("开始处理非地图页 - 页面名称:", page)
                
                if poe2_api.find_text({UI_info = env.UI_info, 
                    refresh = true,
                    text = page,
                    max_y = max_y,
                    min_x = min_x,
                    max_x = max_x,
                    min_y = min_y,
                    click = 2
                }) then
                    api_Sleep(1000)
                    
                    -- 获取页面索引
                    local page_index = 0
                    for _, page_info in ipairs(repositoryPages) do
                        if page_info.name_utf8 == page and page_info.type ~= 5 then
                            page_index = page_info.manage_index
                            break
                        end
                    end
                    poe2_api.dbgp("获取页面索引 - 结果:", page_index)
                    
                    -- 获取仓库物品
                    local items
                    if text == "公會倉庫" then
                        items = api_Getinventorys(page_index, 2)
                        poe2_api.dbgp("获取公会仓库物品 - 数量:", items and #items or 0)
                    else
                        items = api_Getinventorys(page_index, 0)
                        poe2_api.dbgp("获取普通仓库物品 - 数量:", items and #items or 0)
                    end
                    
                    -- 检查是否可以合成
                    local can_synthesize = check_same_map_over_3(items)
                    poe2_api.dbgp("合成检查 - 是否可以合成:", can_synthesize, "需要合成:", need_synthesis)
                 
                    -- 如果不需要合成或地图数量足够
                    if full_map then
                        poe2_api.dbgp("满地图处理 - 开始处理")
                        local all_map_nums = count_all_maps(items)

                        if not poe2_api.get_space_point({width = 1, height = 1}) then
                            poe2_api.dbgp("满地图 - 返回成功")
                            return true
                        end
                        -- 从仓库取地图
                        poe2_api.dbgp("开始从仓库取地图")
                        for i = 1, math.floor(all_map_nums * 0.6) do
                            -- print("循环执行第 ", i, " 次")
                            -- 获取仓库物品
                            local items
                            if text == "公會倉庫" then
                                items = api_Getinventorys(page_index, 2)
                                poe2_api.dbgp("获取公会仓库物品 - 数量:", items and #items or 0)
                            else
                                items = api_Getinventorys(page_index, 0)
                                poe2_api.dbgp("获取普通仓库物品 - 数量:", items and #items or 0)
                            end

                            local select_result = poe2_api.select_best_map_key({
                                inventory = items,
                                click = 1,
                                type = 1,
                                not_use_map = not_use_map,
                                entry_length = map_update_to,
                                trash_map = full_map
                            })
                            poe2_api.dbgp("选择地图结果:", select_result ~= nil)
                            
                            if not poe2_api.get_space_point({width = 1, height = 1}) or not select_result then
                                poe2_api.dbgp("满地图 - 返回成功")
                                return true
                            end
                            api_Sleep(100)
                        end
                    else
                        if not (need_synthesis and can_synthesize) then
                            if map_num then
                                local bag_count = check_map_in_bag(api_Getinventorys(1, 0))
                                poe2_api.dbgp("背包地图检查 - 当前数量:", bag_count, "需要数量:", map_num)
                                
                                if bag_count and bag_count > map_num and best_map then
                                    env.entry_length_take_map = false
                                    poe2_api.dbgp("满足数量要求 - 返回成功")
                                    return true
                                end
                            end
                        end
                        -- 从仓库取地图
                        poe2_api.dbgp("开始从仓库取地图")
                        local select_result = poe2_api.select_best_map_key({
                            inventory = items,
                            click = 1,
                            key_level_threshold = user_map,
                            type = 1,
                            not_use_map = not_use_map,
                            entry_length = map_update_to,
                        })
                        poe2_api.dbgp("选择地图结果:", select_result ~= nil)
                        
                        if map_num then
                            local bag_count = check_map_in_bag(api_Getinventorys(1, 0))
                            poe2_api.dbgp("最终检查 - 当前数量:", bag_count, "需要数量:", map_num)
                            if bag_count > map_num and best_map then
                                poe2_api.dbgp("满足最终数量要求 - 返回成功")
                                return true
                            end
                        end
                    end
                    
                    
                    
                end
                
                env.is_need_strengthen = false
                poe2_api.dbgp("所有检查未通过 - 返回失败")
                return false
            end


            -- 主逻辑
            if not current_map_info or not player_info then
                poe2_api.dbgp("缺失必要数据 - 当前地图信息副本:", current_map_info, "玩家信息:", player_info)
                return bret.RUNNING
            end

            -- 检查背包地图数量
            local bag_map_count = 0
            if bag_info then
                for _, item in ipairs(bag_info) do
                    if item.baseType_utf8 and string.find(item.baseType_utf8, "地圖鑰匙") then
                        bag_map_count = bag_map_count + 1
                    end
                end
            end

            -- 选择最佳地图
            local best_map = poe2_api.select_best_map_key({
                inventory = bag_info,
                key_level_threshold = user_map,
                not_use_map = not_use_map,
                entry_length = map_update_to
            })

            -- 如果背包已有足够地图且不需要强化
            if bag_map_count >= 2 and best_map and not env.is_need_strengthen and not full_map then
                env.is_have_map = true
                return bret.RUNNING
            end

            -- 在env中初始化或获取当前检查的仓库页索引
            env.current_storage_page_index = env.current_storage_page_index or 1

            -- 获取仓库标签按钮
            local tab_list_button = poe2_api.click_text_UI({UI_info = env.UI_info, text = "tab_list_button",ret_data = true})

            poe2_api.dbgp("tab_list_button:", tostring(tab_list_button))

            -- 按优先级尝试各个仓库页
            for i = env.current_storage_page_index, #storage_pages do
                local page_info = storage_pages[i]
                poe2_api.dbgp("尝试从仓库页获取地图:", page_info.name, "类型:", page_info.is_guild and "公会" or "个人", "当前索引:", i)
                
                -- 切换到目标仓库页
                local warehouse_result = open_warehouse(page_info.is_guild)
                poe2_api.dbgp("warehouse_result: ----===>>>>", warehouse_result)

                if warehouse_result == bret.FAIL then
                    -- 仓库未打开，设置标志并返回，保存当前索引
                    env.need_open_warehouse = true
                    env.target_warehouse_type = page_info.is_guild and "公会" or "个人"
                    env.current_storage_page_index = i  -- 保存当前索引以便下次继续
                    return bret.FAIL

                elseif warehouse_result then
                    -- 仓库已打开，继续切换到具体页面
                    if switch_to_storage_page(page_info.name, page_info.is_guild) then
                        api_Sleep(1500)
                        
                        -- 获取仓库物品
                        local repositoryPages = api_GetRepositoryPages(page_info.is_guild and 1 or 0)
                        local page_index = 0
                        for _, page in ipairs(repositoryPages) do
                            if page.name_utf8 == page_info.name then
                                page_index = page.manage_index
                                break
                            end
                        end
                        
                        local items = api_Getinventorys(page_index, page_info.is_guild and 2 or 0)
                        
                        -- 尝试从仓库取地图
                        if tab_list_button then
                            local SUCCESS = check_map_test(469, 556, 851, 20, 2, page_info.name, page_info.is_guild)
                        else
                            poe2_api.dbgp("未展开标签列表的情况")
                            local SUCCESS = check_map_test(90, 0, 500, 0, 2, page_info.name, page_info.is_guild)
                        end

                        -- local SUCCESS = check_map_test(
                        --     page_info.is_guild and 469 or 90, 
                        --     page_info.is_guild and 556 or 0, 
                        --     page_info.is_guild and 851 or 500, 
                        --     page_info.is_guild and 20 or 0, 
                        --     3, 
                        --     page_info.name
                        -- )
                        
                        if SUCCESS then
                            -- 检查是否成功获取地图
                            local new_bag_info = api_Getinventorys(1, 0)
                            local new_count = 0
                            for _, item in ipairs(new_bag_info) do
                                if item.baseType_utf8 and string.find(item.baseType_utf8, "地圖鑰匙") then
                                    new_count = new_count + 1
                                end
                            end
                            
                            if new_count > bag_map_count then
                                env.is_have_map = true
                                env.current_storage_page_index = 1  -- 成功获取后重置索引
                                return bret.RUNNING
                            end
                        end
                    end
                end
                
                -- 当前页面检查完成，递增索引
                env.current_storage_page_index = i + 1
            end

            -- 所有仓库页尝试完成，重置索引
            env.current_storage_page_index = 1

            -- 所有仓库页尝试失败
            poe2_api.dbgp("所有仓库页尝试失败")
            env.take_map_times = (env.take_map_times or 0) + 1
            poe2_api.dbgp("entry_length_take_map-->", entry_length_take_map)
            poe2_api.dbgp("self.times-->", self.times)
            if env.take_map_times > 3 then
                env.take_map_times = 0
                if entry_length_take_map then
                    env.map_up = true
                else
                    poe2_api.dbgp("111111111")
                    env.map_up = false
                    env.is_shop = true
                end
            end
            poe2_api.dbgp("22222")
            env.is_have_map = false
            return bret.RUNNING

        end
    },

    -- 取地图
    Take_Map = {
        run = function(self, env)
            poe2_api.print_log("从仓库拿地图...")
            poe2_api.dbgp("开始执行取地图 - 环境变量:", env)
            
            local current_time = api_GetTickCount64()
            local bag_info = env.bag_info
            local user_map = env.user_map
            local current_map_info = env.current_map_info
            local not_use_map = env.not_use_map
            -- poe2_api.printTable(env.user_map)
            local config = env.user_config
            local need_synthesis = config["全局設置"]["刷图通用設置"]["自動合成地圖"]
            local player_info = env.player_info
            local entry_length_take_map = env.entry_length_take_map
            local map_update_to = env.map_update_to
            
            local full_map = (env.need_sale_map and env.map_page_full == "Map") or false

            -- 获取所有地图仓库页配置
            local storage_pages = {}
            for _, item in ipairs(poe2_api.get_items_config_info(config)) do
                if item["類型"] and item["類型"] == "地圖鑰匙" and item["存倉頁名"] then
                    table.insert(storage_pages, {
                        name = item["存倉頁名"],
                        is_guild = item["工會倉庫"] or false,
                        priority = item["優先級"] or 1  -- 默认优先级为1
                    })
                end
            end

            -- 按优先级排序仓库页
            table.sort(storage_pages, function(a, b) return a.priority > b.priority end)

            -- 检查仓库是否打开
            local function check_warehouse_opened(warehouse_type)
                local emphasize_text = poe2_api.find_text({UI_info = env.UI_info, text = "強調物品", min_x = 250, min_y = 700})
                local warehouse_text = poe2_api.find_text({UI_info = env.UI_info, text = warehouse_type, min_x=0, min_y=32, max_x=381, max_y=81})
                return emphasize_text and warehouse_text
            end

            -- 打开指定类型的仓库
            local function open_warehouse(is_guild)
                local warehouse_type = is_guild and "公會倉庫" or "倉庫"
                poe2_api.dbgp("尝试打开仓库:", warehouse_type)
                
                -- 先确保仓库界面已打开
                if not check_warehouse_opened(warehouse_type) then
                    if warehouse_type == "公會倉庫" then
                        env.warehouse_type_interactive = "公仓"
                    else
                        env.warehouse_type_interactive = "个仓"
                    end
                    poe2_api.dbgp("仓库界面未打开，返回FAIL进入其他节点")
                    return bret.FAIL  -- 返回FAIL让主逻辑可以进入其他节点处理
                end
                
                -- 检查当前仓库类型
                local current_type_text = poe2_api.find_text({UI_info = env.UI_info, text = "倉庫", min_x=0, min_y=32, max_x=381, max_y=81}) and "倉庫" or
                                        poe2_api.find_text({UI_info = env.UI_info, text = "公會倉庫", min_x=0, min_y=32, max_x=381, max_y=81}) and "公會倉庫" or nil
                
                -- 如果需要切换仓库类型
                if current_type_text ~= warehouse_type then
                    local switch_button = poe2_api.find_text({UI_info = env.UI_info, 
                        text = warehouse_type, 
                        min_x=0, min_y=32, max_x=381, max_y=81,
                        add_x = 250, 
                        click = 2
                    })
                    
                    if switch_button then
                        api_Sleep(1500)
                        return true
                    end
                    return false
                end
                return true
            end

            -- 切换到指定仓库页
            local function switch_to_storage_page(page_name, is_guild)
                poe2_api.dbgp("尝试切换到仓库页:", page_name, "类型:", is_guild and "公会" or "个人")
                
                -- 先确保打开正确的仓库类型
                if not open_warehouse(is_guild) then
                    return false
                end
                
                -- 检查标签列表是否展开
                local tab_list_button = poe2_api.click_text_UI({UI_info = env.UI_info, text = "tab_list_button", ret_data = true})
                
                if tab_list_button then
                    local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
                    -- poe2_api.printTable(lock)
                    -- api_Sleep()
                    local lock_button = {}
                    for _,v in ipairs(lock) do
                        if v.name_utf8 == "" and v.text_utf8 == "" then
                            table.insert(lock_button,v)
                        end
                    end
                    if not lock_button or not next(lock_button) then
                        api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                        api_Sleep(2000)
                        api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),1)
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    -- 已展开标签列表的情况
                    return poe2_api.find_text({UI_info = env.UI_info, 
                        text = page_name, 
                        max_y = 469, min_x = 556, min_y = 20, max_x = 851, 
                        click = 2
                    })
                else
                    -- 未展开标签列表的情况
                    return poe2_api.find_text({UI_info = env.UI_info, 
                        text = page_name, 
                        max_y = 90, min_x = 0, max_x = 500, min_y = 0, 
                        click = 2
                    })
                end
            end

            -- 检查背包中的地图
            local function check_map_in_bag(bag_info)
                local count = 0  -- 初始化计数器为0
                
                poe2_api.dbgp("检查背包中的地图 - 背包信息:", bag_info)
                
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        -- 查找包含“地圖鑰匙”的物品
                        if item.baseType_utf8 and string.find(item.baseType_utf8, "地圖鑰匙") then
                            count = count + 1  -- 找到则计数+1
                        end
                    end
                end
                
                poe2_api.dbgp("检查背包地图结果（数量）:", count)
                return count or 0  -- 直接返回数量，无匹配时自然为0
            end
            
            -- 检查相同地图是否超过3个
            local function check_same_map_over_3(bag_info)
                poe2_api.dbgp("检查相同地图是否超过3个 - 背包信息:", bag_info)
                
                local item_counts = {}
                if bag_info then
                    for _, actor in ipairs(bag_info) do
                        if actor.baseType_utf8 and string.find(actor.baseType_utf8, "地圖鑰匙") and not actor.contaminated and not actor.not_identified and actor.baseType_utf8 ~= "地圖鑰匙（階級 15）" and actor.baseType_utf8 ~= "地圖鑰匙（階級 16）" then
                            item_counts[actor.baseType_utf8] = (item_counts[actor.baseType_utf8] or 0) + 1
                        end
                    end
                else
                    poe2_api.dbgp("背包没有地图")
                    poe2_api.dbgp("检查相同地图结果:", false)
                    return false
                end
                
                -- 检查是否有至少3个相同的物品
                local synthesis_possible = false
                for _, count in pairs(item_counts) do
                    if count >= 3 then
                        synthesis_possible = true
                        break
                    end
                end
                
                poe2_api.dbgp("检查相同地图结果 - 物品计数:", item_counts, "是否可以合成:", synthesis_possible)
                return synthesis_possible
            end

            -- 统计所有名称包含"地圖鑰匙"的物品数量
            local function count_all_maps(bag_info)
                poe2_api.dbgp("开始统计所有地图钥匙数量 - 背包信息:", bag_info)
                
                local total_count = 0
                
                if bag_info then
                    for _, actor in ipairs(bag_info) do
                        if actor.baseType_utf8 and string.find(actor.baseType_utf8, "地圖鑰匙") then
                            total_count = total_count + 1
                        end
                    end
                end
                
                poe2_api.dbgp("地图钥匙总数:", total_count)
                return total_count
            end

            local function check_map_test(max_y, min_x, max_x, min_y, map_num, page, is_guild)
                -- 初始化变量
                local map_page = false
                local page_index = 0
                local user_map = env.user_map
                local not_use_map = env.not_use_map
                local map_update_to = env.map_update_to
                local need_synthesis = env.need_synthesis
                local bag_info = env.bag_info
                
                -- 调试输出初始参数
                poe2_api.dbgp("开始执行check_map_test - 参数:", 
                    "max_y" , max_y,
                    "min_x" , min_x,
                    "max_x" , max_x,
                    "min_y" , min_y,
                    "map_num" , map_num,
                    "page", page,
                    "is_guild", is_guild
                )
                
                -- 获取仓库页面
                local repositoryPages
                if is_guild then
                    repositoryPages = api_GetRepositoryPages(1)
                    poe2_api.dbgp("获取公会仓库页面 - 结果:", repositoryPages and #repositoryPages or 0)
                else
                    repositoryPages = api_GetRepositoryPages(0)
                    poe2_api.dbgp("获取普通仓库页面 - 结果:", repositoryPages and #repositoryPages or 0)
                end
                
                -- 检查是否为地图页
                if repositoryPages then
                    poe2_api.dbgp("开始检查仓库页面 - 总页数:", #repositoryPages)
                    for i, page_info in ipairs(repositoryPages) do
                        poe2_api.dbgp("检查页面#"..i.." - 名称:", page_info.name_utf8, "类型:", page_info.type)
                        if page_info.name_utf8 == page and page_info.type == 5 then
                            map_page = true
                            poe2_api.dbgp("找到匹配的地图页 - 索引:", i)
                            break
                        end
                    end
                end
                
                -- 选择最佳地图
                local best_map = poe2_api.select_best_map_key({
                    inventory = bag_info,
                    key_level_threshold = user_map,
                    not_use_map = not_use_map,
                    entry_length = map_update_to
                })
                poe2_api.dbgp("选择最佳地图 - 结果:", best_map ~= nil)
                
                
                -- 处理地图页
                if map_page then
                    poe2_api.dbgp("开始处理地图页 - 页面名称:", page)

                    if poe2_api.find_text({UI_info = env.UI_info, 
                        text = page,
                        max_y = max_y,
                        min_x = min_x,
                        max_x = max_x,
                        min_y = min_y,
                        click = 2
                    }) then
                        api_Sleep(500)
                    end
                    
                    -- 初始化颜色和等级列表
                    local white, blue, gold, valls, level = {}, {}, {}, {}, {}
                    if user_map then
                        poe2_api.dbgp("开始解析用户地图配置 - 配置数量:", #user_map)
                        for _, config in ipairs(user_map) do
                            local levels = tonumber(config["階級"]) or 0
                            table.insert(level, levels)
                            
                            poe2_api.dbgp("配置项 - 等级:", levels, 
                                         "白图:", config["白"], 
                                         "蓝图:", config["藍"], 
                                         "黄图:", config["黃"], 
                                         "污染:", config["已污染"])
                            
                            if config["白"] and not poe2_api.table_contains(white, levels) then
                                table.insert(white, levels)
                            end
                            if config["藍"] and not poe2_api.table_contains(blue, levels) then
                                table.insert(blue, levels)
                            end
                            if config["黃"] and not poe2_api.table_contains(gold, levels) then
                                table.insert(gold, levels)
                            end
                            if config["已污染"] and not poe2_api.table_contains(valls, levels) then
                                table.insert(valls, levels)
                            end
                        end
                    end
                    
                    -- 罗马数字映射
                    local ROMAN_NUMERALS = {
                        [1] = "I", [2] = "II", [3] = "III", [4] = "IV", [5] = "V",
                        [6] = "VI", [7] = "VII", [8] = "VIII", [9] = "IX", [10] = "X",
                        [11] = "XI", [12] = "XII", [13] = "XIII", [14] = "XIV", [15] = "XV", [16] = "XVI"
                    }
                    
                    local the_maps_num = 0
                    local click_positions = {152, 202, 252, 302, 352, 402}
                    
                    -- 按等级降序查找
                    table.sort(level, function(a, b) return a > b end)
                    poe2_api.dbgp("排序后的等级列表 - 内容:", table.concat(level, ","))
                    
                    for _, num in ipairs(level) do
                        poe2_api.dbgp("处理等级 - 当前等级:", num)
                        if num >= 1 and num <= 16 then
                            local roman_num = ROMAN_NUMERALS[num]
                            poe2_api.dbgp("转换罗马数字 - 数字:", num, "罗马数字:", roman_num)
                            
                            local a = poe2_api.find_text({UI_info = env.UI_info, 
                                refresh = true,
                                text = roman_num,
                                max_y = 242,
                                min_x = 0,
                                max_x = 544,
                                min_y = 0,
                                position = 1
                            })
                            
                            if a then
                                poe2_api.dbgp("找到罗马数字 - 位置X:", a[1], "位置Y:", a[2])
                                
                                local min_x = a[1] - 48
                                local min_y = a[2] - 48
                                local max_x = a[1] + 48
                                local max_y = a[2] + 48
                                
                                the_maps_num = poe2_api.find_text_position({UI_info = env.UI_info, 
                                    refresh = true,
                                    min_x = min_x,
                                    min_y = min_y,
                                    max_x = max_x,
                                    max_y = max_y,
                                    lens = 0
                                })
                                -- api_Sleep(100000)
                                -- poe2_api.dbgp("the_maps_num: ",the_maps_num)
                                the_maps_num = tonumber(the_maps_num) or 0
                                poe2_api.dbgp("地图数量检测 - 数量:", the_maps_num)
                                
                                if the_maps_num == 0 then
                                    poe2_api.dbgp("跳过空地图 - 罗马数字:", roman_num)
                                    goto continue
                                end
                                
                                if poe2_api.find_text({UI_info = env.UI_info, 
                                    refresh = true,
                                    text = roman_num,
                                    max_y = 242,
                                    min_x = 0,
                                    max_x = 544,
                                    min_y = 0,
                                    click = 2
                                }) then
                                    api_Sleep(1000)
                                    -- poe2_api.dbgp("==================================")
                                    map_table = api_GetMapRepositoryItems(19,305,545,640)
                                    -- poe2_api.printTable(map_table)
                                    -- poe2_api.dbgp("==================================")
                                    
                                    local c = poe2_api.select_best_map_key({
                                        inventory = map_table,
                                        key_level_threshold = user_map,
                                        not_use_map = not_use_map,
                                        entry_length = map_update_to
                                    })

                                    poe2_api.printTable(c)

                                    if c then
                                        local map_x = (c.RectSart_x + c.RectEnd_x) / 2
                                        local map_y = (c.RectSart_y + c.RectEnd_y) / 2
                                        -- poe2_api.dbgp("准备点击地图 - X坐标:", map_x, "Y坐标:", map_y)
                                        -- poe2_api.dbgp("准备点击地图 - X坐标:", poe2_api.toInt(map_x), "Y坐标:", poe2_api.toInt(map_y))
                                        poe2_api.click_position(map_x, map_y, 1)
                                        -- poe2_api.dbgp("找到匹配的地图 - 数量:", c)
                                    end

                                    -- api_Sleep(5000)

                                    local b = poe2_api.select_best_map_key({
                                        inventory = api_Getinventorys(1, 0),
                                        key_level_threshold = user_map,
                                        not_use_map = not_use_map,
                                        entry_length = map_update_to
                                    })
                                    poe2_api.dbgp("背包地图检查 - 最佳地图:", b ~= nil)

                                    if full_map then
                                        if not poe2_api.get_space_point({width = 1, height = 1}) then
                                            poe2_api.dbgp("满地图 - 返回成功")
                                            return true
                                        end
                                    else
                                        if map_num then
                                            local current_map_count = check_map_in_bag(api_Getinventorys(1, 0))
                                            poe2_api.dbgp("地图数量验证 - 当前:", current_map_count, "需要:", map_num + 3)
                                            
                                            if current_map_count >= map_num + 3 and b then
                                                poe2_api.dbgp("满足地图数量要求 - 返回成功")
                                                return true
                                            end
                                        end
                                    end
                                    
                                    if c == 0 then
                                        poe2_api.dbgp("开始尝试点击不同位置 - 位置列表:", table.concat(click_positions, ","))
                                        
                                        for _, k in ipairs(click_positions) do
                                            poe2_api.dbgp("尝试位置 - X坐标:", k)
                                            local b = poe2_api.select_best_map_key({
                                                inventory = api_Getinventorys(1, 0),
                                                key_level_threshold = user_map,
                                                not_use_map = not_use_map,
                                                entry_length = map_update_to
                                            })
                                            
                                            if map_num then
                                                local map_num1 = check_map_in_bag(api_Getinventorys(1, 0))
                                                poe2_api.dbgp("地图数量检查 - 当前:", map_num1, "需要:", map_num)
                                                
                                                if map_num1 >= map_num and b then
                                                    poe2_api.dbgp("满足最低数量要求 - 返回成功")
                                                    return true
                                                end
                                            end
                                            
                                            api_ClickScreen(k, 258, 1)
                                            api_Sleep(1000)
    
                                            c = poe2_api.find_text_position({UI_info = env.UI_info, 
                                                refresh = true,
                                                min_x = 13,
                                                min_y = 263,
                                                max_x = 544,
                                                max_y = 622,
                                                num = 1,
                                                text = roman_num,
                                                click_times = 2,
                                                lens = 0
                                            })
                                            poe2_api.dbgp("点击后查找结果 - 找到数量:", c)
                                            
                                            if c then
                                                poe2_api.dbgp("位置点击成功 - 返回成功")
                                                return true
                                            end

                                        end
                                        goto continue
                                    end
                                    
                                    poe2_api.dbgp("成功点击罗马数字 ", roman_num, " (对应等级 ", num, ")")
                                    return true
                                end
                            else
                                poe2_api.dbgp("未找到罗马数字 - 跳过")
                            end
                        else
                            poe2_api.dbgp("无效等级 - 跳过")
                        end
                        ::continue::
                    end
                    return false
                end
                
                -- 非地图页处理
                poe2_api.dbgp("开始处理非地图页 - 页面名称:", page)
                
                if poe2_api.find_text({UI_info = env.UI_info, 
                    refresh = true,
                    text = page,
                    max_y = max_y,
                    min_x = min_x,
                    max_x = max_x,
                    min_y = min_y,
                    click = 2
                }) then
                    api_Sleep(1000)
                    
                    -- 获取页面索引
                    local page_index = 0
                    for _, page_info in ipairs(repositoryPages) do
                        if page_info.name_utf8 == page and page_info.type ~= 5 then
                            page_index = page_info.manage_index
                            break
                        end
                    end
                    poe2_api.dbgp("获取页面索引 - 结果:", page_index)
                    
                    -- 获取仓库物品
                    local items
                    if text == "公會倉庫" then
                        items = api_Getinventorys(page_index, 2)
                        poe2_api.dbgp("获取公会仓库物品 - 数量:", items and #items or 0)
                    else
                        items = api_Getinventorys(page_index, 0)
                        poe2_api.dbgp("获取普通仓库物品 - 数量:", items and #items or 0)
                    end
                    
                    -- 检查是否可以合成
                    local can_synthesize = check_same_map_over_3(items)
                    poe2_api.dbgp("合成检查 - 是否可以合成:", can_synthesize, "需要合成:", need_synthesis)
                 
                    -- 如果不需要合成或地图数量足够
                    if full_map then
                        poe2_api.dbgp("满地图处理 - 开始处理")
                        local all_map_nums = count_all_maps(items)

                        if not poe2_api.get_space_point({width = 1, height = 1}) then
                            poe2_api.dbgp("满地图 - 返回成功")
                            return true
                        end
                        -- 从仓库取地图
                        poe2_api.dbgp("开始从仓库取地图")
                        for i = 1, math.floor(all_map_nums * 0.6) do
                            -- print("循环执行第 ", i, " 次")
                            -- 获取仓库物品
                            local items
                            if text == "公會倉庫" then
                                items = api_Getinventorys(page_index, 2)
                                poe2_api.dbgp("获取公会仓库物品 - 数量:", items and #items or 0)
                            else
                                items = api_Getinventorys(page_index, 0)
                                poe2_api.dbgp("获取普通仓库物品 - 数量:", items and #items or 0)
                            end

                            local select_result = poe2_api.select_best_map_key({
                                inventory = items,
                                click = 1,
                                type = 1,
                                not_use_map = not_use_map,
                                entry_length = map_update_to,
                                trash_map = full_map
                            })
                            poe2_api.dbgp("选择地图结果:", select_result ~= nil)
                            
                            if not poe2_api.get_space_point({width = 1, height = 1}) or not select_result then
                                poe2_api.dbgp("满地图 - 返回成功")
                                return true
                            end
                            api_Sleep(100)
                        end
                    else
                        if not (need_synthesis and can_synthesize) then
                            if map_num then
                                local bag_count = check_map_in_bag(api_Getinventorys(1, 0))
                                poe2_api.dbgp("背包地图检查 - 当前数量:", bag_count, "需要数量:", map_num)
                                
                                if bag_count and bag_count > map_num and best_map then
                                    env.entry_length_take_map = false
                                    poe2_api.dbgp("满足数量要求 - 返回成功")
                                    return true
                                end
                            end
                        end
                        -- 从仓库取地图
                        poe2_api.dbgp("开始从仓库取地图")
                        local select_result = poe2_api.select_best_map_key({
                            inventory = items,
                            click = 1,
                            key_level_threshold = user_map,
                            type = 1,
                            not_use_map = not_use_map,
                            entry_length = map_update_to,
                        })
                        poe2_api.dbgp("选择地图结果:", select_result ~= nil)
                        
                        if map_num then
                            local bag_count = check_map_in_bag(api_Getinventorys(1, 0))
                            poe2_api.dbgp("最终检查 - 当前数量:", bag_count, "需要数量:", map_num)
                            if bag_count > map_num and best_map then
                                poe2_api.dbgp("满足最终数量要求 - 返回成功")
                                return true
                            end
                        end
                    end
                    
                    
                    
                end
                
                env.is_need_strengthen = false
                poe2_api.dbgp("所有检查未通过 - 返回失败")
                return false
            end


            -- 主逻辑
            if not current_map_info or not player_info then
                poe2_api.dbgp("缺失必要数据 - 当前地图信息副本:", current_map_info, "玩家信息:", player_info)
                return bret.RUNNING
            end

            -- 检查背包地图数量
            local bag_map_count = 0
            if bag_info then
                for _, item in ipairs(bag_info) do
                    if item.baseType_utf8 and string.find(item.baseType_utf8, "地圖鑰匙") then
                        bag_map_count = bag_map_count + 1
                    end
                end
            end

            -- 选择最佳地图
            local best_map = poe2_api.select_best_map_key({
                inventory = bag_info,
                key_level_threshold = user_map,
                not_use_map = not_use_map,
                entry_length = map_update_to
            })

            -- 如果背包已有足够地图且不需要强化
            if bag_map_count >= 2 and best_map and not env.is_need_strengthen and not full_map then
                env.is_have_map = true
                return bret.RUNNING
            end

            -- 在env中初始化或获取当前检查的仓库页索引
            env.current_storage_page_index = env.current_storage_page_index or 1

            -- 获取仓库标签按钮
            local tab_list_button = poe2_api.click_text_UI({UI_info = env.UI_info, text = "tab_list_button",ret_data = true})

            poe2_api.dbgp("tab_list_button:", tostring(tab_list_button))

            -- 按优先级尝试各个仓库页
            for i = env.current_storage_page_index, #storage_pages do
                local page_info = storage_pages[i]
                poe2_api.dbgp("尝试从仓库页获取地图:", page_info.name, "类型:", page_info.is_guild and "公会" or "个人", "当前索引:", i)
                
                -- 切换到目标仓库页
                local warehouse_result = open_warehouse(page_info.is_guild)
                poe2_api.dbgp("warehouse_result: ----===>>>>", warehouse_result)

                if warehouse_result == bret.FAIL then
                    -- 仓库未打开，设置标志并返回，保存当前索引
                    env.need_open_warehouse = true
                    env.target_warehouse_type = page_info.is_guild and "公会" or "个人"
                    env.current_storage_page_index = i  -- 保存当前索引以便下次继续
                    return bret.FAIL

                elseif warehouse_result then
                    -- 仓库已打开，继续切换到具体页面
                    if switch_to_storage_page(page_info.name, page_info.is_guild) then
                        api_Sleep(1500)
                        
                        -- 获取仓库物品
                        local repositoryPages = api_GetRepositoryPages(page_info.is_guild and 1 or 0)
                        local page_index = 0
                        for _, page in ipairs(repositoryPages) do
                            if page.name_utf8 == page_info.name then
                                page_index = page.manage_index
                                break
                            end
                        end
                        
                        local items = api_Getinventorys(page_index, page_info.is_guild and 2 or 0)
                        
                        -- 尝试从仓库取地图
                        if tab_list_button then
                            local SUCCESS = check_map_test(469, 556, 851, 20, 2, page_info.name, page_info.is_guild)
                        else
                            poe2_api.dbgp("未展开标签列表的情况")
                            local SUCCESS = check_map_test(90, 0, 500, 0, 2, page_info.name, page_info.is_guild)
                        end

                        -- local SUCCESS = check_map_test(
                        --     page_info.is_guild and 469 or 90, 
                        --     page_info.is_guild and 556 or 0, 
                        --     page_info.is_guild and 851 or 500, 
                        --     page_info.is_guild and 20 or 0, 
                        --     3, 
                        --     page_info.name
                        -- )
                        
                        if SUCCESS then
                            -- 检查是否成功获取地图
                            local new_bag_info = api_Getinventorys(1, 0)
                            local new_count = 0
                            for _, item in ipairs(new_bag_info) do
                                if item.baseType_utf8 and string.find(item.baseType_utf8, "地圖鑰匙") then
                                    new_count = new_count + 1
                                end
                            end
                            
                            if new_count > bag_map_count then
                                env.is_have_map = true
                                env.current_storage_page_index = 1  -- 成功获取后重置索引
                                return bret.RUNNING
                            end
                        end
                    end
                end
                
                -- 当前页面检查完成，递增索引
                env.current_storage_page_index = i + 1
            end

            -- 所有仓库页尝试完成，重置索引
            env.current_storage_page_index = 1

            -- 所有仓库页尝试失败
            poe2_api.dbgp("所有仓库页尝试失败")
            env.take_map_times = (env.take_map_times or 0) + 1
            poe2_api.dbgp("entry_length_take_map-->", entry_length_take_map)
            poe2_api.dbgp("self.times-->", self.times)
            if env.take_map_times > 3 then
                env.take_map_times = 0
                if entry_length_take_map then
                    env.map_up = true
                else
                    poe2_api.dbgp("111111111")
                    env.map_up = false
                    env.is_shop = true
                end
            end
            poe2_api.dbgp("22222")
            env.is_have_map = false
            return bret.RUNNING

        end
    },

    -- 物品丢弃
    StackableCurrency_Discard = {
        run = function(self, env)
            poe2_api.print_log("物品丢弃...")
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.item_name = nil
                self.index = 0
                self.bool = true
            end
            local config = env.user_config
            local is_decompose = config['全局設置']["刷图通用設置"]["是否分解暗金"] or false
            local altar_shop_config = config['刷圖設置']["祭祀購買"]
            -- local range_info = env.range_info
            local player_info = env.player_info
            local bag_info = env.bag_info
           
            local processed_configs = poe2_api.get_items_config_info(config)
            local Attachments = api_Getinventorys(0xd,0)
            -- 背包和附着物为空
            if (not bag_info or not next(bag_info)) and (not Attachments or not next(Attachments)) then
                poe2_api.dbgp("背包和附着物为空,不丢弃")
                poe2_api.time_p("物品丢弃（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS 
            end
            -- 是否需要丢弃
            local function get_not_item(items)
                local function is_props(bag)
                    local text_list = {"知識之書","知識之結晶核心"}
                    -- for _, i in ipairs(bag) do
                        -- poe2_api.dbgp("i.baseType_utf8:",i.baseType_utf8)
                        -- poe2_api.dbgp("i.category_utf8:",i.category_utf8)
                        -- poe2_api.dbgp("i.color:","----------------------------------")
                        if bag.category_utf8 == "QuestItem" then
                            for _, v in ipairs(text_list) do
                                if string.find(bag.baseType_utf8,v) then
                                    return true
                                end
                                
                            end
                        end
                    -- end
                    return false
                end
                local function get_not(item)
                    local props = is_props(item)
                    if props then
                        return false
                    end
                    if poe2_api.is_do_without_pick_up(item,processed_configs) then
                        return true
                    end
                    for _, cfg in ipairs(processed_configs) do
                        if poe2_api.match_item(item,cfg) then
                            if cfg["不撿"] then
                                if poe2_api.table_contains(item.baseType_utf8,altar_shop_config) then
                                    return false
                                end
                                if is_decompose and type(is_decompose)~="table" then
                                    if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                        return false
                                        
                                    end
                                end
                                return true
                            end
                            if item.baseType_utf8 == "知識卷軸" then
                                local number = 0
                                for _, v in ipairs(items) do
                                    if v.baseType_utf8 == "知識卷軸" then
                                        number = number + v.stackCount
                                    end
                                end
                                if number > 80 then
                                    return true
                                end
                            end
                            local item_entry = cfg["物品詞綴"] or {}
                            if item_entry and next(item_entry) then
                                local function get_cfg_entry(entry_list)
                                    for k, v in pairs(entry_list) do
                                        if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                            if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                return true
                                            end
                                        end
                                    end
                                    return false
                                end
                                if get_cfg_entry(item_entry) then
                                    if poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) and not item.not_identified then
                                        local suffixes = api_GetObjectSuffix(item.mods_obj)
                                        if not suffixes or #suffixes == 0 then
                                            return {item}
                                        end
                                        if not poe2_api.filter_item(item,suffixes,config["物品過濾"]) then
                                            if is_decompose and type(is_decompose)~="table" then
                                                if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                                    return false
                                                end
                                            end
                                            return true
                                        end
                                    end
                                end
                            end
                            return false
                        end
                        if is_decompose and type(is_decompose)~="table" then
                            if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                return false
                            end
                        end
                    end
                    if poe2_api.table_contains(item.baseType_utf8,altar_shop_config) then
                        return false
                    end
                    return true
                end
                if not items or not next(items) then
                    return false
                end
                for _, item in ipairs(items) do
                    local is_dis = get_not(item)
                    if is_dis then
                        if type(is_dis) == "table" then
                            return is_dis
                        end
                        if item.baseType_utf8 == "知識卷軸" then
                            local mininumber = nil
                            local miniobj = nil
                            for _, v in ipairs(items) do
                                if v.baseType_utf8 == "知識卷軸" then
                                    if not mininumber or mininumber > v.stackCount then
                                        miniobj = v
                                        mininumber = v.stackCount
                                    end
                                end
                            end
                            env.discard_item = miniobj
                            return true
                        end
                        env.discard_item = item
                        return true
                    end
                end
                return false
            end
            -- 找黑雾祭坛
            local function get_altar(range_info)
                if not range_info or not next(range_info) then
                    return false
                end
                for _, i in ipairs(range_info) do
                    if i.path_name_utf8 and i.path_name_utf8 ~= "" and string.find("Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable",i.path_name_utf8) then
                        -- local stateMachineList = i:GetStateMachineList()
                        if i.stateMachineList and next(i.stateMachineList) then
                            local current_state = (i.stateMachineList or {}).current_state or 5
                            local interaction_enabled = (i.stateMachineList or {}).interaction_enabled or 5
                            if current_state == 2 and interaction_enabled == 0 then
                                return i
                            end
                        end
                        
                    end
                end
                return false
            end
            -- 判断自身一定范围内是否有激活怪
            local function get_monster(range_info,mate,distance)
                if not range_info or not next(range_info) then
                    return false
                end
                for _, v in ipairs(range_info) do
                    if v.type == 1 and not v.is_friendly and v.life > 0
                     and not poe2_api.table_contains(v.name_utf8,my_game_info.not_attact_mons_CN_name)
                     and v.isActive and not string.find(v.name_utf8,"神殿") and v.is_selectable then
                        local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                        if dis and dis < distance then
                            return true
                        end
                    end
                end
                return false
            end
            local is_not_item = get_not_item(bag_info)
            -- 没有要丢弃物品和附着物为空
            if not is_not_item and (not Attachments or not next(Attachments)) then
                poe2_api.dbgp("没有要丢弃物品和附着物为空,不丢弃")
                poe2_api.time_p("物品丢弃（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local is_altar = get_altar(env.range_info)
            if is_altar then
                local dis = poe2_api.point_distance(is_altar.grid_x, is_altar.grid_y,player_info)
                if dis and dis < 105 then
                    poe2_api.dbgp("在黑屋祭坛,不丢弃")
                    poe2_api.time_p("物品丢弃（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
            end
            local mon = get_monster(env.range_info,player_info,100)
            if mon then
                poe2_api.dbgp("在怪附近,不丢弃")
                poe2_api.time_p("物品丢弃（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if player_info.isInDangerArea then
                poe2_api.dbgp("玩家是否在危险区域:", player_info.isInDangerArea)
                local point = api_GetSafeAreaLocation(player_info.grid_x, player_info.grid_y, 60, 10, 0, 0.5)
                if point then
                    api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),poe2_api.toInt(player_info.world_z-70),7)
                    api_Sleep(100)
                    poe2_api.dbgp1("+++++++++++++++++++++++++++++++++++++++++++++++")
                    poe2_api.click_keyboard("space")
                    poe2_api.time_p("物品丢弃（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            if type(is_not_item) == "table" then
                if not poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                    poe2_api.click_keyboard("i")
                    api_Sleep(300)
                    poe2_api.dbgp("开背包,刷新词条")
                    poe2_api.time_p("物品丢弃（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local point = poe2_api.get_center_position({is_not_item[1].start_x,is_not_item[1].start_y},{is_not_item[1].end_x,is_not_item[1].end_y})
                if point and next(point) then
                    api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                    poe2_api.time_p("物品丢弃（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            if not Attachments or not next(Attachments) then
                if not bag_info or not next(bag_info) then
                    env.discard_item = nil
                    poe2_api.time_p("物品丢弃（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local obj = nil
                for _, v in ipairs(bag_info) do
                    if v.obj == env.discard_item.obj then
                        obj = v
                    end
                end
                if not obj then
                    env.discard_item = nil
                    poe2_api.time_p("物品丢弃（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if not poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                    poe2_api.click_keyboard("i")
                    api_Sleep(300)
                    poe2_api.dbgp("开背包,丢弃1")
                    poe2_api.time_p("物品丢弃（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local point = poe2_api.get_center_position({env.discard_item.start_x,env.discard_item.start_y},{env.discard_item.end_x,env.discard_item.end_y})
                api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                api_Sleep(500)
                poe2_api.time_p("物品丢弃（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            else
                local index_list ={2,3,4,5,6,7,8,9,0xa,0xb}
                local point_list = {
                    [2] = {1320,250},
                    [3] = {1151,191},
                    [4] = {1493,191},
                    [5] = {1322,133},
                    [6] = {1410,201},
                    [7] = {1237,255},
                    [8] = {1410,255},
                    [9] = {1213,330},
                    [0xa] = {1431,330},
                    [0xb] = {1322,353},
                }
                local point = nil
                for _, v in ipairs(index_list) do
                    if poe2_api.table_contains(v,{10,11}) then
                        v = string.format("0x%x", v)
                    end
                    local item = env["item"..v]
                    if item and next(item) then
                        if Attachments[1].baseType_utf8 == item[1].baseType_utf8 
                        and Attachments[1].DemandStrength == item[1].DemandStrength
                        and Attachments[1].DemandAgility == item[1].DemandAgility
                        and Attachments[1].DemandWisdom == item[1].DemandWisdom
                        and Attachments[1].DemandLevel == item[1].DemandLevel
                        and Attachments[1].not_identified == item[1].not_identified
                        and Attachments[1].category_utf8 == item[1].category_utf8
                        and Attachments[1].color == item[1].color then
                            local current_item = api_Getinventorys(v,0)
                            if current_item and next(current_item) then
                                if current_item[1].baseType_utf8 == item[1].baseType_utf8 
                                and current_item[1].DemandStrength == item[1].DemandStrength
                                and current_item[1].DemandAgility == item[1].DemandAgility
                                and current_item[1].DemandWisdom == item[1].DemandWisdom
                                and current_item[1].DemandLevel == item[1].DemandLevel
                                and current_item[1].not_identified == item[1].not_identified
                                and current_item[1].category_utf8 == item[1].category_utf8
                                and current_item[1].color == item[1].color then
                                else
                                    point = point_list[v]
                                    break
                                end
                            else
                                point = point_list[v]
                                break
                            end
                        end
                    end
                end
                if point then
                    if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                        api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                        api_Sleep(100)
                        poe2_api.time_p("物品丢弃（RUNNING8）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    else
                        poe2_api.dbgp("开背包,丢弃2")
                        poe2_api.click_keyboard("i")
                        api_Sleep(300)
                        poe2_api.time_p("物品丢弃（RUNNING9）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                else     
                    -- 先设置随机种子（只需执行一次）
                    math.randomseed(os.time())
                    -- 生成 [20, 450) 范围内的随机浮点数
                    local x = 20 + (450 - 20) * math.random()
                    -- 生成 [50, 500) 范围内的随机浮点数
                    local y = 50 + (500 - 50) * math.random()
                    api_ClickScreen(poe2_api.toInt(x),poe2_api.toInt(y),1)
                    api_Sleep(200)
                    if not self.item_name then
                        self.item_name = Attachments[1].baseType_utf8
                    end
                    if self.item_name ~= Attachments[1].baseType_utf8 then
                        self.item_name = Attachments[1].baseType_utf8
                    else
                        self.index = self.index + 1
                    end
                    if self.index > 8 then
                        if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                            poe2_api.click_keyboard("i")
                            poe2_api.dbgp("关背包6")
                            api_Sleep(300)
                        end
                        local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),50)
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),poe2_api.toInt(player_info.world_z),1)
                            api_Sleep(200)
                            poe2_api.dbgp1("rsdgjtgjasdvzxbfdhfsdh")
                            poe2_api.click_keyboard("space")
                            self.index = 0
                        end
                    end
                    poe2_api.time_p("物品丢弃（RUNNING10）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            poe2_api.time_p("物品丢弃（RUNNING11）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.RUNNING
        end
    },

    -- 鉴定指定装备
    Identify_designated_equipment = {
        run = function(self, env)
            poe2_api.print_log("鉴定指定装备...") 
            local player_info = env.player_info
            local attack_dis_map = env.map_level_dis
            local stuck_monsters = env.stuck_monsters
            local not_attack_mos = env.not_attack_mos
            local config = env.user_config

            if self.need_identify_in_map == nil then
                self.need_identify_in_map = config["全局設置"]["刷图通用設置"]["是否图内鉴定"]
                return bret.RUNNING
            end

            if not self.need_identify_in_map then
                return bret.SUCCESS
            end

            local config_name = env.item_config_name
            local config_type = env.item_config_type

            poe2_api.dbgp(string.format("当前地图: %s, 危险区域: %s", 
                player_info.current_map_name_utf8 or "未知", 
                tostring(player_info.isInDangerArea)))
            
            if poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout) then
                return bret.SUCCESS
            end

            -- poe2_api.dbgp("====== 开始装备鉴定流程 ======")

            -- 创建反向字典
            local reverse_type_conversion = {}
            for k, v in pairs(my_game_info.type_conversion) do
                reverse_type_conversion[v] = k
                -- poe2_api.dbgp(string.format("类型转换表: %s -> %s", k, v))
            end

            local function convert_key(key)
                local converted = my_game_info.type_conversion[key] or reverse_type_conversion[key]
                -- poe2_api.dbgp(string.format("类型转换: %s -> %s", key, converted or "无对应转换"))
                return converted
            end

            local function convert_config_type(config_type_dict)
                if not config_type_dict then
                    poe2_api.dbgp("警告: 配置类型字典为空")
                    return {}
                end
                
                local converted_dict = {}
                poe2_api.dbgp("开始转换配置类型...")
                
                for chinese_type, info_list in pairs(config_type_dict) do
                    local english_type = my_game_info.type_conversion[chinese_type]
                    -- poe2_api.dbgp(string.format("处理类型: %s -> %s", chinese_type, english_type or "无对应英文"))
                    
                    if english_type then
                        -- 处理内嵌'類型'字段
                        if type(info_list) == "table" and info_list["類型"] then
                            poe2_api.dbgp("发现嵌套类型字段，开始处理...")
                            if type(info_list["類型"]) == "table" then
                                local converted_types = {}
                                for _, t in ipairs(info_list["類型"]) do
                                    local converted = my_game_info.type_conversion[t] or t
                                    table.insert(converted_types, converted)
                                    -- poe2_api.dbgp(string.format("转换嵌套类型: %s -> %s", t, converted))
                                end
                                info_list["類型"] = converted_types
                            else
                                local converted = my_game_info.type_conversion[info_list["類型"]] or info_list["類型"]
                                info_list["類型"] = {converted}
                                -- poe2_api.dbgp(string.format("转换单类型: %s -> %s", info_list["類型"], converted))
                            end
                        end
                        converted_dict[english_type] = info_list
                    else
                        poe2_api.dbgp(string.format("严重警告: 未找到类型 '%s' 的英文转换", chinese_type))
                    end
                end
                
                poe2_api.dbgp("配置类型转换完成")
                return converted_dict
            end

            -- 转换配置类型
            poe2_api.dbgp("开始转换主配置类型...")
            config_type = convert_config_type(config_type)
            -- poe2_api.dbgp(string.format("转换后配置类型条目数: %d", table.count(config_type)))

            if poe2_api.find_text({UI_info = env.UI_info, text = "繼續遊戲", click = 2}) then
                poe2_api.dbgp("城外鉴定: 发现'繼續遊戲'文本，点击处理中...")
                return bret.RUNNING
            end

            local appraisal_item_list = {}

            local function need_appraisal(bag_info)
                if not bag_info then
                    poe2_api.dbgp("城外鉴定: 背包信息为空")
                    return false
                end
                
                -- poe2_api.dbgp(string.format("开始检查背包物品，总数: %d", #bag_info))
                
                local function get_matched_config(bag)
                    -- 初始物品信息检查
                    -- poe2_api.dbgp("\n========== 开始物品匹配流程 ==========")
                    -- poe2_api.dbgp(string.format("[物品基本信息] 名称: %s | 类型: %s | 基础类型: %s | 颜色: %d", 
                    --     bag.name_utf8 or "nil", 
                    --     bag.category_utf8 or "nil", 
                    --     bag.baseType_utf8 or "nil", 
                    --     bag.color or -1))
                    
                    -- 检查config_type是否存在
                    if not config_type then
                        -- poe2_api.dbgp("[错误] config_type 配置表不存在！")
                        return nil
                    end
                
                    -- 1. 首先检查类型匹配
                    -- poe2_api.dbgp("\n=== 开始类型配置匹配 ===")
                    for config_name, item_config in pairs(config_type) do
                        -- poe2_api.dbgp(string.format("\n[检查配置组] 配置组名称: %s", config_name))
                        -- poe2_api.dbgp("[配置内容] %s", poe2_api.printTable(item_config))

                        for idx, item in ipairs(item_config) do
                            -- poe2_api.dbgp("\n[检查配置项] 序号: %d", idx)
                            -- poe2_api.dbgp("------------------------------------------------------------------------")
                            if type(item) ~= "table" then
                                -- poe2_api.dbgp("[警告] 配置项不是table类型，跳过")
                                goto continue
                            end
                
                            -- 类型检查
                            local item_type = item["類型"]
                            -- poe2_api.dbgp(string.format("[类型检查] 配置类型: %s | 物品类型: %s", 
                            --     poe2_api.printTable(item_type), 
                            --     bag.category_utf8 or "nil"))
                
                            -- 处理类型匹配
                            local type_match = false
                            if type(item_type) == "table" and #item_type > 0 then
                                type_match = (item_type[1] == convert_key(bag.category_utf8))
                            elseif type(item_type) == "string" then
                                type_match = (item_type == convert_key(bag.category_utf8))
                            else
                                -- poe2_api.dbgp("[警告] 配置类型格式无效")
                            end
                
                            if not type_match then
                                -- poe2_api.dbgp("-> 类型不匹配，跳过")
                                goto continue
                            end
                            -- poe2_api.dbgp("-> 类型匹配通过")
                
                            -- 基础类型检查
                            local base_type = item["基礎類型名"] or "nil"
                            -- poe2_api.dbgp(string.format("[基础类型检查] 配置基础类型: %s | 物品基础类型: %s", 
                            --     base_type, bag.baseType_utf8 or "nil"))
                
                            if bag.baseType_utf8 ~= base_type and base_type ~= "全部物品" and not string.find(base_type, bag.baseType_utf8) then
                                -- poe2_api.dbgp("-> 基础类型不匹配，跳过")
                                goto continue
                            end
                            poe2_api.dbgp("-> 基础类型匹配通过")
                
                            -- 品质检查
                            local quality_check = {
                                white = item["白裝"],
                                blue = item["藍裝"],
                                yellow = item["黃裝"],
                                unique = item["暗金"]
                            }
                            -- poe2_api.dbgp(string.format("[品质检查] 配置要求: 白=%s 蓝=%s 黄=%s 暗金=%s | 物品颜色: %d",
                            --     tostring(quality_check.white),
                            --     tostring(quality_check.blue),
                            --     tostring(quality_check.yellow),
                            --     tostring(quality_check.unique),
                            --     bag.color or -1))
                
                            local quality_ok = false
                            if bag.color == 0 and quality_check.white then
                                quality_ok = true
                            elseif bag.color == 1 and quality_check.blue then
                                quality_ok = true
                            elseif bag.color == 2 and quality_check.yellow then
                                quality_ok = true
                            -- elseif bag.color == 3 and quality_check.unique then
                            elseif bag.color == 3 then
                                quality_ok = true
                            end
                
                            if not quality_ok then
                                poe2_api.dbgp("-> 品质不匹配，跳过")
                                goto continue
                            end
                            poe2_api.dbgp("-> 品质检查通过")
                
                            -- 名称检查
                            if item["名稱"] then
                                -- poe2_api.dbgp(string.format("[名称检查] 配置名称: %s | 物品名称: %s",
                                --     item["名稱"], bag.name_utf8 or "nil"))
                                
                                if item["名稱"] == bag.name_utf8 then
                                    -- poe2_api.dbgp("-> 名称完全匹配，返回配置")
                                    -- poe2_api.dbgp("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item))
                                    return item
                                else
                                    -- poe2_api.dbgp("-> 名称不匹配，继续检查")
                                end
                            else
                                -- poe2_api.dbgp("[名称检查] 配置无名称要求，检查词缀")
                                
                                -- 词缀检查
                                if item["物品詞綴"] then
                                    poe2_api.dbgp("[词缀检查] 发现词缀配置")
                                    local affix_dict = item["物品詞綴"]
                                    
                                    if affix_dict and type(affix_dict) == "table" then
                                        for affix_name, v in pairs(affix_dict) do
                                            if type(v) == "table" and v["詞綴"] then
                                                -- poe2_api.dbgp(string.format("-> 发现有效词缀: %s", affix_name))
                                                -- poe2_api.dbgp(string.format("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item)))
                                                return item
                                            end
                                        end
                                    end
                                end
                            end
                
                            -- 如果前面都通过但没返回，检查基础类型名
                            -- poe2_api.dbgp("[最终检查] 基础类型名匹配检查")
                            if base_type == bag.baseType_utf8 or base_type == "全部物品" or string.find(item["基礎類型名"] , bag.baseType_utf8) then
                                -- poe2_api.dbgp("-> 基础类型名匹配，返回配置")
                                -- poe2_api.dbgp(string.format("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item)))
                                return item
                            end
                
                            ::continue::
                        end
                    end
                    
                    -- 2. 检查名称匹配
                    poe2_api.dbgp("\n=== 开始名称配置匹配 ===")
                    if not config_name then
                        poe2_api.dbgp("[警告] config_name 配置表不存在")
                    else
                        for config_name, item_config in pairs(config_name) do
                            -- poe2_api.dbgp(string.format("\n[检查名称配置组] %s", config_name))
                            
                            for idx, item in ipairs(item_config) do
                                -- poe2_api.dbgp(string.format("[检查配置项] 序号: %d", idx))
                                
                                if type(item) == "table" then
                                    -- poe2_api.dbgp(string.format("[基础类型比较] 配置: %s | 物品: %s",
                                    --     item["基礎類型名"] or "nil", bag.baseType_utf8 or "nil"))
                                    
                                    if item["基礎類型名"] == bag.baseType_utf8 or string.find(item["基礎類型名"] , bag.baseType_utf8) or item["名稱"] ~= "" or item["名稱"] ~= nil then
                                        poe2_api.dbgp("-> 基础类型匹配")
                                        
                                        local type_ok = true
                                        if item["類型"] and item["類型"][1] then
                                            type_ok = (item["類型"][1] == bag.category_utf8)
                                            -- poe2_api.dbgp(string.format("[类型比较] 配置: %s | 物品: %s | 结果: %s",
                                            --     item["類型"][1], bag.category_utf8 or "nil",
                                            --     type_ok and "匹配" or "不匹配"))
                                        end
                                        
                                        if type_ok then
                                            -- poe2_api.dbgp("-> 所有条件匹配，返回配置")
                                            return item
                                        end
                                    end
                                end
                            end
                        end
                    end
                
                    poe2_api.dbgp("\n[匹配结果] 未找到匹配配置")
                    return nil
                end

                local items_to_identify = {}
                poe2_api.dbgp("开始扫描背包物品...")
                
                for i, bag in ipairs(bag_info) do
                    -- poe2_api.dbgp(string.format("\n物品 %d/%d: %s (类型: %s, 基础类型: %s, 颜色: %d, 已鉴定: %s)", 
                    --     i, #bag_info, bag.name_utf8 or "无名", bag.category_utf8 or "无类型", 
                    --     bag.baseType_utf8 or "无基础类型", bag.color or -1, 
                    --     tostring(not bag.not_identified)))
                    
                    -- 基础条件：未鉴定、未污染、不在排除列表
                    if not (bag.not_identified and
                            not poe2_api.table_contains(my_game_info.not_need_identify, bag.category_utf8)) then
                        -- poe2_api.dbgp("物品已鉴定或在不需鉴定列表中，跳过")
                        goto continue_item
                    end
                    
                    -- 特殊类别直接加入鉴定列表
                    if poe2_api.table_contains({"Map", "TowerAugmentation"}, bag.category_utf8) then
                        poe2_api.dbgp("特殊类别物品，直接加入鉴定列表")
                        table.insert(items_to_identify, bag)
                        goto continue_item
                    end

                    -- 获取匹配的配置
                    poe2_api.dbgp("开始匹配配置...")
                    local matched_config = get_matched_config(bag)
                    
                    -- 检查物品詞綴配置
                    if matched_config and matched_config["物品詞綴"] or matched_config["名稱"] then
                        poe2_api.dbgp("找到匹配配置，检查词缀...")
                        local affix_dict = matched_config["物品詞綴"]
                        if matched_config["名稱"] ~= nil then
                            table.insert(items_to_identify, bag)
                            poe2_api.dbgp(string.format("发现有效名稱内容: %s", matched_config["名稱"]))
                        end
                        if affix_dict and type(affix_dict) == "table" then
                            local has_valid_affix = false
                            for affix_name, v in pairs(affix_dict) do
                                if type(v) == "table" and v["詞綴"] then
                                    poe2_api.dbgp(string.format("发现有效词缀: %s", affix_name))
                                    has_valid_affix = true
                                    break
                                end
                            end
                            
                            if has_valid_affix then
                                poe2_api.dbgp("物品有有效词缀或者名稱，加入鉴定列表")
                                table.insert(items_to_identify, bag)
                            else
                                poe2_api.dbgp("配置中无有效词缀，跳过")
                            end
                        end
                    else
                        poe2_api.dbgp("未找到匹配配置或配置无词缀要求")
                    end
                    ::continue_item::
                end

                if #items_to_identify > 0 then
                    poe2_api.dbgp(string.format("找到 %d 件需要鉴定的物品", #items_to_identify))
                    appraisal_item_list = items_to_identify
                    return items_to_identify
                end
                poe2_api.dbgp("未找到需要鉴定的物品")
                return false
            end

            poe2_api.dbgp("开始检查是否需要鉴定...")
            local bag_info = api_Getinventorys(1, 0)
            if not bag_info then
                poe2_api.dbgp("错误: 无法获取背包信息")
                return bret.SUCCESS
            end

            local items_to_identify = need_appraisal(bag_info)
            if not items_to_identify then
                poe2_api.dbgp("当前没有需要鉴定的物品")
                return bret.SUCCESS
            end

            poe2_api.dbgp(string.format("需要鉴定的物品数量: %d", #items_to_identify))
            
            if player_info.isInDangerArea then
                poe2_api.dbgp("警告: 玩家处于危险区域，暂停鉴定")
                return bret.SUCCESS
            end

            local has_monsters = poe2_api.is_have_mos({range_info = env.range_info, 
                player_info = player_info, 
                attack_dis_map = attack_dis_map, 
                stuck_monsters = stuck_monsters, 
                not_attack_mos = not_attack_mos,
                not_sight = true
            })
            
            if has_monsters then
                poe2_api.dbgp("警告: 周围有怪物，暂停鉴定")
                return bret.SUCCESS
            end

            local function use_items(bag_info, click)
                if not bag_info then 
                    poe2_api.dbgp("错误: use_items 传入的背包信息为空")
                    return false 
                end
                
                poe2_api.dbgp("开始查找知识卷轴...")
                for _, actor in ipairs(bag_info) do
                    if actor.baseType_utf8 == "知識卷軸" then
                        poe2_api.dbgp(string.format("找到知识卷轴，位置: %d,%d - %d,%d", 
                            actor.start_x, actor.start_y, actor.end_x, actor.end_y))
                        
                        if click == 1 then
                            -- 计算中心坐标
                            local start_cell = {actor.start_x, actor.start_y}
                            local end_cell = {actor.end_x, actor.end_y}
                            local center_position = poe2_api.get_center_position(start_cell, end_cell)
                            
                            poe2_api.dbgp(string.format("卷轴中心位置: %d, %d", center_position[1], center_position[2]))
                            
                            poe2_api.dbgp("点击卷轴...")
                            api_ClickScreen(center_position[1], center_position[2],0)
                            api_Sleep(200)
                            api_ClickScreen(center_position[1], center_position[2],2)
                            api_Sleep(500)
                        end
                        return true
                    end
                end
                poe2_api.dbgp("警告: 背包中没有找到知识卷轴")
                return false
            end

            poe2_api.dbgp("准备使用卷轴...")
            if not use_items(bag_info) then
                poe2_api.dbgp("错误: 无法使用知识卷轴")
                return bret.SUCCESS
            end

            -- 重新获取背包信息
            poe2_api.dbgp("重新获取背包信息...")
            bag_info = api_Getinventorys(1, 0)
            if not bag_info then
                poe2_api.dbgp("错误: 重新获取背包信息失败")
                return bret.SUCCESS
            end

            items_to_identify = need_appraisal(bag_info)
            if not items_to_identify then
                poe2_api.dbgp("重新检查后没有需要鉴定的物品")
                return bret.SUCCESS
            end

            if (poe2_api.is_have_mos({range_info = env.range_info, player_info = player_info}) and 
                (poe2_api.table_contains(my_game_info.hideout_CH, player_info.current_map_name_utf8) or 
                string.find(player_info.current_map_name_utf8, "town"))) then
                poe2_api.dbgp("警告: 安全区域发现怪物，暂停鉴定")
                return bret.SUCCESS
            end
            
            poe2_api.dbgp("开始鉴定物品...")
            for _, items in ipairs(bag_info) do
                for _, k in ipairs(items_to_identify) do
                    if items.obj == k.obj then
                        poe2_api.dbgp(string.format("鉴定物品: %s (类型: %s)", 
                            items.name_utf8 or "无名", items.category_utf8 or "无类型"))
                        
                        if not poe2_api.find_text({UI_info = env.UI_info, text = "背包", min_x = 1020, min_y = 32, max_x = 1600, max_y = 81}) then
                            poe2_api.dbgp("未检测到背包UI，尝试打开背包...")
                            poe2_api.click_keyboard("i")
                            api_Sleep(500)
                        end

                        use_items(bag_info, 1)
                        api_Sleep(500)
                        
                        -- 计算中心坐标
                        local start_cell = {items.start_x, items.start_y}
                        local end_cell = {items.end_x, items.end_y}
                        local center_position = poe2_api.get_center_position(start_cell, end_cell)
                        poe2_api.dbgp(string.format("物品中心位置: %d, %d", center_position[1], center_position[2]))

                        poe2_api.dbgp("左键点击物品...")
                        api_ClickScreen(center_position[1], center_position[2],0)
                        api_Sleep(200)
                        poe2_api.dbgp("右键点击物品...")
                        api_ClickScreen(center_position[1], center_position[2],1)
                        api_Sleep(200)
                        
                        poe2_api.dbgp("物品鉴定完成")
                        return bret.RUNNING
                    end
                end
            end

            poe2_api.dbgp("错误: 未找到匹配的需要鉴定的物品")
            return bret.SUCCESS
        end
    },

    -- 检查是否拾取
    Is_Pick_UP = {
        run = function(self, env)
            poe2_api.print_log("检查是否需要拾取...")
            local start_time = api_GetTickCount64()
            local current_time = api_GetTickCount64()
            if not self.bool then
                self.id1 = nil
                self.number = 0
                self.bool = true
                self.wait = false
                self.wait_time = 0
                self.currte_time = 0
            end
            local config = env.user_config
            local need_item = env.need_item
            local is_decompose = config["全局設置"]["刷图通用設置"]["是否分解暗金"] or false
            local altar_shop_config = config['刷圖設置']["祭祀購買"]
            local stuck_monsters = env.stuck_monsters
            -- local item_list = env.range_items
            local player_info = env.player_info
            -- local range_info = env.range_info
            local bag_info = env.bag_info
            -- local current_map_info = env.current_map_info
            if not next(player_info) then
                poe2_api.dbgp("人物信息为空")
                poe2_api.time_p("检查是否拾取（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local function is_props(bag)
                local text_list = {"知識之書","知識之結晶核心"}
                for _, i in ipairs(bag) do
                    if i.category_utf8 == "QuestItem" then
                        for _, v in ipairs(text_list) do
                            if string.match(i.baseType_utf8,v) then
                                return i
                            end
                            
                        end
                    end
                end
                return false
            end
            local function get_item(items,processed_configs)
                
                local sorted_items = poe2_api.get_sorted_list(items,player_info)
                if not sorted_items or not next(sorted_items) then
                    poe2_api.dbgp("数据有问题2222")
                    return false
                end
                -- for _, v in ipairs(sorted_items) do
                --     poe2_api.dbgp(v.name_utf8)
                --     poe2_api.dbgp(v.baseType_utf8)
                --     poe2_api.dbgp(v.category_utf8)
                --     poe2_api.dbgp(tostring(v.grid_x))
                --     poe2_api.dbgp(tostring(v.grid_y))
                --     poe2_api.dbgp(tostring("========================================"))
                -- end
                poe2_api.dbgp(tostring(#sorted_items))
                for _, item in ipairs(sorted_items) do
                    -- api_Sleep(5000)
                    -- poe2_api.dbgp(item.name_utf8)
                    -- poe2_api.dbgp(item.baseType_utf8)
                    -- poe2_api.dbgp(item.category_utf8)
                    -- poe2_api.dbgp(tostring(item.grid_x))
                    -- poe2_api.dbgp(tostring(item.grid_y))
                    -- poe2_api.dbgp(tostring("========================================"))
                    if item.grid_x ~= 0 and item.grid_y ~= 0 then
                        -- poe2_api.dbgp("cccccccccccccccccccccccccccccccccc")
                        if item.category_utf8 == "QuestItem" then
                            if is_props(items) then
                                env.interactive = item
                                env.need_item = item
                                return true
                            end
                        end
                        for _, cfg in ipairs(processed_configs) do
                            
                            if poe2_api.match_item(item,cfg) then
                                -- poe2_api.dbgp("999================================================")
                                if env.pick_up_timeout and next(env.pick_up_timeout) and poe2_api.table_contains(item.id,env.pick_up_timeout) then
                                    break
                                end
                                if not cfg['不撿'] then
                                    if poe2_api.is_do_without_pick_up(item,processed_configs) then
                                        break
                                    end
                                    local item_entry = cfg["物品詞綴"] or {}
                                    if item_entry and next(item_entry) then
                                        local function get_cfg_entry(entry_list)
                                            for k, v in pairs(entry_list) do
                                                if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                                    if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                        return true
                                                    end
                                                end
                                            end
                                            return false
                                        end
                                        if get_cfg_entry(item_entry) then
                                            if poe2_api.table_contains(item.category_utf8,my_game_info.equip_type)
                                             and not item.not_identified then
                                                local suffixes = api_GetObjectSuffix(item.mods_obj)
                                                if suffixes and next(suffixes) then
                                                    if not poe2_api.filter_item(item,suffixes,config["物品過濾"]) then
                                                        poe2_api.dbgp("词缀不符合*******************************************")
                                                        break
                                                    end
                                                else
                                                    poe2_api.dbgp("未找到物品词缀——————————————————————————————————————————————")
                                                    break
                                                end
                                                
                                            end
                                        end
                                    end
                                    if bag_info and next(bag_info) then
                                        if item.baseType_utf8 == "知識卷軸" then
                                            local number = 0
                                            for _, v in ipairs(bag_info) do
                                                if v.baseType_utf8 == "知識卷軸" then
                                                    number = number + v.stackCount
                                                end
                                            end
                                            if number >= 80 then
                                                break
                                            end
                                        end
                                    end
                                    local distance = poe2_api.point_distance(item.grid_x,item.grid_y,player_info)
                                    local function is_point(grid_x,grid_y)
                                        local point = api_FindNearestReachablePoint(math.floor(grid_x),math.floor(grid_y),15,0)
                                        local ralet = api_FindPath(player_info.grid_x,player_info.grid_y,math.floor(point.x),math.floor(point.y))
                                        return ralet
                                    end
                                    if distance and distance > 15 then
                                        local ralet = is_point(item.grid_x,item.grid_y)
                                        if not ralet or not next(ralet) then
                                            poe2_api.dbgp("无路径")
                                            break
                                        end
                                    end
                                    env.interactive = item
                                    env.need_item = item
                                    return true
                                end
                                break
                            end

                        end
                        if poe2_api.table_contains(item.baseType_utf8,altar_shop_config) then
                            -- poe2_api.dbgp("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk")
                            if env.pick_up_timeout and next(env.pick_up_timeout) and poe2_api.table_contains(item.id,env.pick_up_timeout) then
                                break
                            end
                            env.interactive = item
                            env.need_item = item
                            return true
                        end
                        if is_decompose then
                            -- poe2_api.dbgp("mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm")
                            if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                if env.pick_up_timeout and next(env.pick_up_timeout) and poe2_api.table_contains(item.id,env.pick_up_timeout) then
                                    -- poe2_api.dbgp("jjjjjjjjjjjjjjjjjjjjjjjjjjjjjj")
                                    break
                                end
                                env.interactive = item
                                env.need_item = item
                                -- poe2_api.dbgp("hhhhhhhhhhhhhhhhhhhhhh")
                                return true
                            end
                        end
                    end
                end
                return false
            end
            
            if (not env.range_items or not next(env.range_items)) and not env.need_item then
                poe2_api.dbgp("无物品可捡1")
                poe2_api.time_p("无物品可捡1(SUCCESS1)... 耗时 -->", api_GetTickCount64() - current_time )
                return bret.SUCCESS
            end
            local processed_configs = poe2_api.get_items_config_info(config)
            if not need_item then
                if not get_item(env.range_items,processed_configs) then
                    poe2_api.dbgp("无物品可捡2")
                    poe2_api.time_p("检查是否拾取（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
            end
            poe2_api.dbgp("1")
            -- 判断自身一定范围内是否有激活怪
            local function is_monster(range_info,mate,distance)
                if not range_info or not next(range_info) then
                    return false
                end
                if distance > env.min_attack_dis then
                    distance = env.min_attack_dis  
                end
                for _, v in ipairs(range_info) do
                    if v.type == 1 and not v.is_friendly and v.life > 0
                     and not poe2_api.table_contains(v.name_utf8,my_game_info.not_attact_mons_CN_name)
                     and v.isActive and not string.find(v.name_utf8,"神殿") and v.hasLineOfSight and v.is_selectable
                     and (not stuck_monsters or not next(stuck_monsters) or not stuck_monsters[v.id]) then
                        local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                        if dis and dis < distance then
                            return true
                        end
                    end
                end
                return false
            end
            local is_target = is_monster(env.range_info, player_info,50)
            if is_target then
                poe2_api.dbgp("附近有怪，不捡")
                poe2_api.time_p("检查是否拾取（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if self.wait then
                if api_GetTickCount64() - self.current_time < self.wait_time then
                    poe2_api.dbgp("等待中")
                    poe2_api.time_p("检查是否拾取（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                self.wait = false
            end
            poe2_api.dbgp("2")
            -- 找黑雾祭坛
            local function get_altar(range_info)
                if not range_info or not next(range_info) then
                    return false
                end
                for _, i in ipairs(range_info) do
                    if i.path_name_utf8 and i.path_name_utf8 ~= "" and string.find("Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable",i.path_name_utf8) then
                        -- local stateMachineList = i:GetStateMachineList()
                        if i.stateMachineList and next(i.stateMachineList) then
                            local current_state = (i.stateMachineList or {}).current_state or 5
                            local interaction_enabled = (i.stateMachineList or {}).interaction_enabled or 5
                            if current_state == 2 and interaction_enabled == 0 then
                                return i
                            end
                        end
                        
                    end
                end
                return false
            end
            need_item = env.need_item
            local is_altar = get_altar(env.range_info)
            if is_altar then
                local dis1 = poe2_api.point_distance(is_altar.grid_x, is_altar.grid_y, player_info)
                if dis1 and dis1 < 100 then
                    local dis2 = poe2_api.point_distance(need_item.grid_x, need_item.grid_y, is_altar)
                    if dis2 and dis2 > 97 then
                        poe2_api.dbgp("黑雾祭坛附近，不捡")
                        poe2_api.time_p("检查是否拾取（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.SUCCESS
                    end
                end
            end
            poe2_api.dbgp("3")
            -- 判断特殊交互对象
            local function get_interactive(range_info)
                if not range_info or not next(range_info) then
                    return false
                end
                for _, v in ipairs(range_info) do
                    if v.name_utf8 ~= "" and poe2_api.table_contains(v.name_utf8,{"開關","門","把手"}) and v.isActive and v.is_selectable
                     and v.grid_x ~= 0 and v.grid_y ~= 0 then
                        if poe2_api.table_contains(v.name_utf8,{"開關","把手"}) then
                            local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                            if dis and dis <= 70 then
                                return v
                            end
                        end
                        if v.name_utf8 == "門" then
                            local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                            if dis and dis <= 25 then
                                return v
                            end
                        end
                        
                    end
                end
                return false
            end
            local is_interactive = get_interactive(env.range_info)
            if is_interactive then
                poe2_api.dbgp("特殊交互对象，不捡:  "..is_interactive.name_utf8)
                poe2_api.time_p("检查是否拾取（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            poe2_api.dbgp("4")
            env.interactive = need_item
            local distance = poe2_api.point_distance(need_item.grid_x, need_item.grid_y,player_info)
            poe2_api.dbgp("距离: "..distance)
            if distance then
                if distance < 25 then
                    local is_item = nil
                    poe2_api.dbgp("need_item.id: "..need_item.id)
                    for _, i in ipairs(env.range_items) do 
                        poe2_api.dbgp("i.id: "..i.id)
                        if i.id == need_item.id then 
                            is_item = i
                            break
                        end 
                    end
                    if not is_item then
                        env.need_item = nil
                        poe2_api.dbgp("物品已捡起1")
                        poe2_api.time_p("检查是否拾取（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    poe2_api.dbgp("111================")
                    local size = my_game_info.item_size[need_item.category_utf8]
                    poe2_api.dbgp("size:"..size[1],size[2])
                    local point = poe2_api.get_space_point({width=size[1],height=size[2],info=bag_info})
                    if not point and not player_info.isInBossBattle then
                        poe2_api.dbgp("背包空间不足，回城")
                        for _, i in ipairs(env.range_info) do
                            if i.name_utf8 ~= "" and i.type == 5 and poe2_api.table_contains(i.name_utf8,my_game_info.hideout_CH) then
                                local dis = poe2_api.point_distance(i.grid_x, i.grid_y, player_info)
                                if dis and dis < 25 then
                                    poe2_api.find_text({text = i.name_utf8,UI_info = env.UI_info,min_x=0,min_y=200,click=2})
                                    api_Sleep(200)
                                    env.need_item = nil
                                    poe2_api.time_p("检查是否拾取（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                                    return bret.RUNNING
                                end
                            end
                        end  
                        api_ClickMove(poe2_api.toInt(player_info.grid_x),poe2_api.toInt(player_info.grid_y),poe2_api.toInt(player_info.world_z),7)
                        api_Sleep(300) 
                        -- 先设置随机种子（只需执行一次）
                        math.randomseed(os.time())
                        -- 生成 [0, 25) 范围内的随机浮点数
                        local x = 0 + (5 - 0) * math.random()
                        -- 生成 [0, 25) 范围内的随机浮点数
                        local y = 0 + (5 - 0) * math.random()
                        api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),0)
                        api_Sleep(50)
                        api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),1)
                        self.wait = true
                        self.current_time = api_GetTickCount64()
                        self.wait_time = 2000
                        poe2_api.dbgp("等待回城")
                        poe2_api.time_p("检查是否拾取（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    local bool = false
                    for _, i in ipairs(env.range_info) do
                        if i.name_utf8 ~= "" and i.type == 5 and poe2_api.table_contains(i.name_utf8,my_game_info.hideout_CH) then
                            local dis = poe2_api.point_distance(i.grid_x, i.grid_y, need_item)
                            if dis and dis < 25 then
                                bool = true
                                break
                            end
                        end
                    end
                    poe2_api.dbgp("是否在隐藏点: "..tostring(bool))
                    if bool then
                        for _, v in ipairs(env.range_info) do
                            if v.name_utf8 ~= "" and v.type == 5 and poe2_api.table_contains(v.name_utf8,my_game_info.hideout_CH) then
                                local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                                if dis and dis < 25 then
                                    local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                                    if point then
                                        api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),poe2_api.toInt(player_info.world_z),0)
                                        -- api_Sleep(200)
                                        poe2_api.dbgp1("fdgherhtfbfdbsrghdghjm")
                                        poe2_api.click_keyboard("space")
                                        api_Sleep(200)
                                        poe2_api.time_p("检查是否拾取（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                                        return bret.RUNNING
                                    end
                                end
                            end
                        end
                        local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),poe2_api.toInt(player_info.world_z),7)
                            api_Sleep(300)
                            -- 先设置随机种子（只需执行一次）
                            math.randomseed(os.time())
                            -- 生成 [0, 25) 范围内的随机浮点数
                            local x = 0 + (5 - 0) * math.random()
                            -- 生成 [0, 25) 范围内的随机浮点数
                            local y = 0 + (5 - 0) * math.random()
                            api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),0)
                            api_Sleep(50)
                            api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),1)
                            self.wait = true
                            self.current_time = api_GetTickCount64()
                            self.wait_time = 2000
                            -- -- api_Sleep(200)
                            -- poe2_api.click_keyboard("space")
                            poe2_api.time_p("检查是否拾取（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end   
                    if not player_info.isMoving then
                        if not self.id1 then
                            self.id1 = env.need_item.id
                        end
                        if self.id1 == env.need_item.id then
                            self.number = self.number + 1
                        else
                            self.number = 1
                            self.id1 = env.need_item.id
                            -- poe2_api.dbgp("物品已捡起,更新状态")
                            -- api_Sleep(1000)
                        end
                        if self.number % 10 == 0 then
                            local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                            if point then
                                api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),poe2_api.toInt(player_info.world_z),7)
                            end
                        end
                        poe2_api.dbgp("number: "..self.number)
                        if self.number >= 50 then
                            table.insert(env.pick_up_timeout,env.need_item.id)
                            env.need_item = nil
                            self.number = 0
                            poe2_api.time_p("检查是否拾取（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end
                    poe2_api.dbgp("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")   
                elseif distance < 50 then
                    local is_item = nil
                    for _, i in ipairs(env.range_items) do 
                        if i.id == need_item.id then 
                            is_item = i
                            break
                        end 
                    end
                    if not is_item then
                        env.need_item = nil
                        poe2_api.dbgp("物品已捡起2")
                        poe2_api.time_p("检查是否拾取（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    local bool = false
                    for _, i in ipairs(env.range_info) do
                        if i.name_utf8 ~= "" and i.type == 5 and poe2_api.table_contains(i.name_utf8,my_game_info.hideout_CH) then
                            local dis = poe2_api.point_distance(i.grid_x, i.grid_y, need_item)
                            if dis and dis < 25 then
                                bool = true
                                break
                            end
                        end
                    end
                    if bool then
                        for _, v in ipairs(env.range_info) do
                            if v.name_utf8 ~= "" and v.type == 5 and poe2_api.table_contains(v.name_utf8,my_game_info.hideout_CH) then
                                local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                                if dis and dis < 30 then
                                    local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                                    if point then
                                        api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),poe2_api.toInt(player_info.world_z),0)
                                        -- api_Sleep(200)
                                        poe2_api.dbgp1("fdsvsdvsdvdsfdrsfv")
                                        poe2_api.click_keyboard("space")
                                        poe2_api.time_p("检查是否拾取（RUNNING8）... 耗时 --> ", api_GetTickCount64() - start_time)
                                        return bret.RUNNING
                                    end
                                end
                            end
                        end
                        local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                        
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),poe2_api.toInt(player_info.world_z),7)
                            api_Sleep(300)
                            -- 先设置随机种子（只需执行一次）
                            math.randomseed(os.time())
                            -- 生成 [0, 25) 范围内的随机浮点数
                            local x = 0 + (5 - 0) * math.random()
                            -- 生成 [0, 25) 范围内的随机浮点数
                            local y = 0 + (5 - 0) * math.random()
                            api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),0)
                            api_Sleep(50)
                            api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),1)
                            self.wait = true
                            self.current_time = api_GetTickCount64()
                            self.wait_time = 2000                            -- -- api_Sleep(200)
                            -- poe2_api.click_keyboard("space")
                            poe2_api.time_p("检查是否拾取（RUNNING9）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end
                       
                end
                
            end
            if poe2_api.find_text({text = "背包" ,UI_info = env.UI_info,min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                poe2_api.click_keyboard("i")
                poe2_api.dbgp("关背包7")
                api_Sleep(200)
                poe2_api.time_p("检查是否拾取（RUNNING10）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            poe2_api.dbgp("背包已關閉*********************************************************")
            poe2_api.time_p("检查是否拾取（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end
    },

    -- 祭坛购买
    Shop_Sacrifice_Items = {
        run = function(self, env)
            poe2_api.print_log("祭祀購買...")
            local current_time = api_GetTickCount64()
            if not self.init then
                self.init = true
                self.deferred_items = {}
            end
            local player_info = env.player_info
            local user_config = env.user_config

            local _get_valid_items = function(all_items, tribute)
                self.deferred_items = {}
                if not all_items or #all_items == 0 then
                    return {}, {}, 0, {}, {}, {}
                end
            
                local ritual_config = user_config['刷圖設置']['祭祀購買']
                if not ritual_config then
                    return {}, {}, 0, {}, {}, {}
                end
            
                -- 创建优先级字典，确保顺序与 ritual_config 一致
                local priority_dict = {}
                for idx, item in ipairs(ritual_config) do
                    priority_dict[item] = idx
                end
            
                -- 初始化物品分组
                local item_groups = {}
                for _, item_name in ipairs(ritual_config) do
                    item_groups[item_name] = {}
                end
            
                -- 分类物品：同时匹配 baseType_utf8 和 name_utf8
                local not_appeared_items = {}
                for _, item in ipairs(all_items) do
                    local matched = false
                    
                    -- 检查 baseType_utf8
                    if item.baseType_utf8 and item_groups[item.baseType_utf8] then
                        table.insert(item_groups[item.baseType_utf8], item)
                        matched = true
                    end
                    
                    -- 检查 name_utf8（如果 baseType_utf8 没有匹配）
                    if item.name_utf8 and item_groups[item.name_utf8] then
                        table.insert(item_groups[item.name_utf8], item)
                        matched = true
                    end
                    
                    -- 如果都没有匹配，且是隐藏道具
                    if not matched and item.baseType_utf8 == '隱藏道具' then
                        table.insert(not_appeared_items, item)
                    end
                end
            
                -- 按优先级排序物品
                local all_config_items = {}
                local all_config_items_no_price = {}
            
                -- 遍历 ritual_config 的顺序
                for _, item_name in ipairs(ritual_config) do
                    if item_groups[item_name] and #item_groups[item_name] > 0 then
                        -- 按价格排序（优先选择价格低的）
                        table.sort(item_groups[item_name], function(a, b)
                            local a_cost = a.totalDeferredConsumption or math.huge
                            local b_cost = b.totalDeferredConsumption or math.huge
                            if a_cost == b_cost then
                                -- 价格相同，则按 tribute（贡品值）排序
                                return (b.tribute or math.huge) < (a.tribute or math.huge)
                            else
                                return a_cost < b_cost
                            end
                        end)
            
                        -- 添加到 all_config_items
                        for _, item in ipairs(item_groups[item_name]) do
                            local condition1 = not item.totalDeferredConsumption or item.totalDeferredConsumption < tribute
                            local condition2 = not item.tribute or item.tribute < tribute
                            if condition1 or condition2 then
                                table.insert(all_config_items, item)
                            end
                        end
            
                        -- 添加到 all_config_items_no_price
                        for _, item in ipairs(item_groups[item_name]) do
                            if not item.tribute or (60000 > item.tribute and item.tribute > tribute) then
                                table.insert(all_config_items_no_price, item)
                            end
                        end
                    end
                end
            
                -- 打印所有存在的配置物品（按 ritual_config 顺序）
                local mapped_items = {}
                for _, item_name in ipairs(ritual_config) do
                    if item_groups[item_name] and #item_groups[item_name] > 0 then
                        table.insert(mapped_items, item_name)
                    end
                end
                poe2_api.dbgp("所有存在的配置物品: ",table.concat(mapped_items, ", "))
            
                return all_config_items, all_config_items_no_price, not_appeared_items
            end

            if poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout) then
                poe2_api.time_p("祭祀購買(SUCCESS)(不在异界)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end

            if env.afoot_altar and env.afoot_altar.stateMachineList["current_state"] == 2 and env.afoot_altar.stateMachineList["interaction_enabled"] == 0 then
                poe2_api.time_p("祭祀購買正在打祭祀(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end

            if not poe2_api.click_text_UI({UI_info = env.UI_info, text = "ritual_open_shop_button"  }) or env.not_items_buy then
                if poe2_api.find_text({UI_info = env.UI_info, text = "恩賜之物"  }) then
                    poe2_api.find_text({UI_info = env.UI_info, text = "恩賜之物" , min_x = 0 , add_x = 272, click = 2})
                    return bret.RUNNING
                end
                poe2_api.time_p("祭祀購買(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
            
            local SacrificeItems = api_GetSacrificeItems()
            -- poe2_api.dbgp("祭坛总数:", SacrificeItems.maxCount, " 已完成数量:", SacrificeItems.finishedCount, " 当前贡礼:", SacrificeItems.leftGifts)
            -- poe2_api.dbgp("祭坛可刷新总数:", SacrificeItems.MaxRefreshCount, " 祭坛已刷新数:", SacrificeItems.CurrentRefreshCount)

            if not (0 < SacrificeItems.maxCount and SacrificeItems.maxCount < 10) or not (0 < SacrificeItems.finishedCount and SacrificeItems.finishedCount < 10) or #SacrificeItems.items == 0 then
                if poe2_api.click_text_UI({UI_info = env.UI_info, text = "ritual_open_shop_button"  ,click = 1 }) then
                    api_Sleep(500)
                    return bret.RUNNING
                end
                return bret.SUCCESS
            end
            
            local all_items, all_items_no_price, not_appeared_items = _get_valid_items(SacrificeItems.items, SacrificeItems.leftGifts)
            
            if SacrificeItems.MaxRefreshCount == SacrificeItems.CurrentRefreshCount and #all_items == 0 and (#all_items_no_price == 0 or SacrificeItems.maxCount == SacrificeItems.finishedCount) then
                env.buy_items =  false
                env.have_ritual = false
                env.not_more_ritual = false
                env.not_items_buy = true
                if poe2_api.find_text({UI_info = env.UI_info, text = "恩賜之物"  }) then
                    local Attachments = api_Getinventorys(0xd,0)
                    if Attachments and #Attachments > 0 then
                        poe2_api.find_text({UI_info = env.UI_info, text = "恩賜之物" , min_x = 0 , add_x = 272, click = 2})
                        return bret.RUNNING
                    end
                    poe2_api.find_text({UI_info = env.UI_info, text = "恩賜之物" , min_x = 0 , add_x = 272, click = 2})
                    return bret.RUNNING
                end
                return bret.SUCCESS
            end
            
            poe2_api.dbgp("祭坛总数:", SacrificeItems.maxCount, " 已完成数量:", SacrificeItems.finishedCount, " 当前贡礼:", SacrificeItems.leftGifts)
            poe2_api.dbgp("祭坛可刷新总数:", SacrificeItems.MaxRefreshCount, " 祭坛已刷新数:", SacrificeItems.CurrentRefreshCount)
            
            local life = player_info.remainingPortalCount
            poe2_api.dbgp("剩余重生机会:", life, "次")
            
            if #all_items == 0 then
                poe2_api.dbgp("没有可购买物品或者暂缓物品")
                if SacrificeItems.leftGifts > SacrificeItems.refreshCost and SacrificeItems.MaxRefreshCount > SacrificeItems.CurrentRefreshCount and #not_appeared_items == 0 then
                    if not poe2_api.find_text({UI_info = env.UI_info, text = "恩賜之物" , min_x = 0}) then
                        env.buy_items = true
                        poe2_api.click_text_UI({UI_info = env.UI_info, text ="ritual_open_shop_button", click = 1})
                        api_Sleep(2000)
                        return bret.RUNNING
                    end
                    poe2_api.dbgp("第",SacrificeItems.CurrentRefreshCount,"次刷新贡礼")
                    poe2_api.find_text({UI_info = env.UI_info, text = "恩賜之物" , click = 2 ,min_x = 0 , add_x = 203, add_y = 53})
                    api_Sleep(2000)
                    return bret.RUNNING
                end

                if SacrificeItems.maxCount == SacrificeItems.finishedCount then
                    env.buy_items = false
                    env.have_ritual = false
                    env.not_items_buy = true
                    return bret.SUCCESS
                end
                
                if poe2_api.find_text({UI_info = env.UI_info, text ="恩賜之物"}) then
                    poe2_api.find_text({UI_info = env.UI_info, text = "恩賜之物" , min_x = 0 , add_x = 272, click = 2})
                    env.buy_items =  false
                    return bret.SUCCESS
                end

                env.buy_items =  false
                env.have_ritual = true
                return bret.SUCCESS
            end

            if (SacrificeItems.finishedCount < SacrificeItems.maxCount and #all_items_no_price > 0 and life >= 2) or #not_appeared_items > 0  then
                env.have_ritual = true
                env.buy_items =  false
                if poe2_api.find_text({UI_info = env.UI_info, text ="恩賜之物"}) then
                    poe2_api.find_text({UI_info = env.UI_info, text = "恩賜之物" , min_x = 0 , add_x = 272, click = 2})
                    env.buy_items =  false
                end
                return bret.SUCCESS
            else
                env.have_ritual = false
            end

            env.buy_items =  true
            if not poe2_api.find_text({UI_info = env.UI_info, text ="恩賜之物"}) then
                poe2_api.click_text_UI({UI_info = env.UI_info, text ="ritual_open_shop_button", click = 1})
                api_Sleep(1000)
                return bret.RUNNING
            end
            
            -- Buy affordable items
            local function buy_affordable(item)
                if not poe2_api.find_text({UI_info = env.UI_info, text = "暫緩道具"}) then
                    poe2_api.find_text({UI_info = env.UI_info, text ="取消", click = 2})
                    api_Sleep(1000)
                    return bret.RUNNING
                end
                
                poe2_api.dbgp("正在购买 ",item.baseType_utf8 or item.name_utf8)
                if poe2_api.ctrl_left_click_altar_items(item.obj, all_items) then
                    api_Sleep(500)
                end
            end
            
            -- Defer items
            local function deferred(item)
                if poe2_api.find_text({UI_info = env.UI_info, text = "暫緩道具"}) then
                    poe2_api.find_text({UI_info = env.UI_info, text = "暫緩道具", click = 2})
                    api_Sleep(1000)
                    return bret.RUNNING
                end
                
                if poe2_api.find_text({UI_info = env.UI_info, text = "確認"}) then
                    poe2_api.find_text({UI_info = env.UI_info, text = "恩賜之物"  ,click = 2 , min_x = 0 , add_x = 272})
                    api_Sleep(500)
                    return bret.RUNNING
                end
                
                poe2_api.dbgp("暫緩 ",item.baseType_utf8 or item.name_utf8, "贡礼: ", item.tribute)
                poe2_api.dbgp("item.totalDeferredConsumption --> ", item.totalDeferredConsumption)
                poe2_api.dbgp("item.tribute --> ", item.tribute)
                if poe2_api.ctrl_left_click_altar_items(item.obj, all_items, 2) then
                    api_Sleep(500)
                end

                poe2_api.find_text({UI_info = env.UI_info, text = "確認", click = 1, refresh = true})
                api_Sleep(100)
                poe2_api.find_text({UI_info = env.UI_info, text = "確認", click = 2, refresh = true})
                api_Sleep(500)
            end
            
            if #all_items > 0 then
                for _, item in ipairs(all_items) do
                    SacrificeItems = api_GetSacrificeItems()
                    if item.tribute < SacrificeItems.leftGifts then
                        buy_affordable(item)
                        api_Sleep(500)
                        return bret.RUNNING
                    else
                        deferred(item)
                        api_Sleep(500)
                        return bret.RUNNING
                    end
                end
            end
            
            return bret.RUNNING 
        end
    },

    -- 躲避技能
    DodgeAction_Inside1 = {
        name = "躲避",
        run = function(self, env)
            poe2_api.dbgp("DodgeAction_Inside")
            local is_initialized  = false
            if not self.last_space_time or self.last_space_time == nil then
                poe2_api.dbgp("DodgeAction_Inside 初始化")
                self.last_space_time = 0.0 -- 上次按下空格的时间
                self.space_cooldown = 1500  -- 空格键冷却时间（秒）
                self.last_space_time1 = 0.0
                is_initialized = true
            end

            local is_bird = false
            for _,k in ipairs(env.player_info.buffs) do
                -- poe2_api.printTable(k)
                -- poe2_api.dbgp("k.name_en", k.name_en)
                if k.name_en == "on_rhoa_mount" then
                    is_bird = true
                    break
                end
            end

            -- "怪物近距離躲避": {
            --     "Boss": true,
            --     "是否翻滚": true,
            --     "是否開啟": false,
            --     "白": true,
            --     "藍": true,
            --     "触发躲避怪物数": 2,
            --     "躲避距离": 60,
            --     "閾值": 1000,
            --     "黃": true
            -- },

            -- env.space_config["躲避距离"]

            local result_60 = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, env.space_config["躲避距离"], 10, 0, 0.5)
            
            local _handle_space_action = function(monster, space_flag, space_monsters, space_time, player_info)
                -- 处理空格键操作
                if not space_time then
                    space_time = 1500
                else
                    space_time = space_time
                end
                poe2_api.dbgp("space_time",space_time)
                if space_flag then
                    local result = nil
                    if poe2_api.table_contains({3},monster.rarity) then
                        result = api_GetNextCirclePosition(
                            monster.grid_x, monster.grid_y, 
                            player_info.grid_x, player_info.grid_y, 50,20,0
                        )

                    else
                        result = api_GetSafeAreaLocation(player_info.grid_x, player_info.grid_y, 60, 10, 0, 0.5)
                    end
                    -- api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 0)
                    -- api_Sleep(200)
                    if not is_bird then
                        
                    -- else
                        -- poe2_api.printTable(space_monsters)
                        poe2_api.dbgp("monster.rarity -->", monster.rarity)
                        poe2_api.dbgp("self.last_space_time -->", self.last_space_time)
                        poe2_api.dbgp("space_time -->", space_time)
                        poe2_api.dbgp("api_GetTickCount64() - self.last_space_time -->", (api_GetTickCount64() - self.last_space_time))
                        poe2_api.dbgp("_handle_space_action")
                        if poe2_api.table_contains(space_monsters,monster.rarity) and api_GetTickCount64() - self.last_space_time >= space_time then
                            api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 7)
                            api_Sleep(200)
                            poe2_api.click_keyboard("space")
                        end
                    else
                        api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 7)
                    end
                    self.last_space_time = api_GetTickCount64() + (math.random(-5, 5)* 0.01)
                    return false
                end

                return true
            end    

            local _handle_space_action_path_name = function(player_info, space_time)
                -- 处理空格键操作（添加20单位距离限制）
                space_time = space_time or 1500
                local ret = nil
                local r = api_IsPointInAnyActive(player_info.grid_x , player_info.grid_y , 0)
                if r then
                    ret = api_FindNearestSafeTile(player_info.grid_x, player_info.grid_y, 60, 5)
                    -- poe2_api.printTable(ret)
                    -- api_Log("ret1 type: " .. type(ret1))
                    -- poe2_api.dbgp("ret1 -->", ret.x, ret.y)
                end
                if r then
                    if ret and ret.x ~= -1 and ret.y ~= -1 then
                        api_ClickMove(poe2_api.toInt(ret.x), poe2_api.toInt(ret.y) ,poe2_api.toInt(player_info.world_z), 0)
                        api_Sleep(200)
                        poe2_api.dbgp("space")
                        -- if is_bird then
                        --     api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 7)
                        -- else
                        env.end_point = nil
                        env.path_list = nil
                        poe2_api.click_keyboard("space")
                        -- end
                        return true
                    -- else
                    --     local rct = api_GetSafeAreaLocation()
                    --     api_ClickMove(poe2_api.toInt(rct.x),poe2_api.toInt(rct.y),poe2_api.toInt(player_info.world_z), 0)
                    --     api_Sleep(200)
                    --     poe2_api.dbgp1("aFEWFGDSVBDSGBSDFGB")
                    --     -- if is_bird then
                    --     --     api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 7)
                    --     -- else
                    --     env.end_point = nil
                    --     env.path_list = nil
                    --     poe2_api.click_keyboard("space")
                    --     -- end
                    --     return true
                    end
                    
                end
                -- end
                return false
            end

            local function keep_distancen(min_attack_range)
                local range_info1 = poe2_api.get_sorted_list(env.range_info, player_info)
                -- 怪物检查主逻辑
                for _, monster in ipairs(range_info1) do
                    -- 快速跳过不符合基本条件的怪物
                    if monster.type ~= 1 or                  -- 类型检查
                    not monster.is_selectable or          -- 可选性检查
                    monster.is_friendly or                -- 友方检查
                    monster.life <= 0 or                  -- 生命值检查
                    monster.name_utf8 == "" or              -- 名称检查
                    poe2_api.table_contains(my_game_info.not_attact_mons_CN_name,monster.name_utf8) or
                    poe2_api.table_contains(my_game_info.not_attact_mons_path_name,monster.path_name_utf8)then  -- 路径名检查
                        goto continue_prop
                    end

                    if not monster.isActive then
                        goto continue_prop
                    end

                    -- 检查坐标有效性
                    if not monster.grid_x or not monster.grid_y then
                        goto continue_prop
                    end

                    -- 检查卡住状态
                    if env.stuck_monsters and next(env.stuck_monsters) and poe2_api.table_contains(env.stuck_monsters,monster.id) then
                        goto continue_prop
                    end

                    for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                        if poe2_api.table_contains(monster.magicProperties, prop) then
                            poe2_api.dbgp("特殊词缀怪物,不闪避")
                            return false
                        end
                    end

                    -- poe2_api.printTable(monster.magicProperties)

                    -- 计算距离
                    local distance = poe2_api.point_distance(monster.grid_x, monster.grid_y, env.player_info)
                    -- _M.dbgp("计算距离：",distance,"==============================",dis)
                    -- _M.print_log("计算距离：",distance)
                    -- _M.printTable(monster)
                    if distance and distance <= min_attack_range then
                        if monster.hasLineOfSight and api_HasObstacleBetween(monster.grid_x, monster.grid_y) then
                            poe2_api.dbgp("keep_distancen -- > ", result_60.x, result_60.y)
                            poe2_api.dbgp("player_info.grid_x, player_info.grid_y -- > ", player_info.grid_x, player_info.grid_y)
                            api_ClickMove(poe2_api.toInt(result_60.x), poe2_api.toInt(result_60.y), poe2_api.toInt(player_info.world_z), 7)
                            -- api_Sleep(200)
                            return true
                        end
                    end
                    ::continue_prop::
                end
                return false
            end

            -- 更新方法，执行躲避逻辑
            local monsters = env.range_info
            local player_info = env.player_info
            local space = env.space
            local space_time = env.space_time
            local space_monster = env.space_monster
            poe2_api.dbgp("space_monster")
            poe2_api.printTable(space_monster)
            if not monsters or not player_info then
                return bret.SUCCESS
            end
            local min_attack_range = 0
            if env.min_attack_range == 0 or not env.min_attack_range then
                min_attack_range = 70
            else
                min_attack_range = env.min_attack_range
            end
            poe2_api.dbgp("env.min_attack_range -- >",env.min_attack_range)
            poe2_api.dbgp("min_attack_range -- >",min_attack_range)

            
            poe2_api.dbgp(space)
            
            local keep_distance = false
            if space or (player_info.mana < (player_info.max_mana * 0.15)) then
                poe2_api.dbgp("怪物躲避")
                monsters = poe2_api.get_sorted_list(monsters, player_info)
                
                for _, monster in ipairs(monsters) do
                    -- poe2_api.printTable(monster)
                    dis = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
                    -- poe2_api.dbgp("dis-->", dis)
                    if monster.life > 0 and monster.isActive and dis and dis < 40 and 
                    not monster.is_friendly and monster.hasLineOfSight then
                        poe2_api.dbgp("monster.rarity-->>", monster.rarity)
                        if not poe2_api.table_contains(monster.rarity, env.space_monster) and (player_info.mana > (player_info.max_mana * 0.15)) then
                            -- poe2_api.dbgp("怪物躲避1")
                            goto continue
                        end
                        if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                            -- poe2_api.dbgp("怪物躲避2")
                            goto continue
                        end
                        local function checks()
                            for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                                if poe2_api.table_contains(monster.magicProperties, prop) then
                                    poe2_api.dbgp("特殊词缀怪物,不闪避")
                                    return true
                                end
                            end
                            return false
                        end
                        -- if poe2_api.has_common_element(my_game_info.first_magicProperties, monster.magicProperties) then
                        --     poe2_api.dbgp("特殊词缀怪物,不闪避")
                        --     goto continue
                        -- end
                        if checks() then
                            poe2_api.dbgp("特殊词缀怪物,不闪避")
                            break
                        end

                        poe2_api.dbgp("躲避")
                        _handle_space_action(monster, space, space_monster, space_time, player_info)
                        -- break
                    end
                    ::continue::
                end

                poe2_api.dbgp("env.select_skill")
                
            end

            -- "怪物近距離躲避": {
            --     "Boss": true,
            --     "是否翻滚": true,
            --     "是否開啟": true,
            --     "白": false,
            --     "藍": false,
            --     "触发躲避怪物数": 2,
            --     "躲避距离": 60,
            --     "閾值": 1000,
            --     "黃": true
            -- },

            if min_attack_range >= 70 and (env.user_config["全局設置"]["刷图通用設置"]["保持距离"] or false) then
                keep_distance = keep_distancen(min_attack_range)
                poe2_api.dbgp("keep_distance --> ",keep_distance)
            end

            -- poe2_api.printTable(env.select_skill)
            -- poe2_api.dbgp("env.select_skill.walk_attack -- >",env.select_skill.walk_attack)
            if not _handle_space_action_path_name(player_info) then
                poe2_api.dbgp("555555")
                -- poe2_api.printTable(env.select_skill)
                -- if env.select_skill and 
                if (env.select_skill and not env.select_skill.walk_attack) or keep_distance then
                    env.end_point = nil
                    env.path_list = nil
                    return bret.RUNNING
                end
                return bret.SUCCESS
            end
            env.end_point = nil
            env.path_list = nil
            return bret.RUNNING
        end
    },

    -- 躲避技能
    DodgeAction_Inside = {
        name = "躲避",
        run = function(self, env)
            poe2_api.dbgp("DodgeAction_Inside")
            local is_initialized  = false
            if not self.last_space_time or self.last_space_time == nil then
                poe2_api.dbgp("DodgeAction_Inside 初始化")
                self.last_space_time = 0.0 -- 上次按下空格的时间
                self.space_cooldown = 1500  -- 空格键冷却时间（秒）
                self.last_space_time1 = 0.0
                is_initialized = true
            end

            local is_bird = false
            for _,k in ipairs(env.player_info.buffs) do
                -- poe2_api.printTable(k)
                -- poe2_api.dbgp("k.name_en", k.name_en)
                if k.name_en == "on_rhoa_mount" then
                    is_bird = true
                    break
                end
            end

            local _handle_space_action_path_name = function(player_info)
                local ret = nil
                local r = api_IsPointInAnyActive(player_info.grid_x , player_info.grid_y , 0)
                if r then
                    ret = api_FindNearestSafeTile(player_info.grid_x, player_info.grid_y, 60, 5)
                end
                if r then
                    if ret and ret.x ~= -1 and ret.y ~= -1 then
                        if not api_ClickMove(poe2_api.toInt(ret.x), poe2_api.toInt(ret.y) ,poe2_api.toInt(player_info.world_z), 0)or api_HasObstacleBetween(ret.x, ret.y) then
                            poe2_api.dbgp("安全点过远或有障碍物")
                            env.end_point = {ret.x, ret.y}
                            return bret.FAIL
                        end
                        api_Sleep(200)
                        env.end_point = nil
                        env.path_list = nil
                        poe2_api.click_keyboard("space")
                        return true
                    end
                end
                return false
            end

            -- "怪物近距離躲避": {
            --     "Boss": true,
            --     "是否翻滚": true,
            --     "是否開啟": false,
            --     "白": true,
            --     "藍": true,
            --     "触发躲避怪物数": 2,
            --     "躲避距离": 60,
            --     "閾值": 1000,
            --     "黃": true
            -- },
            local is_space_open = env.space_config["是否開啟"] or false
            local space_check_dis = env.space_config["躲避距离"]
            local space_time = env.space_config["閾值"]
            local mons_num = env.space_config["触发躲避怪物数"]
            local is_space = env.space_config["是否翻滚"]

            -- 躲避技能
            _handle_space_action_path_name(env.player_info)
            
            -- local safe_point = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, env.space_config["躲避距离"], env.min_attack_dis, 2, 0.5)
            local safe_point = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 100, env.space_config["躲避距离"], 2, 0.5)
            
            local _handle_space_action = function(monster, space_flag, space_monsters, space_time, player_info)
                poe2_api.dbgp("space_time",space_time)
                if space_flag then
                    local result = nil
                    result = api_GetNextCirclePosition(monster.grid_x, monster.grid_y, player_info.grid_x, player_info.grid_y, 50,20,0)

                    -- api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 0)
                    -- api_Sleep(200)
                    if not is_bird then
                        poe2_api.dbgp("monster.rarity -->", monster.rarity)
                        poe2_api.dbgp("self.last_space_time -->", self.last_space_time)
                        poe2_api.dbgp("space_time -->", space_time)
                        poe2_api.dbgp("api_GetTickCount64() - self.last_space_time -->", (api_GetTickCount64() - self.last_space_time))
                        poe2_api.dbgp("_handle_space_action")
                        if poe2_api.table_contains(space_monsters,monster.rarity) and api_GetTickCount64() - self.last_space_time >= space_time then
                            api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 7)
                            api_Sleep(200)
                            poe2_api.click_keyboard("space")
                        end
                    else
                        if not api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 7) or api_HasObstacleBetween(result.x, result.y) then
                            poe2_api.dbgp("安全点过远或有障碍物")
                            env.end_point = {safe_point.x, safe_point.y}
                            return bret.FAIL
                        end
                    end
                    self.last_space_time = api_GetTickCount64() + (math.random(-5, 5)* 0.01)
                    return false
                end

                return true
            end    

            local function keep_distancen(min_attack_range)
                local range_info1 = poe2_api.get_sorted_list(env.range_info, player_info)
                -- 怪物检查主逻辑
                for _, monster in ipairs(range_info1) do
                    -- 快速跳过不符合基本条件的怪物
                    if monster.type ~= 1 or                  -- 类型检查
                    not monster.is_selectable or          -- 可选性检查
                    monster.is_friendly or                -- 友方检查
                    monster.life <= 0 or                  -- 生命值检查
                    monster.name_utf8 == "" or              -- 名称检查
                    poe2_api.table_contains(my_game_info.not_attact_mons_CN_name,monster.name_utf8) or
                    poe2_api.table_contains(my_game_info.not_attact_mons_path_name,monster.path_name_utf8)then  -- 路径名检查
                        goto continue_prop
                    end

                    if not monster.isActive then
                        goto continue_prop
                    end

                    -- 检查坐标有效性
                    if not monster.grid_x or not monster.grid_y then
                        goto continue_prop
                    end

                    -- 检查卡住状态
                    if env.stuck_monsters and next(env.stuck_monsters) and poe2_api.table_contains(env.stuck_monsters,monster.id) then
                        goto continue_prop
                    end

                    for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                        if poe2_api.table_contains(monster.magicProperties, prop) then
                            poe2_api.dbgp("特殊词缀怪物,不闪避")
                            return false
                        end
                    end

                    -- poe2_api.printTable(monster.magicProperties)

                    -- 计算距离
                    local distance = poe2_api.point_distance(monster.grid_x, monster.grid_y, env.player_info)
                    -- _M.dbgp("计算距离：",distance,"==============================",dis)
                    -- _M.print_log("计算距离：",distance)
                    -- _M.printTable(monster)
                    if distance and distance <= min_attack_range then
                        if monster.hasLineOfSight and api_HasObstacleBetween(monster.grid_x, monster.grid_y) then
                            poe2_api.dbgp("keep_distancen -- > ", safe_point.x, safe_point.y)
                            api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y), poe2_api.toInt(player_info.world_z), 7)
                            -- api_Sleep(200)
                            return true
                        end
                    end
                    ::continue_prop::
                end
                return false
            end

            -- 更新方法，执行躲避逻辑
            local monsters = env.range_info
            local player_info = env.player_info
            local space = env.space
            local space_time = env.space_time
            local space_monster = env.space_monster
            poe2_api.dbgp("space_monster")
            -- poe2_api.printTable(space_monster)

            if not monsters or not player_info or not is_space_open then
                return bret.SUCCESS
            end

            poe2_api.printTable(safe_point)

            if player_info.grid_x == safe_point.x and player_info.grid_y == safe_point.y then
                poe2_api.dbgp("无安全点可用")
                return bret.SUCCESS
            end
            
            local keep_distance = false

            
            local monster_count = poe2_api.count_mos_in_range({range_info = env.range_info, player_info = env.player_info, dis = space_check_dis, not_sight = false})
            poe2_api.dbgp("范围内怪物数量:", monster_count)
            
            if (monster_count < mons_num or not is_space_open) and (player_info.mana > (player_info.max_mana * 0.15)) then
                return bret.SUCCESS
            end

            poe2_api.dbgp("怪物躲避")
            monsters = poe2_api.get_sorted_list(monsters, player_info)
            for _, monster in ipairs(monsters) do
                -- poe2_api.printTable(monster)
                dis = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
                -- poe2_api.dbgp("dis-->", dis)
                if monster.life > 0 and monster.isActive and dis and dis < space_check_dis and 
                not monster.is_friendly and monster.hasLineOfSight then
                    -- poe2_api.printTable(monster)
                    poe2_api.dbgp("monster.rarity-->>", tostring(monster.rarity))
        
                    poe2_api.dbgp("怪物靠近。。。。。")
                    
                    if not poe2_api.table_contains(monster.rarity, env.space_monster) and (player_info.mana > (player_info.max_mana * 0.15)) then
                        -- keep_distance = keep_distancen(space_check_dis, monster)
                        if not api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y), poe2_api.toInt(player_info.world_z), 7) or api_HasObstacleBetween(safe_point.x, safe_point.y) then
                            poe2_api.dbgp("安全点过远或有障碍物")
                            env.end_point = {safe_point.x, safe_point.y}
                            return bret.FAIL
                        end
                        keep_distance = true
                        env.end_point = nil
                        env.path_list = nil
                        return bret.RUNNING
                    end
                    if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                        -- poe2_api.dbgp("怪物躲避2")
                        goto continue
                    end
                    local function checks()
                        for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                            if poe2_api.table_contains(monster.magicProperties, prop) then
                                poe2_api.dbgp("特殊词缀怪物,不闪避")
                                return true
                            end
                        end
                        return false
                    end

                    -- if poe2_api.has_common_element(my_game_info.first_magicProperties, monster.magicProperties) then
                    --     poe2_api.dbgp("特殊词缀怪物,不闪避")
                    --     goto continue
                    -- end

                    if checks() then
                        poe2_api.dbgp("特殊词缀怪物,不闪避")
                        break
                    end

                    poe2_api.dbgp("躲避")
                    _handle_space_action(monster, space, space_monster, space_time, player_info)
                    break
                end
                ::continue::
            end


            -- poe2_api.printTable(env.select_skill)
            -- poe2_api.dbgp("env.select_skill.walk_attack -- >",env.select_skill.walk_attack)
            poe2_api.dbgp("env.select_skill and not env.select_skill.walk_attack --> ",(env.select_skill and not env.select_skill.walk_attack))
            poe2_api.dbgp("keep_distance --> ",keep_distance)
            poe2_api.dbgp("is_space --> ",is_space)
            if (env.select_skill and not env.select_skill.walk_attack) or keep_distance or is_space then
                env.end_point = nil
                env.path_list = nil
                return bret.RUNNING
            else
                return bret.SUCCESS
            end
            env.end_point = nil
            env.path_list = nil
            return bret.RUNNING
        end
    },

    -- 躲避技能
    DodgeAction = {
        name = "躲避",
        run = function(self, env)
            local is_initialized  = false
            if self.last_space_time == nil then
                self.last_space_time = 0.0 -- 上次按下空格的时间
                self.space_cooldown = 1500 -- 空格键冷却时间（秒）
                self.last_space_time1 = 0.0
                is_initialized = true
            end

            local is_bird = false
            for _,k in ipairs(env.player_info.buffs) do
                -- poe2_api.printTable(k)
                -- poe2_api.dbgp("k.name_en", k.name_en)
                if k.name_en == "on_rhoa_mount" then
                    is_bird = true
                    break
                end
            end
            
            local _handle_space_action = function(monster, space_flag, space_monsters, space_time, player_info)
                -- 处理空格键操作
                if not space_time then
                    space_time = 1500
                else
                    space_time = space_time
                end
                if ((space_flag and poe2_api.table_contains(space_monsters,monster.rarity)) or (player_info.mana < (player_info.max_mana * 0.15))) and
                api_GetTickCount64() - self.last_space_time >= space_time  then
                    local result = api_GetNextCirclePosition(
                        monster.grid_x, monster.grid_y, 
                        player_info.grid_x, player_info.grid_y, 50,20,0
                    )
                    api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 0)
                    api_Sleep(200)
                    poe2_api.dbgp1("_handle_space_action")
                    if is_bird then
                        api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 7)
                    else
                        poe2_api.click_keyboard("space")
                    end
                    self.last_space_time = api_GetTickCount64()
                end
            end    
            local _handle_space_action_path_name1 = function(player_info, space_time)
                -- 处理空格键操作（添加20单位距离限制）
                space_time = space_time or 1500
                if player_info.isInDangerArea then
                    local rct = api_GetSafeAreaLocation(player_info.grid_x, player_info.grid_y, 60, 10, 0, 0.5)
                    -- if is_bird then
                    --     local ret = api_GetSafeAreaLocationNoMonsters(60)
                    -- else
                    --     local ret = api_GetSafeAreaLocationNoMonsters(40)
                    -- end
                    if ret and ret.x ~= -1 and ret.y ~= -1 then
                        api_ClickMove(poe2_api.toInt(ret.x), poe2_api.toInt(ret.y) ,poe2_api.toInt(player_info.world_z), 0)
                        api_Sleep(200)
                        poe2_api.dbgp1("sdgbvsadgavagbzgbaz")
                        -- if is_bird then
                        --     api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 7)
                        -- else
                        poe2_api.click_keyboard("space")
                        -- end
                        return true
                    else
                        local rct = api_GetSafeAreaLocation(player_info.grid_x, player_info.grid_y, 60, 10, 0, 0.5)
                        api_ClickMove(poe2_api.toInt(rct.x),poe2_api.toInt(rct.y),poe2_api.toInt(player_info.world_z), 0)
                        api_Sleep(200)
                        poe2_api.dbgp1("aFEWFGDSVBDSGBSDFGB")
                        -- if is_bird then
                        --     api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 7)
                        -- else
                        poe2_api.click_keyboard("space")
                        -- end
                        return true
                    end
                end
                return false
            end

            local _handle_space_action_path_name = function(player_info, space_time)
                -- 处理空格键操作（添加20单位距离限制）
                space_time = space_time or 1500
                local rct = nil
                local r = api_IsPointInAnyActive(player_info.grid_x , player_info.grid_y , 0)
                if r then
                    rct = api_FindNearestSafeTile(player_info.grid_x , player_info.grid_y , 60 , 5)
                end
                poe2_api.dbgp("r -->", r)
                poe2_api.dbgp("rct -->")
                poe2_api.printTable(rct)
                -- if player_info.isInDangerArea then
                    -- local rct = api_GetSafeAreaLocation()
                    -- -- if is_bird then
                    -- local ret = api_GetSafeAreaLocationNoMonsters(60)
                    -- else
                    --     local ret = api_GetSafeAreaLocationNoMonsters(40)
                    -- end
                
                if ret and ret.x ~= -1 and ret.y ~= -1 then
                    api_ClickMove(poe2_api.toInt(ret.x), poe2_api.toInt(ret.y) ,poe2_api.toInt(player_info.world_z), 0)
                    api_Sleep(200)
                    poe2_api.dbgp1("sdgbvsadgavagbzgbaz")
                    -- if is_bird then
                    --     api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 7)
                    -- else
                    env.end_point = nil
                    env.path_list = nil
                    poe2_api.click_keyboard("space")
                    -- end
                    return true
                -- else
                --     local rct = api_GetSafeAreaLocation()
                --     api_ClickMove(poe2_api.toInt(rct.x),poe2_api.toInt(rct.y),poe2_api.toInt(player_info.world_z), 0)
                --     api_Sleep(200)
                --     poe2_api.dbgp1("aFEWFGDSVBDSGBSDFGB")
                --     -- if is_bird then
                --     --     api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 7)
                --     -- else
                --     env.end_point = nil
                --     env.path_list = nil
                --     poe2_api.click_keyboard("space")
                --     -- end
                --     return true
                end
                -- end
                return false
            end

            local function keep_distancen(min_attack_range)
                local range_info1 = poe2_api.get_sorted_list(env.range_info, player_info)
                local result_60 = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 60, 10, 0, 0.5)
                -- 怪物检查主逻辑
                for _, monster in ipairs(range_info1) do
                    -- 快速跳过不符合基本条件的怪物
                    if monster.type ~= 1 or                  -- 类型检查
                    not monster.is_selectable or          -- 可选性检查
                    monster.is_friendly or                -- 友方检查
                    monster.life <= 0 or                  -- 生命值检查
                    monster.name_utf8 == "" or              -- 名称检查
                    poe2_api.table_contains(my_game_info.not_attact_mons_CN_name,monster.name_utf8) or
                    poe2_api.table_contains(my_game_info.not_attact_mons_path_name,monster.path_name_utf8)then  -- 路径名检查
                        goto continue
                    end

                    if not monster.isActive then
                        goto continue
                    end

                    -- 检查坐标有效性
                    if not monster.grid_x or not monster.grid_y then
                        goto continue
                    end

                    -- 检查卡住状态
                    if env.stuck_monsters and next(env.stuck_monsters) and poe2_api.table_contains(env.stuck_monsters,monster.id) then
                        goto continue
                    end

                    for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                        if poe2_api.table_contains(monster.magicProperties, prop) then
                            poe2_api.dbgp("特殊词缀怪物,不闪避")
                            goto continue
                        end
                    end

                    -- if poe2_api.has_common_element(my_game_info.first_magicProperties, monster.magicProperties) then
                    --     poe2_api.dbgp("特殊词缀怪物,不闪避")
                    --     goto continue
                    -- end

                    -- 计算距离
                    local distance = poe2_api.point_distance(monster.grid_x, monster.grid_y, env.player_info)
                    -- _M.dbgp("计算距离：",distance,"==============================",dis)
                    -- _M.print_log("计算距离：",distance)
                    -- _M.printTable(monster)
                    if distance and distance <= min_attack_range then
                        if monster.hasLineOfSight and api_HasObstacleBetween(monster.grid_x, monster.grid_y) then
                            poe2_api.dbgp("keep_distancen -- > ", result_60.x, result_60.y)
                            api_ClickMove(poe2_api.toInt(result_60.x), poe2_api.toInt(result_60.y), poe2_api.toInt(player_info.world_z), 7)
                            -- api_Sleep(200)
                            return true
                        end
                    end
                    ::continue::
                end
                return false
            end


            -- 更新方法，执行躲避逻辑
            local monsters = env.range_info
            local player_info = env.player_info
            local space = env.space
            local space_time = env.space_time
            local space_monster = env.space_monster
            if not monsters or not player_info then
                return bret.SUCCESS
            end
            local min_attack_range = env.min_attack_range or 70
            if space or (player_info.mana < (player_info.max_mana * 0.15)) then
                for _, monster in ipairs(monsters) do
                    dis = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
                    if monster.life > 0 and monster.isActive and dis and dis < min_attack_range and 
                    not monster.is_friendly and monster.hasLineOfSight then
                        if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                            goto continue
                        end
                        -- if poe2_api.has_common_element(my_game_info.first_magicProperties, monster.magicProperties) then
                        --     -- poe2_api.dbgp("特殊词缀怪物"..monster.magicProperties.."不闪避")
                        --     goto continue
                        -- end
                        for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                            if poe2_api.table_contains(monster.magicProperties, prop) then
                                poe2_api.dbgp("特殊词缀怪物,不闪避")
                                goto continue
                            end
                        end
                        _handle_space_action(monster, space, space_monster, space_time, player_info)
                    end
                    ::continue::
                end
                -- poe2_api.dbgp("env.select_skill")
                -- if min_attack_range >= 70 then
                --     local keep_distance = keep_distancen(min_attack_range)
                --     poe2_api.dbgp("keep_distance --> ",keep_distance)
                -- end
            end
            
            _handle_space_action_path_name(player_info)
            return bret.SUCCESS
        end
    },

    -- 躲避技能
    DodgeAction1 = {
        name = "躲避",
        run = function(self, env)
            poe2_api.dbgp("DodgeAction")
            local is_initialized  = false
            if not self.last_space_time or self.last_space_time == nil then
                poe2_api.dbgp("DodgeAction 初始化")
                self.last_space_time = 0.0 -- 上次按下空格的时间
                self.space_cooldown = 1500  -- 空格键冷却时间（秒）
                self.last_space_time1 = 0.0
                is_initialized = true
            end

            local is_bird = false
            for _,k in ipairs(env.player_info.buffs) do
                -- poe2_api.printTable(k)
                -- poe2_api.dbgp("k.name_en", k.name_en)
                if k.name_en == "on_rhoa_mount" then
                    is_bird = true
                    break
                end
            end

            local _handle_space_action_path_name = function(player_info)
                local ret = nil
                local r = api_IsPointInAnyActive(player_info.grid_x , player_info.grid_y , 0)
                if r then
                    ret = api_FindNearestSafeTile(player_info.grid_x, player_info.grid_y, 60, 5)
                end
                if r then
                    if ret and ret.x ~= -1 and ret.y ~= -1 then
                        if not api_ClickMove(poe2_api.toInt(ret.x), poe2_api.toInt(ret.y) ,poe2_api.toInt(player_info.world_z), 0) or api_HasObstacleBetween(ret.x, ret.y) then
                            poe2_api.dbgp("安全点过远或有障碍物")
                            env.end_point = {ret.x, ret.y}
                            return bret.FAIL
                        end
                        api_Sleep(200)
                        env.end_point = nil
                        env.path_list = nil
                        poe2_api.click_keyboard("space")
                        return true
                    end
                end
                return false
            end

            -- "怪物近距離躲避": {
            --     "Boss": true,
            --     "是否翻滚": true,
            --     "是否開啟": false,
            --     "白": true,
            --     "藍": true,
            --     "触发躲避怪物数": 2,
            --     "躲避距离": 60,
            --     "閾值": 1000,
            --     "黃": true
            -- },
            local is_space_open = env.space_config["是否開啟"] or false
            local space_check_dis = env.space_config["躲避距离"]
            local space_time = env.space_config["閾值"]
            local mons_num = env.space_config["触发躲避怪物数"]
            local is_space = env.space_config["是否翻滚"]

            -- 躲避技能
            _handle_space_action_path_name(env.player_info)
            
            -- local safe_point = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, env.space_config["躲避距离"], env.min_attack_dis, 2, 0.5)
            local safe_point = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 100, env.space_config["躲避距离"], 2, 0.5)
            
            local _handle_space_action = function(monster, space_flag, space_monsters, space_time, player_info)
                poe2_api.dbgp("space_time",space_time)
                if space_flag then
                    local result = nil
                    result = api_GetNextCirclePosition(monster.grid_x, monster.grid_y, player_info.grid_x, player_info.grid_y, 50,20,0)

                    -- api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 0)
                    -- api_Sleep(200)
                    if not is_bird then
                        poe2_api.dbgp("monster.rarity -->", monster.rarity)
                        poe2_api.dbgp("self.last_space_time -->", self.last_space_time)
                        poe2_api.dbgp("space_time -->", space_time)
                        poe2_api.dbgp("api_GetTickCount64() - self.last_space_time -->", (api_GetTickCount64() - self.last_space_time))
                        poe2_api.dbgp("_handle_space_action")
                        if poe2_api.table_contains(space_monsters,monster.rarity) and api_GetTickCount64() - self.last_space_time >= space_time then
                            api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 7)
                            api_Sleep(200)
                            poe2_api.click_keyboard("space")
                        end
                    else
                        if not api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 7) or api_HasObstacleBetween(result.x, result.y) then
                            poe2_api.dbgp("安全点过远或有障碍物")
                            env.end_point = {safe_point.x, safe_point.y}
                            return bret.FAIL
                        end
                    end
                    self.last_space_time = api_GetTickCount64() + (math.random(-5, 5)* 0.01)
                    return false
                end

                return true
            end    

            local function keep_distancen(min_attack_range)
                local range_info1 = poe2_api.get_sorted_list(env.range_info, player_info)
                -- 怪物检查主逻辑
                for _, monster in ipairs(range_info1) do
                    -- 快速跳过不符合基本条件的怪物
                    if monster.type ~= 1 or                  -- 类型检查
                    not monster.is_selectable or          -- 可选性检查
                    monster.is_friendly or                -- 友方检查
                    monster.life <= 0 or                  -- 生命值检查
                    monster.name_utf8 == "" or              -- 名称检查
                    poe2_api.table_contains(my_game_info.not_attact_mons_CN_name,monster.name_utf8) or
                    poe2_api.table_contains(my_game_info.not_attact_mons_path_name,monster.path_name_utf8)then  -- 路径名检查
                        goto continue_prop
                    end

                    if not monster.isActive then
                        goto continue_prop
                    end

                    -- 检查坐标有效性
                    if not monster.grid_x or not monster.grid_y then
                        goto continue_prop
                    end

                    -- 检查卡住状态
                    if env.stuck_monsters and next(env.stuck_monsters) and poe2_api.table_contains(env.stuck_monsters,monster.id) then
                        goto continue_prop
                    end

                    for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                        if poe2_api.table_contains(monster.magicProperties, prop) then
                            poe2_api.dbgp("特殊词缀怪物,不闪避")
                            return false
                        end
                    end

                    -- poe2_api.printTable(monster.magicProperties)

                    -- 计算距离
                    local distance = poe2_api.point_distance(monster.grid_x, monster.grid_y, env.player_info)
                    -- _M.dbgp("计算距离：",distance,"==============================",dis)
                    -- _M.print_log("计算距离：",distance)
                    -- _M.printTable(monster)
                    if distance and distance <= min_attack_range then
                        if monster.hasLineOfSight and api_HasObstacleBetween(monster.grid_x, monster.grid_y) then
                            poe2_api.dbgp("keep_distancen -- > ", safe_point.x, safe_point.y)
                            api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y), poe2_api.toInt(player_info.world_z), 7)
                            -- api_Sleep(200)
                            return true
                        end
                    end
                    ::continue_prop::
                end
                return false
            end

            -- 更新方法，执行躲避逻辑
            local monsters = env.range_info
            local player_info = env.player_info
            local space = env.space
            local space_time = env.space_time
            local space_monster = env.space_monster
            poe2_api.dbgp("space_monster")
            -- poe2_api.printTable(space_monster)

            if not monsters or not player_info or not is_space_open then
                return bret.SUCCESS
            end

            poe2_api.printTable(safe_point)

            if player_info.grid_x == safe_point.x and player_info.grid_y == safe_point.y then
                poe2_api.dbgp("无安全点可用")
                return bret.SUCCESS
            end
            
            local keep_distance = false

            
            local monster_count = poe2_api.count_mos_in_range({range_info = env.range_info, player_info = env.player_info, dis = space_check_dis, not_sight = false})
            poe2_api.dbgp("范围内怪物数量:", monster_count)
            
            if (monster_count < mons_num or not is_space_open) and (player_info.mana > (player_info.max_mana * 0.15)) then
                return bret.SUCCESS
            end

            poe2_api.dbgp("怪物躲避")
            monsters = poe2_api.get_sorted_list(monsters, player_info)
            for _, monster in ipairs(monsters) do
                -- poe2_api.printTable(monster)
                dis = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
                -- poe2_api.dbgp("dis-->", dis)
                if monster.life > 0 and monster.isActive and dis and dis < space_check_dis and 
                not monster.is_friendly and monster.hasLineOfSight then
                    -- poe2_api.printTable(monster)
                    poe2_api.dbgp("monster.rarity-->>", tostring(monster.rarity))
        
                    poe2_api.dbgp("怪物靠近。。。。。")
                    
                    if not poe2_api.table_contains(monster.rarity, env.space_monster) and (player_info.mana > (player_info.max_mana * 0.15)) then
                        -- keep_distance = keep_distancen(space_check_dis, monster)
                        if not api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y), poe2_api.toInt(player_info.world_z), 7) or api_HasObstacleBetween(safe_point.x, safe_point.y) then
                            poe2_api.dbgp("安全点过远或有障碍物")
                            env.end_point = {safe_point.x, safe_point.y}
                            return bret.FAIL
                        end
                        keep_distance = true
                        env.end_point = nil
                        env.path_list = nil
                        return bret.RUNNING
                    end
                    if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                        -- poe2_api.dbgp("怪物躲避2")
                        goto continue
                    end
                    local function checks()
                        for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                            if poe2_api.table_contains(monster.magicProperties, prop) then
                                poe2_api.dbgp("特殊词缀怪物,不闪避")
                                return true
                            end
                        end
                        return false
                    end

                    -- if poe2_api.has_common_element(my_game_info.first_magicProperties, monster.magicProperties) then
                    --     poe2_api.dbgp("特殊词缀怪物,不闪避")
                    --     goto continue
                    -- end

                    if checks() then
                        poe2_api.dbgp("特殊词缀怪物,不闪避")
                        break
                    end

                    poe2_api.dbgp("躲避")
                    _handle_space_action(monster, space, space_monster, space_time, player_info)
                    break
                end
                ::continue::
            end


            -- poe2_api.printTable(env.select_skill)
            -- poe2_api.dbgp("env.select_skill.walk_attack -- >",env.select_skill.walk_attack)
            poe2_api.dbgp("env.select_skill and not env.select_skill.walk_attack --> ",(env.select_skill and not env.select_skill.walk_attack))
            poe2_api.dbgp("keep_distance --> ",keep_distance)
            poe2_api.dbgp("is_space --> ",is_space)
            if (env.select_skill and not env.select_skill.walk_attack) or keep_distance or is_space then
                env.end_point = nil
                env.path_list = nil
                return bret.SUCCESS
            end
            env.end_point = nil
            env.path_list = nil
            return bret.SUCCESS
        end
    },


    -- 清理遮挡页面
    Game_Block = {
        run = function(self, env)
            poe2_api.print_log("游戏阻挡处理模块开始执行...")
            poe2_api.dbgp("=== 开始处理游戏阻挡 ===")
            
            local current_time = api_GetTickCount64()
            
            local player_info = env.player_info
            -- if player_info then
            --     return bret.SUCCESS
            -- end
            
            -- poe2_api.dbgp(string.format("当前时间戳: %d", current_time))
            -- poe2_api.dbgp(string.format("当前地图: %s", player_info.current_map_name_utf8 or "未知"))

            -- 检查交易拒绝情况
            local refuse_click = {"等待玩家接受交易請求..."}
            if poe2_api.find_text({UI_info = env.UI_info, text = refuse_click, min_x = 0, add_x = 253, click = 2}) then
                poe2_api.dbgp("检测到交易请求等待，将执行拒绝操作")
                return bret.RUNNING
            end

            ---常驻
            local all_check = {
                {UI_info = env.UI_info, text = "繼續遊戲", add_x = 0, add_y = 0, click = 2},
                {UI_info = env.UI_info, text = "寶石切割", add_x = 280, add_y = 17, click = 2},
                {UI_info = env.UI_info, text = "技能", min_x = 0, add_x = 253, click = 2, max_y = 75, max_x = 550},
            }
            -- 检查单个按钮
            for _, check in ipairs(all_check) do
                if poe2_api.find_text(check) then
                    poe2_api.dbgp(string.format("检测到按钮: %s，将执行点击操作", check.text))
                    return bret.RUNNING
                end
            end

            if poe2_api.find_text({UI_info = env.UI_info, text = "私訊", add_x = 265, min_x = 0, max_x = 400, click = 2}) then
                return bret.RUNNING
            end

            -- 检查顶部中间页面按钮
            local top_mid_page = {"傳送", "Checkpoints"}
            if poe2_api.find_text({UI_info = env.UI_info, text = top_mid_page, min_x = 0, add_x = 215, click = 2}) then
                return bret.RUNNING
            end

            -- 按键
            if not self.once_check then
                api_Log("检查是否在主页面11111")
                local once_check = {
                    {UI_info = env.UI_info, text = "精選", add_x = 677, min_x = 0, add_y = 10, click = 2},
                    
                    {UI_info = env.UI_info, text = "社交", min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = "角色", min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = "活動", min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = "選項", min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = "重置天賦點數", min_x = 0, add_x = 215, click = 2},
                    {UI_info = env.UI_info, text = "天賦技能", min_x = 0, add_x = 215, click = 2},
                    {UI_info = env.UI_info, text = "黯幣",min_x = 0,min_y = 0,max_y = 81,add_x = 673,add_y = 4,click = 2},
                    {UI_info = env.UI_info, text = "願望清單",min_x = 0,min_y = 0,max_y = 81,add_x = 673,add_y = 4,click = 2},

                }
                -- 检查单个按钮
                for _, check in ipairs(once_check) do
                    if poe2_api.find_text(check) then
                        poe2_api.dbgp(string.format("检测到按钮: %s，将执行点击操作", check.text))
                        return bret.RUNNING
                    end
                end
                self.once_check = true
            end
            
            -- 藏身处特殊处理
            local current_map_info = env.current_map_info
            local function is_map_device(obj_list)
                if not obj_list or #obj_list == 0 then
                    return false
                end
                for _, i in ipairs(obj_list) do
                    if i.name_utf8 == "MapDevice" then
                        return true
                    end
                end
                return false
            end
            local map = is_map_device(current_map_info)
            if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) and map then
                poe2_api.dbgp("当前位于藏身处")

                -- 检测地图启动失败情况
                if poe2_api.find_text({UI_info = env.UI_info, text = "啟動失敗。地圖無法進入。"}) then
                    poe2_api.dbgp("检测到地图启动失败提示，设置need_SmallRetreat为true")
                    env.need_SmallRetreat = true
                    return bret.RUNNING
                end

                -- 检查背包保存提示
                local save_click = {"你無法將此背包丟置於此。請問要摧毀它嗎？"}
                if poe2_api.find_text({UI_info = env.UI_info, text = save_click, min_x = 0, click = 2}) then
                    poe2_api.dbgp("检测到背包保存提示，将执行保留操作")
                    return bret.RUNNING
                end

                local reward_click = {"任務獎勵","請選擇一個獎勵"}
                if poe2_api.find_text({UI_info = env.UI_info, text = reward_click,min_x = 100}) then 
                    poe2_api.find_text({UI_info = env.UI_info, text = reward_click, min_x = 0 ,add_y = 50,click = 2})
                    if poe2_api.find_text({UI_info = env.UI_info, text ="背包", min_x = 1020} ) then
                        local point = poe2_api.get_space_point({width = 2,height = 2,index = 1})
                        if point then
                            api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                            return bret.RUNNING
                        else 
                            return bret.SUCCESS
                        end
                    else
                        poe2_api.click_keyboard("i")
                        api_Sleep(500)
                        return bret.RUNNING
                    end
                end

                --- 藏身处
                local in_safe = {
                    {UI_info = env.UI_info, text = "購買或販賣", add_x = 270, add_y = -9, click = 2},
                    {UI_info = env.UI_info, text = "選擇藏身處", add_x = 516, click = 2, max_y = 130},
                    {UI_info = env.UI_info, text = "通貨交換", add_x = 300, click = 2},
                    {UI_info = env.UI_info, text = "重組", add_x = 235, add_y = -298, click = 2},
                    {UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", add_x = 240, min_x = 0, click = 2},
                    {UI_info = env.UI_info, text = "回收具有品質或插槽的裝備，以獲得品質通貨和工匠碎片", add_x = 160, add_y = -60, min_x = 0, click = 2},
                    {UI_info = env.UI_info, text = "世界地圖", min_x = 0, add_x = 215, click = 2},
                }
                -- 检查单个按钮
                for _, check in ipairs(in_safe) do
                    if poe2_api.find_text(check) then
                        poe2_api.dbgp(string.format("检测到按钮: %s，将执行点击操作", check.text))
                        return bret.RUNNING
                    end
                end
                
                -- 检查仓库页面
                local warehouse_page = {"倉庫","聖域鎖櫃","公會倉庫"}
                if poe2_api.find_text({UI_info = env.UI_info, text = warehouse_page, min_x = 0}) and 
                poe2_api.find_text({UI_info = env.UI_info, text = "強調物品", min_x = 0}) then
                    poe2_api.dbgp("检测到仓库页面，将执行点击操作")
                    poe2_api.find_text({UI_info = env.UI_info, text = warehouse_page, min_x = 0, click = 2, add_x = 253})
                    return bret.RUNNING
                end
                
                local item = api_Getinventorys(0xd,0)
                if item and next(item) then
                    local width = item[1].end_x - item[1].start_x
                    local height = item[1].end_y - item[1].start_y
                    local item_category = {"One Hand Mace","Two Hand Mace","Warstaff","Wand","Staff","Crossbow","Sceptre","Bow",
                    "Body Armour","Helmet","Gloves","Boots","Shield","Quiver","Focus","Amulet","Belt","Ring","Spear","Buckler"}
                    if poe2_api.table_contains(item[1].category_utf8,item_category) then
                        poe2_api.dbgp("检测到物品，将执行点击操作111111")
                        local index_list ={2,3,4,5,6,7,8,9,0xa,0xb}
                        local point_list = {
                            [2] = {1320,250},
                            [3] = {1151,191},
                            [4] = {1493,191},
                            [5] = {1322,133},
                            [6] = {1410,201},
                            [7] = {1237,255},
                            [8] = {1410,255},
                            [9] = {1213,330},
                            [0xa] = {1431,330},
                            [0xb] = {1322,353},
                        }
                        local point = nil
                        for _, v in ipairs(index_list) do
                            if poe2_api.table_contains(v,{10,11}) then
                                v = string.format("0x%x", v)
                            end
                            local item_player = env["item"..v]
                            if item_player and next(item_player) then
                                if item[1].baseType_utf8 == item_player[1].baseType_utf8 
                                and item[1].DemandStrength == item_player[1].DemandStrength
                                and item[1].DemandAgility == item_player[1].DemandAgility
                                and item[1].DemandWisdom == item_player[1].DemandWisdom
                                and item[1].DemandLevel == item_player[1].DemandLevel
                                and item[1].not_identified == item_player[1].not_identified
                                and item[1].category_utf8 == item_player[1].category_utf8
                                and item[1].color == item_player[1].color then
                                    local current_item = api_Getinventorys(v,0)
                                    if current_item and next(current_item) then
                                        if current_item[1].baseType_utf8 == item_player[1].baseType_utf8 
                                        and current_item[1].DemandStrength == item_player[1].DemandStrength
                                        and current_item[1].DemandAgility == item_player[1].DemandAgility
                                        and current_item[1].DemandWisdom == item_player[1].DemandWisdom
                                        and current_item[1].DemandLevel == item_player[1].DemandLevel
                                        and current_item[1].not_identified == item_player[1].not_identified
                                        and current_item[1].category_utf8 == item_player[1].category_utf8
                                        and current_item[1].color == item_player[1].color then
                                        else
                                            point = point_list[v]
                                            break
                                        end
                                    else
                                        point = point_list[v]
                                        break
                                    end
                                end
                            else
                                point = point_list[v]
                                break
                            end
                        end
                        if point then
                            if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                                api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                                api_Sleep(500)
                                poe2_api.time_p("开背包,城区附着... 耗时 --> ", api_GetTickCount64() - current_time)
                                return bret.RUNNING
                            else
                                poe2_api.dbgp("开背包,城区附着")
                                poe2_api.click_keyboard("i")
                                api_Sleep(300)
                                poe2_api.time_p("开背包,城区附着1... 耗时 --> ", api_GetTickCount64() - current_time)
                                return bret.RUNNING
                            end
                        end
                    end
                    local point = poe2_api.get_space_point({width = width, height = height, info = env.bag_info})
                    
                    poe2_api.dbgp(string.format("物品尺寸: 宽%d, 高%d", width, height))
                    poe2_api.dbgp(point[1],point[2])
                    if point then
                        poe2_api.dbgp(string.format("获取到空间点: (%d, %d)", poe2_api.toInt(point[1]), poe2_api.toInt(point[2])))
                        
                        if poe2_api.find_text({UI_info = env.UI_info, text = "背包",min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                            poe2_api.dbgp("检测到背包文字，将执行点击操作")
                            api_ClickScreen(point[1], point[2])
                            api_Sleep(100)
                            api_ClickScreen(point[1], point[2],1)
                            api_Sleep(500)
                        else
                            poe2_api.dbgp("未检测到背包文字，将按I键打开背包")
                            poe2_api.click_keyboard("i")
                            api_Sleep(500)
                        end
                        return bret.RUNNING
                    else
                        poe2_api.dbgp("警告: 无法获取物品空间点")
                    end
                else
                    poe2_api.dbgp("wufuzhuowu")
                end
            end
            
            if poe2_api.find_text({UI_info = env.UI_info, text = "背包", add_x = 250, min_x = 1020}) then
                poe2_api.click_keyboard("i")
                api_Sleep(500)
                return bret.RUNNING
            end
            
            poe2_api.dbgp("未检测到任何阻挡情况，模块返回SUCCESS状态")
            poe2_api.time_p("Game_Block 耗时 --> ", api_GetTickCount64() - current_time)
            return bret.SUCCESS
        end
    },

    -- 清理遮挡页面
    Game_Block_Inside = {
        run = function(self, env)
            poe2_api.print_log("游戏阻挡处理模块开始执行...")
            poe2_api.dbgp("=== 开始处理游戏阻挡 ===")
            
            local current_time = api_GetTickCount64()
            
            local player_info = env.player_info
            -- if player_info then
            --     return bret.SUCCESS
            -- end
            
            -- poe2_api.dbgp(string.format("当前时间戳: %d", current_time))
            -- poe2_api.dbgp(string.format("当前地图: %s", player_info.current_map_name_utf8 or "未知"))

            -- 检查交易拒绝情况
            local refuse_click = {"等待玩家接受交易請求..."}
            if poe2_api.find_text({UI_info = env.UI_info, text = refuse_click, min_x = 0, add_x = 253, click = 2}) then
                poe2_api.dbgp("检测到交易请求等待，将执行拒绝操作")
                return bret.RUNNING
            end

            ---常驻
            local all_check = {
                {UI_info = env.UI_info, text = "繼續遊戲", add_x = 0, add_y = 0, click = 2},
                {UI_info = env.UI_info, text = "寶石切割", add_x = 280, add_y = 17, click = 2},
                {UI_info = env.UI_info, text = "技能", min_x = 0, add_x = 253, click = 2, max_y = 81},
            }
            -- 检查单个按钮
            for _, check in ipairs(all_check) do
                if poe2_api.find_text(check) then
                    poe2_api.dbgp(string.format("检测到按钮: %s，将执行点击操作", check.text))
                    return bret.RUNNING
                end
            end

            if poe2_api.find_text({UI_info = env.UI_info, text = "私訊", add_x = 265, min_x = 0, max_x = 400, click = 2}) then
                return bret.RUNNING
            end

            -- 检查顶部中间页面按钮
            local top_mid_page = {"傳送", "Checkpoints"}
            if poe2_api.find_text({UI_info = env.UI_info, text = top_mid_page, min_x = 0, add_x = 215, click = 2}) then
                return bret.RUNNING
            end

            -- 按键
            if not self.once_check then
                api_Log("检查是否在主页面11111")
                local once_check = {
                    {UI_info = env.UI_info, text = "精選", add_x = 677, min_x = 0, add_y = 10, click = 2},
                    
                    {UI_info = env.UI_info, text = "社交", min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = "角色", min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = "活動", min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = "選項", min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = "重置天賦點數", min_x = 0, add_x = 215, click = 2},
                    {UI_info = env.UI_info, text = "天賦技能", min_x = 0, add_x = 215, click = 2},
                    {UI_info = env.UI_info, text = "黯幣",min_x = 0,min_y = 0,max_y = 81,add_x = 673,add_y = 4,click = 2},
                    {UI_info = env.UI_info, text = "願望清單",min_x = 0,min_y = 0,max_y = 81,add_x = 673,add_y = 4,click = 2},

                }
                -- 检查单个按钮
                for _, check in ipairs(once_check) do
                    if poe2_api.find_text(check) then
                        poe2_api.dbgp(string.format("检测到按钮: %s，将执行点击操作", check.text))
                        return bret.RUNNING
                    end
                end
                self.once_check = true
            end
            
            -- 藏身处特殊处理
            local current_map_info = env.current_map_info
            local function is_map_device(obj_list)
                if not obj_list or #obj_list == 0 then
                    return false
                end
                for _, i in ipairs(obj_list) do
                    if i.name_utf8 == "MapDevice" then
                        return true
                    end
                end
                return false
            end
            
            if poe2_api.find_text({UI_info = env.UI_info, text = "背包", add_x = 250, min_x = 1020}) then
                poe2_api.click_keyboard("i")
                api_Sleep(500)
                return bret.RUNNING
            end
            
            poe2_api.dbgp("未检测到任何阻挡情况，模块返回SUCCESS状态")
            poe2_api.time_p("Game_Block 耗时 --> ", api_GetTickCount64() - current_time)
            return bret.FAIL
        end
    },

    -- 检查是否需要攻击
    Check_Is_Need_Attack = {
        run = function(self, env)
            poe2_api.print_log("检查是否需要攻击...")
            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            local stuck_monsters = poe2_api.deepCopy(env.stuck_monsters)
            local is_active = true
            local not_sight = false

            if poe2_api.table_contains(env.player_info.current_map_name_utf8,my_game_info.hideout) then
                return bret.FAIL
			end
            
            if not player_info then
                poe2_api.dbgp("玩家信息不存在")
                return bret.RUNNING
            end
            
            if string.find(player_info.current_map_name_utf8, "Claimable") then
                local range_sorted = poe2_api.get_sorted_list(env.range_info, env.player_info)
                for _, i in ipairs(range_sorted) do
                    if i.path_name_utf8 == "Metadata/MiscellaneousObjects/Monolith" then
                        is_active = true
                        not_sight = true
                        break
                    end
                end
                is_active = false
                not_sight = true
            end
            -- 特殊怪物檢查

            local function spcify_monsters()
                local spcify_monsters_name_list = {"巨蛇女王．瑪娜莎"}
                for _, monster in ipairs(env.range_info) do
                    for _, name in ipairs(spcify_monsters_name_list) do
						if monster.name_utf8 == name and monster.life > 0 then

							return true
						end
					end
                end
                return false
            end

            poe2_api.dbgp("is_active:",is_active," ","not_sight:",not_sight)
            if #env.center_point > 0 and env.center_radius > 0 then
                stuck_monsters = {}
            end
            


            nomarl_monster = poe2_api.is_have_mos({range_info = env.range_info, dis = env.min_attack_dis, player_info = player_info,is_active = is_active, not_sight = not_sight,stuck_monsters = stuck_monsters})
            poe2_api.dbgp("nomarl_monster -- > ", nomarl_monster)
            -- api_Log("nomarl_monster -- > ")
            -- api_Log(nomarl_monster)
            Boss_monster = poe2_api.is_have_mos_boss(env.range_info, my_game_info.boss_name)
            poe2_api.dbgp("Boss_monster --> ", Boss_monster)
            -- poe2_api.printTable(Boss_monster)
            local a = spcify_monsters()
            poe2_api.dbgp("spcify_monsters() --> ")
            if nomarl_monster or Boss_monster or spcify_monsters() then
                poe2_api.dbgp("需要攻击")
                poe2_api.time_p("Check_Is_Need_Attack(SUCCESS) 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            else
                poe2_api.dbgp("不需要攻击")
                
                if env.afoot_altar then
                    return bret.RUNNING
                end
                poe2_api.time_p("Check_Is_Need_Attack(FAIL) 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.FAIL
            end
        end
    },

    -- 检查是否需要攻击
    Check_Is_Need_Attack_Inside = {
        run = function(self, env)
            poe2_api.print_log("检查是否需要攻击...")
            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            local stuck_monsters = poe2_api.deepCopy(env.stuck_monsters)
            local is_active = true
            local not_sight = false

            -- if poe2_api.table_contains(env.player_info.current_map_name_utf8,my_game_info.hideout) then
            --     return bret.SUCCESS
			-- end
            
            if not player_info then
                poe2_api.dbgp("玩家信息不存在")
                return bret.RUNNING
            end
            
            if string.find(player_info.current_map_name_utf8, "Claimable") then
                local range_sorted = poe2_api.get_sorted_list(env.range_info, env.player_info)
                for _, i in ipairs(range_sorted) do
                    if i.path_name_utf8 == "Metadata/MiscellaneousObjects/Monolith" then
                        is_active = true
                        not_sight = true
                        break
                    end
                end
                is_active = false
                not_sight = true
            end
            -- 特殊怪物檢查

            local function spcify_monsters()
                local spcify_monsters_name_list = {"巨蛇女王．瑪娜莎"}
                for _, monster in ipairs(env.range_info) do
                    for _, name in ipairs(spcify_monsters_name_list) do
						if monster.name_utf8 == name and monster.life > 0 then
							return true
						end
					end
                end
                return false
            end
            poe2_api.dbgp("is_active:",is_active," ","not_sight:",not_sight)
            if #env.center_point > 0 and env.center_radius > 0 then
                stuck_monsters = {}
            end
            
            nomarl_monster = poe2_api.is_have_mos({range_info = env.range_info, dis = env.min_attack_dis, player_info = player_info,is_active = is_active, not_sight = not_sight,stuck_monsters = stuck_monsters})
            poe2_api.dbgp("nomarl_monster -- > ", nomarl_monster)
            Boss_monster = poe2_api.is_have_mos_boss(env.range_info, my_game_info.boss_name)
            poe2_api.dbgp("Boss_monster --> ", Boss_monster)
            if nomarl_monster or Boss_monster or spcify_monsters() then
                poe2_api.dbgp("需要攻击")
                poe2_api.time_p("Check_Is_Need_Attack(FAIL) 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.FAIL
            else
                poe2_api.dbgp("不需要攻击")
                -- if env.afoot_altar then
                --     return bret.RUNNING
                -- end
                poe2_api.time_p("Check_Is_Need_Attack(FAIL) 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
        end
    },

    -- 释放技能动作
    ReleaseSkillAction_Inside = {
        run = function(self, env)
            local current_time_ms = api_GetTickCount64()
            local player_info = env.player_info
            env.select_skill = nil
            --- 辅助函数
            -- 根据稀有度获取可释放的技能

            local available_skills = {}
            local function _get_available_skills(monster_rarity)
                -- 根据怪物稀有度获取可用技能
                local current_time = api_GetTickCount64()
                
                for _, skill in ipairs(self.skills) do
                    
                    -- 检查冷却
                    poe2_api.dbgp("current_time --> ",current_time)
                    poe2_api.dbgp("skill.name --> ",skill.name)
                    poe2_api.dbgp("self.skill_cooldowns[skill.name] --> ",self.skill_cooldowns[skill.name])
                    if current_time < (self.skill_cooldowns[skill.name] or 0) then
                        goto continue
                    end
                    
                    -- 检查技能是否适合攻击该稀有度怪物
                    if monster_rarity == 3 then  -- Boss
                        if not skill.target_targets["Boss"] then
                            goto continue
                        end
                    elseif monster_rarity == 2 then  -- 黄怪
                        if not skill.target_targets["黃怪"] then
                            goto continue
                        end
                    elseif monster_rarity == 1 then  -- 蓝怪
                        if not skill.target_targets["藍怪"] then
                            goto continue
                        end
                    elseif monster_rarity == 0 then  -- 白怪
                        if not skill.target_targets["白怪"] then
                            goto continue
                        end
                    end
                    
                    table.insert(available_skills, skill)
                    
                    ::continue::
                end
                return available_skills
            end

            -- 取可释放的单个技能
            local function _select_skill(available_skills)
                local current_time = api_GetTickCount64()

                local skill_setting = env.user_config["技能設置"]

                
                -- 参数检查
                if type(available_skills) ~= "table" or #available_skills == 0 then
                    error("Invalid skills list: " .. tostring(available_skills))
                end
                
                -- 筛选有效技能（有数字间隔的技能）
                local valid_skills = {}
                for _, skill in ipairs(available_skills) do
                    if type(skill.interval) == "number" then
                        table.insert(valid_skills, skill)
                    end
                end
                
                if #valid_skills == 0 then
                    error("No valid skills with numeric intervals")
                end
                
                -- 排序技能（先按interval降序，再按priority升序）
                table.sort(valid_skills, function(a, b)
                    if a.interval ~= b.interval then
                        return a.interval > b.interval  -- 降序
                    else
                        return (a.priority or 0) < (b.priority or 0)  -- 升序
                    end
                end)
                
                -- 获取最大间隔值
                local max_interval = valid_skills[1].interval
                local candidates = {}
                for _, skill in ipairs(valid_skills) do
                    if skill.interval == max_interval then
                        table.insert(candidates, skill)
                    else
                        break  -- 因为已排序，可以提前退出
                    end
                end
                
                -- 随机选择一个候选技能
                if #candidates > 0 then
                    return candidates[math.random(#candidates)]
                else
                    return nil
                end
            end

            -- 获取技能设置
            local function parse_skill_config()
                local skill_setting = env.user_config["技能設置"]
                local new_skills = {}
                local new_sup_skills = {}
                local preserved_cooldowns = {}
                local sup_preserved_cooldowns = {}
                local current_time = api_GetTickCount64()
                
                -- 确保skill_cooldowns表存在
                if not self.skill_cooldowns then
                    self.skill_cooldowns = {}
                end
                if not self.sup_skill_cooldowns then
                    self.sup_skill_cooldowns = {}
                end

                if not self.all_skill_infos or self.all_skill_infos == nil then
                    self.all_skill_infos = api_GetSkillSlots()
                end

                if not self.all_skill or self.all_skill == nil then
                    self.all_skill = api_GetSelectableSkillControls()
                end
                -- poe2_api.dbgp("22222222222222222222")
                -- poe2_api.printTable(api_GetSkillSlots())
                -- poe2_api.dbgp("111111111111111111111")
                -- poe2_api.printTable(api_GetSelectableSkillControls())
                -- poe2_api.dbgp("33333333333333333")
                -- api_Sleep(10000)
                local skill_pos = {
                    ["q"] = {1194, 1230},
                    ["w"] = {1236, 1272},
                    ["e"] = {1279, 1315},
                    ["r"] = {1322, 1358},
                    ["t"] = {1365, 1401},
                }

                -- 首先建立按键到控件的映射
                local key_to_control = {}
                if self.all_skill and next(self.all_skill) ~= nil then
                    for _, control in ipairs(self.all_skill) do
                        if not control.text_utf8 or control.text_utf8 == "" then
                            goto continue
                        end
                        -- 跳过非主技能栏的技能
                        if control.top > 845 and control.left > 1190 then
                            for key, range in pairs(skill_pos) do
                                local pos = (control.left + control.right) / 2
                                if pos >= range[1] and pos <= range[2] then
                                    key_to_control[key] = control
                                    break
                                end
                            end
                        end
                        ::continue::
                    end
                end
                
                -- 创建按键到技能ID的映射
                local key_to_skill_id = {}
                for key, skill_data in pairs(skill_setting) do
                    if skill_data["启用"] then
                        local control = key_to_control[key]
                        if control then
                            for _, skill in ipairs(self.all_skill_infos) do
                                if control.text_utf8 == skill.name_utf8 then
                                    key_to_skill_id[key] = skill.id
                                    break
                                end
                            end
                        end
                    end
                end
                
                -- 遍历技能设置
                for key, skill_data in pairs(skill_setting) do
                    -- 只处理启用技能
                    if skill_data["启用"] then
                        -- 处理攻击技能
                        if skill_data["技能屬性"] == "攻击技能" then
                            local skill = {
                                name = key,
                                key = key,
                                id = key_to_skill_id[key] or 0,
                                interval = (tonumber(skill_data["釋放間隔"]) or 0) / 1000,
                                priority = 1,
                                weight = 1.0,
                                attack = skill_data["釋放對象"],
                                walk_attack = skill_data["走A"],
                                attack_range = tonumber(skill_data["攻擊距離"]) or 100,
                                target_targets = {
                                    ["白怪"] = skill_data["白怪"] or false,
                                    ["藍怪"] = skill_data["藍怪"] or false,
                                    ["黃怪"] = skill_data["黃怪"] or false,
                                    ["Boss"] = skill_data["Boss"] or false
                                }
                            }
                            
                            -- 保留原有冷却时间
                            if self.skill_cooldowns[skill.name] then
                                preserved_cooldowns[skill.name] = self.skill_cooldowns[skill.name]
                            else
                                preserved_cooldowns[skill.name] = 0
                            end
                            
                            table.insert(new_skills, skill)
                            
                        -- 处理辅助技能
                        elseif skill_data["技能屬性"] == "辅助技能" then
                            local sup_skill = {
                                name = key,
                                key = key,
                                id = key_to_skill_id[key] or 0,
                                interval = (tonumber(skill_data["釋放間隔"]) or 0) / 1000
                            }
                            
                            -- 保留原有冷却时间
                            if self.sup_skill_cooldowns[sup_skill.name] then
                                sup_preserved_cooldowns[sup_skill.name] = self.sup_skill_cooldowns[sup_skill.name]
                            else
                                sup_preserved_cooldowns[sup_skill.name] = 0
                            end
                            
                            table.insert(new_sup_skills, sup_skill)
                        end
                    end
                end
                
                self.skills = new_skills
                self.sup_skills = new_sup_skills
                -- poe2_api.printTable(self.skills)
                self.skill_cooldowns = preserved_cooldowns
                self.sup_skill_cooldowns = sup_preserved_cooldowns

                -- 提取技能权重
                self._skill_weights = {}
                for _, skill in ipairs(self.skills) do
                    table.insert(self._skill_weights, skill.weight)
                end
                
                return {
                    attack_skills = self.skills,
                    support_skills = self.sup_skills
                }
            end
            
            -- 计算释放距离
            local function _calculate_intermediate_position(start_x, start_y, end_x, end_y, ratio)
                local current_time = api_GetTickCount64()
                ratio = ratio or 0.8  -- 默认比例0.8
                
                -- 计算方向向量
                local dx = end_x - start_x
                local dy = end_y - start_y
                
                -- 添加随机扰动（避免完全直线移动）
                if ratio > 0.5 then  -- 靠近目标时增加随机性
                    dx = dx * (0.9 + math.random() * 0.2)  -- 0.9-1.1
                    dy = dy * (0.9 + math.random() * 0.2)
                end
                
                -- 计算中间点
                local mid_x = start_x + dx * ratio
                local mid_y = start_y + dy * ratio
                
                return mid_x, mid_y
            end

            -- 选择释放对象
            local function _calculate_movement(skill, monster, player_info)
                local current_time = api_GetTickCount64()
                local target_type = skill.target or "敵對"
                local move_x, move_y, move_z = nil, nil, nil
                
                -- 根据技能目标类型计算基础位置
                if target_type == "敵對" then
                    move_x = monster.grid_x
                    move_y = monster.grid_y
                    
                elseif target_type == "自身" then
                    -- 对自身释放：小范围随机移动
                    move_x = player_info.grid_x + (math.random() * 4 - 2)  -- -2到2
                    move_y = player_info.grid_y + (math.random() * 4 - 2)
                    move_z =poe2_api.toInt(player_info.world_z)
                    
                elseif target_type == "敵對尸體" then
                    -- 对尸体释放：查找最近的尸体
                    local death_em = poe2_api.enemy_death_target_object({env.range_info,env.player_info})
                    if death_em then
                        move_x = death_em.grid_x + (math.random() * 6 - 3)  -- -3到3
                        move_y = death_em.grid_y + (math.random() * 6 - 3)
                    end
                    
                elseif target_type == "友方召喚物" then
                    -- 对友方召唤物释放
                    local fr_ob = poe2_api.friendly_target_object({env.range_info,env.player_info})
                    if fr_ob then
                        move_x, move_y = api_FindNearestReachablePoint(
                            fr_ob.grid_x,
                            fr_ob.grid_y,
                            20,
                            0
                        )
                    end
                end
                
                -- 默认位置（如果前面未计算）
                if move_x == nil or move_y == nil then
                    move_x = monster.grid_x
                    move_y = monster.grid_y
                    move_z = monster.world_z
                end
                
                -- 特殊技能处理（如传送类技能）
                if skill.key == '`' then
                    -- 计算玩家到怪物的中间位置
                    move_x, move_y = _calculate_intermediate_position(
                        player_info.grid_x,
                        player_info.grid_y,
                        monster.grid_x,
                        monster.grid_y,
                        0.70  -- ratio
                    )
                end
                
                -- poe2_api.dbgp(777777777777777777)
                -- 
                return move_x, move_y, move_z
            end

            -- 释放技能
            local function _execute_skill(skill, monster, player_info)
                poe2_api.dbgp("释放技能=-=-=-->>>>")
                poe2_api.printTable(skill)
                local current_time = api_GetTickCount64()
                
                -- 计算移动位置
                local move_x, move_y, move_z =  _calculate_movement(skill, monster, player_info)

                if self.attack_last_time == nil then
                    self.attack_last_time = api_GetTickCount64()
                end
                
                -- api_ClickMove(math.floor(move_x), math.floor(move_y), poe2_api.toInt(move_z), 0)
                
                -- 设置冷却时间
                local skill_start = api_GetTickCount64()
                local base_cd = skill.interval
                poe2_api.dbgp("base_cd =-=-=-->>>>", base_cd)
                local actual_cd = (math.max(base_cd * (1 + math.random() * 0.2), 0.1)) * 1000
                self.skill_cooldowns[skill.name] = skill_start + actual_cd
                
                -- 释放技能
                -- poe2_api.click_keyboard(skill.key)
                -- poe2_api.dbgp("id=-=-=-->>>>", skill.id)
                -- poe2_api.dbgp("env.player_info.grid_x=-=-=-->>>>", env.player_info.grid_x)
                -- poe2_api.dbgp("env.player_info.grid_y=-=-=-->>>>", env.player_info.grid_y)
                -- poe2_api.dbgp("move_x=-=-=-->>>>", move_x)
                -- poe2_api.dbgp("move_y=-=-=-->>>>", move_y)
                api_CastSkill(skill.id, 0, env.player_info.grid_x, env.player_info.grid_y, move_x, move_y)
                -- api_CastSkill(skill.id, 0, env.player_info.grid_x, env.player_info.grid_y, monster.grid_x, monster.grid_y)

                poe2_api.dbgp("释放技能=-=-=-->>>>", skill.key)
            end

            -- 释放辅助技能
            local function _execute_support_skill(skill, player_info)
                poe2_api.dbgp("释放辅助技能=-=-=-->>>>")
                poe2_api.printTable(skill)
                local current_time = api_GetTickCount64()
                
                -- 设置冷却时间
                local skill_start = api_GetTickCount64()
                local base_cd = skill.interval
                local actual_cd = (math.max(base_cd * (1 + math.random() * 0.2), 0.1)) * 1000
                self.sup_skill_cooldowns[skill.name] = skill_start + actual_cd
                
                -- 释放辅助技能
                if skill.id and skill.id ~= 0 then
                    -- 辅助技能通常不需要目标位置，使用玩家当前位置
                    api_CastSkill(skill.id, 0, env.player_info.grid_x, env.player_info.grid_y, env.player_info.grid_x, env.player_info.grid_y)
                    poe2_api.dbgp("通过技能ID释放辅助技能:", skill.key, "技能ID:", skill.id)
                else
                    -- 备用方案：使用按键释放
                    poe2_api.click_keyboard(skill.key)
                    poe2_api.dbgp("通过按键释放辅助技能:", skill.key)
                end
            end

            -- 检查并释放辅助技能
            local function check_and_cast_support_skills()
                if not self.sup_skills or #self.sup_skills == 0 then
                    return
                end
                
                local current_time = api_GetTickCount64()
                
                -- 按优先级排序辅助技能
                table.sort(self.sup_skills, function(a, b)
                    return a.priority > b.priority
                end)
                
                for _, skill in ipairs(self.sup_skills) do
                    -- 检查冷却时间
                    local last_cast = self.sup_skill_cooldowns[skill.name] or 0
                    if current_time - last_cast >= skill.interval * 1000 then
                        _execute_support_skill(skill, env.player_info)
                    end
                end
            end

            -- check_and_cast_support_skills()
            
            -- 特殊boss处理
            local function _handle_special_boss_movement(boss, player_info)
                local current_time = api_GetTickCount64()
                
                -- 使用pcall进行错误处理（替代try-catch）
                -- 计算安全距离（30单位）
                local safe_distance = 30
                local angle = math.atan2(
                    boss.grid_y - player_info.grid_y,
                    boss.grid_x - player_info.grid_x
                )
                
                -- 计算目标位置（保持安全距离）
                local target_x = boss.grid_x - safe_distance * math.cos(angle)
                local target_y = boss.grid_y - safe_distance * math.sin(angle)
                
                -- 寻找可达点
                local reachable_x, reachable_y = api_FindNearestReachablePoint(
                    target_x, 
                    target_y,
                    safe_distance * 0.7,  -- radius
                    0  -- z
                )
                
                -- 设置移动目标
                env.attack_move = true
                env.end_point = {reachable_x, reachable_y}
            
            end

            

            --- 主要动作
            poe2_api.dbgp("释放技能...")
            nearest_distance_sq = math.huge

            -- 加载技能设置
            if not self.is_have_skills then
                poe2_api.dbgp("加载技能设置...")
                self.stuck_monsters = {}
                
                parse_skill_config()
                self.is_have_skills = true
                return bret.RUNNING
            end


            if not self.skills or #self.skills == 0 then
                poe2_api.dbgp("主动攻击无技能")
                return bret.FAIL
            end

            if (player_info.mana < (player_info.max_mana * 0.15)) then
                poe2_api.dbgp("蓝量小于15%")
                return bret.FAIL
            end

            -- 是否激活
            local is_active = true
            if string.find(env.player_info.current_map_name_utf8 or "", "Claimable") then
                local range_sorted = poe2_api.get_sorted_list(env.range_info, env.player_info)
                for _, i in ipairs(range_sorted) do
                    if i.path_name_utf8 == "Metadata/MiscellaneousObjects/Monolith" then
                        is_active = true
                        break
                    end
                end
                is_active = false
            end

            local valid_monsters = nil
            
            -- 怪物筛选和处理逻辑
            for _, monster in ipairs(env.range_info) do
                if monster.name_utf8 == "" then
                    goto continue
                end
                -- poe2_api.dbgp("monster ------------------------------------------------------->")
                -- poe2_api.printTable(monster)
                -- poe2_api.dbgp("monster name -->" ,monster.name_utf8)
                -- poe2_api.dbgp("obj: ",tostring(string.format("%x",monster.obj)))
                -- poe2_api.dbgp("monster -->" ,monster.life)
                -- local a = monster
                -- poe2_api.print_log("a monster ------------------------------------------------------->")
                -- poe2_api.print_log("a monster name -->" ,a.name_utf8)
                -- poe2_api.print_log("a obj: ",tostring(string.format("%x",a.obj)))
                -- poe2_api.print_log("a monster -->" ,a.life)

                -- 快速失败条件检查（按计算成本从低到高排序）
                if not monster.is_selectable or          -- 可选性检查
                monster.is_friendly or                -- 友方检查
                monster.life <= 0 or                  -- 生命值检查
                monster.name_utf8 == "" or              -- 名称检查
                poe2_api.table_contains(my_game_info.not_attact_mons_CN_name, monster.name_utf8) or
                poe2_api.table_contains(my_game_info.not_attact_mons_path_name , monster.path_name_utf8) then  -- 路径名检查
                    goto continue
                end
                if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                    goto continue
                end    
                -- poe2_api.dbgp("monster ------------------------------------------------------->")
                -- poe2_api.dbgp("monster name -->" ,monster.name_utf8)
                -- poe2_api.dbgp("obj: ",tostring(string.format("%x",monster.obj)))
                -- poe2_api.dbgp("monster -->" ,monster.life)

                -- if string.find(monster.path_name_utf8,"Metadata/Monsters/TormentedSpirits/") then
                --     goto continue
                -- end

                -- 检查是否在中心点半径范围内
                if #env.center_point > 0 and env.center_radius > 0 then
                    local distance_to_center = math.sqrt(
                        (monster.grid_x - env.center_point[1])^2 + 
                        (monster.grid_y - env.center_point[2])^2
                    )
                    if distance_to_center > env.center_radius then
                        goto continue  -- 超出范围则跳过
                    end
                else
                    if self.stuck_monsters and poe2_api.table_contains(self.stuck_monsters, monster.id) then
                        goto continue
                    end
                end
                
                -- 是否激活  
                if (not monster.isActive) and is_active then
                    goto continue
                end

                -- 稀有度检查
                if env.not_attack_mos and env.not_attack_mos[monster.rarity] then
                    goto continue
                end

                -- 计算距离平方
                local distance_sq = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
                -- poe2_api.dbgp("当前怪物：",monster.name_utf8,"，距离：",distance_sq,"米")

                if not player_info.isInBossBattle and monster.rarity ~= 3 and not string.find(player_info.current_map_name_utf8 or "", "Claimable") then
                    if monster.hasLineOfSight and distance_sq < nearest_distance_sq then
                        nearest_distance_sq = distance_sq
                        valid_monsters = monster

                    end
                else
                    if distance_sq < nearest_distance_sq then
                        nearest_distance_sq = distance_sq
                        valid_monsters = monster
                    end
                end
                ::continue::
            end

            if valid_monsters then
                -- 获取当前目标ID
                local current_target_id = valid_monsters and valid_monsters.id or nil
                -- poe2_api.dbgp("a valid_monsters ------------------------------------------------------->")
                -- poe2_api.dbgp("a valid_monsters name -->" ,valid_monsters.name_utf8)
                -- poe2_api.dbgp("a valid_monsters path_name -->" ,valid_monsters.path_name_utf8)
                -- poe2_api.dbgp("a valid_monsters: ",tostring(string.format("%x",valid_monsters.obj)))
                -- poe2_api.dbgp("a life -->" ,valid_monsters.life)
                -- poe2_api.dbgp("a grid_x -->" ,valid_monsters.grid_x)
                -- poe2_api.dbgp("a grid_y -->" ,valid_monsters.grid_y)


                if not (#env.center_point > 0 and env.center_radius > 0) then
                    -- 第二次遍历进行卡住检测和其他处理
                    for _, monster in ipairs(env.range_info) do
                        local current_time = api_GetTickCount64()

                        if string.find(player_info.current_map_name_utf8,"Abyss") then
                            break
                        end  
                        
                        -- 快速失败条件检查
                        if not monster.is_selectable or 
                        poe2_api.table_contains(self.stuck_monsters,monster.id) or 
                        monster.is_friendly then
                            goto continue_second
                        end
                        if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                            goto continue_second
                        end   
                        -- Metadata/Monsters/TormentedSpirits/Cat/SpiritOfTheCat
                        -- if string.find(monster.path_name_utf8,"Metadata/Monsters/TormentedSpirits/") then
                        --     goto continue_second
                        -- end

                        if monster.name_utf8 == "" then
                            goto continue_second
                        end

                        -- 黑名单检查
                        if poe2_api.table_contains(my_game_info.not_attact_mons_CN_name, monster.name_utf8) or
                            poe2_api.table_contains(my_game_info.not_attact_mons_path_name, monster.path_name_utf8) or
                        string.find(monster.name_utf8 or "", "神殿") then
                            goto continue_second
                        end
                        
                        --- 基础状态检查       
                        if (not monster.isActive) and is_active then
                            goto continue_second
                        end

                        if not (monster.life > 0) then
                            goto continue_second
                        end
                        
                        -- 死亡怪物处理
                        if monster.life <= 0 then
                            self.monster_tracker[monster.id] = nil
                            self.stuck_monsters = {}
                            goto continue_second
                        end
                        
                        -- 卡住检测（仅对当前目标）
                        if monster.id == current_target_id then
                            -- 目标切换时重置所有数据
                            if current_target_id ~= self.last_target_id then
                                self.current_target_data = {
                                    first_seen = current_time,
                                    last_seen = current_time,
                                    initial_life = monster.life,
                                    grid_x = monster.grid_x,
                                    grid_y = monster.grid_y,
                                    rarity = monster.rarity
                                }
                                self.last_target_id = current_target_id
                            else
                                -- 仅更新时间戳
                                self.current_target_data.last_seen = current_time
                            end
                            
                            -- 计算存活时间和生命比例
                            local time_elapsed = current_time - self.current_target_data.first_seen
                            local life_ratio = monster.life / math.max(self.current_target_data.initial_life, 1)
                            
                            -- 获取稀有度对应的时间阈值
                            local rarity_index = math.min(monster.rarity, 3) + 1  -- Lua数组从1开始
                            local time_thresholds = {45, 60, 120, 180}
                            local time_threshold = (time_thresholds[rarity_index]) * 1000

                            -- 综合判断条件
                            if time_elapsed > time_threshold and life_ratio > 0.95 then
                                table.insert(self.stuck_monsters, monster.id)
                                poe2_api.dbgp(string.format("%s 卡住（%.1f秒未击杀）", monster.name_utf8 or "未知怪物", time_elapsed / 1000))
                                valid_monsters = nil
                                goto continue_second
                            end
                        end
                        ::continue_second::
                    end
                end
            end

            -- 更新黑板数据
            if self.stuck_monsters then
                env.stuck_monsters = self.stuck_monsters
                -- poe2_api.printTable(self.stuck_monsters)
            end

            env.valid_monsters = valid_monsters

            if valid_monsters then
                -- 计算距离
                local distance = math.sqrt((valid_monsters.grid_x - player_info.grid_x)^2 + 
                                        (valid_monsters.grid_y - player_info.grid_y)^2)

                poe2_api.dbgp("++++++++++++++++++++++++++++++++++")
                poe2_api.dbgp(string.format("攻击 %s(稀有度:%d) | 距离: %.1f",valid_monsters.name_utf8 or "未知怪物", valid_monsters.rarity or 0, distance))
                poe2_api.dbgp("is_friendly: ", tostring(valid_monsters.is_friendly))
                poe2_api.dbgp("hasLineOfSight: ", tostring(valid_monsters.hasLineOfSight))
                poe2_api.dbgp("isActive: ", tostring(valid_monsters.isActive))
                -- poe2_api.dbgp("isActive: ", tostring(valid_monsters.isActive))
                -- poe2_api.dbgp("rarity: ", tostring(valid_monsters.rarity))
                -- poe2_api.dbgp("path_name_utf8: ", tostring(valid_monsters.path_name_utf8))
                poe2_api.dbgp("obj: ", tostring(string.format("%x",valid_monsters.obj)))
                poe2_api.dbgp("grid_x: ", tostring(string.format("%x",valid_monsters.grid_x)))
                poe2_api.dbgp("grid_y: ", tostring(string.format("%x",valid_monsters.grid_y)))
                -- api_ClickMove(valid_monsters.grid_x, valid_monsters.grid_y, player_info.world_z, 0)
                poe2_api.dbgp("magicProperties: ", tostring(valid_monsters.magicProperties))
                poe2_api.printTable(valid_monsters.magicProperties)
                -- poe2_api.dbgp("stateMachineList: ", tostring(valid_monsters.stateMachineList))
                poe2_api.dbgp("血量：", valid_monsters.life )
                -- poe2_api.print_log("type --> ", type(valid_monsters))
                poe2_api.dbgp("++++++++++++++++++++++++++++++++++")
                
                -- 特殊Boss处理
                local special_bosses = {'巨蛇女王．瑪娜莎', '被遺忘的囚犯．帕拉薩'}
                if poe2_api.table_contains(valid_monsters.name_utf8, special_bosses) and distance > 50 and not valid_monsters.isActive then
                    poe2_api.dbgp("special_bosses,或者未激活")
                    _handle_special_boss_movement(valid_monsters, player_info)
                    poe2_api.dbgp("移动到目标附近444")
                    return bret.SUCCESS
                end
                -- 构建可用技能池

                local available_skills = _get_available_skills(valid_monsters.rarity)

                local min_attack_range = 0
                if available_skills and #available_skills > 0 then
                    for _, skill in ipairs(available_skills) do
                        if skill.attack_range > min_attack_range then
                            min_attack_range = skill.attack_range
                        end
                    end
                end

                env.min_attack_range = min_attack_range
                
                if available_skills and #available_skills > 0 then
                    local selected_skill = _select_skill(available_skills)
                    if distance > 25 then
                        poe2_api.printTable(valid_monsters.magicProperties)
                        -- 检查特殊词缀
                        for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                            if poe2_api.table_contains(valid_monsters.magicProperties, prop) then
                                env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                poe2_api.dbgp("移动到目标附近111")
                                return bret.SUCCESS
                            end
                            ::continue_prop::
                        end
                    end

                    poe2_api.dbgp("selected_skill.attack_range", selected_skill.attack_range)
                    poe2_api.dbgp("min_attack_range", min_attack_range)
                    poe2_api.dbgp("distance", distance)

                    if valid_monsters.name_utf8 ~= "骨之暴君．札瓦里" then
                        poe2_api.dbgp("11111111111111")
                        if distance > selected_skill.attack_range and distance > min_attack_range or not valid_monsters.isActive then
                            -- poe2_api.dbgp("移动到目标附近")
                            -- -- 拾取不移动
                            -- if need_item and not env.center_point and not center_radius then
                            --     return bret.FAIL
                            -- end

                            -- if env.is_map_complete then
                            --     -- 寻找传送门
                            --     if env.range_info then
                            --         for _, k in ipairs(env.range_info) do
                            --             if k.name_utf8 ~= '' and k.type == 5 and poe2_api.table_contains(k.name_utf8, my_game_info.hideout_CH) then
                            --                 dis = poe2_api.point_distance(k.grid_x, k.grid_y, player_info)
                            --                 if dis and dis < 25 then
                            --                     if not poe2_api.find_text({UI_info = env.UI_info, text = k.name_utf8, click = 2}) then
                            --                         api_ClickMove(poe2_api.toInt(k.grid_x), poe2_api.toInt(k.grid_y), poe2_api.toInt(k.world_z), 1)
                            --                     end
                            --                 end
                            --             end
                            --         end
                            --     end

                            --     env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                            --     poe2_api.dbgp("移动到目标附近555")
                            --     return bret.SUCCESS
                            -- end
                            
                            if env.afoot_altar then
                                local distance = poe2_api.point_distance(env.afoot_altar.grid_x, env.afoot_altar.grid_y, env.player_info)
                                if distance < 105 then
                                    env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                    poe2_api.dbgp("移动到目标附近222")
                                    return bret.SUCCESS
                                end
                            end

                            if env.afoot_box then
                                local distance = poe2_api.point_distance(env.afoot_box.grid_x, env.afoot_box.grid_y, env.player_info)
                                if distance < 120 then
                                    env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                    poe2_api.dbgp("移动到目标附近333")
                                    return bret.SUCCESS
                                end
                            end
                            
                            if poe2_api.table_contains(valid_monsters.rarity, {2, 3}) then
                                poe2_api.dbgp("精英怪移动到目标附近")
                                env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                return bret.SUCCESS
                            -- else
                            --     return bret.SUCCESS
                            end
                            return bret.FAIL
                        end
                    else
                        if distance > 80 then
                            env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                            poe2_api.dbgp("移动到目标附近333")
                            return bret.SUCCESS
                        end
                    end
                    
                    _execute_skill(selected_skill, valid_monsters, player_info)
                    poe2_api.dbgp("释放：")
                    poe2_api.printTable(selected_skill)
                    env.select_skill = selected_skill
                    -- if valid_monsters.rarity > 1 then
                    --     poe2_api.time_p("ReleaseSkillAction(RUNNING) 耗时 --> ", api_GetTickCount64() - current_time_ms)
                    --     return bret.RUNNING
                    -- end
                    poe2_api.time_p("ReleaseSkillAction 耗时(123123123123) --> ", api_GetTickCount64() - current_time_ms)
                    return bret.FAIL
                end
                poe2_api.dbgp("ReleaseSkillAction bret.FAIL")
                -- return bret.RUNNING
                return bret.FAIL
            end

            poe2_api.time_p("ReleaseSkillAction 耗时(hcdhfhfhfhf) --> ", api_GetTickCount64() - current_time_ms)
            return bret.FAIL
        end
    },

    -- 释放技能动作
    ReleaseSkillAction = {
        run = function(self, env)
            local current_time_ms = api_GetTickCount64()
            --- 辅助函数
            env.select_skill = nil
            -- 根据稀有度获取可释放的技能
            local available_skills = {}
            local function _get_available_skills(monster_rarity)
                -- 根据怪物稀有度获取可用技能
                local current_time = api_GetTickCount64()
                
                for _, skill in ipairs(self.skills) do
                    
                    -- 检查冷却
                    poe2_api.dbgp("current_time --> ",current_time)
                    poe2_api.dbgp("skill.name --> ",skill.name)
                    poe2_api.dbgp("self.skill_cooldowns[skill.name] --> ",self.skill_cooldowns[skill.name])
                    if current_time < (self.skill_cooldowns[skill.name] or 0) then
                        goto continue
                    end
                    
                    -- 检查技能是否适合攻击该稀有度怪物
                    if monster_rarity == 3 then  -- Boss
                        if not skill.target_targets["Boss"] then
                            goto continue
                        end
                    elseif monster_rarity == 2 then  -- 黄怪
                        if not skill.target_targets["黃怪"] then
                            goto continue
                        end
                    elseif monster_rarity == 1 then  -- 蓝怪
                        if not skill.target_targets["藍怪"] then
                            goto continue
                        end
                    elseif monster_rarity == 0 then  -- 白怪
                        if not skill.target_targets["白怪"] then
                            goto continue
                        end
                    end
                    
                    table.insert(available_skills, skill)
                    
                    ::continue::
                end
                return available_skills
            end

            -- 取可释放的单个技能
            local function _select_skill(available_skills)
                local current_time = api_GetTickCount64()
                
                -- 参数检查
                if type(available_skills) ~= "table" or #available_skills == 0 then
                    error("Invalid skills list: " .. tostring(available_skills))
                end
                
                -- 筛选有效技能（有数字间隔的技能）
                local valid_skills = {}
                for _, skill in ipairs(available_skills) do
                    if type(skill.interval) == "number" then
                        table.insert(valid_skills, skill)
                    end
                end
                
                if #valid_skills == 0 then
                    error("No valid skills with numeric intervals")
                end
                
                -- 排序技能（先按interval降序，再按priority升序）
                table.sort(valid_skills, function(a, b)
                    if a.interval ~= b.interval then
                        return a.interval > b.interval  -- 降序
                    else
                        return (a.priority or 0) < (b.priority or 0)  -- 升序
                    end
                end)
                
                -- 获取最大间隔值
                local max_interval = valid_skills[1].interval
                local candidates = {}
                for _, skill in ipairs(valid_skills) do
                    if skill.interval == max_interval then
                        table.insert(candidates, skill)
                    else
                        break  -- 因为已排序，可以提前退出
                    end
                end
                
                -- 随机选择一个候选技能
                if #candidates > 0 then
                    return candidates[math.random(#candidates)]
                else
                    return nil
                end
            end

            -- 获取技能设置
            local function parse_skill_config()
                local skill_setting = env.user_config["技能設置"]
                local new_skills = {}
                local preserved_cooldowns = {}
                local current_time = api_GetTickCount64()
                
                -- 确保skill_cooldowns表存在
                if not self.skill_cooldowns then
                    self.skill_cooldowns = {}
                end
                
                -- 遍历技能设置
                for key, skill_data in pairs(skill_setting) do
                    -- 只处理启用技能
                    if skill_data["启用"] then
                        -- 处理攻击技能
                        if skill_data["技能屬性"] == "攻击技能"then
                            local skill = {
                                name = key,
                                key = key,
                                interval = (tonumber(skill_data["釋放間隔"]) or 0) / 1000,
                                priority = 1,  -- 默认值
                                weight = 1.0,  -- 默认值
                                attack = skill_data["釋放對象"],
                                attack_range = tonumber(skill_data["攻擊距離"]) or 100,
                                target_targets = {
                                    ["白怪"] = skill_data["白怪"] or false,
                                    ["藍怪"] = skill_data["藍怪"] or false,
                                    ["黃怪"] = skill_data["黃怪"] or false,
                                    ["Boss"] = skill_data["Boss"] or false
                                }
                            }
                            
                            -- 保留原有冷却时间
                            if self.skill_cooldowns[skill.name] then
                                preserved_cooldowns[skill.name] = self.skill_cooldowns[skill.name]
                            else
                                preserved_cooldowns[skill.name] = 0
                            end
                            
                            table.insert(new_skills, skill)
                        end
                    end
                end
                
                self.skills = new_skills
                poe2_api.printTable(self.skills)
                self.skill_cooldowns = preserved_cooldowns
                
                -- 提取技能权重
                self._skill_weights = {}
                for _, skill in ipairs(self.skills) do
                    table.insert(self._skill_weights, skill.weight)
                end
                
            end
            
            -- 计算释放距离
            local function _calculate_intermediate_position(start_x, start_y, end_x, end_y, ratio)
                local current_time = api_GetTickCount64()
                ratio = ratio or 0.8  -- 默认比例0.8
                
                -- 计算方向向量
                local dx = end_x - start_x
                local dy = end_y - start_y
                
                -- 添加随机扰动（避免完全直线移动）
                if ratio > 0.5 then  -- 靠近目标时增加随机性
                    dx = dx * (0.9 + math.random() * 0.2)  -- 0.9-1.1
                    dy = dy * (0.9 + math.random() * 0.2)
                end
                
                -- 计算中间点
                local mid_x = start_x + dx * ratio
                local mid_y = start_y + dy * ratio
                
                return mid_x, mid_y
            end

            -- 选择释放对象
            local function _calculate_movement(skill, monster, player_info)
                local current_time = api_GetTickCount64()
                local target_type = skill.target or "敵對"
                local move_x, move_y, move_z = nil, nil, nil
                
                -- 根据技能目标类型计算基础位置
                if target_type == "敵對" then
                    -- 对敌人释放：向怪物方向移动，但保持一定距离
                    local angle = math.random() * 2 * math.pi  -- 随机角度
                    local distance = 2 + math.random() * 3    -- 随机距离2-5
                    move_x = monster.grid_x
                    move_y = monster.grid_y
                    move_z = monster.world_z
                    
                elseif target_type == "自身" then
                    -- 对自身释放：小范围随机移动
                    move_x = player_info.grid_x + (math.random() * 4 - 2)  -- -2到2
                    move_y = player_info.grid_y + (math.random() * 4 - 2)
                    move_z =poe2_api.toInt(player_info.world_z)
                    
                elseif target_type == "敵對尸體" then
                    -- 对尸体释放：查找最近的尸体
                    local death_em = poe2_api.enemy_death_target_object({env.range_info,env.player_info})
                    if death_em then
                        move_x = death_em.grid_x + (math.random() * 6 - 3)  -- -3到3
                        move_y = death_em.grid_y + (math.random() * 6 - 3)
                    end
                    
                elseif target_type == "友方召喚物" then
                    -- 对友方召唤物释放
                    local fr_ob = poe2_api.friendly_target_object({env.range_info,env.player_info})
                    if fr_ob then
                        move_x, move_y = api_FindNearestReachablePoint(
                            fr_ob.grid_x,
                            fr_ob.grid_y,
                            20,
                            0
                        )
                    end
                end
                
                -- 默认位置（如果前面未计算）
                if move_x == nil or move_y == nil then
                    move_x = monster.grid_x
                    move_y = monster.grid_y
                    move_z = monster.world_z
                end
                
                -- 特殊技能处理（如传送类技能）
                if skill.key == '`' then
                    -- 计算玩家到怪物的中间位置
                    move_x, move_y = _calculate_intermediate_position(
                        player_info.grid_x,
                        player_info.grid_y,
                        monster.grid_x,
                        monster.grid_y,
                        0.70  -- ratio
                    )
                end
                
                -- poe2_api.dbgp(777777777777777777)
                -- 
                return move_x, move_y, move_z
            end

            -- 释放技能
            local function _execute_skill(skill, monster, player_info)
                poe2_api.dbgp("释放技能=-=-=-->>>>")
                poe2_api.printTable(skill)
                local current_time = api_GetTickCount64()
                
                -- 计算移动位置
                local move_x, move_y, move_z =  _calculate_movement(skill, monster, player_info)

                if self.attack_last_time == nil then
                    self.attack_last_time = api_GetTickCount64()
                end

                api_ClickMove(math.floor(move_x), math.floor(move_y), poe2_api.toInt(move_z), 0)
                
                -- 设置冷却时间
                local skill_start = api_GetTickCount64()
                local base_cd = skill.interval
                poe2_api.dbgp("base_cd =-=-=-->>>>", base_cd)
                local actual_cd = (math.max(base_cd * (1 + math.random() * 0.2), 0.1)) * 1000
                self.skill_cooldowns[skill.name] = skill_start + actual_cd
                
                -- 释放技能
                poe2_api.click_keyboard(skill.key)
                poe2_api.dbgp("释放技能=-=-=-->>>>", skill.key)
            end
            
            -- 特殊boss处理
            local function _handle_special_boss_movement(boss, player_info)
                local current_time = api_GetTickCount64()
                
                -- 使用pcall进行错误处理（替代try-catch）
                -- 计算安全距离（30单位）
                local safe_distance = 30
                local angle = math.atan2(
                    boss.grid_y - player_info.grid_y,
                    boss.grid_x - player_info.grid_x
                )
                
                -- 计算目标位置（保持安全距离）
                local target_x = boss.grid_x - safe_distance * math.cos(angle)
                local target_y = boss.grid_y - safe_distance * math.sin(angle)
                
                -- 寻找可达点
                local reachable_x, reachable_y = api_FindNearestReachablePoint(
                    target_x, 
                    target_y,
                    safe_distance * 0.7,  -- radius
                    0  -- z
                )
                
                -- 设置移动目标
                env.attack_move = true
                env.end_point = {reachable_x, reachable_y}
            
            end

            

            poe2_api.dbgp("释放技能...")
            nearest_distance_sq = math.huge

            -- 加载技能设置
            if not self.is_have_skills then
                poe2_api.dbgp("加载技能设置...")
                self.stuck_monsters = {}
                
                parse_skill_config()
                self.is_have_skills = true
                return bret.RUNNING
            end


            if not self.skills or #self.skills == 0 then
                poe2_api.dbgp("主动攻击无技能")
                return bret.FAIL
            end

            if (player_info.mana < (player_info.max_mana * 0.15)) then
                poe2_api.dbgp("蓝量小于15%")
                return bret.FAIL
            end

            -- 是否激活
            local is_active = true
            if string.find(env.player_info.current_map_name_utf8 or "", "Claimable") then
                local range_sorted = poe2_api.get_sorted_list(env.range_info, env.player_info)
                for _, i in ipairs(range_sorted) do
                    if i.path_name_utf8 == "Metadata/MiscellaneousObjects/Monolith" then
                        is_active = true
                        break
                    end
                end
                is_active = false
            end

            local valid_monsters = nil
            
            -- 怪物筛选和处理逻辑
            for _, monster in ipairs(env.range_info) do
                -- if monster.name_utf8 == "" then
                --     goto continue
                -- end
                -- poe2_api.dbgp("monster ------------------------------------------------------->")
                -- poe2_api.dbgp("monster name -->" ,monster.name_utf8)
                -- poe2_api.dbgp("obj: ",tostring(string.format("%x",monster.obj)))
                -- poe2_api.dbgp("monster -->" ,monster.life)
                -- local a = monster
                -- poe2_api.print_log("a monster ------------------------------------------------------->")
                -- poe2_api.print_log("a monster name -->" ,a.name_utf8)
                -- poe2_api.print_log("a obj: ",tostring(string.format("%x",a.obj)))
                -- poe2_api.print_log("a monster -->" ,a.life)

                -- 快速失败条件检查（按计算成本从低到高排序）
                if not monster.is_selectable or          -- 可选性检查
                monster.is_friendly or                -- 友方检查
                monster.life <= 0 or                  -- 生命值检查
                monster.name_utf8 == "" or              -- 名称检查
                poe2_api.table_contains(my_game_info.not_attact_mons_CN_name, monster.name_utf8) or
                poe2_api.table_contains(my_game_info.not_attact_mons_path_name , monster.path_name_utf8) then  -- 路径名检查
                    goto continue
                end
                if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                    goto continue
                end   
                -- if string.find(monster.path_name_utf8,"Metadata/Monsters/TormentedSpirits/") then
                --     goto continue
                -- end

                -- 检查是否在中心点半径范围内
                if #env.center_point > 0 and env.center_radius > 0 then
                    local distance_to_center = math.sqrt(
                        (monster.grid_x - env.center_point[1])^2 + 
                        (monster.grid_y - env.center_point[2])^2
                    )
                    if distance_to_center > env.center_radius then
                        goto continue  -- 超出范围则跳过
                    end
                else
                    if self.stuck_monsters and poe2_api.table_contains(self.stuck_monsters, monster.id) then
                        goto continue
                    end
                end
                
                -- 是否激活  
                if (not monster.isActive) and is_active then
                    goto continue
                end

                -- 稀有度检查
                if env.not_attack_mos and env.not_attack_mos[monster.rarity] then
                    goto continue
                end

               
                
                -- 计算距离平方
                local distance_sq = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
                -- poe2_api.dbgp("当前怪物：",monster.name_utf8,"，距离：",distance_sq,"米") q

                if not player_info.isInBossBattle and monster.rarity ~= 3 and not string.find(player_info.current_map_name_utf8 or "", "Claimable") then
                    if monster.hasLineOfSight and distance_sq < nearest_distance_sq then
                        nearest_distance_sq = distance_sq
                        valid_monsters = monster

                    end
                else
                    if distance_sq < nearest_distance_sq then
                        nearest_distance_sq = distance_sq
                        valid_monsters = monster
                    end
                end
                ::continue::
            end

            if valid_monsters then
                -- 获取当前目标ID
                local current_target_id = valid_monsters and valid_monsters.id or nil
                poe2_api.dbgp("a valid_monsters ------------------------------------------------------->")
                poe2_api.dbgp("a valid_monsters name -->" ,valid_monsters.name_utf8)
                poe2_api.dbgp("a valid_monsters path_name -->" ,valid_monsters.path_name_utf8)
                poe2_api.dbgp("a valid_monsters: ",tostring(string.format("%x",valid_monsters.obj)))
                poe2_api.dbgp("a life -->" ,valid_monsters.life)
                poe2_api.dbgp("a grid_x -->" ,valid_monsters.grid_x)
                poe2_api.dbgp("a grid_y -->" ,valid_monsters.grid_y)


                if not (#env.center_point > 0 and env.center_radius > 0) then
                    -- 第二次遍历进行卡住检测和其他处理
                    for _, monster in ipairs(env.range_info) do
                        local current_time = api_GetTickCount64()

                        if string.find(player_info.current_map_name_utf8,"Abyss") then
                            break
                        end  

                        -- 快速失败条件检查
                        if not monster.is_selectable or 
                        poe2_api.table_contains(self.stuck_monsters,monster.id) or 
                        monster.is_friendly then
                            goto continue_second
                        end

                        if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                            goto continue_second
                        end  

                        -- Metadata/Monsters/TormentedSpirits/Cat/SpiritOfTheCat
                        -- if string.find(monster.path_name_utf8,"Metadata/Monsters/TormentedSpirits/") then
                        --     goto continue_second
                        -- end

                        if monster.name_utf8 == "" then
                            goto continue_second
                        end

                        -- 黑名单检查
                        if poe2_api.table_contains(my_game_info.not_attact_mons_CN_name, monster.name_utf8) or
                            poe2_api.table_contains(my_game_info.not_attact_mons_path_name, monster.path_name_utf8) or
                        string.find(monster.name_utf8 or "", "神殿") then
                            goto continue_second
                        end
                        
                        --- 基础状态检查       
                        if (not monster.isActive) and is_active then
                            goto continue_second
                        end

                        if not (monster.life > 0) then
                            goto continue_second
                        end
                        
                        -- 死亡怪物处理
                        if monster.life <= 0 then
                            self.monster_tracker[monster.id] = nil
                            self.stuck_monsters = {}
                            goto continue_second
                        end
                        
                        -- 卡住检测（仅对当前目标）
                        if monster.id == current_target_id then
                            -- 目标切换时重置所有数据
                            if current_target_id ~= self.last_target_id then
                                self.current_target_data = {
                                    first_seen = current_time,
                                    last_seen = current_time,
                                    initial_life = monster.life,
                                    grid_x = monster.grid_x,
                                    grid_y = monster.grid_y,
                                    rarity = monster.rarity
                                }
                                self.last_target_id = current_target_id
                            else
                                -- 仅更新时间戳
                                self.current_target_data.last_seen = current_time
                            end
                            
                            -- 计算存活时间和生命比例
                            local time_elapsed = current_time - self.current_target_data.first_seen
                            local life_ratio = monster.life / math.max(self.current_target_data.initial_life, 1)
                            
                            -- 获取稀有度对应的时间阈值
                            local rarity_index = math.min(monster.rarity, 3) + 1  -- Lua数组从1开始
                            local time_thresholds = {45, 60, 120, 180}
                            local time_threshold = (time_thresholds[rarity_index]) * 1000

                            -- 综合判断条件
                            if time_elapsed > time_threshold and life_ratio > 0.95 then
                                table.insert(self.stuck_monsters, monster.id)
                                poe2_api.dbgp(string.format("%s 卡住（%.1f秒未击杀）", monster.name_utf8 or "未知怪物", time_elapsed / 1000))
                                valid_monsters = nil
                                goto continue_second
                            end
                        end
                        ::continue_second::
                    end
                end
            end

            -- 更新黑板数据
            if self.stuck_monsters then
                env.stuck_monsters = self.stuck_monsters
                -- poe2_api.printTable(self.stuck_monsters)
            end

            env.valid_monsters = valid_monsters

            if valid_monsters then
                -- 计算距离
                local distance = math.sqrt((valid_monsters.grid_x - player_info.grid_x)^2 + 
                                        (valid_monsters.grid_y - player_info.grid_y)^2)

                poe2_api.dbgp("++++++++++++++++++++++++++++++++++")
                poe2_api.dbgp(string.format("攻击 %s(稀有度:%d) | 距离: %.1f",valid_monsters.name_utf8 or "未知怪物", valid_monsters.rarity or 0, distance))
                poe2_api.dbgp("is_friendly: ", tostring(valid_monsters.is_friendly))
                poe2_api.dbgp("hasLineOfSight: ", tostring(valid_monsters.hasLineOfSight))
                poe2_api.dbgp("isActive: ", tostring(valid_monsters.isActive))
                -- poe2_api.dbgp("isActive: ", tostring(valid_monsters.isActive))
                -- poe2_api.dbgp("rarity: ", tostring(valid_monsters.rarity))
                -- poe2_api.dbgp("path_name_utf8: ", tostring(valid_monsters.path_name_utf8))
                poe2_api.dbgp("obj: ", tostring(string.format("%x",valid_monsters.obj)))
                poe2_api.dbgp("grid_x: ", tostring(string.format("%x",valid_monsters.grid_x)))
                poe2_api.dbgp("grid_y: ", tostring(string.format("%x",valid_monsters.grid_y)))
                -- api_ClickMove(valid_monsters.grid_x, valid_monsters.grid_y, player_info.world_z, 0)
                poe2_api.dbgp("magicProperties: ", tostring(valid_monsters.magicProperties))
                poe2_api.printTable(valid_monsters.magicProperties)
                -- poe2_api.dbgp("stateMachineList: ", tostring(valid_monsters.stateMachineList))
                poe2_api.dbgp("血量：", valid_monsters.life )
                -- poe2_api.print_log("type --> ", type(valid_monsters))
                poe2_api.dbgp("++++++++++++++++++++++++++++++++++")
                
                -- 特殊Boss处理
                local special_bosses = {'巨蛇女王．瑪娜莎', '被遺忘的囚犯．帕拉薩'}
                if poe2_api.table_contains(valid_monsters.name_utf8, special_bosses) and distance > 50 and not valid_monsters.isActive then
                    poe2_api.dbgp("special_bosses,或者未激活")
                    _handle_special_boss_movement(valid_monsters, player_info)
                    poe2_api.dbgp("移动到目标附近444")
                    return bret.SUCCESS
                end
                -- 构建可用技能池

                local available_skills = _get_available_skills(valid_monsters.rarity)

                local min_attack_range = 0
                if available_skills and #available_skills > 0 then
                    for _, skill in ipairs(available_skills) do
                        if skill.attack_range > min_attack_range then
                            min_attack_range = skill.attack_range
                        end
                    end
                end

                env.min_attack_range = min_attack_range
                
                if available_skills and #available_skills > 0 then
                    local selected_skill = _select_skill(available_skills)
                    if distance > 25 then
                        poe2_api.printTable(valid_monsters.magicProperties)
                        -- 检查特殊词缀
                        for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                            if poe2_api.table_contains(valid_monsters.magicProperties, prop) then
                                env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                poe2_api.dbgp("移动到目标附近111")
                                return bret.SUCCESS
                            end
                            ::continue_prop::
                        end
                    end

                    poe2_api.dbgp("selected_skill.attack_range", selected_skill.attack_range)
                    poe2_api.dbgp("min_attack_range", min_attack_range)
                    poe2_api.dbgp("distance", distance)

                    if valid_monsters.name_utf8 ~= "骨之暴君．札瓦里" then
                        
                        if distance > selected_skill.attack_range and distance > min_attack_range or not valid_monsters.isActive then
                            -- poe2_api.dbgp("移动到目标附近")
                            -- -- 拾取不移动
                            -- if need_item and not env.center_point and not center_radius then
                            --     return bret.SUCCESS
                            -- end

                            if env.is_map_complete then
                                -- 寻找传送门
                                if env.range_info then
                                    for _, k in ipairs(env.range_info) do
                                        if k.name_utf8 ~= '' and k.type == 5 and poe2_api.table_contains(k.name_utf8, my_game_info.hideout_CH) then
                                            dis = poe2_api.point_distance(k.grid_x, k.grid_y, player_info)
                                            if dis and dis < 25 then
                                                if not poe2_api.find_text({UI_info = env.UI_info, text = k.name_utf8, click = 2}) then
                                                    api_ClickMove(poe2_api.toInt(k.grid_x), poe2_api.toInt(k.grid_y), poe2_api.toInt(k.world_z), 1)
                                                end
                                            end
                                        end
                                    end
                                end

                                env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                poe2_api.dbgp("移动到目标附近555")
                                return bret.SUCCESS
                            end
                            
                            if env.afoot_altar then
                                local distance = poe2_api.point_distance(env.afoot_altar.grid_x, env.afoot_altar.grid_y, env.player_info)
                                if distance < 105 then
                                    env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                    poe2_api.dbgp("移动到目标附近222")
                                    return bret.SUCCESS
                                end
                            end

                            if env.afoot_box then
                                local distance = poe2_api.point_distance(env.afoot_box.grid_x, env.afoot_box.grid_y, env.player_info)
                                if distance < 120 then
                                    env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                    poe2_api.dbgp("移动到目标附近333")
                                    return bret.SUCCESS
                                end
                            end
                            
                            -- env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                            return bret.FAIL
                            -- return bret.SUCCESS
                        end
                    else
                        if distance > 80 then
                            env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                            poe2_api.dbgp("移动到目标附近333")
                            return bret.FAIL
                        end
                    end
                    
                    _execute_skill(selected_skill, valid_monsters, player_info)
                    poe2_api.dbgp("释放：")
                    poe2_api.printTable(selected_skill)
                    env.select_skill = selected_skill
                    return bret.RUNNING
                end
                return bret.FAIL
            end

            poe2_api.time_p("ReleaseSkillAction 耗时 --> ", api_GetTickCount64() - current_time_ms)
            return bret.FAIL
        end
    },

    -- 检查是否到达点
    Is_Arrive_Point = {
        run = function(self, env)
            poe2_api.print_log("检查是否到达目标点...")
            return bret.SUCCESS
        end
    },

    -- 进入异界地图节点
    Enter_Map = {
        name = "进入异界地图",
        run = function(self, env)
            local current_time = api_GetTickCount64()
            
            local player_info = env.player_info
            if not poe2_api.table_contains(env.player_info.current_map_name_utf8,my_game_info.hideout) then
                return bret.RUNNING
			end
            poe2_api.print_log("进入异界地图...")
            local is_map_complete = env.is_map_complete
            poe2_api.print_log("进入异界地图env.is_map_complete...", env.is_map_complete)
            local one_other_map = env.one_other_map
            local not_enter_map = env.not_enter_map
            local click_counter = env.enter_map_click_counter or 0
            local error_other_map = env.error_other_map or {}
            local click_grid_pos = env.click_grid_pos
            
            
            -- 检查加载中状态
            if poe2_api.click_text_UI({UI_info = env.UI_info, text = "loading_screen_tip_label"}) then
                return bret.RUNNING
            end

            if poe2_api.find_text({UI_info = env.UI_info, text = "重組", add_x = 240}) then
                poe2_api.click_keyboard("spcae")
                return bret.RUNNING
            end

            if not poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", min_x = 0}) then
                if poe2_api.find_text({UI_info = env.UI_info, text = "背包", add_x = 250, min_x = 1020}) then
                    poe2_api.click_keyboard("i")
                    api_Sleep(500)
                    return bret.RUNNING
                end

                -- 检查仓库页面
                local warehouse_page = {"倉庫","聖域鎖櫃","公會倉庫"}
                if poe2_api.find_text({UI_info = env.UI_info, text = warehouse_page, min_x = 0, add_x = 253}) and
                poe2_api.find_text({UI_info = env.UI_info, text = "強調物品", min_x = 0}) then
                    poe2_api.dbgp("检测到仓库页面，将执行点击操作")
                    poe2_api.find_text({UI_info = env.UI_info, text = warehouse_page, min_x = 0, click = 2, add_x = 253})
                    return bret.RUNNING
                end
            end
            
            -- 获取符合条件的非地图物品（传送点/异界之门除外）
            local function get_not_map(num)
                num = num or 1
                local valid_items = {}
                
                for _, item in ipairs(env.range_info) do
                    if item.type == 5 and item.name_utf8 ~= '' and item.name_utf8 ~= "傳送點" and item.name_utf8 ~= '異界之門' then
                        table.insert(valid_items, item)
                    end
                end
                
                -- 检查是否达到阈值数量
                if #valid_items < num then
                    return false
                end
                
                -- 按距离排序，返回最近的物品
                if #valid_items > 0 then
                    table.sort(valid_items, function(a, b)
                        a_dis = poe2_api.point_distance(a.grid_x, a.grid_y, player_info)
                        b_dis = poe2_api.point_distance(b.grid_x, b.grid_y, player_info)
                        if a_dis and b_dis then
                            return a_dis < b_dis
                        else
                            return false
                        end
                    end)
                    
                    -- -- 打印排序后的结果（调试用）
                    -- for i, item in ipairs(valid_items) do
                    --     local distance = poe2_api.point_distance(item.grid_x, item.grid_y, player_info)
                    --     poe2_api.dbgp(string.format("[dbgp] #%d: %s 距离=%.2f", i, item.name_utf8, distance))
                    -- end
                    
                    return valid_items[1]
                end
                
                return false
            end
            
            -- 点击计数器检查
            if click_counter >= 5 then
                env.is_map_complete = true
                env.one_other_map = nil
                env.enter_map_click_counter = 0
                
                return bret.FAIL
            end
            
            -- 错误文本检查
            local error_text = {"錯誤：無法進入，原因：伺服器斷線。", "錯誤：無法進入。", "啟動失敗。地圖無法進入。"}
            for _, k in ipairs(error_text) do
                if poe2_api.find_text({UI_info = env.UI_info, text = k, min_x = 0}) then
                    if one_other_map then
                        table.insert(error_other_map, one_other_map)
                    end
                    env.one_other_map = nil
                    if not poe2_api.find_text({UI_info = env.UI_info, text = "/clear", min_x = 0}) then
                        api_Sleep(1000)
                        poe2_api.click_keyboard("enter")
                        api_Sleep(500)
                        poe2_api.paste_text("/clear")
                        api_Sleep(500)
                        poe2_api.click_keyboard("enter")
                        api_Sleep(500)
                        self.bool = true
                        
                        return bret.RUNNING
                    end
                end
            end
            
            -- 检查是否在藏身处
            if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                -- poe2_api.dbgp("Enter_Map:is_map_complete ==> ", tostring(is_map_complete))
                -- poe2_api.dbgp("Enter_Map:one_other_map ==> ", (one_other_map and one_other_map.name_cn_utf8 or "nil"))
                
                if env.range_info then
                    local items = get_not_map()
                    if items and not one_other_map and not is_map_complete and not poe2_api.table_contains({items.name_utf8}, not_enter_map) then
                        poe2_api.dbgp("items: ", items.name_utf8)

                        
                        if poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", min_x = 0}) or 
                        poe2_api.find_text({UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", min_x = 0}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", min_x = 0, click = 2, add_x = 216})
                            env.click_grid_pos = true
                            
                            return bret.RUNNING
                        end

                        dis = poe2_api.point_distance(items.grid_x, items.grid_y, player_info)
                        if dis and dis > 30 then
                            env.is_map_complete = false
                            env.end_point = {items.grid_x, items.grid_y}
                            return bret.SUCCESS
                        else
                            
                            env.enter_map_click_counter = click_counter + 1
                            if click_grid_pos then
                                api_ClickMove(poe2_api.toInt(items.grid_x), poe2_api.toInt(items.grid_y), poe2_api.toInt(items.world_z - 100), 1)
                                api_Sleep(1000)
                                return bret.RUNNING
                            end
                            
                            if player_info.isMoving then
                                poe2_api.dbgp("等待静止")
                                api_Sleep(1000)
                                return bret.RUNNING
                            end

                            poe2_api.find_text({UI_info = env.UI_info, text = items.name_utf8, click = 2, sorted = true, min_x = 0})

                            api_Sleep(1000)
                            if not poe2_api.find_text({UI_info = env.UI_info, text = items.name_utf8, click = 2, sorted = true, min_x = 0}) then
                                api_ClickMove(poe2_api.toInt(items.grid_x), poe2_api.toInt(items.grid_y), poe2_api.toInt(items.world_z - 100), 1)
                                api_Sleep(1000)
                            end
                            
                            return bret.RUNNING
                        end
                    end
                    
                    local not_map = get_not_map()
                    if one_other_map and not_map and not is_map_complete and not_map.name_utf8 == one_other_map.name_cn_utf8 and 
                    not poe2_api.table_contains({one_other_map.name_cn_utf8}, not_enter_map) then
                        poe2_api.dbgp("not_map: ", not_map.name_utf8)

                        if not poe2_api.find_text({UI_info = env.UI_info, text = one_other_map.name_cn_utf8, min_x = 0}) and 
                        poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", min_x = 0}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", min_x = 0, click = 2, add_x = 216})
                            env.click_grid_pos = true
                            
                            return bret.RUNNING
                        end
                        
                        -- 记录地图开始时间和名称
                        env.map_start_time = api_GetTickCount64()
                        env.map_name = one_other_map.name_cn_utf8
                        env.map_recorded = false
                        
                        if poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", min_x = 0}) or 
                        poe2_api.find_text({UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", min_x = 0}) then
                            poe2_api.click_position(1013, 25)
                            return bret.RUNNING
                        end
                        
                        dis = poe2_api.point_distance(not_map.grid_x, not_map.grid_y, player_info)
                        if dis and dis > 30 then
                            env.is_map_complete = false
                            env.end_point = {not_map.grid_x, not_map.grid_y}
                            
                            return bret.SUCCESS
                        else
                            env.enter_map_click_counter = click_counter + 1
                            if click_grid_pos then
                                api_ClickMove(poe2_api.toInt(not_map.grid_x), poe2_api.toInt(not_map.grid_y), poe2_api.toInt(not_map.world_z - 100), 1)
                                api_Sleep(1000)
                                
                                return bret.RUNNING
                            end
                            if player_info.isMoving then
                                poe2_api.dbgp("等待静止")
                                api_Sleep(1000)
                                return bret.RUNNING
                            end
                            
                            poe2_api.find_text({UI_info = env.UI_info, text = not_map.name_utf8, click = 2, sorted = true, min_x = 0})

                            api_Sleep(1000)
                            if not poe2_api.find_text({UI_info = env.UI_info, text = not_map.name_utf8, click = 2, sorted = true, min_x = 0}) then
                                api_ClickMove(poe2_api.toInt(not_map.grid_x), poe2_api.toInt(not_map.grid_y), poe2_api.toInt(not_map.world_z - 100), 1)
                                api_Sleep(1000)
                            end
                            
                            return bret.RUNNING
                        end
                    end
                end
            end
            return bret.FAIL
        end
    },

    -- 放置异界地图节点
    Put_Map_In_Otherworld = {
        run = function(self, env)
            poe2_api.print_log("放置异界地图节点...")
            if not self.last_action_time then
                self.last_action_time = 0  -- 记录上次操作时间
                self.action_interval = 1  -- 操作间隔时间
                self.open_num = 0          -- 操作计数器
                self.add_num = 1           -- 方向计数器
                self.origin_point = {}    -- 原点坐标
                self.expansion_step = 1    -- 扩张步数
                self.spiral_round = 0      -- 螺线圈数
            end

            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            local one_other_map = env.one_other_map
            local bag_info = env.bag_info
            local user_map = env.user_map
            local not_use_map = env.not_use_map
            local sorted_map = env.sorted_map
            local not_enter_map = env.not_enter_map
            local priority_map = env.priority_map
            local error_other_map = env.error_other_map or {}
            local not_have_stackableCurrency = env.not_have_stackableCurrency
            local not_attack_mos = nil
            local entry_length = 0
            local color = 0
            
            -- 检查加载中状态
            if poe2_api.click_text_UI({UI_info = env.UI_info, text = "loading_screen_tip_label"}) then
                return bret.RUNNING
            end
            
            if not player_info then
                return bret.RUNNING
            end
            
            if not poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", min_x = 0}) then
                return bret.FAIL
            end

            local otherworld_info = nil
            if not otherworld_info then
                local otherworld_info1 = api_GetEndgameMapNodes()
                if not otherworld_info1 then
                    poe2_api.dbgp("未找到异界地图节点信息")
                    return bret.RUNNING
                end
                otherworld_info = otherworld_info1
            end
            
            -- 检查背包中的地图
            local function check_map_in_bag(bag_info, return_count)
                return_count = return_count or true
                local matches = {}
                
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        if item.baseType_utf8 and string.find(item.baseType_utf8, "地圖鑰匙") then
                            table.insert(matches, item)
                        end
                    end
                end
                
                if return_count then
                    return #matches > 0 and #matches or false
                else
                    return #matches > 0 and matches or false
                end
            end
            
            if current_time - self.last_action_time >= self.action_interval then
                if otherworld_info == nil or #otherworld_info == 0 then
                    return bret.RUNNING
                end
                
                if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) and 
                poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", min_x = 0}) then
                    
                    if not one_other_map or (not one_other_map.isMapAccessible and one_other_map.isCompleted) then
                        -- 获取地图信息
                        local map_info = poe2_api.get_map(
                            {otherworld_info = otherworld_info, sorted_map = sorted_map, not_enter_map = not_enter_map, bag_info = bag_info, 
                            key_level_threshold = user_map, not_use_map = not_use_map, 
                            priority_map = priority_map, error_other_map = error_other_map, 
                            not_have_stackableCurrency = not_have_stackableCurrency}
                        )
                        
                        if map_info then
                            poe2_api.dbgp("map_info.name_utf8: ", map_info.name_cn_utf8)
                            poe2_api.dbgp("map_info.mapPlayModes: ")
                            poe2_api.printTable(map_info.mapPlayModes)
                        end
                        
                        if not map_info then
                            local point1, point2 = api_GetcurrentEndgameNodePoints()
                            -- poe2_api.dbgp("point: ", point)
                            if point1 ~= 0 and point2 ~= 0 then
                                if not self.origin_point then
                                    self.origin_point = {point1, point2}
                                end
                                
                                -- 计算动态扩张因子
                                local dynamic_factor = 1 + (self.spiral_round * 0.2)
                                
                                -- 计算当前扩张距离
                                local base_offset = math.floor(4000 * self.expansion_step * dynamic_factor)
                                local diagonal_offset = math.floor(2000 * self.expansion_step * dynamic_factor)
                                
                                -- 定义四个方向的偏移
                                local move_directions = {
                                    {self.origin_point[1] + base_offset, self.origin_point[2] + base_offset},      -- 右上
                                    {self.origin_point[1] - base_offset, self.origin_point[2] + diagonal_offset},  -- 左上
                                    {self.origin_point[1] - base_offset, self.origin_point[2] - base_offset},      -- 左下
                                    {self.origin_point[1] + base_offset, self.origin_point[2] - diagonal_offset}   -- 右下
                                }
                                
                                -- 获取目标位置
                                local target_x, target_y = move_directions[self.add_num][1], move_directions[self.add_num][2]
                                
                                -- 执行移动
                                api_EndgameNodeMove(target_x, target_y)
                                
                                -- 更新方向和扩张参数
                                self.add_num = (self.add_num % 4) + 1
                                if self.add_num == 1 then
                                    self.expansion_step = self.expansion_step + 1
                                    self.spiral_round = self.spiral_round + 1
                                end
                                
                                poe2_api.dbgp("等待地图加载 (5s)")
                                api_Sleep(5000)
                            end
                            return bret.RUNNING
                        else
                            self.add_num = 1
                            self.expansion_step = 1
                            self.spiral_round = 0
                            self.origin_point = nil
                        end
                        
                        entry_length = 0
                        local vall = false
                        if map_info and map_info.mapPlayModes and poe2_api.table_contains(map_info.mapPlayModes, "腐化聖域") then
                            entry_length = 4
                            color = 2
                            vall = true
                        end
                        
                        local map_level = poe2_api.select_best_map_key({inventory = bag_info,
                            key_level_threshold = user_map, not_use_map = not_use_map, priority_map = priority_map, color = color, entry_length = entry_length, vall = vall})
                        
                        if entry_length > 0 and map_level ~= nil then
                            if entry_length > map_level.fixedSuffixCount then
                                env.entry_length_take_map = true
                                env.the_update_map = map_level
                                env.map_update_to = entry_length
                                env.map_up = true
                                return bret.RUNNING
                            else
                                env.entry_length_take_map = false
                                env.the_update_map = nil
                                env.map_update_to = 0
                                env.map_up = false
                            end
                        end
                        
                        if map_info then
                            api_EndgameNodeMove(map_info.position_x - 1900, map_info.position_y - 1900)
                            env.one_other_map = map_info
                            api_Sleep(1000)
                            
                            return bret.RUNNING
                        else
                            
                            return bret.RUNNING
                        end
                    end
                    
                    if one_other_map then
                        if poe2_api.find_text({UI_info = env.UI_info, text = "地區"}) and 
                        poe2_api.find_text({UI_info = env.UI_info, text = "私訊"}) and 
                        poe2_api.find_text({UI_info = env.UI_info, text = "勢力"}) and 
                        poe2_api.find_text({UI_info = env.UI_info, text = "公會"}) then
                            poe2_api.click_keyboard('esc')
                        end
                        
                        if type(one_other_map) == "boolean" then
                            self.last_action_time = current_time
                            
                            return bret.RUNNING
                        end
                        
                        if one_other_map.name_utf8 and not poe2_api.table_contains(my_game_info.trash_map, one_other_map.name_utf8) and 
                        one_other_map.isMapAccessible and not one_other_map.isCompleted then
                            
                            if not poe2_api.find_text({UI_info = env.UI_info, text = "穿越", min_x = 0}) then
                                if self.open_num > 5 and poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", max_y = 100, min_x = 0}) then
                                    poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", max_y = 100, min_x = 0, click = 2, add_x = 212})
                                    table.insert(error_other_map, one_other_map)
                                    env.one_other_map = nil
                                    api_Sleep(1000)
                                    self.open_num = 0
                                    
                                    return bret.RUNNING
                                end
                                poe2_api.dbgp("更新前window_client_x, window_client_y --> ", one_other_map.window_client_x, ", ", one_other_map.window_client_y)
                                api_EndgameNodeMove(one_other_map.position_x - 1900, one_other_map.position_y - 1900)
                                api_Sleep(200)
                                
                                local one_other_map_refresh = api_GetEndgameMapNodes()
                                local window_client_x
                                local window_client_y
                                if one_other_map_refresh then
                                    for _, k1 in ipairs(one_other_map_refresh) do
                                        if k1.name_utf8 == one_other_map.name_utf8 and 
                                        k1.index_x == one_other_map.index_x and 
                                        k1.index_y == one_other_map.index_y then
                                            poe2_api.printTable(k1)
                                            if k1.window_client_x == 0 or k1.window_client_y == 0 then
                                                poe2_api.dbgp("更新后window_client_x, window_client_y --> ", k1.window_client_x, ", ", k1.window_client_y)
                                                -- env.need_SmallRetreat = true
                                                return bret.RUNNING
                                            end
                                            api_ClickScreen(k1.window_client_x, k1.window_client_y,0)
                                            window_client_x = k1.window_client_x
                                            window_client_y = k1.window_client_y
                                            api_Sleep(500)
                                        end
                                    end
                                end
                                
                                if poe2_api.find_text({UI_info = env.UI_info, text = one_other_map.name_cn_utf8, min_x = 0}) then
                                    api_ClickScreen(window_client_x, window_client_y,1)
                                    api_Sleep(500)
                                    api_EndgameNodeMove(one_other_map.position_x - 3900, one_other_map.position_y - 3900)
                                end
                                
                                self.last_action_time = current_time
                                self.open_num = self.open_num + 1
                                api_Sleep(100)
                                
                                return bret.RUNNING
                            end
                            
                            if not poe2_api.find_text({UI_info = env.UI_info, text = "背包", min_x = 1020}) then
                                poe2_api.click_keyboard('i')
                                api_Sleep(1000)
                                self.last_action_time = current_time
                                return bret.RUNNING
                            end
                            
                            local k = poe2_api.find_text({UI_info = env.UI_info, text = "穿越", min_x = 0, position = 2})
                            local center_x = nil
                            local center_y = nil
                            if k.text_utf8 == "穿越" then
                                center_x = math.floor((k.left + k.right) / 2)
                                center_y = math.floor((k.top + k.bottom) / 2)
                            end
                            -- poe2_api.printTable(k)
                            -- poe2_api.dbgp("center_x -->", center_x)
                            -- poe2_api.dbgp("center_y -->", center_y)
                            
                            if poe2_api.find_text({UI_info = env.UI_info, text = "背包", min_x = 1020}) and k then
                                if k.text_utf8 == '穿越' then
                                    local count = api_Getinventorys(0xe,0)
                                    poe2_api.dbgp("count -->", #count)
                                    -- api_Sleep(100000)
                                    if count then
                                        entry_length = 0
                                        local map_level = nil
                                        local vall = false
                                        
                                        if one_other_map and one_other_map.mapPlayModes and 
                                        poe2_api.table_contains(one_other_map.mapPlayModes, "腐化聖域") then
                                            entry_length = 4
                                            vall = true
                                        end
                                    
                                        map_level = poe2_api.select_best_map_key(
                                            {inventory = count, 
                                            key_level_threshold = user_map, not_use_map = not_use_map, 
                                            priority_map = priority_map, color = color, vall = vall}
                                        )
                                        -- poe2_api.printTable(map_level)

                                        if map_level and (#count > 1 or (entry_length > 0 and entry_length > map_level.fixedSuffixCount)) then
                                            for _, k in ipairs(count) do
                                                poe2_api.dbgp("22222")
                                                poe2_api.select_best_map_key(
                                                    {inventory = api_Getinventorys(0xe,0), index = 1, click = 1, 
                                                    type = 3, START_X = center_x - 47, START_Y = center_y - 125}
                                                )
                                                api_Sleep(500)
                                            end
                                            
                                            return bret.RUNNING
                                        elseif count and #count == 1 then
                                            need_put = false
                                        else
                                            need_put = true
                                        end
                                    end
                                end
                            end
                            
                            if need_put then
                                if not check_map_in_bag(bag_info) then
                                    if poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", max_y = 100, min_x = 250}) then
                                        poe2_api.dbgp1("SDGBWSGDASGSDG")
                                        poe2_api.click_keyboard("space")
                                    end
                                    
                                    return bret.SUCCESS
                                end
                                
                                entry_length = 0
                                local vall = false
                                if one_other_map and one_other_map.mapPlayModes and 
                                poe2_api.table_contains(one_other_map.mapPlayModes, "腐化聖域") then
                                    entry_length = 4
                                    color = 2
                                    vall = true
                                end
                                
                                local map_level = poe2_api.select_best_map_key(
                                    {inventory = bag_info, 
                                    key_level_threshold = user_map, not_use_map = not_use_map, 
                                    priority_map = priority_map, color = color, vall = vall}
                                )
                                
                                if entry_length > 0 and map_level then
                                    if entry_length > map_level.fixedSuffixCount then
                                        env.entry_length_take_map = true
                                        env.the_update_map = map_level
                                        env.map_update_to = entry_length
                                        env.map_up = true
                                        return bret.RUNNING
                                    else
                                        env.entry_length_take_map = false
                                        env.the_update_map = nil
                                        env.map_update_to = 0
                                        env.map_up = false
                                    end
                                end

                                map_level = poe2_api.select_best_map_key(
                                    {inventory = bag_info, 
                                    click = 1, key_level_threshold = user_map, not_use_map = not_use_map, 
                                    priority_map = priority_map, entry_length = entry_length}
                                )

                                poe2_api.dbgp("map_level",map_level)

                                if map_level then
                                    local attack_distance = nil
                                    not_attack_mos = {}
                                    for _, config in ipairs(user_map) do
                                        if config["階級"] == map_level then
                                            attack_distance = config["搜怪距離"] or 100
                                            
                                            if config["不打Boss"] then
                                                table.insert(not_attack_mos, 3)
                                            end
                                            if config["不打黃怪"] then
                                                table.insert(not_attack_mos, 2)
                                            end
                                            if config["不打藍怪"] then
                                                table.insert(not_attack_mos, 1)
                                            end
                                            if config["不打白怪"] then
                                                table.insert(not_attack_mos, 0)
                                            end
                                            
                                            break
                                        end
                                    end
                                    env.map_level_dis = attack_distance
                                    if #not_attack_mos > 0 then
                                        table.sort(not_attack_mos)
                                        env.not_attack_mos = not_attack_mos
                                    else
                                        env.not_attack_mos = not_attack_mos
                                    end
                                else
                                    poe2_api.dbgp("背包没有合适的地图钥匙")
                                    env.map_level_dis = nil
                                    env.is_have_map = false
                                end
                                poe2_api.dbgp("2222222")
                                api_Sleep(500)
                                
                                return bret.RUNNING
                            else
                                local maps = api_Getinventorys(0xe,0)
                                if maps and #maps > 0 then
                                    poe2_api.dbgp("len(maps): ", #maps)
                                    local map_level = poe2_api.extract_key_level(maps[1].baseType_utf8)
                                    
                                    local attack_distance = nil
                                    not_attack_mos = {}
                                    
                                    for _, config in ipairs(user_map) do
                                        if config["階級"] == map_level then
                                            attack_distance = config["搜怪距離"]
                                            
                                            if config["不打Boss"] then
                                                table.insert(not_attack_mos, 3)
                                            end
                                            if config["不打黃怪"] then
                                                table.insert(not_attack_mos, 2)
                                            end
                                            if config["不打藍怪"] then
                                                table.insert(not_attack_mos, 1)
                                            end
                                            if config["不打白怪"] then
                                                table.insert(not_attack_mos, 0)
                                            end
                                            
                                            break
                                        end
                                    end
                                    
                                    if attack_distance == nil then
                                        attack_distance = 100
                                    end
                                    
                                    env.map_level_dis = attack_distance
                                    env.not_attack_mos = not_attack_mos
                                    
                                    if maps and entry_length > 0 then
                                        local suffx = api_GetObjectSuffix(maps[1].mods_obj)
                                        -- poe2_api.dbgp("===========")
                                        -- poe2_api.printTable(maps[1])
                                        -- poe2_api.dbgp("----")
                                        -- poe2_api.printTable(suffx)
                                        -- api_Sleep(10000)
                                        if suffx and #suffx < entry_length then
                                            poe2_api.select_best_map_key({inventory = api_Getinventorys(0xe,0), index = 1, click = 1, type = 3, START_X = center_x - 47, START_Y = center_y - 125})
                                            env.one_other_map = nil
                                            env.map_level_dis = nil
                                            
                                            return bret.RUNNING
                                        end
                                    end
                                    
                                    if poe2_api.find_text({UI_info = env.UI_info, text = "穿越", click = 2, min_x = 0}) then
                                        api_Sleep(1000)
                                        if poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", max_y = 100, min_x = 250, refresh = true}) then
                                            return bret.RUNNING
                                        end
                                        env.click_traverse = true
                                        poe2_api.dbgp("点击穿越成功")
                                        env.is_map_complete = false
                                        self.open_num = 0
                                        env.enter_map_times = (env.enter_map_times or 0) + 1
                                        api_Sleep(3000)
                                        
                                        return bret.SUCCESS
                                    else
                                        env.one_other_map = nil
                                        env.map_level_dis = nil
                                        env.click_traverse = false
                                        
                                        return bret.RUNNING
                                    end
                                end
                            end
                        end
                    end
                    
                    
                    return bret.RUNNING
                end
            else
                
                return bret.RUNNING
            end
        end
    },

    -- 清除所有遮挡物节点
    Clear_All_Page = {
        run = function(self, env)
            poe2_api.print_log('清除遮挡物...')
            if not self.last_action_time then
                self.last_action_time = 0  -- 记录上次操作时间
                self.action_interval = 1.5 -- 操作间隔时间
                self.wait_num = 0          -- 等待计数器
            end

            local current_time = api_GetTickCount64()
            
            local one_other_map = env.one_other_map
            
            local click_traverse = env.click_traverse
            local error_other_map = env.error_other_map or {}
            
            if not click_traverse then
                env.one_other_map = nil
                env.is_map_complete = true
                
                return bret.RUNNING
            end

            if not one_other_map then
                return bret.RUNNING
            end
            
            -- 获取非地图物品（传送点/异界之门除外）
            local function get_not_map()
                for _, item in ipairs(env.range_info) do
                    if item.type == 5 and item.name_utf8 ~= '' and 
                    item.name_utf8 ~= "傳送點" and item.name_utf8 ~= '異界之門' then
                        return item
                    end
                end
                return false
            end
            
            local not_map = get_not_map()
            
            if one_other_map then
                local error_text = {
                    "錯誤：無法進入，原因：伺服器斷線。",
                    "錯誤：無法進入。",
                    "啟動失敗。地圖無法進入。"
                }
                
                for _, k in ipairs(error_text) do
                    if poe2_api.find_text({UI_info = env.UI_info, text = k, min_x = 0}) then
                        table.insert(error_other_map, one_other_map)
                        env.one_other_map = nil
                        env.is_map_complete = true
                        
                        if not poe2_api.find_text({UI_info = env.UI_info, text = "/clear", min_x = 0}) then
                            poe2_api.click_keyboard("enter")
                            api_Sleep(500)
                            poe2_api.paste_text("/clear")
                            api_Sleep(500)
                            poe2_api.click_keyboard("enter")
                            api_Sleep(1000)
                            self.bool = true
                            
                            return bret.RUNNING
                        end
                    end
                end
                
                env.enter_map_click_counter = 0
                env.is_map_complete = false
                
                if self.wait_num > 3 then
                    if poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", max_y = 100, min_x = 250}) then
                        poe2_api.click_position(1013, 25)
                    end
                    
                    return bret.RUNNING
                end
                
                if not_map and not_map.name_utf8 ~= one_other_map.name_cn_utf8 then
                    api_Sleep(3000)
                    
                    return bret.RUNNING
                end
                
                if not poe2_api.find_text({UI_info = env.UI_info, text = one_other_map.name_cn_utf8, min_x = 0}) then
                    if poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", max_y = 100, min_x = 250}) then
                        poe2_api.click_position(1013, 25)
                        
                        return bret.RUNNING
                    end
                end
                
                api_Sleep(3000)
                self.wait_num = self.wait_num + 1
                
                return bret.RUNNING
            end
            
            
            return bret.FAIL
        end
    },

    -- 打开异界地图页面节点
    Open_The_Otherworld_Page = {
        run = function(self, env)
            poe2_api.print_log('打开异界地图页面...')

            if not self.last_action_time then 
                self.last_action_time = 0  -- 记录上次操作时间
                self.action_interval = 1   -- 操作间隔时间
                self.wait_start = 0        -- 等待开始时间
            end

            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            
            if current_time - self.last_action_time >= self.action_interval then
                if player_info and 
                poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) and 
                not poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", min_x = 0}) then
                    poe2_api.dbgp("打开异界地图页面")
                    env.interactive = "MapDevice"
                    env.one_other_map = nil
                    
                    return bret.SUCCESS
                end
            end
            
            
            return bret.RUNNING
        end
    },

    -- 寻找精英怪怪物
    Find_Monster = {
        run = function(self, env)
            poe2_api.print_log("寻找怪物...")
            local current_time = api_GetTickCount64()
            local nearest_distance_sq = math.huge
            local stuck_monsters = env.stuck_monsters
            local player_info = env.player_info
            local valid_monsters = nil
            if env.range_info then
                -- 先确定当前目标
                for _, monster in ipairs(env.range_info) do
                    if poe2_api.table_contains(stuck_monsters, monster.id) then
                        goto continue
                    end
                    
                    -- 快速失败条件检查
                    if monster.type ~= 1 or not monster.is_selectable then
                        goto continue
                    end
                    
                    if monster.is_friendly then
                        goto continue
                    end
                    
                    if not monster.isActive then
                        goto continue
                    end
                    
                    if monster.life <= 0 or monster.name_utf8 == "" then
                        goto continue
                    end
                    
                    if poe2_api.table_contains(my_game_info.not_attact_mons_path_name, monster.path_name_utf8) then
                        goto continue
                    end
                    
                    if not_attack_mos and poe2_api.table_contains(not_attack_mos, monster.rarity) then
                        goto continue
                    end
                    
                    if monster.rarity == 0 or monster.rarity == 1 then
                        goto continue
                    end
                    
                    -- if monster.hasLineOfSight then
                    --     goto continue
                    -- end
                    
                    -- 计算距离平方
                    local distance_sq = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
                    
                    if distance_sq and distance_sq < nearest_distance_sq then
                        nearest_distance_sq = distance_sq
                        valid_monsters = monster
                    end
                    ::continue::
                end
            end
            
            if valid_monsters then
                -- if env.end_point and #env.path_list > 0 then
                    -- local dis = poe2_api.point_distance(valid_monsters.grid_x, valid_monsters.grid_y,{env.end_point[1], env.end_point[2]})
                    -- if dis and dis > 25 then
                poe2_api.dbgp("寻找怪物...", valid_monsters.grid_x, valid_monsters.grid_y)
                env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                    -- end
                -- end
                poe2_api.time_p("寻找怪物(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                return bret.FAIL
            else
                poe2_api.time_p("寻找怪物(FAIL) 耗时 -->", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
            -- return bret.SUCCESS
        end
    },

    -- 检查是否在异界中
    Check_In_Otherworld_Map = {
        run = function(self, env)
            local current_time = api_GetTickCount64()
            poe2_api.print_log("检查是否在异界中...", env.player_info.current_map_name_utf8)
            if poe2_api.table_contains(env.player_info.current_map_name_utf8,my_game_info.hideout) then
                env.boss_drop_time = 0
                env.boss_drop = false
                env.boss_id_list = {}
                env.drop_items = false
                env.need_item = nil
                env.not_more_ritual = true
                env.afoot_altar = nil
                env.afoot_box = nil
                env.interactive_timeout = nil
                env.not_match_id = nil
                env.interactive_id = nil
                env.interactive_id_list = {}
                env.interactive_replytime = 0
                env.interactive_permanent_id_list = {}
                env.obj_color = nil
                env.is_abyss_complete = false
                env.is_abyss_time = false
                
                -- for _,k in ipairs(env.player_info.buffs) do
                --     -- poe2_api.printTable(k)
                --     -- poe2_api.dbgp("k.name_en", k.name_en)
                --     if k.name_en == "on_rhoa_mount" then
                --         poe2_api.print_log("取消骑乘状态...")
                --         api_ClickMove(env.player_info.grid_x, env.player_info.grid_y, env.player_info.world_z, 0)
                --         poe2_api.click_keyboard("space")
                --         return true
                --     end
                -- end

                return bret.FAIL
			end
            poe2_api.dbgp("异界中...")
            env.clear_bool = false
            env.not_exist_stone = {}
            env.is_get_plaque = false
            env.is_get_plaque_node = true
            env.is_public_warehouse = true
            env.is_strengthened_map = true
            env.amplification_use_count = 0
            env.supreme_use_count = 0
            env.strengthened_map_obj = nil
            env.is_public_warehouse_plaque = true
            env.is_update_plaque = false
            env.entry_length_take_map = false
            env.not_have_stackableCurrency = false
            env.operated_plaque = false
            env.lack_of_currency = {} -- 缺少通货
            env.is_have_stone = true
            env.page_full_list = {} -- 页满列表
            -- env.drop_items = false
            -- env.not_exist_stone = {}
            -- env.is_get_plaque_node = true


            -- if not env.open_map_UI and not poe2_api.table_contains(env.player_info.current_map_name_utf8, my_game_info.hideout) then 
            if not poe2_api.table_contains(env.player_info.current_map_name_utf8, my_game_info.hideout) then   
                if poe2_api.find_text({UI_info = env.UI_info, text = my_game_info.game_region, max_x=1800}) then
                    env.open_map_UI = true
                else
                    poe2_api.click_keyboard("tab")
                    api_Sleep(1000)
                    return bret.RUNNING
                end
            end

            -- 获取技能设置
            local function parse_skill_config()
                local skill_setting = env.user_config["技能設置"]
                local new_skills = {}
                local new_sup_skills = {}
                local preserved_cooldowns = {}
                local sup_preserved_cooldowns = {}
                local current_time = api_GetTickCount64()
                
                -- 确保skill_cooldowns表存在
                if not self.skill_cooldowns then
                    self.skill_cooldowns = {}
                end
                if not self.sup_skill_cooldowns then
                    self.sup_skill_cooldowns = {}
                end

                if not self.all_skill_infos or self.all_skill_infos == nil then
                    self.all_skill_infos = api_GetSkillSlots()
                end

                if not self.all_skill or self.all_skill == nil then
                    self.all_skill = api_GetSelectableSkillControls()
                end
                
                local skill_pos = {
                    ["q"] = {1194, 1230},
                    ["w"] = {1236, 1272},
                    ["e"] = {1279, 1315},
                    ["r"] = {1322, 1358},
                    ["t"] = {1365, 1401},
                }

                -- 首先建立按键到控件的映射
                local daimos_change = "DemonFormPlayer"  -- 要匹配的技能名称
                local key_to_control = {}
                if self.all_skill and next(self.all_skill) ~= nil then
                    for _, control in ipairs(self.all_skill) do
                        if not control.text_utf8 or control.text_utf8 == "" then
                            goto continue
                        end
                        if control.text_utf8 == daimos_change then
                            goto continue
                        end
                        -- 跳过非主技能栏的技能
                        if control.top > 845 and control.left > 1190 then
                            for key, range in pairs(skill_pos) do
                                local pos = (control.left + control.right) / 2
                                if pos >= range[1] and pos <= range[2] then
                                    key_to_control[key] = control
                                    break
                                end
                            end
                        end
                        ::continue::
                    end
                end
                
                -- 创建按键到技能ID的映射
                local key_to_skill_id = {}
                for key, skill_data in pairs(skill_setting) do
                    if skill_data["启用"] then
                        local control = key_to_control[key]
                        if control then
                            for _, skill in ipairs(self.all_skill_infos) do
                                if control.text_utf8 == skill.name_utf8 then
                                    key_to_skill_id[key] = skill.id
                                    break
                                end
                            end
                        end
                    end
                end
                
                -- 遍历技能设置
                for key, skill_data in pairs(skill_setting) do
                    -- 只处理启用技能
                    if skill_data["启用"] then
                        if skill_data["技能屬性"] == "辅助技能" then
                            
                            local sup_skill = {
                                name = key,
                                key = key,
                                id = key_to_skill_id[key] or 0,
                                interval = (tonumber(skill_data["釋放間隔"]) or 0) / 1000
                            }
                            
                            -- 保留原有冷却时间
                            if self.sup_skill_cooldowns[sup_skill.name] then
                                sup_preserved_cooldowns[sup_skill.name] = self.sup_skill_cooldowns[sup_skill.name]
                            else
                                sup_preserved_cooldowns[sup_skill.name] = 0
                            end
                            
                            table.insert(new_sup_skills, sup_skill)
                        end
                    end
                end
                
                self.skills = new_skills
                self.sup_skills = new_sup_skills
                poe2_api.printTable(self.skills)
                self.skill_cooldowns = preserved_cooldowns
                self.sup_skill_cooldowns = sup_preserved_cooldowns

                -- 提取技能权重
                self._skill_weights = {}
                for _, skill in ipairs(self.skills) do
                    table.insert(self._skill_weights, skill.weight)
                end
                
                return {
                    attack_skills = self.skills,
                    support_skills = self.sup_skills
                }
            end

            -- 释放辅助技能
            local function _execute_support_skill(skill, player_info)
                poe2_api.dbgp("释放辅助技能=-=-=-->>>>")
                poe2_api.printTable(skill)
                local current_time = api_GetTickCount64()
                
                -- 设置冷却时间
                local skill_start = api_GetTickCount64()
                local base_cd = skill.interval
                local actual_cd = (math.max(base_cd * (1 + math.random() * 0.2), 0.1)) * 1000
                self.sup_skill_cooldowns[skill.name] = skill_start + actual_cd
                if env.user_config["全局設置"]["内存模式"] then
                    -- 释放辅助技能
                    if skill.id and skill.id ~= 0 then
                        -- 辅助技能通常不需要目标位置，使用玩家当前位置
                        if env.target_point and next(env.target_point) then
                            api_CastSkill(skill.id, 0, env.player_info.grid_x, env.player_info.grid_y, env.target_point[1], env.target_point[2])
                        else
                            api_CastSkill(skill.id, 0, env.player_info.grid_x, env.player_info.grid_y, env.player_info.grid_x, env.player_info.grid_y)
                        end
                        
                        poe2_api.dbgp("通过技能ID释放辅助技能:", skill.key, "技能ID:", skill.id)
                    end
                else
                    -- 备用方案：使用按键释放
                    poe2_api.click_keyboard(skill.key)
                    poe2_api.dbgp("通过按键释放辅助技能:", skill.key)
                end
            end

            -- 检查并释放辅助技能
            local function check_and_cast_support_skills()
                if not self.sup_skills or #self.sup_skills == 0 then
                    return
                end
                
                local current_time = api_GetTickCount64()
                
                -- 按优先级排序辅助技能
                table.sort(self.sup_skills, function(a, b)
                    return a.priority > b.priority
                end)
                
                for _, skill in ipairs(self.sup_skills) do
                    -- 检查冷却时间
                    local last_cast = self.sup_skill_cooldowns[skill.name] or 0
                    if current_time - last_cast >= skill.interval * 1000 then
                        _execute_support_skill(skill, env.player_info)
                    end
                end
            end

            -- if env.user_config["全局設置"]["内存模式"] then
                -- 加载技能设置
            if not self.skills then
                poe2_api.dbgp("加载技能设置...")
                self.stuck_monsters = {}
                
                parse_skill_config()
                return bret.RUNNING
            end
            
            check_and_cast_support_skills()
            -- end


            local function take_bird()
                for _,k in ipairs(env.player_info.buffs) do
                    -- poe2_api.printTable(k)
                    -- poe2_api.dbgp("k.name_en", k.name_en)
                    if k.name_en == "on_rhoa_mount" then
                        return true
                    end
                end
                -- if not bird then
                for _,i in ipairs(env.range_info) do
                    if i.name_utf8 == "恐喙鳥盟友" and i.life > 0 then
                        -- poe2_api.printTable(i)
                        local dis = poe2_api.point_distance(i.grid_x, i.grid_y, env.player_info)
                        poe2_api.dbgp("恐喙鳥盟友...", dis)
                        -- poe2_api.dbgp("恐喙鳥盟友i.grid_x", i.grid_x)
                        -- poe2_api.dbgp("恐喙鳥盟友i.grid_y", i.grid_y)
                        -- poe2_api.dbgp("player_info.grid_x", env.player_info.grid_x)
                        -- poe2_api.dbgp("player_info.grid_y", env.player_info.grid_y)
                        -- poe2_api.dbgp("============================================")
                        if dis and dis > 25 then
                            api_ClickMove(env.player_info.grid_x, env.player_info.grid_y, env.player_info.world_z, 7)
                            api_Sleep(200)
                            poe2_api.click_keyboard("`")
                            api_Sleep(500)
                            return false
                        end
                        api_ClickMove(i.grid_x, i.grid_y, env.player_info.world_z, 0)
                        api_Sleep(500)
                        api_ClickMove(i.grid_x, i.grid_y, env.player_info.world_z, 1)
                        api_Sleep(500)
                        return false
                    end
                end
                poe2_api.dbgp("没有恐喙鳥盟友...")
                return true
            end

            -- 获取技能设置
            local function parse_skill_config()
                poe2_api.dbgp("---恶魔变身---")
                for _,k in ipairs(env.player_info.buffs) do
                    -- poe2_api.printTable(k)
                    -- poe2_api.dbgp("k.name_en", k.name_en)
                    if k.name_en == "demon_form_tick_prevention_buff" then
                        return true
                    end
                end

                local skill_setting = env.user_config["技能設置"]

                local daimos_change = "DemonFormPlayer"  -- 要匹配的技能名称

                -- local all_skill = api_GetSelectableSkillControls()
                if not self.all_skill or self.all_skill == nil then
                    self.all_skill = api_GetSelectableSkillControls()
                end
                
                -- poe2_api.printTable(self.all_skill)

                local skill_pos = {
                    ["q"] = {1194, 1230},
                    ["w"] = {1236, 1272},
                    ["e"] = {1279, 1315},
                    ["r"] = {1322, 1358},
                    ["t"] = {1365, 1401},
                }

                -- 首先建立按键到控件的映射
                local key_to_control = {}
                if self.all_skill and next(self.all_skill) ~= nil then
                    for _, control in ipairs(self.all_skill) do
                        if not control.text_utf8 or control.text_utf8 == "" then
                            goto continue
                        end
                        -- 跳过非主技能栏的技能
                        if control.top > 845 and control.left > 1190 then
                            
                            for key, range in pairs(skill_pos) do
                                pos = (control.left + control.right) / 2
                                if pos >= range[1] and pos <= range[2] then
                                    key_to_control[key] = control
                                    break
                                end
                            end
                        end
                        ::continue::
                    end
                end
                
                -- 遍历技能设置，查找匹配的技能
                for key, skill_data in pairs(skill_setting) do
                    -- 只处理启用的辅助技能
                    if skill_data["启用"] and skill_data["技能屬性"] == "辅助技能" then
                        local control = key_to_control[key]
                        -- poe2_api.printTable(control)
                        -- 使用control中的text_utf8进行比对
                        if control and control.text_utf8 == daimos_change then
                            -- 直接返回匹配的按键
                            poe2_api.click_keyboard(key)
                            api_Sleep(500)
                            return false
                        end
                    end
                end

                -- 如果没有找到匹配的技能，返回nil或默认值
                -- print("警告：未找到名称为 '" .. daimos_change .. "' 的辅助技能")
                return false
            end

            if env.player_info.life > 0 then
                parse_skill_config()
                -- api_Sleep(100000)
            end

            -- local skill_key = parse_skill_config()
            -- if skill_key then
            --     poe2_api.dbgp(skill_key)  -- 输出单个按键，如 "q", "w" 等
            -- else
            --     poe2_api.dbgp("未找到匹配的技能按键")
            -- end
            -- api_Sleep(10000)
            
            poe2_api.time_p("检查是否在异界中(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
            return bret.SUCCESS
        end
    },

    -- 检查目标点
    Check_Target_Point = {
        run = function(self, env)
            poe2_api.print_log("检查目标点...")
            local current_time = api_GetTickCount64()
            -- 使用参数
            if self.no_mos_back == nil then
                self.no_mos_back = env.user_config["全局設置"]["刷图通用設置"]["是否全圖"]
            end
            -- local no_mos_back = false
            local result = false
            env.radius = 120

            local player_info = env.player_info
            local path_list = env.path_list
            local current_map_info = env.current_map_info
            local have_ritual = env.have_ritual
            local afoot_altar = env.afoot_altar

            if self.last_action_time == nil then
                self.last_action_time = api_GetTickCount64()
                self.action_interval = 1000
                self.false_times = 0
                self.is_wait = false
                self.dq = 0
            end

            if env.boss_drop then
                if api_GetTickCount64() - env.boss_drop_time < 10000 then
                    poe2_api.dbgp("等待Boss掉落...")
                    return bret.RUNNING
                end
                env.boss_drop = false
            end
            if env.is_abyss_time then
                if api_GetTickCount64() - env.abyss_time < 5000 then
                    poe2_api.dbgp("等待深渊物品掉落...")
                    return bret.RUNNING
                end
            end
            -- 判断boss死亡
            local function is_not_boss(range_info)
                for _, monster in ipairs(range_info) do
                    if monster.rarity == 3 and monster.life == 0 and monster.type == 1 and (not env.boss_id_list or not next(env.boss_id_list) or not poe2_api.table_contains(monster.path_name_utf8, env.boss_id_list)) then
                        return monster
                    end
                end
                return false
            end

            local bossname = is_not_boss(env.range_info)
            if not env.boss_drop and bossname then
                env.boss_drop = true
                env.boss_drop_time = api_GetTickCount64()
                table.insert(env.boss_id_list,bossname.path_name_utf8)
                poe2_api.dbgp("boss: "..bossname.name_utf8.." 死亡,添加到boss等待列表")
                api_RestoreOriginalMap()
                api_UpdateMapObstacles(300)
                return bret.RUNNING
            end
            -- 查找小地图对象
            local function get_target_minimap_object(current_map_info)
                if not current_map_info or not next(current_map_info) then
                    return false
                end
                local current_map_sorted_info = poe2_api.get_sorted_list(current_map_info, player_info)
                poe2_api.dbgp("current_map_sorted_info: ",current_map_sorted_info)
                if not env.minimap_info then
                    local black_mist_sacrifice = nil
                    local not_sacrifice = nil
                    local ultimately_boss = nil
                    local elite_boss = nil
                    local target = nil
                    poe2_api.dbgp("not_more_ritual: ",env.not_more_ritual)
                    if env.not_more_ritual then
                        for _, item in ipairs(current_map_sorted_info) do
                            if item.name_utf8 == 'RitualRune' and item.flagStatus == 1 and item.flagStatus1 == 1 and afoot_altar and poe2_api.point_distance(item.grid_x,item.grid_y,afoot_altar)<20 then
                                env.minimap_info = item 
                                poe2_api.dbgp("小地图对象中黑雾祭坛----------------------------")
                                env.end_point = {item.grid_x, item.grid_y}
                                return true
                            end
                        end
                        local sacrifice_info = api_GetSacrificeItems()
                        if sacrifice_info and next(sacrifice_info) then
                            for _, item in ipairs(current_map_sorted_info) do
                                if item.name_utf8 == 'RitualRune' and item.flagStatus == 1 and item.flagStatus1 == 1 and ((0 < sacrifice_info.maxCount and sacrifice_info.maxCount < 10 and 0 < sacrifice_info.finishedCount and sacrifice_info.finishedCount < 10 and sacrifice_info.finishedCount  ~= sacrifice_info.maxCount) or (sacrifice_info.maxCount == 0 and sacrifice_info.finishedCount == 0)) then
                                    poe2_api.dbgp("小地图对象中普通祭坛----------------------------")
                                    env.minimap_info = item
                                    env.end_point = {item.grid_x, item.grid_y}
                                    return true
                                end
                            end
                        end
                    end
                    for _, item in ipairs(current_map_sorted_info) do
                        if item.name_utf8 == 'RareMonsterAlive' and item.flagStatus == 1 then
                            if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not poe2_api.find_text({text = "地圖完成"})) then
                                poe2_api.dbgp("小地图对象中精英boss----------------------------")
                                env.minimap_info = item
                                env.end_point = {item.grid_x, item.grid_y}
                                return true
                            end
                        end
                    end

                    for _, item in ipairs(current_map_sorted_info) do
                        if item.name_utf8 == 'AbyssChestActive' and item.flagStatus == 0 and item.flagStatus1 == 1 then
                            if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not poe2_api.find_text({text = "地圖完成"})) then
                                poe2_api.dbgp("小地图对象中深渊宝箱----------------------------")
                                env.minimap_info = item
                                env.end_point = {item.grid_x, item.grid_y}
                                return true
                            end
                        end
                    end
                    for _, item in ipairs(current_map_sorted_info) do
                        if item.name_utf8 == 'RuneMarkersActive' and item.flagStatus1 == 1 then
                            if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not poe2_api.find_text({text = "地圖完成"})) then
                                poe2_api.dbgp("小地图对象中巨石召唤----------------------------")
                                env.minimap_info = item
                                env.end_point = {item.grid_x, item.grid_y}
                                return true
                            end
                        end
                    end
                    for _, item in ipairs(current_map_sorted_info) do
                        if string.find(item.name_utf8,"Abyss_") and item.flagStatus1 == 1 and not env.is_abyss_complete then
                            if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not poe2_api.find_text({text = "地圖完成"})) then
                                poe2_api.dbgp("小地图对象中深渊入口----------------------------")
                                env.minimap_info = item
                                env.end_point = {item.grid_x, item.grid_y}
                                return true
                            end
                        end
                    end

                    local function is_point1(grid_x,grid_y)
                        local player_position = api_FindNearestReachablePoint(grid_x,grid_y, 50, 0)
                        local resu = api_FindPath(player_info.grid_x,player_info.grid_y,player_position.x, player_position.y)
                        return resu
                    end
                        
                    for _, item in ipairs(current_map_sorted_info) do
                        if item.name_utf8 == 'UniqueMonsterAlive' and item.flagStatus == 1 and item.flagStatus1 == 1 then
                            local is_path = is_point1(item.grid_x,item.grid_y)
                            if is_path and next(is_path) then
                                poe2_api.dbgp("小地图对象中最终boss----------------------------")
                                env.minimap_info = item
                                local player_position = api_FindNearestReachablePoint(item.grid_x, item.grid_y, 50, 0)
                                env.end_point = {player_position.x, player_position.y}
                                return true
                            end
                            
                        end
                    end

                    

                    if not env.minimap_info then
                        return false
                    end
                else
                    poe2_api.dbgp("小地图对象中已有目标--------------------------------------------------------------------------------------------")
                    local minimap_info = env.minimap_info 
                    if string.find(minimap_info.name_utf8,"Abyss_") then
                        if env.is_abyss_complete then
                            env.minimap_info = nil
                            return "刷新"
                        end
                        local distance = poe2_api.point_distance(minimap_info.grid_x,minimap_info.grid_y,env.player_info)
                        if distance < 50 then
                            local function get_abyss()
                                if not env.range_info or not next(env.range_info) then
                                    return false
                                end
                                for _, i in ipairs(env.range_info) do
                                    local condition25 = i.path_name_utf8 == "Metadata/MiscellaneousObjects/Abyss/AbyssSubAreaTransition" 
                                    if condition25 then
                                        return true
                                    end
                                end
                                return false
                            end
                            if not get_abyss() then
                                env.minimap_info = nil
                                env.is_abyss_complete = true
                                return "刷新"
                            end
                        end
                    end
                    for _, item in ipairs(current_map_sorted_info) do
                        local distance = poe2_api.point_distance(item.grid_x,item.grid_y,minimap_info)
                        if item.name_utf8 == minimap_info.name_utf8 and item.flagStatus == minimap_info.flagStatus and item.flagStatus1 == minimap_info.flagStatus1 and distance and distance < 20 then
                            if minimap_info.name_utf8 == 'UniqueMonsterAlive' then
                                local player_position = api_FindNearestReachablePoint(item.grid_x, item.grid_y, 50, 0)
                                env.end_point = {player_position.x, player_position.y}
                            else
                                env.end_point = {item.grid_x, item.grid_y}
                            end
                            
                            return true 
                        end
                    end
                    env.minimap_info = nil
                    return "刷新"
                end
            end

            -- 骑鸟
            local function take_bird()
                for _,k in ipairs(env.player_info.buffs) do
                    -- poe2_api.printTable(k)
                    -- poe2_api.dbgp("k.name_en", k.name_en)
                    if k.name_en == "on_rhoa_mount" then
                        return true
                    end
                end
                -- if not bird then
                for _,i in ipairs(env.range_info) do
                    if i.name_utf8 == "恐喙鳥盟友" and i.life > 0 then
                        -- poe2_api.printTable(i)
                        local dis = poe2_api.point_distance(i.grid_x, i.grid_y, env.player_info)
                        poe2_api.dbgp("恐喙鳥盟友...", dis)
                        -- poe2_api.dbgp("恐喙鳥盟友i.grid_x", i.grid_x)
                        -- poe2_api.dbgp("恐喙鳥盟友i.grid_y", i.grid_y)
                        -- poe2_api.dbgp("player_info.grid_x", env.player_info.grid_x)
                        -- poe2_api.dbgp("player_info.grid_y", env.player_info.grid_y)
                        -- poe2_api.dbgp("============================================")
                        if dis and dis > 25 then
                            api_ClickMove(env.player_info.grid_x, env.player_info.grid_y, env.player_info.world_z, 7)
                            api_Sleep(200)
                            poe2_api.click_keyboard("`")
                            api_Sleep(500)
                            return false
                        end
                        api_ClickMove(i.grid_x, i.grid_y, env.player_info.world_z, 0)
                        api_Sleep(500)
                        api_ClickMove(i.grid_x, i.grid_y, env.player_info.world_z, 1)
                        api_Sleep(500)
                        return false
                    end
                end
                poe2_api.dbgp("没有恐喙鳥盟友...")
                return true
            end
            nomarl_monster = poe2_api.is_have_mos({range_info = env.range_info, dis = env.min_attack_dis, player_info = player_info,is_active = is_active, not_sight = true,stuck_monsters = stuck_monsters})
            Boss_monster = poe2_api.is_have_mos_boss(env.range_info, my_game_info.boss_name)
            if env.is_bird and not env.is_map_complete and not nomarl_monster and not Boss_monster then
                poe2_api.dbgp("---上鸟---")
                local function is_door()
                    for _, v in ipairs(env.range_info) do
                        if v.name_utf8 ~= "" and v.type == 5 and poe2_api.table_contains(v.name_utf8,my_game_info.hideout_CH) then
                            local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                            if dis and dis < 50 then
                                return false
                            end
                        end
                    end
                    return true
                end
                if is_door() then
                    if not take_bird() then
                        return bret.RUNNING
                    end
                end
            end

            poe2_api.dbgp("current_map_info: ",current_map_info)
            if path_list and next(path_list) and #path_list > 1 then  
                -- poe2_api.printTable(path_list)
                poe2_api.dbgp("next(path_list)(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end 

            if not poe2_api.table_contains(player_info.current_map_name_utf8,{"MapAugury","MapAugury_NoBoss"}) then
                local state = get_target_minimap_object(current_map_info)
                if type(state) == "string" then
                    poe2_api.dbgp("刷新小地图对象--------------------------")
                    return bret.RUNNING
                elseif state then
                    poe2_api.dbgp("statestatestatestatestatestatestatestatestatestate(state)(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                    return bret.SUCCESS 
                end
            end

            -- 主要逻辑
            if self.no_mos_back then
                result = poe2_api.monster_monitor(45, env.UI_info)
            else
                result = true
            end

            if string.find(player_info.current_map_name_utf8,"Claimable") then
                result = poe2_api.monster_monitor(0, env.UI_info)
                env.radius = 30
            end
            poe2_api.dbgp("result -- > ", result)

            -- if current_time - self.last_action_time >= self.action_interval then
            if current_time - self.last_action_time >= 10 then
                point = api_GetUnexploredArea(env.radius)
                
                poe2_api.dbgp("radius -- > ", env.radius)
                poe2_api.dbgp("point -- > ", point.x, "--", point.y)
                poe2_api.dbgp("env.have_ritual -- > ", env.have_ritual)
                if point.x ~= -1 and point.y ~= -1 and env.have_ritual then
                    poe2_api.dbgp("貪圖========================================")
                    env.is_map_complete = false
                    env.end_point = {point.x, point.y}
                    env.is_arrive_end = false
                    self.last_action_time = current_time
                    poe2_api.time_p("检查目标点(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                end

                -- poe2_api.dbgp(poe2_api.find_text({UI_info = env.UI_info, text = "地圖完成"}))

                if (point.x == -1 and point.y == -1) or (poe2_api.find_text({UI_info = env.UI_info, text = "地圖完成"}) and (result or poe2_api.find_text({UI_info = env.UI_info, text = "競技場",min_x=0,max_x=1600}))) or (poe2_api.find_text({UI_info = env.UI_info, text ="剩餘 0 隻怪物"}) and not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS)) or poe2_api.find_text({UI_info = env.UI_info, text = "重返地表",min_x = 0,min_y = 0}) then
                    poe2_api.dbgp("地圖完成")
                    
                    -- 提前结束迷雾状态
                    -- if poe2_api.click_text_UI({UI_info = env.UI_info, text = "delirium_skip_delay_button",click=2}) then
                    --     api_Sleep(1000)
                    --     return bret.RUNNING
                    -- end
                
                    -- Boss战Bug记录点回城
                    if player_info.isInBossBattle then
                        local list = poe2_api.get_sorted_list(env.range_info, env.player_info)
                        for _, item in ipairs(list) do
                            if item.name_utf8 == "記錄點" then
                                env.end_point = {item.grid_x, item.grid_y}
                                env.is_arrive_end = false
                                poe2_api.time_p("检查目标点(Boss战Bug记录点回城)(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                                return bret.SUCCESS
                            end
                        end
                    end

                    if poe2_api.table_contains(player_info.current_map_name_utf8,{"MapAugury","MapAugury_NoBoss"}) then
                        if (point.x == -1 and point.y == -1) or poe2_api.find_text({UI_info = env.UI_info, text = "地圖完成"}) or result then
                            local state = get_target_minimap_object(current_map_info)
                            if type(state) == "string" then
                                poe2_api.dbgp("刷新小地图对象--------------------------")
                                return bret.RUNNING
                            elseif state then
                                poe2_api.time_p("检查目标点(state)(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                                return bret.SUCCESS 
                            end
                        end
                    end

                    if string.find(player_info.current_map_name_utf8,"Abyss") then
                        if not poe2_api.find_text({UI_info = env.UI_info, text = "重返地表",min_x = 0,min_y = 0}) then
                            api_InitExplorationArea()
                            poe2_api.time_p("深渊地图(RUNNING1) 耗时 -->", api_GetTickCount64() - current_time)
                            return bret.RUNNING
                        end
                        if not env.is_abyss_time then
                            env.is_abyss_time = true
                            env.abyss_time = api_GetTickCount64()
                            poe2_api.time_p("深渊地图(RUNNING2) 耗时 -->", api_GetTickCount64() - current_time)
                            return bret.RUNNING
                        end
                        env.is_abyss_complete = true
                        poe2_api.find_text({UI_info = env.UI_info, text = "重返地表",min_x = 0,min_y = 0,add_x = -50, click = 2})
                        api_Sleep(1000)
                        poe2_api.time_p("深渊地图(RUNNING) 耗时 -->", api_GetTickCount64() - current_time)
                        return bret.RUNNING
                    else
                        env.is_map_complete = true
                        env.one_other_map = nil
                    end

                    if not string.find(player_info.current_map_name_utf8 or "", "town") and not poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout) or poe2_api.table_contains(player_info.current_map_name_utf8, PRIORITY_MAPS) then
                        no = poe2_api.is_have_mos({range_info = env.range_info, player_info = player_info,dis = 80, not_sight = 1})
                        if no then
                            point = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 60, 10, 0, 0.5)
                            if point then
                                env.end_point = {point.x, point.y}
                                env.is_arrive_end = false
                                poe2_api.time_p("检查目标点(api_GetSafeAreaLocationNoMonsters)(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                                return bret.SUCCESS
                            end
                            env.drop_items = true
                        end

                        -- 寻找传送门

                        if env.range_info then
                            for _, k in ipairs(env.range_info) do
                                if k.name_utf8 ~= '' and k.type == 5 and poe2_api.table_contains(k.name_utf8, my_game_info.hideout_CH) then
                                    dis = poe2_api.point_distance(k.grid_x, k.grid_y, player_info)
                                    if dis and dis < 25 then
                                        if not poe2_api.find_text({UI_info = env.UI_info, text = k.name_utf8, click = 2}) then
                                            api_ClickMove(poe2_api.toInt(k.grid_x), poe2_api.toInt(k.grid_y), poe2_api.toInt(k.world_z), 1)
                                        end
                                        api_Sleep(2000)
                                        env.false_times = 0
                                        return bret.RUNNING
                                    end
                                end
                            end
                        end

                        api_ClickMove(poe2_api.toInt(player_info.grid_x),poe2_api.toInt(player_info.grid_y),poe2_api.toInt(player_info.world_z),7)
                        api_Sleep(500)
                        api_ClickScreen(1230, 815, 0)
                        api_Sleep(500)
                        api_ClickScreen(1230, 815, 1)
                        -- api_Sleep(1500)
                        poe2_api.dbgp("重置地图信息")
                        api_RestoreOriginalMap()
                        api_UpdateMapObstacles(env.radius * 2)
                        self.false_times = self.false_times + 1000
                        env.false_times = self.false_times
                        self.last_action_time = current_time + 2000
                        return bret.RUNNING
                    else
                        env.return_town = false
                        point = api_FindRandomWalkablePosition(player_info.grid_x,player_info.grid_y,50)
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y),poe2_api.toInt(player_info.world_z), 7)
                        end
                        self.last_action_time = current_time 
                        return bret.RUNNING
                    end
                else
                    env.is_map_complete = false
                    env.end_point = {point.x, point.y}
                    env.is_arrive_end = false
                    poe2_api.time_p("检查目标点(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                end
            end
            return bret.RUNNING
        end
    },


    -- 强化(通用)
    -- 核心参数 env.strengthened_map_obj(要强化的物品)
    --  env.warehouse_type_interactive(仓库类型)
    --  env.currency_name(使用通货物品名称)
    Strengthened = {
        run = function(self, env)
            poe2_api.print_log("执行强化操作...")
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.is_wait = false
                self.current = 0
                self.wait_item = nil  
                self.type = nil
                self.bool = true
            end

            if self.current == 0 then
                self.current = api_GetTickCount64()
            end
            if api_GetTickCount64() - self.current > 3000 then
                self.type = nil
                self.current = 0
            end
            poe2_api.dbgp("env.strengthened_map_obj" , env.strengthened_map_obj.category_utf8)
            poe2_api.dbgp("env.warehouse_type_interactive" , env.warehouse_type_interactive)
            poe2_api.dbgp("env.currency_name" , env.currency_name)
            -- api_Sleep(1000000)
            local config = env.user_config
            local item_config = poe2_api.get_items_config_info(config)
            local page = nil
            local type_ck = false -- false 为个仓  true 为公仓
            local map_object = env.strengthened_map_obj
            if env.warehouse_type_interactive == "个仓" then
                type_ck = false
            else
                type_ck = true
            end
            for _, v in ipairs(item_config) do
                if v["類型"] == "通貨" and not v["不撿"] and string.find(env.currency_name,v["基礎類型名"]) and v["工會倉庫"] == type_ck then
                    page = v["存倉頁名"]
                    break
                end
            end
            if not page then
                for _, v in ipairs(item_config) do
                    if v["類型"] == "通貨" and not v["不撿"] and v["基礎類型名"] == "全部物品" and v["工會倉庫"] == type_ck then
                        page = v["存倉頁名"]
                        break
                    end
                end
            end
            poe2_api.dbgp("page" , page)
            -- api_Sleep(1000000)
            local function bag_operate(godown_info,min_x,min_y,max_x,max_y)
                -- 判断背包物品
                local function get_items(bag_info,item)
                    if not bag_info or not next(bag_info) then
                        return false
                    end
                    -- poe2_api.printTable(bag_info)

                    -- api_Sleep()
                    for _, v in ipairs(bag_info) do
                        if v.baseType_utf8 == item then
                            return v
                        end
                    end
                    return false
                end
                -- 判断仓库有无通货页
                local function get_special_page(godown_info,page_type)
                    if not godown_info or not next(godown_info) then
                        return false
                    end
                    -- poe2_api.printTable(godown_info)
                    -- api_Sleep()
                    for _, v in ipairs(godown_info) do
                        if v.type == page_type then
                            if not v.name_utf8 or v.name_utf8 == "" then 
                                error("通货页未设置文本，请在游戏中设置！！！")
                            end
                            return v
                        end
                    end
                    return false
                end
                
                local bag_info = env.bag_info
                local item = get_items(bag_info,env.currency_name)
                if item then
                    local point = poe2_api.get_center_position({item.start_x,item.start_y},{item.end_x,item.end_y})
                    api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                    api_Sleep(300)
                    api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),2)
                    api_Sleep(300)
                    local point = poe2_api.get_center_position({map_object.start_x,map_object.start_y},{map_object.end_x,map_object.end_y})
                    api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                    api_Sleep(300)
                    api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                    api_Sleep(300)
                    if env.currency_name == "崇高石" then
                        env.supreme_use_count = env.supreme_use_count + 1
                    end
                    env.streng_map_flushed_switch = true
                    return false
                end
                local precut_page = nil
                for _, v in ipairs(godown_info) do
                    if v.name_utf8 == page then
                        precut_page = v
                        break
                    end
                end
                if not precut_page then 
                    error("未找到预设存仓页 ->"..tostring(page).."<-,请检查预设存仓页与游戏仓库页是否一致")
                    
                elseif precut_page.manage_index == 0 then
                    if poe2_api.find_text({text = page,UI_info = env.UI_info,max_y=max_y,min_x=min_x,max_x=max_x,min_y=min_y,click = 2}) then 
                        self.is_wait = true
                        self.current = api_GetTickCount64()
                        self.wait_item = 500
                        self.type = page
                    end
                    return false
                end
                local index = nil
                if not type_ck then
                    index = 0
                else
                    index = 2
                end
                
                local currency = api_Getinventorys(precut_page.manage_index,index)
                if currency and next(currency) then
                    
                    local item = get_items(currency,env.currency_name)
                    if item then
                        -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk11111")
                        -- api_Sleep(10000000000000000)
                        if self.type ~= page then
                            if poe2_api.find_text({text = page,UI_info = env.UI_info,max_y=max_y,min_x=min_x,max_x=max_x,min_y=min_y,click = 2}) then 
                                self.is_wait = true
                                self.current = api_GetTickCount64()
                                self.wait_item = 500
                                self.type = page
                                return false
                            end
                        end
                        local point = nil
                        if poe2_api.table_contains(precut_page.type,{0,1}) then
                            point = poe2_api.get_center_position_store({item.start_x,item.start_y},{item.end_x,item.end_y})
                        elseif precut_page.type == 3 then
                            point = my_game_info.currency_page[item.baseType_utf8]
                        elseif precut_page.type == 7 then
                            point = poe2_api.get_center_position_store_max({item.start_x,item.start_y},{item.end_x,item.end_y})
                        end
                        api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                        api_Sleep(200)
                        if index == 0 then
                            api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),2)
                            api_Sleep(200)
                            local point = poe2_api.get_center_position({map_object.start_x,map_object.start_y},{map_object.end_x,map_object.end_y})
                            api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                            api_Sleep(200)
                            api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                            api_Sleep(200)
                            if env.currency_name == "崇高石" then
                                env.supreme_use_count = env.supreme_use_count + 1
                            end
                        else
                            poe2_api.ctrl_left_click(point[1],point[2])
                            api_Sleep(800)
                        end
                        
                        env.streng_map_flushed_switch = true
                        return false
                    end
                end
                -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk222222")
                -- api_Sleep(10000000000000000)
                local page_type = get_special_page(godown_info,3)
                poe2_api.dbgp("precut_page.type",precut_page.type)
                poe2_api.dbgp("page_type",page_type)
                -- api_Sleep(10000000000)
                if precut_page.type == 3 or not page_type then
                    if string.find(map_object.baseType_utf8,"碑牌") then
                        env.is_public_warehouse_plaque = true
                        env.is_update_plaque = false
                    else
                        table.insert(env.lack_of_currency,env.currency_name)
                        -- env.is_strengthened_map = false
                        -- env.streng_map_flushed_switch = false
                        -- env.is_public_warehouse = true
                    end
                    -- env.item_state[env.currency_name] = false
                    return false
                end
                
                if page_type.manage_index == 0 then
                    if poe2_api.find_text({text = page_type.name_utf8,UI_info = env.UI_info,max_y=max_y,min_x=min_x,max_x=max_x,min_y=min_y,click = 2}) then 
                        self.is_wait = true
                        self.current = api_GetTickCount64()
                        self.wait_item = 500
                        self.type = page_type.name_utf8
                        return false
                    end
                end
                -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk44444")
                -- api_Sleep(10000000000000000)
                local currency = api_Getinventorys(page_type.manage_index,index)
                if currency and next(currency) then
                    -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk6666")
                    -- api_Sleep(10000000000000000)
                    poe2_api.dbgp("TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT")
                    local item = get_items(currency,env.currency_name)
                    poe2_api.dbgp(env.currency_name)
                    if item then
                        -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk")
                        -- api_Sleep(10000000000000000)
                        if self.type ~= page_type.name_utf8 then
                            if poe2_api.find_text({text = page_type.name_utf8,UI_info = env.UI_info,max_y=max_y,min_x=min_x,max_x=max_x,min_y=min_y,click = 2}) then 
                                self.is_wait = true
                                self.current = api_GetTickCount64()
                                self.wait_item = 500
                                self.type = page_type.name_utf8
                                return false
                            end
                        end
                        local point = my_game_info.currency_page[item.baseType_utf8]
                        api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                        api_Sleep(200)
                        if index == 0 then
                            api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),2)
                            api_Sleep(200)
                            local point = poe2_api.get_center_position({map_object.start_x,map_object.start_y},{map_object.end_x,map_object.end_y})
                            api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                            api_Sleep(200)
                            api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                            api_Sleep(200)
                            if env.currency_name == "崇高石" then
                                env.supreme_use_count = env.supreme_use_count + 1
                            end
                        else
                            poe2_api.ctrl_left_click(point[1],point[2])
                            api_Sleep(800)
                        end
                        env.streng_map_flushed_switch = true
                        return false
                    end
                end
                -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk555555")
                -- api_Sleep(10000000000000000)
                if string.find(map_object.baseType_utf8,"碑牌") then
                    env.is_public_warehouse_plaque = true
                    env.is_update_plaque = false
                else
                    table.insert(env.lack_of_currency,env.currency_name)
                    -- env.is_strengthened_map = false
                    -- env.streng_map_flushed_switch = false
                    -- env.is_public_warehouse = true
                end
                -- env.item_state[env.currency_name] = false
                return false
            end
            
            if self.is_wait then
                if api_GetTickCount64() - self.current > self.wait_item then 
                    poe2_api.dbgp("等待间隔时间到达")
                    poe2_api.time_p("强化(通用)（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                self.is_wait = false
            end
            if not poe2_api.find_text({UI_info=env.UI_info,text="背包",min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                poe2_api.click_keyboard("i")
                api_Sleep(500)
                self.is_wait = true
                self.current = api_GetTickCount64()
                self.wait_item = 1000
                poe2_api.time_p("强化(通用)（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local tab_list_button = poe2_api.click_text_UI({text = "tab_list_button", UI_info = env.UI_info,ret_data = true})
            if not tab_list_button then
                local godown_info
                if not type_ck then
                    godown_info = api_GetRepositoryPages(0)
                else
                    godown_info = api_GetRepositoryPages(1)
                end
                if not bag_operate(godown_info,0,0,500,90) then
                    poe2_api.time_p("强化(通用)（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            else
                
                local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
                local lock_button = {}
                for _,v in ipairs(lock) do
                    if v.name_utf8 == "" and v.text_utf8 == "" then
                        table.insert(lock_button,v)
                    end
                end
                if not lock_button or not next(lock_button) then
                    api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                    api_Sleep(2000)
                    api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),1)
                    api_Sleep(1000)
                    poe2_api.time_p("强化(通用)（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local godown_info
                if not type_ck then
                    godown_info = api_GetRepositoryPages(0)
                else
                    godown_info = api_GetRepositoryPages(1)
                end
                if not bag_operate(godown_info,556,20,851,469) then
                    poe2_api.time_p("强化(通用)（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            poe2_api.time_p("强化(通用)（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.RUNNING
        end
    },

    -- 地图强化是否到点
    Is_Arrive_Point_FUHUASHENGYV = {
        run = function(self, env)
            poe2_api.print_log("强化地图(腐化圣域)...")
            local start_time = api_GetTickCount64()
            local player_info = env.player_info
            local bag_info = env.bag_info
            local current_map_info = env.current_map_info
            local is_insert_stone = env.is_insert_stone
            local entry_length_take_map = env.entry_length_take_map
            local the_update_map = env.the_update_map
            local map_update_to = env.map_update_to
            local user_map = env.user_map
            local map_up = env.map_up
            local priority_map = env.priority_map
            local not_have_stackableCurrency = env.not_have_stackableCurrency
            
            -- 检查是否在城镇或藏身处
            if not string.find(player_info.current_map_name_utf8, "town") and 
                not poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) or 
                not map then
                    poe2_api.dbgp("不在城镇或藏身处，或未找到地图装置")
                    env.entry_length_take_map = true
                    env.not_have_stackableCurrency = false
                    poe2_api.dbgp(string.format("节点执行耗时: %.2f 毫秒", (api_GetTickCount64() - start_time) * 1000))
                    return bret.SUCCESS
            end
            
            -- 检查地图强化条件
            if the_update_map then
                poe2_api.dbgp("检查地图强化条件...")
                local map_level = poe2_api.select_best_map_key({
                    inventory = bag_info,
                    key_level_threshold = user_map,
                    priority_map = priority_map,
                    vall = true
                })
                
                if map_level then
                    poe2_api.dbgp(string.format("找到地图: %s (颜色: %d, 词缀数: %d)", 
                        map_level.baseType_utf8, map_level.color, map_level.fixedSuffixCount))
                    
                    if map_level.color > 0 and map_level.fixedSuffixCount >= map_update_to then
                        poe2_api.dbgp("地图已满足强化条件，重置状态")
                        env.map_up = false
                        env.entry_length_take_map = false
                        env.the_update_map = nil
                        poe2_api.dbgp(string.format("节点执行耗时: %.2f 毫秒", (api_GetTickCount64() - start_time) * 1000))
                        return bret.SUCCESS
                    end
                end
            end
            
            -- 检查是否需要强化
            if not map_up or not entry_length_take_map then
                poe2_api.dbgp("不需要强化地图或未设置entry_length_take_map")
                env.not_have_stackableCurrency = false
                poe2_api.dbgp(string.format("节点执行耗时: %.2f 毫秒", (api_GetTickCount64() - start_time) * 1000))
                return bret.SUCCESS
            end
            
            local map = nil
            for _, item in ipairs(current_map_info) do
                if item.name_utf8 == "MapDevice" then
                    map = item
                    break
                end
            end
            
            if not the_update_map then
                poe2_api.dbgp("未设置the_update_map")
                env.not_have_stackableCurrency = false
                env.entry_length_take_map = true
                poe2_api.dbgp(string.format("节点执行耗时: %.2f 毫秒", (api_GetTickCount64() - start_time) * 1000))
                return bret.SUCCESS
            end
            
            if not_have_stackableCurrency then
                poe2_api.dbgp("没有可堆叠货币")
                poe2_api.dbgp(string.format("节点执行耗时: %.2f 毫秒", (api_GetTickCount64() - start_time) * 1000))
                return bret.SUCCESS
            end
            
            -- 移动逻辑部分
            poe2_api.dbgp("开始处理移动逻辑...")
            local function get_items_config_info()
                local config = env.user_config
                local item_filters = config["物品過濾"] or {}
                local processed_configs = {}
                
                for _, cfg in ipairs(item_filters) do
                    local item_type = cfg["類型"]
                    if type(item_type) == "string" then
                        item_type = {item_type}
                    end
                    
                    local processed_cfg = {
                        ["類型"] = item_type,
                        ["名稱模式"] = cfg["基礎類型名"] == "全部物品" and "all" or "specific",
                        ["匹配名稱"] = cfg["基礎類型名"] ~= "全部物品" and {cfg["基礎類型名"]} or {},
                        ["颜色"] = {}
                    }
                    
                    if cfg["白裝"] then table.insert(processed_cfg["颜色"], 0) end
                    if cfg["藍裝"] then table.insert(processed_cfg["颜色"], 1) end
                    if cfg["黃裝"] then table.insert(processed_cfg["颜色"], 2) end
                    if cfg["暗金"] then table.insert(processed_cfg["颜色"], 3) end
                    
                    table.insert(processed_configs, processed_cfg)
                end
                
                return processed_configs
            end
            
            local items_info = get_items_config_info()
            local unique_storage_pages = {}
            
            for _, item in ipairs(items_info) do
                if item["類型"] == "通貨" and item["存倉頁名"] and not item["工會倉庫"] then
                    unique_storage_pages[item["存倉頁名"]] = true
                end
            end
            
            local obj = nil
            local text = nil
            local warehouse = nil
            
            if next(unique_storage_pages) ~= nil then
                poe2_api.dbgp("使用个人仓库")
                for _, item in ipairs(current_map_info) do
                    if item.name_utf8 == "StashPlayer" then
                        warehouse = item
                        break
                    end
                end
                obj = "StashPlayer"
                text = "公會倉庫"
            else
                poe2_api.dbgp("使用公会仓库")
                for _, item in ipairs(current_map_info) do
                    if item.name_utf8 == "StashGuild" then
                        warehouse = item
                        break
                    end
                end
                obj = "StashGuild"
                text = "倉庫"
                env.is_public_warehouse_plaque = false
            end
            
            if poe2_api.find_text({UI_info = env.UI_info, text = "強調物品", min_y = 700, min_x = 250}) and 
            not poe2_api.find_text({UI_info = env.UI_info, text = text, min_x = 0, min_y = 32, max_x = 381, max_y = 81}) then
                poe2_api.dbgp("已打开仓库界面")
                poe2_api.print_log("清路径444")
                env.path_list = nil
                env.end_point = nil
                return bret.SUCCESS
            end
            
            if not warehouse then
                poe2_api.dbgp("未找到仓库对象")
                return bret.FAIL
            end
            
            local distance = poe2_api.point_distance(warehouse.grid_x, warehouse.grid_y, player_info)
            poe2_api.dbgp(string.format("与仓库的距离: %.2f", distance))
            
            if distance and distance > 25 then
                poe2_api.dbgp("距离仓库太远，设置交互对象")
                env.interactive = obj
                poe2_api.dbgp(string.format("节点执行耗时: %.2f 毫秒", (api_GetTickCount64() - start_time) * 1000))
                return bret.FAIL
            else
                poe2_api.dbgp("正在移动到仓库位置...")
                api_ClickMove(poe2_api.toInt(warehouse.grid_x), poe2_api.toInt(warehouse.grid_y), poe2_api.toInt(player_info.world_z - 70), 1)
                poe2_api.dbgp(string.format("节点执行耗时: %.2f 毫秒", (api_GetTickCount64() - start_time) * 1000))
                return bret.RUNNING
            end
        end
    },

    -- 是否需要插入碑牌
    Is_Insert_Plaque = {
        run = function(self, env)
            poe2_api.print_log("是否需要插入碑牌...")
            local start_time = api_GetTickCount64()
            local player_info = env.player_info
            local current_map_info = env.current_map_info
            if not next(player_info) then
                poe2_api.dbgp("未找到玩家信息,插碑")
                poe2_api.time_p("是否需要插入碑牌（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            
            local is_insert_stone = env.is_insert_stone
            if not is_insert_stone then
                poe2_api.dbgp("未开启插碑，不判断")
                poe2_api.time_p("是否需要插入碑牌（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local is_have_stone = env.is_have_stone
            if not is_have_stone then
                poe2_api.dbgp("未找到可插入的塔")
                poe2_api.time_p("是否需要插入碑牌（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time) 
                return bret.SUCCESS
            end
            local not_exist_stone = env.not_exist_stone
            local stone_order = env.stone_order
            -- 判断两个数组是否相等
            local function deep_equal_unordered(a, b)
                if type(a) ~= type(b) then return false end
                if type(a) ~= "table" then return a == b end
                if #a ~= #b then return false end
            
                -- 统计 a 的元素（支持嵌套 table）
                local count = {}
                for _, v in ipairs(a) do
                    local key = type(v) == "table" and table.concat(v, ",") or tostring(v)
                    count[key] = (count[key] or 0) + 1
                end
            
                -- 检查 b 的元素
                for _, v in ipairs(b) do
                    local key = type(v) == "table" and table.concat(v, ",") or tostring(v)
                    if not count[key] then return false end
                    count[key] = count[key] - 1
                end
            
                return true
            end
            local function get_bag_plaque()
                if not env.bag_info or not next(env.bag_info) then return false end
                for i, v in ipairs(env.bag_info) do
                    if v.category_utf8 == "TowerAugmentation" then
                        return true
                    end
                end
                return false
            end 
            if not_exist_stone and next(not_exist_stone) and stone_order and next(stone_order) then
                if not get_bag_plaque and deep_equal_unordered(not_exist_stone, stone_order)  then
                    poe2_api.dbgp("没有可用碑牌")
                    poe2_api.time_p("是否需要插入碑牌（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
            end
            poe2_api.time_p("是否需要插入碑牌（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end
    },

    -- 是否需要移动插碑
    Is_Move_Insert_Plaque = {
        run = function(self, env)
            poe2_api.dbgp("是否需要移动插碑...")
            local start_time = api_GetTickCount64()
            local current_map_info = env.current_map_info
            local player_info = env.player_info
            if not next(player_info) then
                poe2_api.dbgp("未找到玩家信息,插碑移动")
                poe2_api.time_p("是否需要移动插碑（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if not current_map_info then
                poe2_api.dbgp("未找到小地图信息,插碑移动")
                poe2_api.time_p("是否需要移动插碑（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local function is_map_device(obj_list)
                if not obj_list or #obj_list == 0 then
                    return false
                end
                for _, i in ipairs(obj_list) do
                    if i.name_utf8 == "MapDevice" then
                        return i
                    end
                end
                return false
            end
            local map = is_map_device(current_map_info)
            if map then
                local distance = poe2_api.point_distance(map.grid_x, map.grid_y, player_info)
                if poe2_api.find_text({text = "世界地圖",UI_info = env.UI_info,min_x=0,min_y=0,max_y=81}) and distance <30 then
                    env.end_point = {}
                    api_Sleep(500)
                    poe2_api.time_p("是否需要移动插碑（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
            end
            env.interactive = "MapDevice"
            poe2_api.dbgp("正在移动到地图装置位置  ")
            poe2_api.time_p("是否需要移动插碑（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end
    },

    -- 插入牌匾(动作)
    Insert_Plaque = {
        run = function(self, env)
            poe2_api.print_log("执行插入牌匾动作...")
            local start_time = api_GetTickCount64()
            if not poe2_api.find_text({UI_info = env.UI_info,text = "世界地圖",min_x=0,min_y=0,max_y=81}) then
                poe2_api.time_p("插入牌匾(动作)（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            else
                api_Sleep(1000)
            end

            local ret = api_GetEndgameMapNodes()
            local bag_info = env.bag_info
            local stone_info = env.stone_info
            local sorted_map = env.sorted_map
            local user_map = env.user_map
            local not_use_map = env.not_use_map
            local not_enter_map = env.not_enter_map
            local priority_map = env.priority_map
            local error_other_map = env.error_other_map
            local not_have_stackableCurrency = env.not_have_stackableCurrency
            local get_map =  poe2_api.get_map(
                {otherworld_info = ret, sorted_map = sorted_map, not_enter_map = not_enter_map, bag_info = bag_info, 
                key_level_threshold = user_map, not_use_map = not_use_map, 
                priority_map = priority_map, error_other_map = error_other_map, 
                not_have_stackableCurrency = not_have_stackableCurrency}
                )
            if not get_map then
                poe2_api.dbgp("没有最优地图，不插碑")
                env.is_have_stone = false
                poe2_api.time_p("插入牌匾(动作)（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not stone_info then
                api_EndgameNodeMove(poe2_api.toInt(get_map.position_x -1900),poe2_api.toInt(get_map.position_y-1900))
                api_Sleep(500)
            end
            if get_map.window_client_x == 0 and get_map.window_client_y == 0 then
                -- env.need_SmallRetreat = true
                poe2_api.time_p("插入牌匾(动作)（FAIL2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local ret2 = api_GetEndgameMapNodes()
            local get_map1 = nil
            for _, i in ipairs(ret2) do
                if i.index_x == get_map.index_x and i.index_y == get_map.index_y then
                    get_map1 = i
                    break
                end
            end
            if stone_info then
                local tower2 = nil
                for _, i in ipairs(ret2) do
                    if poe2_api.table_contains(i.name_utf8,my_game_info.PRIORITY_MAPS) 
                     and i.isCompleted and i.index_x == stone_info.index_x and i.index_y == stone_info.index_y then
                        tower2 = i
                        break
                    end
                end
                if not tower2 then
                    env.stone_info = nil
                    env.is_get_plaque = false
                    env.pick_up_number = 0
                    poe2_api.time_p("插入牌匾(动作)（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            if not stone_info then
                local tower = nil
                for _, i in ipairs(ret2) do
                    if poe2_api.table_contains(i.name_utf8,my_game_info.PRIORITY_MAPS)
                     and i.isCompleted and get_map1 and poe2_api.get_point_distance(get_map1.window_client_x,get_map1.window_client_y,i.window_client_x,i.window_client_y) <= 1000 then
                        tower = i
                        break
                    end
                end
                if tower then
                    env.stone_info = tower
                    env.pick_up_number = tower.monumentUnlockCount
                    local get_plaque = api_Getinventorys(77,0)
                    -- local pick_up_number = env.pick_up_number
                    if get_plaque and next(get_plaque) and #get_plaque >= tower.monumentUnlockCount then

                    else
                        env.is_get_plaque = true
                        env.is_update_plaque = true
                    end
                    
                    poe2_api.time_p("插入牌匾(动作)（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                else
                    env.is_have_stone = false
                    env.is_get_plaque = false
                    env.pick_up_number = 0
                    poe2_api.time_p("插入牌匾(动作)（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end

            local stone_order = env.stone_order
            api_EndgameNodeMove(poe2_api.toInt(stone_info.position_x),poe2_api.toInt(stone_info.position_y))
            api_Sleep(500)
            local ret1 = api_GetEndgameMapNodes()
            local tower1 = nil 
            for _, i in ipairs(ret1) do
                if poe2_api.table_contains(i.name_utf8,my_game_info.PRIORITY_MAPS)
                 and i.isCompleted and i.index_x == stone_info.index_x and i.index_y == stone_info.index_y then
                    tower1 = i
                    break
                end
            end
            -- poe2_api.printTable(tower1)
            -- api_Sleep(5000)
            if not poe2_api.find_text({text = tower1.name_cn_utf8, UI_info = env.UI_info,max_y=500,min_x=750,max_x=1100,min_y=400}) then
                if tower1.window_client_x == 0 or tower1.window_client_y == 0 then
                    -- env.need_SmallRetreat = true
                    poe2_api.time_p("插入牌匾(动作)（FAIL3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if env.operated_plaque then
                    env.is_have_stone = false
                    poe2_api.time_p("插入牌匾(动作)（RUNNING11）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                math.randomseed(os.time())
                local x = math.random(tower1.window_client_x - 10, tower1.window_client_x + 10)
                local y = math.random(tower1.window_client_y - 10, tower1.window_client_y + 10)
                poe2_api.dbgp("x,y:",x,y)
                poe2_api.click_keyboard("ctrl")
                api_Sleep(200)
                api_ClickScreen(poe2_api.toInt(x),poe2_api.toInt(y),0)
                api_Sleep(200)
                api_ClickScreen(poe2_api.toInt(x),poe2_api.toInt(y),1)
                api_Sleep(500)
                poe2_api.time_p("插入牌匾(动作)（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            elseif poe2_api.find_text({text = "警告", UI_info = env.UI_info,min_x=0}) then
                poe2_api.find_text({text = "勢力", UI_info = env.UI_info,min_x=0,click = 2,sorted=true})
                api_Sleep(500)
                poe2_api.find_text({text = "確定", UI_info = env.UI_info,min_x=0,click = 2})
                api_Sleep(500)
                poe2_api.time_p("插入牌匾(动作)（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            elseif poe2_api.find_text({text = tower1.name_cn_utf8, UI_info = env.UI_info,max_y=500,min_x=750,max_x=1100,min_y=400}) and poe2_api.find_text({text = "勢力", UI_info = env.UI_info,max_y=880,min_x=750,max_x=1100}) then
                if not poe2_api.find_text({UI_info=env.UI_info,text="背包",min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                    poe2_api.click_keyboard("i")
                    api_Sleep(200)
                    poe2_api.time_p("插入牌匾(动作)（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local get_plaque = api_Getinventorys(77,0)
                local pick_up_number = env.pick_up_number
                if get_plaque and next(get_plaque) and #get_plaque >= pick_up_number then
                    poe2_api.find_text({text = "勢力", UI_info = env.UI_info,max_y=880,min_x=750,max_x=1100,click = 2})
                    api_Sleep(200)
                    env.operated_plaque = true
                    poe2_api.time_p("插入牌匾(动作)（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                else
                    if not stone_order then
                        poe2_api.time_p("插入牌匾(动作)（RUNNING8）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    local function store_plaque(bag_info,stone_order)
                        if not bag_info or not next(bag_info) then
                            return false
                        end
                        for _,v in ipairs(stone_order) do
                            for _,v2 in ipairs(bag_info) do
                                if v == v2.baseType_utf8 then
                                    return v2
                                end
                            end
                        end
                        return false
                    end
                    local one_plaque = store_plaque(bag_info,stone_order)
                    if one_plaque then
                        poe2_api.ctrl_left_click_bag_items(one_plaque.obj,bag_info)
                    else
                        env.is_have_stone = false
                    end
                    poe2_api.time_p("插入牌匾(动作)（RUNNING9）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            poe2_api.time_p("插入牌匾(动作)（RUNNING10）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.RUNNING
        end
    },

    -- 是否需要交换
    Is_Need_Exchange = {
        run = function(self, env)
            poe2_api.dbgp("开始执行通货交换检查...")
            local current_time = api_GetTickCount64()  -- 获取的是毫秒数
            local config = env.user_config
            local bag_info = env.bag_info
            local player_info = env.player_info

            env.in_exchange = false
            
            if not self.is_exchange then
                self.is_exchange = config["刷圖設置"]["通貨交換設置"]["是否自動對換"]
            end

            -- 基础条件检查
            if not self.is_exchange then
                poe2_api.dbgp("自动兑换未开启，跳过")
                env.exchange_status = true
                poe2_api.time_p("Is_Need_Exchange(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
            
            -- 初始化执行时间
            if env.last_execution_time == nil or env.last_execution_time == 0 then
                poe2_api.dbgp("初始化执行时间")
                env.last_execution_time = api_GetTickCount64()
                return bret.RUNNING
            end
            
            -- 检查是否在藏身处
            if not poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                poe2_api.dbgp("不在藏身处，跳过")
                return bret.SUCCESS
            end
            
            -- 检查背包空间
            if bag_info then
                local point = poe2_api.get_space_point({width = 2, height = 4, info = bag_info})
                if not point then
                    poe2_api.dbgp("背包空间不足，跳过")
                    return bret.SUCCESS
                end
            end
            
            -- 检查仓库是否已满
            -- if not env.warehouse_full then
            --     poe2_api.dbgp("仓库已满，跳过")
            --     return bret.SUCCESS
            -- end
            
            -- 冷却时间检查
            local cooldown_hours = config["刷圖設置"]["通貨交換設置"]["兌換間隔時間"] or 1
            local cooldown_ms = cooldown_hours * 60 * 60 * 1000  -- 转换为毫秒
            local elapsed_time = current_time - env.last_execution_time  -- 毫秒数相减

            -- 毫秒转换为分钟和秒的字符串
            local function ms_to_min_sec(ms)
                local total_seconds = math.floor(ms / 1000)
                local minutes = math.floor(total_seconds / 60)
                local seconds = total_seconds % 60
                return string.format("%d分%d秒", minutes, seconds)
            end
            
            -- 使用转换函数显示更友好的时间格式
            poe2_api.dbgp(string.format("冷却时间检查: 已过 %s (需要 %s)", 
                ms_to_min_sec(elapsed_time), 
                ms_to_min_sec(cooldown_ms)))
            
            if elapsed_time < cooldown_ms and not env.warehouse_full then
                poe2_api.dbgp("冷却时间未到，跳过")
                return bret.SUCCESS
            end
            
            -- 取消遮挡
            if poe2_api.find_text({UI_info = env.UI_info, text = "繼續", click = 2}) then
                poe2_api.dbgp("发现遮挡，点击继续")
                return bret.RUNNING
            end

            if poe2_api.find_text({UI_info = env.UI_info, text = "重鑄台", min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", min_x = 0}) then
                poe2_api.dbgp("发现重铸台界面，按空格关闭")
                poe2_api.click_keyboard("space")
                self.last_action_time = current_time
                return bret.RUNNING
            end
            
            poe2_api.dbgp("满足所有条件，执行兑换")
            env.in_exchange = true
            return bret.FAIL
        end
    },

    -- 获取物品数量
    Obtain_The_Quantity_of_Items = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Obtain_The_Quantity_of_Items 节点")
            
            -- 检查仓库页面是否可用
            local function check_pages()
                poe2_api.dbgp("检查仓库页面是否可用...")
                local pages = api_GetRepositoryPages(0)
                if not pages then
                    poe2_api.dbgp("警告: 无法获取仓库页面信息")
                    return false
                end
                
                for _, page in ipairs(pages) do
                    if page.onlyWithdraw then
                        goto continue
                    end
                    if page.manage_index == 0 and page.type ~= 5 then
                        poe2_api.dbgp("发现无效仓库页面(manage_index=0且type≠5)")
                        return false
                    end
                    ::continue::
                end
                return true
            end
            
            -- 获取所有库存物品
            local function get_all_inventory_items()
                poe2_api.dbgp("开始获取所有库存物品...")
                local items = {}
                
                -- 获取常规背包物品
                local bag_items = api_Getinventorys(1, 0)
                if bag_items then
                    poe2_api.dbgp(string.format("获取到背包物品数量: %d", #bag_items))
                    for _, item in ipairs(bag_items) do
                        table.insert(items, item)
                    end
                else
                    poe2_api.dbgp("警告: 无法获取背包物品")
                end
                
                -- 检查特定槽位(0x7a 到 0x7a + 199)
                for offset = 0x7a, 0x7a + 199 do
                    local slot_data = api_Getinventorys(offset, 0)
                    if slot_data then
                        -- poe2_api.dbgp(string.format("槽位 0x%x 找到 %d 件物品", offset, #slot_data))
                        for _, item in ipairs(slot_data) do
                            table.insert(items, item)
                        end
                    end
                end
                
                poe2_api.dbgp(string.format("总共获取到 %d 件物品", #items))
                return items
            end
            
            -- 主逻辑开始
            if not check_pages() then
                poe2_api.dbgp("仓库页面不可用，返回FAIL")
                return bret.FAIL
            end
            
            local config = env.user_config
            if not config then
                poe2_api.dbgp("错误: 用户配置为空")
                return bret.FAIL
            end
            
            -- 获取通货交换设置
            local exchange_config = config["刷圖設置"] and config["刷圖設置"]["通貨交換設置"] or {}
            poe2_api.dbgp("获取通货交换配置:", #exchange_config)
            -- poe2_api.printTable(exchange_config)

            -- 初始化拥有和需要的通货列表
            local owned_currencies = {}
            local needed_currencies = {}

            -- 检查是否存在物品表
            if exchange_config["物品表"] then
                for _, item in ipairs(exchange_config["物品表"]) do
                    -- 添加拥有的通货
                    if item["我擁有的"] and item["我擁有的"] ~= "" then
                        table.insert(owned_currencies, item["我擁有的"])
                    end
                    
                    -- 添加需要的通货
                    if item["我需要的"] and item["我需要的"] ~= "" then
                        table.insert(needed_currencies, item["我需要的"])
                    end
                end
            end

            poe2_api.dbgp("配置中的拥有通货:", #owned_currencies)
            -- poe2_api.printTable(owned_currencies)
            poe2_api.dbgp("配置中的需要通货:", #needed_currencies)
            -- poe2_api.printTable(needed_currencies)
            
            -- 初始化物品数量字典
            local item_nums_dict = {}
            local all_items = get_all_inventory_items()
            
            -- 检查是否存在"全部物品"需求
            local has_all_items = false
            for _, currency in ipairs(owned_currencies) do
                if currency == "全部物品" then
                    has_all_items = true
                    break
                end
            end
            
            poe2_api.dbgp("配置中包含'全部物品':", has_all_items)
            
            -- 通货类别列表
            local currency_categories = {}
            
            -- 合并所有通货类别
            local function merge_tables(...)
                local result = {}
                for _, tbl in ipairs({...}) do
                    for _, v in ipairs(tbl) do
                        table.insert(result, v)
                    end
                end
                return result
            end
            
            currency_categories = merge_tables(
                my_game_info.StackableCurrency_CN,
                my_game_info.Delirium_in_foreign_lands_CN,
                my_game_info.Crack_Alliance_CN,
                my_game_info.Fragment_CN,
                my_game_info.Dead_realm_exploration_CN,
                my_game_info.Essence_CN,
                my_game_info.Rune_CN,
                my_game_info.Sign_CN,
                my_game_info.SoulCore_CN,
                my_game_info.Sigil_CN
            )
            
            if has_all_items then
                poe2_api.dbgp("处理'全部物品'配置...")
                for _, currency in ipairs(currency_categories) do
                    item_nums_dict[currency] = 0
                    for _, item in ipairs(all_items) do
                        if item.baseType_utf8 == currency then
                            item_nums_dict[currency] = (item_nums_dict[currency] or 0) + (item.stackCount or 1)
                        end
                    end
                end
            else
                poe2_api.dbgp("处理特定通货配置...")
                for _, currency in ipairs(owned_currencies) do
                    if string.find(currency, "|") then
                        -- 处理分割的通货(如"混沌石|崇高石")
                        local currency_parts = {}
                        for part in string.gmatch(currency, "([^|]+)") do
                            table.insert(currency_parts, part)
                        end
                        
                        for _, part in ipairs(currency_parts) do
                            item_nums_dict[part] = 0
                            for _, item in ipairs(all_items) do
                                if item.baseType_utf8 == part then
                                    item_nums_dict[part] = (item_nums_dict[part] or 0) + (item.stackCount or 1)
                                end
                            end
                        end
                    else
                        item_nums_dict[currency] = 0
                        for _, item in ipairs(all_items) do
                            if item.baseType_utf8 == currency then
                                item_nums_dict[currency] = (item_nums_dict[currency] or 0) + (item.stackCount or 1)
                            end
                        end
                    end
                end
            end
            
            -- 过滤掉数量为0的通货
            local filtered_dict = {}
            for currency, count in pairs(item_nums_dict) do
                if count > 0 then
                    filtered_dict[currency] = count
                end
            end
            item_nums_dict = filtered_dict
            
            poe2_api.dbgp("过滤后的物品数量字典:", item_nums_dict)
            
            -- 检查兑换条件并过滤不满足的货币
            local valid_owned = {}
            local valid_needed = {}
            
            for i = 1, math.min(#owned_currencies, #needed_currencies) do
                local owned = owned_currencies[i]
                local needed = needed_currencies[i]
                
                if owned == "全部物品" then
                    if has_all_items then
                        for item, _ in pairs(item_nums_dict) do
                            if item ~= "神聖石" and 
                            not poe2_api.table_contains(owned_currencies, item) and 
                            item ~= needed then
                                table.insert(valid_owned, item)
                                table.insert(valid_needed, needed)
                            end
                        end
                    end
                    goto continue
                end
                
                -- 处理包含"|"的分割货币
                if string.find(owned, "|") then
                    for part in string.gmatch(owned, "([^|]+)") do
                        if item_nums_dict[part] then
                            table.insert(valid_owned, part)
                            table.insert(valid_needed, needed)
                        end
                    end
                    goto continue
                end
                
                if owned == needed then
                    goto continue
                end
                
                if not item_nums_dict[owned] then
                    goto continue
                end
                
                -- 检查货币数量是否>0且比例有效
                table.insert(valid_owned, owned)
                table.insert(valid_needed, needed)
                
                ::continue::
            end
            
            poe2_api.dbgp("有效的拥有通货:", #valid_owned)
            -- poe2_api.printTable(valid_owned)
            poe2_api.dbgp("有效的需要通货:", #valid_needed)
            -- poe2_api.printTable(valid_needed)
            
            -- 更新黑板参数
            if not next(env.owned_currencies) and not next(env.needed_currencies) then
                env.owned_currencies = valid_owned
                env.needed_currencies = valid_needed
                poe2_api.dbgp("首次设置黑板中的通货列表")
            end
            
            -- 转换为列表格式并更新黑板
            local item_nums_list = {}
            for _, currency in ipairs(valid_owned) do
                if item_nums_dict[currency] then
                    table.insert(item_nums_list, {currency, item_nums_dict[currency]})
                end
            end
            
            env.item_nums_list = item_nums_list
            poe2_api.dbgp("更新黑板中的物品数量列表:", item_nums_list)
            
            -- 检查是否有满足兑换条件的货币
            if #valid_owned > 0 then
                env.enough_currency = true
                poe2_api.dbgp("找到满足兑换条件的货币，返回FAIL")
                return bret.FAIL
            end
            
            env.enough_currency = false
            poe2_api.dbgp("未找到满足兑换条件的货币，返回SUCCESS")
            return bret.SUCCESS
        end
    },

    -- 点击所有仓库页
    Click_All_Pages = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Click_All_Pages 节点")
            
            local current_time = api_GetTickCount64()
            
            
            -- 检查仓库页面是否可用
            local function _check_pages()
                poe2_api.dbgp("检查仓库页面可用性...")
                local pages = api_GetRepositoryPages(0)  -- 0表示个人仓库
                if not pages then
                    poe2_api.dbgp("获取仓库页面失败")
                    return false
                end
                
                for _, page in ipairs(pages) do
                    if page.onlyWithdraw then
                        goto continue
                    end
                    if page.manage_index == 0 and page.type ~= 5 then
                        poe2_api.dbgp(string.format("发现无效页面: 索引=%d, 类型=%d, 名称=%s", 
                            page.manage_index, page.type, page.name_utf8 or "未知"))
                        return false
                    end
                    ::continue::
                end
                return true
            end

            -- 主逻辑
            if _check_pages() then
                poe2_api.dbgp("所有仓库页面均可用，返回FAIL")
                return bret.FAIL
            end

            -- 检查是否已打开仓库界面
            local emphasize_text = poe2_api.find_text({UI_info = env.UI_info, text = "強調物品", min_x = 250, min_y = 700})
            local warehouse_text = poe2_api.find_text({UI_info = env.UI_info, text = "倉庫", min_x = 0, min_y = 32, max_x = 381, max_y = 81})
            -- local warehouse_text = poe2_api.find_text({UI_info = env.UI_info, text = "公會倉庫", min_x = 0, min_y = 32, max_x = 381, max_y = 81})
            
            poe2_api.dbgp("仓库界面检查结果:", {
                emphasize_text = emphasize_text and "found" or "not found",
                warehouse_text = warehouse_text and "found" or "not found"
            })

            if not emphasize_text or not warehouse_text then
                poe2_api.dbgp("未打开仓库界面，返回SUCCESS")
                env.warehouse_type_interactive = "个仓"
                -- env.warehouse_type_interactive = "公仓"
                return bret.SUCCESS
            end

            api_Sleep(2000)  -- 等待2秒

            -- 获取仓库标签按钮
            local tab_list_button = poe2_api.click_text_UI({UI_info = env.UI_info, text = "tab_list_button", ret_data = true})
            poe2_api.dbgp("标签按钮状态:", tab_list_button and "found" or "not found")

            -- 获取仓库页面
            local item_pages = {}
            local pages = api_GetRepositoryPages(0)
            if pages then
                for _, page in ipairs(pages) do
                    if page.onlyWithdraw then
                        goto continue
                    end
                    if page.type ~= 5 and page.manage_index == 0 then  -- 跳过地图页
                        table.insert(item_pages, page)
                        poe2_api.dbgp(string.format("添加仓库页: 名称=%s, 类型=%d, 索引=%d", page.name_utf8, page.type, page.manage_index))
                        poe2_api.dbgp("qvchu=%d", page.onlyWithdraw)
                    end
                    ::continue::
                end
            else
                poe2_api.dbgp("警告: 无法获取仓库页面列表")
                return bret.RUNNING
            end

            if not tab_list_button then
                poe2_api.dbgp("未展开标签列表的情况")
                -- 未展开标签列表的情况
                for _, page in ipairs(item_pages) do
                    poe2_api.dbgp(string.format("尝试点击页面: %s", page.name_utf8))
                    local text = nil
                    if page.onlyWithdraw then
                        text = page.name_utf8 .. "（只可取出）"
                    else
                        text = page.name_utf8
                    end
                    poe2_api.dbgp(string.format("点击页面: %s", text))
                    poe2_api.find_text({UI_info = env.UI_info, 
                        text = text,
                        max_y = 90,
                        min_x = 0,
                        max_x = 550,
                        min_y = 0,
                        click = 2
                    })
                    api_Sleep(200)
                end
                poe2_api.dbgp("完成未展开标签列表的页面点击")
                return bret.RUNNING
            else
                poe2_api.dbgp("已展开标签列表的情况")
                -- 已展开标签列表的情况
                local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
                -- poe2_api.printTable(lock)
                -- api_Sleep(10000)
                local lock_button = nil
                for _, v in ipairs(lock) do
                    if v.left >= 549 and v.top >= 34 and v.right <= 586 and v.bottom <= 76 and v.name_utf8 ~= 'bottom_icons_layout' then
                        lock_button = v
                        break
                    end
                end

                if not lock_button then
                    poe2_api.dbgp("未找到锁定按钮，尝试点击标签列表")
                    api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),0)
                    api_Sleep(500)
                    api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                    api_Sleep(2000)
                    api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),0)
                    api_Sleep(500)
                    api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),1)
                    api_Sleep(1000)
                    return bret.RUNNING
                end

                -- 点击所有页面
                for _, page in ipairs(item_pages) do
                    poe2_api.dbgp(string.format("尝试点击展开列表中的页面: %s", page.name_utf8))
                    local text = nil
                    if page.onlyWithdraw then
                        text = page.name_utf8 .. " （只可取出）"
                    else
                        text = page.name_utf8
                    end
                    poe2_api.dbgp(string.format("展开列表中的页面: %s", text))
                    poe2_api.find_text({UI_info = env.UI_info, 
                        text = text,
                        max_y = 750,
                        min_x = 556,
                        min_y = 20,
                        max_x = 851,
                        click = 2
                    })
                    api_Sleep(200)
                end
                poe2_api.dbgp("完成已展开标签列表的页面点击")
                return bret.RUNNING
            end
        end
    },

    -- 打开交换界面
    Open_The_Exchange_Interface = {
        run = function(self, env)
            poe2_api.dbgp("打开交换界面...")
            
            
            local player_info = env.player_info

            if poe2_api.find_text({UI_info = env.UI_info, text = "重組", min_x = 0, max_y = 200, add_x = 240}) then
                poe2_api.click_keyboard("spcae")
                return bret.RUNNING
            end

            local function check_in_range(object)
                for _, k in ipairs(env.range_info) do
                    if object then
                        if k.name_utf8 == object or k.path_name_utf8 == object then
                            return k
                        end
                    end
                    if (k.name_utf8 == interactive_object or k.path_name_utf8 == interactive_object) and k.grid_x ~= 0 and k.grid_y ~= 0 and k.is_selectable then
                        return k
                    end
                end
                return nil
            end

            if not poe2_api.find_text({UI_info = env.UI_info, text = "通貨交換", min_x = 0, max_y = 200}) then
                local target = check_in_range("安潔")
                local distance = poe2_api.point_distance(target.grid_x, target.grid_y, env.player_info)
                if distance and distance > 25 then 
                    env.interactive = "安潔"
                    return bret.FAIL
                else
                    if player_info.isMoving then
                        poe2_api.dbgp("等待静止")
                        api_Sleep(500)
                        return bret.RUNNING
                    end
                    api_Sleep(1000)
                    if not poe2_api.find_text({UI_info = env.UI_info, text = "通貨交換", min_x = 0}) then
                        api_Sleep(200)
                        if env.player_info.current_map_name_utf8 == "G_Endgame_Town" then
                            poe2_api.find_text({UI_info = env.UI_info, text = "艾瓦", min_x = 0, click = 2, max_x = 1200})
                        else
                            poe2_api.find_text({UI_info = env.UI_info, text = "安潔", min_x = 0, click = 2, max_x = 1200})
                        end
                        
                        api_Sleep(1000)
                    else
                        poe2_api.find_text({UI_info = env.UI_info, text = "通貨交換", min_x = 0, click = 2, max_x = 1200})
                        api_Sleep(1000)
                        api_Sleep(500)
                    end
                    return bret.RUNNING
                end
            else
                return bret.SUCCESS
            end
        end
    },

    -- 领取通货
    Click_All_Exchange = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Click_All_Exchange 节点")
            
            -- 查找"完成的訂單"文本
            local position = poe2_api.find_text({UI_info = env.UI_info, text = "完成的訂單", max_y = 540, position = 3, min_x = 0})
            if position then
                poe2_api.dbgp(string.format("找到'完成的訂單'文本，位置: x=%d, y=%d", position[1], position[2]))
                
                -- 点击左侧领取按钮
                poe2_api.dbgp("点击左侧领取按钮")
                poe2_api.click_position(position[1]-108, position[2]-37, 2)
                api_Sleep(200)
                
                -- 再次检查"完成的訂單"文本
                position = poe2_api.find_text({UI_info = env.UI_info, text = "完成的訂單", max_y = 540, position = 3, min_x = 0})
                if position then
                    poe2_api.dbgp("找到第二个'完成的訂單'文本，点击右侧领取按钮")
                    poe2_api.click_position(position[1]+108, position[2]-37, 2)
                else
                    poe2_api.dbgp("未找到第二个'完成的訂單'文本")
                end
                
                poe2_api.dbgp("通货领取操作完成，返回RUNNING")
                return bret.RUNNING
            else
                poe2_api.dbgp("未找到'完成的訂單'文本")
            end
            
            poe2_api.dbgp("Click_All_Exchange 节点执行完成，返回SUCCESS")
            return bret.SUCCESS
        end
    },

    -- 訂單取消
    Click_All_Cancel = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Click_All_Cancel 节点")
            
            -- 查找"訂單取消"文本
            local position = poe2_api.find_text({UI_info = env.UI_info, text = "訂單取消", max_y = 540, position = 3, min_x = 0})
            if position then
                poe2_api.dbgp(string.format("找到'訂單取消'文本，位置: x=%d, y=%d", position[1], position[2]))
                
                -- 点击左侧取消按钮
                poe2_api.dbgp("点击左侧取消按钮")
                poe2_api.click_position(position[1]-108, position[2]-37, 2)
                api_Sleep(200)
                
                -- 再次检查"訂單取消"文本
                position = poe2_api.find_text({UI_info = env.UI_info, text = "訂單取消", max_y = 540, position = 3, min_x = 0})
                if position then
                    poe2_api.dbgp("找到第二个'訂單取消'文本，点击右侧取消按钮")
                    poe2_api.click_position(position[1]+108, position[2]-37, 2)
                else
                    poe2_api.dbgp("未找到第二个'訂單取消'文本")
                end
                
                poe2_api.dbgp("订单取消操作完成，返回RUNNING")
                return bret.RUNNING
            else
                poe2_api.dbgp("未找到'訂單取消'文本")
            end
            
            poe2_api.dbgp("Click_All_Cancel 节点执行完成，返回SUCCESS")
            return bret.SUCCESS
        end
    },

    -- 清除旧的兑换
    Click_Old_Exchange = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Click_Old_Exchange 节点")
            poe2_api.dbgp(string.format("当前兑换索引: %d", env.current_pair_index or 0))
            
            -- 只在第一次执行时清除旧订单
            if (env.current_pair_index or 0) == 0 then
                poe2_api.dbgp("当前是第一次兑换，开始清除旧订单")
                
                -- 查找"關閉訂單"文本
                if poe2_api.find_text({UI_info = env.UI_info, text = "關閉訂單"}) then
                    poe2_api.dbgp("找到'關閉訂單'文本，点击'確定'按钮")
                    poe2_api.find_text({UI_info = env.UI_info, text = "確定", click = 2})
                    api_Sleep(200)
                    return bret.RUNNING
                end
                
                -- 查找"列出的訂單"文本
                local position = poe2_api.find_text({UI_info = env.UI_info, text = "列出的訂單", max_y = 540, position = 3, min_x = 0})
                if position then
                    poe2_api.dbgp(string.format("找到'列出的訂單'文本，位置: x=%d, y=%d", position[1], position[2]))
                    poe2_api.dbgp("点击右侧关闭按钮")
                    poe2_api.click_position(position[1]+145, position[2]-33)
                    api_Sleep(200)
                    return bret.RUNNING
                else
                    poe2_api.dbgp("未找到'列出的訂單'文本")
                end
            else
                poe2_api.dbgp("非首次兑换，跳过清除旧订单步骤")
            end
            
            poe2_api.dbgp("Click_Old_Exchange 节点执行完成，返回SUCCESS")
            return bret.SUCCESS
        end
    },

    -- 点击无状态兑换
    Click_Stateless_Exchange = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Click_Stateless_Exchange 节点")
            
            -- 检查是否存在任何订单状态文本
            local position1 = poe2_api.find_text({UI_info = env.UI_info, text = "列出的訂單", max_y = 540, min_x = 0})
            local position2 = poe2_api.find_text({UI_info = env.UI_info, text = "訂單取消", max_y = 540, min_x = 0})
            local position3 = poe2_api.find_text({UI_info = env.UI_info, text = "完成的訂單", max_y = 540, min_x = 0})
            
            poe2_api.dbgp(string.format("订单状态检查结果 - 列出的訂單: %s, 訂單取消: %s, 完成的訂單: %s", 
                tostring(position1), tostring(position2), tostring(position3)))
            
            if not position1 and not position2 and not position3 then
                poe2_api.dbgp("未找到任何订单状态文本，开始处理无状态订单")
                
                local stateless = api_GetCurrencyExchangeList()
                poe2_api.dbgp(string.format("获取无状态订单列表: %s", next(stateless) and "有数据" or "无数据"))
                
                if next(stateless) then
                    local position = poe2_api.find_text({UI_info = env.UI_info, text = "我需要的", max_y = 540, position = 3})
                    if position then
                        poe2_api.dbgp(string.format("找到'我需要的'文本，位置: x=%d, y=%d", position[1], position[2]))
                        
                        -- 点击左侧取消按钮
                        poe2_api.dbgp("点击左侧取消按钮")
                        poe2_api.click_position(position[1] - 68, position[2] + 192, 2)
                        api_Sleep(200)
                        
                        -- 点击右侧取消按钮
                        poe2_api.dbgp("点击右侧取消按钮")
                        poe2_api.click_position(position[1] + 150, position[2] + 192, 2)
                        api_Sleep(200)
                        
                        poe2_api.dbgp("无状态订单清除操作完成，返回RUNNING")
                        return bret.RUNNING
                    else
                        poe2_api.dbgp("未找到'我需要的'文本")
                    end
                else
                    poe2_api.dbgp("无状态订单列表为空")
                end
            else
                poe2_api.dbgp("存在有效订单状态，无需处理无状态订单")
            end
            
            poe2_api.dbgp("Click_Stateless_Exchange 节点执行完成，返回SUCCESS")
            return bret.SUCCESS
        end
    },

    -- 选择和交换
    Select_AND_Exhange = {
        new = function(self, name)
            local o = {}
            setmetatable(o, self)
            self.__index = self
            o.name = name or self.name
            return o
        end,
    
        run = function(self, env)
            poe2_api.dbgp("开始执行 Select_AND_Exhange 节点")
            
            -- 检查是否有低比率提示
            if poe2_api.find_text({UI_info = env.UI_info, text="你選擇的交易比率低於當下市集需求的標準。",refresh = true, min_x=0, match=2, delay = 50}) then
                poe2_api.dbgp("发现低比率提示，点击取消")
                poe2_api.find_text({UI_info = env.UI_info, text="取消",refresh = true, click=2, delay = 50})
                return bret.RUNNING
            end

            local function _select_currency(currency)
                poe2_api.dbgp("选择通货:", currency)
                -- 判断类型并点击对应分类
                if poe2_api.table_contains(my_game_info.StackableCurrency_CN, currency) then
                    -- api_Sleep(500)
                    poe2_api.find_text({UI_info = env.UI_info, text="通貨",refresh = true, min_x=0, max_x=580, click=2, delay = 50})
                    api_Sleep(1000)
                    if poe2_api.table_contains(my_game_info.Identify_Currency_CN, currency) then
                        poe2_api.find_text({UI_info = env.UI_info, text='品質通貨',refresh = true, click=2, delay = 50})
                        api_Sleep(1500)
                        api_MouseWheelSmooth(-50)
                        api_Sleep(1500)
                    end
                elseif poe2_api.table_contains(my_game_info.Abyss_CN, currency) then
                    poe2_api.find_text({UI_info = env.UI_info, text="深淵",refresh = true, min_x=0, max_x=580, click=2, delay = 50})
                    -- api_Sleep(500)
                elseif poe2_api.table_contains(my_game_info.Delirium_in_foreign_lands_CN, currency) then
                    poe2_api.find_text({UI_info = env.UI_info, text="譫妄異域",refresh = true, min_x=0, max_x=580, click=2, delay = 50})
                    -- api_Sleep(500)
                elseif poe2_api.table_contains(my_game_info.Crack_Alliance_CN, currency) then
                    poe2_api.find_text({UI_info = env.UI_info, text="裂痕聯盟",refresh = true, min_x=0, max_x=580, click=2, delay = 50})
                    -- api_Sleep(500)
                elseif poe2_api.table_contains(my_game_info.Fragment_CN, currency) then
                    poe2_api.find_text({UI_info = env.UI_info, text="碎片",refresh = true, min_x=0, max_x=580, click=2, delay = 50})
                    -- api_Sleep(500)
                elseif poe2_api.table_contains(my_game_info.Dead_realm_exploration_CN, currency) then
                    poe2_api.find_text({UI_info = env.UI_info, text="死境探險",refresh = true, min_x=0, max_x=580, click=2, delay = 50})
                    -- api_Sleep(500)
                elseif poe2_api.table_contains(my_game_info.Essence_CN, currency) then
                    poe2_api.find_text({UI_info = env.UI_info, text="精髓",refresh = true, min_x=0, max_x=580, click=2, delay = 50})
                    if poe2_api.table_contains(my_game_info.High_Essence_CN, currency) then
                        poe2_api.find_text({UI_info = env.UI_info, text='高階精髓',refresh = true, click=2, delay = 50})
                        api_Sleep(1500)
                        api_MouseWheelSmooth(-50)
                        api_Sleep(1500)
                    end
                    if poe2_api.table_contains(my_game_info.Perfect_Essence_CN, currency) then
                        poe2_api.find_text({UI_info = env.UI_info, text='高階精髓',refresh = true, click=2, delay = 50})
                        api_Sleep(1500)
                        api_MouseWheelSmooth(-50)
                        api_Sleep(1500)
                    end
                    if poe2_api.table_contains(my_game_info.Contaminated_Essence_CN, currency) then
                        poe2_api.find_text({UI_info = env.UI_info, text='高階精髓',refresh = true, click=2, delay = 50})
                        api_Sleep(1500)
                        api_MouseWheelSmooth(-50)
                        api_Sleep(1500)
                    end
                elseif poe2_api.table_contains(my_game_info.Rune_CN, currency) then
                    poe2_api.find_text({UI_info = env.UI_info, text="符文",refresh = true, min_x=0, max_x=580, click=2, delay = 50})
                    api_Sleep(1000)
                    if poe2_api.table_contains(my_game_info.High_Rune_CN, currency) then
                        poe2_api.find_text({UI_info = env.UI_info, text='高階符文',refresh = true, click=2, delay = 50})
                        api_Sleep(1500)
                        api_MouseWheelSmooth(-50)
                        api_Sleep(1500)
                    end
                elseif poe2_api.table_contains(my_game_info.Sign_CN, currency) then
                    poe2_api.find_text({UI_info = env.UI_info, text="徵兆",refresh = true, min_x=0, max_x=580, click=2, delay = 50})
                    -- api_Sleep(500)
                elseif poe2_api.table_contains(my_game_info.SoulCore_CN, currency) then
                    poe2_api.find_text({UI_info = env.UI_info, text="靈魂核心",refresh = true, min_x=0, max_x=580, click=2, delay = 50})
                    -- api_Sleep(500)
                elseif poe2_api.table_contains(my_game_info.Sigil_CN, currency) then
                    poe2_api.find_text({UI_info = env.UI_info, text="魔符",refresh = true, min_x=0, max_x=580, click=2, delay = 50})
                    -- api_Sleep(500)
                elseif poe2_api.table_contains(my_game_info.UncutGemstone_CN, currency) then
                    poe2_api.find_text({UI_info = env.UI_info, text="未切割的寶石",refresh = true, min_x=0, max_x=580, click=2, delay = 50})
                    if poe2_api.table_contains(my_game_info.UncutGemstoneSkill_CN, currency) then
                        poe2_api.find_text({UI_info = env.UI_info, text='未切割的技能寶石',refresh = true, click=2, delay = 50})
                        api_Sleep(1500)
                        api_MouseWheelSmooth(-50)
                        api_Sleep(1500)
                    end
                    if poe2_api.table_contains(my_game_info.UncutGemstoneReserved_CN, currency) then
                        poe2_api.find_text({UI_info = env.UI_info, text='未切割的技能寶石',refresh = true, click=2, delay = 50})
                        api_Sleep(1500)
                        api_MouseWheelSmooth(-50)
                        api_Sleep(1500)
                    end
                elseif poe2_api.table_contains(my_game_info.Rune_CN, currency) then
                    poe2_api.find_text({UI_info = env.UI_info, text="符文",refresh = true, min_x=0, max_x=580, click=2, delay = 50})
                    api_Sleep(1000)
                    if poe2_api.table_contains(my_game_info.High_Rune_CN, currency) then
                        poe2_api.find_text({UI_info = env.UI_info, text='高階符文',refresh = true, click=2, delay = 50})
                        api_Sleep(1500)
                        api_MouseWheelSmooth(-50)
                        api_Sleep(1500)
                    end
                else
                    poe2_api.dbgp("錯誤的設定:", currency)
                    return false, nil
                end
        
                api_Sleep(1000)
                
                -- 尝试直接点击目标通货
                if poe2_api.find_text({UI_info = env.UI_info, text = currency,refresh = true, click=2, min_x=0, delay = 50}) then
                    api_Sleep(500)
                    return true, currency
                end
                
                return false, nil
            end

            local function _verify_left_currency(expected)
                poe2_api.dbgp("验证左边通货:", expected)
                
                local poesition_left = poe2_api.find_text({UI_info = env.UI_info, text="我需要的",refresh = true, min_x=0, position=1, delay = 50})
                if not poesition_left then
                    poe2_api.dbgp("未找到'我需要的'文本")
                    return false, nil
                end
                
                local ratio_area = {poesition_left[1] - 40, 174, poesition_left[3] + 40, 234}
                local current_left = poe2_api.find_text_position({UI_info = env.UI_info, 
                    min_x=ratio_area[1],
                    min_y=ratio_area[2],
                    max_x=ratio_area[3],
                    max_y=ratio_area[4],
                    lens=nil
                })
                
                -- 已经是目标通货
                if current_left and string.find(current_left, expected) then
                    poe2_api.dbgp("左边通货已经是目标通货:", expected)
                    return true, current_left
                end
                
                poe2_api.find_text({UI_info = env.UI_info, text="我需要的",refresh = true, min_x=0, add_y=30, click=2, delay = 50})
                api_Sleep(500)
                    
                -- 需要重新选择
                local a, currency = _select_currency(expected)
                return a, currency
            end
        
            local function _verify_right_currency(expected)
                poe2_api.dbgp("验证右边通货:", expected)
                local poesition_left = poe2_api.find_text({UI_info = env.UI_info, text="我擁有的",refresh = true, min_x=0, position=1, delay = 50})
                if not poesition_left then
                    poe2_api.dbgp("未找到'我擁有的'文本")
                    return false, nil
                end
                
                local ratio_area = {poesition_left[1] - 40, 174, poesition_left[3] + 40, 234}
                local current_right = poe2_api.find_text_position({UI_info = env.UI_info, 
                    min_x=ratio_area[1],
                    min_y=ratio_area[2],
                    max_x=ratio_area[3],
                    max_y=ratio_area[4],
                    lens=nil
                })
                
                -- 已经是目标通货
                if current_right and string.find(current_right, expected) then
                    poe2_api.dbgp("右边通货已经是目标通货:", expected)
                    return true, current_right
                end
                
                -- 左边输入（需要的数量）
                poe2_api.find_text({UI_info = env.UI_info, text="我需要的",refresh = true, min_x=0, add_x=132, add_y=37, click=2, delay = 50})
                api_Sleep(500)
                -- poe2_api.paste_text("1")
                poe2_api.key_board_input_text(1)
                api_Sleep(500)
                poe2_api.find_text({UI_info = env.UI_info, text="我需要的",refresh = true, min_x=0, add_x=132, add_y=37, click=2, delay = 50})

                api_Sleep(800)
        
                poe2_api.find_text({UI_info = env.UI_info, text="我擁有的",refresh = true, min_x=0, add_y=30, click=2, delay = 50})
                api_Sleep(500)
                    
                -- 需要重新选择
                local a, currency = _select_currency(expected)
                return a, currency
            end

        
            local function _get_currency_amount(currency_type)
                poe2_api.dbgp("获取通货数量:", currency_type)
                
                if not env.item_nums_list then
                    poe2_api.dbgp("item_nums_list为空")
                    return 0
                end
                
                for _, item in ipairs(env.item_nums_list) do
                    if item[1] == currency_type then  -- item格式: {'通货名称', 数量}
                        poe2_api.dbgp("找到通货数量:", item[2])
                        return item[2]
                    end
                end
                
                poe2_api.dbgp("未找到该通货")
                return 0
            end
        
        
            local function _get_live_ratio()
                poe2_api.dbgp("获取实时市场比例")
                
                local poesition_left = poe2_api.find_text({UI_info = env.UI_info, text="我需要的",refresh = true, min_x=0, position=1, delay = 50})
                if not poesition_left then
                    poe2_api.dbgp("未找到'我需要的'文本")
                    return nil
                end
                
                local ratio_area = {poesition_left[3], poesition_left[4] - 53, poesition_left[3] + 280, poesition_left[4] + 12}
                poe2_api.dbgp("文本区域:", poesition_left[3],",", poesition_left[4] - 53,",",  poesition_left[3] + 280,",",  poesition_left[4] + 12)
                local ratio_text = poe2_api.find_text_position({UI_info = env.UI_info, 
                    refresh = true,
                    min_x=ratio_area[1],
                    min_y=ratio_area[2],
                    max_x=ratio_area[3],
                    max_y=ratio_area[4],
                    lens=4
                })
                poe2_api.dbgp("原始比例文本:", ratio_text)

                if ratio_text then
                    poe2_api.dbgp("原始比例文本:", ratio_text)
                    
                    -- 改进的文本解析逻辑，匹配<kalguurlightgrey>{数字}：<kalguurlightgrey>{数字}格式
                    local pattern = "<kalguurlightgrey>{(%d+%.?%d*)}：<kalguurlightgrey>{(%d+%.?%d*)}"
                    local need, have = string.match(ratio_text, pattern)
                    
                    if need and have then
                        need = tonumber(need)
                        have = tonumber(have)
                        if need > 0 and have > 0 then
                            poe2_api.dbgp("解析比例成功:", need, ":", have)
                            return {need, have}  -- (需要的, 拥有的)
                        end
                    end
                end
                
                poe2_api.dbgp("无法解析比例")
                return nil
            end
        
            local function _calculate_optimal_exchange(have_amount, current_ratio)
                poe2_api.dbgp("计算最优兑换量 - 当前数量:", have_amount, "市场比例:", current_ratio[1], ":", current_ratio[2])
                
                if not current_ratio or have_amount <= 0 then
                    poe2_api.dbgp("无效输入")
                    return {0, 0}, {0, 0}
                end
                
                local market_need, market_have = current_ratio[1], current_ratio[2]
                
                -- 计算最小精确整数倍兑换单位
                local function gcd(a, b)
                    while b ~= 0 do
                        a, b = b, a % b
                    end
                    return a
                end
                
                local rounded_need = math.floor(market_need * 10 + 0.5) / 10
                local rounded_have = math.floor(market_have * 10 + 0.5) / 10
                
                local factor = 10
                local int_need = math.floor(rounded_need * factor + 0.5)
                local int_have = math.floor(rounded_have * factor + 0.5)
                
                local common_divisor = gcd(int_need, int_have)
                local unit_need = int_need // common_divisor
                local unit_have = int_have // common_divisor
                
                poe2_api.dbgp("最小兑换单位:", unit_need, ":", unit_have)
                
                if have_amount < unit_have then
                    poe2_api.dbgp("持有量不足: 需要", unit_have, "当前", have_amount)
                    return {0, 0}, {unit_need, unit_have}
                end
                
                local max_trades = have_amount // unit_have
                local actual_trades = max_trades  -- 移除了限制
                
                poe2_api.dbgp("最大交易次数:", actual_trades)
                
                return {unit_need * actual_trades, unit_have * actual_trades},{unit_need, unit_have}
                
            end
        
            local function _execute_exchange(ratio)
                poe2_api.dbgp("执行兑换操作 - 比例:", ratio[1], ":", ratio[2])
                local need, give = ratio[1], ratio[2]
                
                -- 左边输入（需要的数量）
                poe2_api.find_text({UI_info = env.UI_info, text="我需要的",refresh = true, min_x=0, add_x=132, add_y=37, click=2, delay = 50})
                api_Sleep(500)
                poe2_api.key_board_input_text(tonumber(need))
                -- poe2_api.paste_text(tostring(need))
                api_Sleep(500)
                poe2_api.find_text({UI_info = env.UI_info, text="我需要的",refresh = true, min_x=0, add_x=132, add_y=37, click=2, delay = 50})

                api_Sleep(1000)

                -- 右边输入（给出的数量）
                poe2_api.find_text({UI_info = env.UI_info, text="我擁有的",refresh = true, min_x=0, add_x=-132, add_y=37, click=2, delay = 50})
                api_Sleep(500)
                -- poe2_api.paste_text(tostring(give))
                poe2_api.key_board_input_text(tonumber(give))
                api_Sleep(500)
                poe2_api.find_text({UI_info = env.UI_info, text="我擁有的",refresh = true, min_x=0, add_x=-132, add_y=37, click=2, delay = 50})
                
                -- 确认交易
                local i = 0
                while i < 3 do
                    poe2_api.find_text({UI_info = env.UI_info, text="下訂單",refresh = true, click=2})
                    api_Sleep(800)
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text="你選擇的交易比率低於當下市集需求的標準。",refresh = true, min_x=0, match=2, delay = 50}) then
                        poe2_api.dbgp("检测到低比率提示")
                        poe2_api.find_text({UI_info = env.UI_info, text="取消",refresh = true, click=2})
                        return false
                    end
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text="你選擇的交易比率低於當下市場市集需求的標準。",refresh = true, min_x=0, delay = 50}) then
                        poe2_api.dbgp("检测到低比率提示(变体)")
                        poe2_api.find_text({UI_info = env.UI_info, text="取消",refresh = true, click=2})
                        break
                    end
                    
                    i = i + 1
                end
                
                -- 根据数值位数调整延迟
                local delay = math.max(0.5, math.min(1.5, (string.len(tostring(need)) + string.len(tostring(give))) * 0.15))
                api_Sleep(poe2_api.toInt(delay * 1000))
                return true
            end
    
            -- 获取当前处理的通货对索引
            local current_pair_index = env.current_pair_index or 1
            poe2_api.dbgp("当前处理通货对索引:", current_pair_index)
            
            -- 获取拥有的和需要的通货列表
            local owned_currencies = env.owned_currencies or {}
            local needed_currencies = env.needed_currencies or {}
            poe2_api.dbgp("拥有的通货列表:", #owned_currencies)
            poe2_api.dbgp("需要的通货列表:", #needed_currencies)
    
            -- 检查通货对是否有效
            if #owned_currencies < current_pair_index + 1 or #needed_currencies < current_pair_index + 1 then
                poe2_api.dbgp("通货对处理完成，重置状态")
                env.last_execution_time = api_GetTickCount64()
                env.current_pair_index = 0
                env.exchange_status = true
                env.warehouse_full = false
                env.owned_currencies = {}
                env.needed_currencies = {}
                return bret.SUCCESS
            end
    
            -- 检查列表长度是否一致
            if #owned_currencies ~= #needed_currencies then
                poe2_api.dbgp("错误：'我擁有的'和'我需要的'列表长度不一致")
                return bret.FAIL
            end
    
            -- 1. 检查并修正左边通货（严格按索引匹配）
            local left_status, selected_currency_left = _verify_left_currency(needed_currencies[current_pair_index + 1])  -- Lua数组从1开始
            poe2_api.dbgp("left_status:", tostring(left_status), "selected_currency_left:", selected_currency_left)
            if not left_status then
                poe2_api.dbgp("左边通货选择失败，跳过当前对")
                env.current_pair_index = current_pair_index + 1
                return bret.RUNNING
            end
            poe2_api.dbgp("左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左")
            api_Sleep(1000)
            -- 2. 检查并修正右边通货（严格按索引匹配）
            local right_status, selected_currency_right = _verify_right_currency(owned_currencies[current_pair_index + 1])
            poe2_api.dbgp("right_status:", tostring(right_status), "selected_currency_right:", selected_currency_right)
            if not right_status then
                poe2_api.dbgp("右边通货选择失败，跳过当前对")
                env.current_pair_index = current_pair_index + 1
                return bret.RUNNING
            end
            poe2_api.dbgp("右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右")
            api_Sleep(2000)
    
            -- 3. 获取当前通货数量
            local have_amount = _get_currency_amount(selected_currency_right)
            poe2_api.dbgp("当前通货数量:", selected_currency_right, "=", have_amount)
            
            if have_amount == 0 then
                poe2_api.dbgp("通货数量为0，跳过当前对")
                env.current_pair_index = current_pair_index + 1
                return bret.RUNNING
            end
    
            -- 4. 获取实时市场比例（左边:需要的，右边:拥有的）
            local current_ratio = _get_live_ratio()
            poe2_api.dbgp("获取实时市场比例  ", current_ratio)
            if not current_ratio then
                poe2_api.dbgp("无法获取市场比例，跳过当前对")
                env.current_pair_index = current_pair_index + 1
                return bret.RUNNING
            end
            poe2_api.dbgp("当前市场比例:", current_ratio[1], ":", current_ratio[2])
    
            -- 5. 计算最优兑换量（使用当前比例）
            local adjusted_ratio, exact_units = _calculate_optimal_exchange(have_amount, current_ratio)
            poe2_api.dbgp("计算最优兑换量 - 调整后比例:", adjusted_ratio[1], ":", adjusted_ratio[2], " 最小单位:", exact_units[1], ":", exact_units[2])
            
            if adjusted_ratio[1] == 0 and adjusted_ratio[2] == 0 then
                poe2_api.dbgp("无法计算有效兑换比例，跳过当前对")
                env.current_pair_index = current_pair_index + 1
                return bret.RUNNING
            end
    
            -- 6. 执行兑换
            local exchange_result = _execute_exchange(adjusted_ratio)
            poe2_api.dbgp("兑换执行结果:", exchange_result and "成功" or "失败")
            
            env.current_pair_index = current_pair_index + 1
            return bret.RUNNING
        end
    },

    -- 点击交互文本
    Click_Item_Text = {
        run = function(self, env)
            poe2_api.print_log("点击交互文本...")
            poe2_api.dbgp("点击交互文本...")
            local current_time = api_GetTickCount64()
            local interactive_object = env.interactive
            local player_info = env.player_info
            local current_map_info = env.current_map_info
            
            local path_list = env.path_list
            local need_item = env.need_item
            
            if not self.bool then
                self.is_click_z = false
                self.bool = true
            end
            
            -- 辅助函数定义
            local function check_in_map()
                if not current_map_info then
                    return nil
                end
                for _, k in ipairs(current_map_info) do
                    if k.name_utf8 == interactive_object and k.flagStatus == 0 and k.flagStatus1 == 1 and k.grid_x ~= 0 and k.grid_y ~= 0 then
                        return k
                    end
                end
                return nil
            end

            local function check_in_range(object)
                for _, k in ipairs(env.range_info) do
                    if object then
                        if k.name_utf8 == object or k.path_name_utf8 == object then
                            return k
                        end
                    end
                    if interactive_object == "MapDevice" then
                        if k.name_utf8 == "黃金製圖儀" or k.name_utf8 == "地圖裝置" then
                            return k
                        end
                    end
                    if (k.name_utf8 == interactive_object or k.path_name_utf8 == interactive_object) and k.grid_x ~= 0 and k.grid_y ~= 0 and k.is_selectable then
                        return k
                    end
                end
                return nil
            end
            
            local function need_move(obj,dis)
                local text = obj.baseType_utf8 or obj.name_utf8
                local x, y
                local point
                if text == "門" then
                    point = api_FindNearestReachablePoint(obj.grid_x, obj.grid_y, 15, 1)
                    local ralet = api_FindPath(player_info.grid_x, player_info.grid_y, point.x, point.y)
                    if not ralet then
                        point = api_FindRandomWalkablePosition(obj.grid_x, obj.grid_y, 15)
                        x, y = point.x, point.y
                    else
                        x, y = point.x, point.y
                    end
                else
                    if not need_item then
                        point = api_FindNearestReachablePoint(obj.grid_x, obj.grid_y, 50, 0)
                        x, y = point.x, point.y
                    else
                        poe2_api.dbgp("dgdvjinbvdijsknvijbiihjbjkdv")
                        x, y = obj.grid_x, obj.grid_y
                    end
                end
                poe2_api.dbgp("移动目标点:", x, y)
                local distance = poe2_api.point_distance(x, y, player_info)
                poe2_api.dbgp("距离:", distance)
                local text = ""      
                local ok, value = pcall(function() 
                    return interactive_object.baseType_utf8 
                end)
                if ok and value ~= nil then
                    text = interactive_object.baseType_utf8 
                    -- text = ""
                else
                    text = interactive_object.name_utf8
                end
                if (distance and distance > dis) or (text ~= "開關" and not api_HasObstacleBetween(x, y)) then
                    env.end_point = {x, y}
                    return {x, y}
                end
                return false
            end
            
            -- 主逻辑
            if type(interactive_object) == "string" then
                local map_obj = check_in_map()
                local range_obj = check_in_range()
                
                local target_obj = map_obj or range_obj
                if not target_obj then
                    poe2_api.dbgp("未找到对象")
                    return bret.FAIL
                end
                
                local distance = poe2_api.point_distance(target_obj.grid_x, target_obj.grid_y, player_info)
                poe2_api.dbgp("交互对象: "..target_obj.name_utf8.." | 位置: "..target_obj.grid_x..","..target_obj.grid_y.." | 距离: "..distance)
                
                if need_move(target_obj,15) then
                    poe2_api.dbgp("移动交互对象")
                    return bret.FAIL
                end

                poe2_api.dbgp("点击交互对象")
                
                if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                    api_Sleep(1000)
                end
                poe2_api.dbgp("111111111")
                if target_obj.name_utf8 == "MapDevice" then
                    local m_list = {"黃金製圖儀", "地圖裝置"}
                    api_Sleep(800)
                    poe2_api.dbgp("2222222222")
                    local maps = check_in_range('Metadata/Terrain/Missions/Hideouts/Objects/MapDeviceVariants/ZigguratMapDevice')
                    if poe2_api.find_text({UI_info = env.UI_info, text = '地圖裝置', click = 2, refresh = true, print_log = true}) then
                        api_Sleep(100)
                        return bret.RUNNING
                    end
                    -- if maps then
                    --     -- api_ClickMove(maps.grid_x, maps.grid_y, maps.world_z + 110, 0)
                    --     api_ClickMove(poe2_api.toInt(maps.grid_x), poe2_api.toInt(maps.grid_y), poe2_api.toInt(maps.world_z - 70), 0)
                    --     api_Sleep(800)
                    -- end
                    -- for _, i in ipairs(m_list) do
                    --     if poe2_api.find_text({UI_info = env.UI_info, text = i, click = 2, refresh = true}) then
                    --         api_Sleep(100)
                    --         return bret.RUNNING
                    --     end
                    -- end
                end
                poe2_api.dbgp("33333333333")
                if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) and target_obj.name_utf8 ~= '傳送點' and not map_obj then
                    poe2_api.find_text({UI_info = env.UI_info, text = interactive_object, click = 2, refresh = true})
                    api_Sleep(100)
                    return bret.RUNNING
                end
                
                if player_info.isMoving then
                    poe2_api.dbgp("等待静止")
                    api_Sleep(1000)
                    return bret.RUNNING
                end

                if not poe2_api.find_text({UI_info = env.UI_info, text = interactive_object, click = 2, max_x = 1200, refresh = true}) then
                    api_ClickMove(poe2_api.toInt(target_obj.grid_x), poe2_api.toInt(target_obj.grid_y),poe2_api.toInt(player_info.world_z), 1)
                end
                api_Sleep(100)
            else
                poe2_api.dbgp1("交互对象: "..interactive_object.name_utf8.." | 位置: "..interactive_object.grid_x..","..interactive_object.grid_y)
                poe2_api.dbgp("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
                local a = poe2_api.point_distance(interactive_object.grid_x,interactive_object.grid_x,env.player_info)
                poe2_api.dbgp("a:",a)
                local text = ""      
                local ok, value = pcall(function() 
                    return interactive_object.baseType_utf8 
                end)
                if ok and value ~= nil then
                    text = interactive_object.baseType_utf8 
                    -- text = ""
                else
                    text = interactive_object.name_utf8
                end
                poe2_api.dbgp("text:",text)
                local point = need_move(interactive_object,30)
                if point then
                    poe2_api.dbgp("text1:",text)
                    -- poe2_api.dbgp("移动交互对象")
                    if env.path_list and next(env.path_list) then
                        local distence = poe2_api.point_distance(env.path_list[#env.path_list].x,env.path_list[#env.path_list].y,point)
                        if distence and distence > 20 and text ~= "門" then
                            poe2_api.dbgp("交互目标点，不一致，清空路径")
                            poe2_api.print_log("清路径555")
                            env.path_list = {}
                        end
                    end
                    poe2_api.dbgp("text2:",text)
                    -- poe2_api.printTable(point)
                    return bret.FAIL
                end
                if player_info.isMoving then
                    poe2_api.dbgp("等待静止")
                    api_Sleep(200)
                    return bret.RUNNING
                end
                if interactive_object and (not text or text == "" or poe2_api.table_contains(text,{"門","聖潔神殿"}) or not poe2_api.find_text({text = text, UI_info = env.UI_info, min_x=200,max_y=750,match=2,max_x=1200,sorted = true, click=2})) then
                    if poe2_api.table_contains(text,{"門","聖潔神殿"}) then
                        -- if text == "門" and poe2_api.find_text({text = "出土遺物", UI_info = env.UI_info, min_x=200,max_y=750,match=2,max_x=1200,sorted = true}) then
                        --     poe2_api.click_keyboard("z")
                        --     self.is_click_z = true
                        --     return bret.RUNNING
                        -- end
                        api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), poe2_api.toInt(interactive_object.world_z - 70), 1)
                    else
                        if env.need_item and env.need_item == interactive_object then
                            api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), poe2_api.toInt(interactive_object.world_z), 1)
                        else
                            local ok, value = pcall(function() 
                                return interactive_object.path_name_utf8 
                            end)
                            if ok and value ~= nil then
                                local path_name_list = {
                                    "Metadata/Terrain/Gallows/Leagues/Delirium/Objects/DeliriumInitiator",
                                    "Metadata/MiscellaneousObjects/Breach/BreachObject"
                                }
                                if string.find("Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable", interactive_object.path_name_utf8) then
                                    poe2_api.find_text({text = "點擊以開始祭祀", UI_info = env.UI_info, min_x=200,max_y=750,match=2,max_x=1200,sorted = true, click=2})
                                elseif "Metadata/MiscellaneousObjects/Monolith" == interactive_object.path_name_utf8 then
                                    poe2_api.find_text({text = "怪物受到強大的精髓禁錮。", UI_info = env.UI_info, min_x=200,max_y=750,match=2,max_x=1200,sorted = true, click=2})
                                elseif poe2_api.table_contains(interactive_object.path_name_utf8, path_name_list) then
                                    api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), poe2_api.toInt(interactive_object.world_z), 1)
                                elseif interactive_object.name_utf8 == "開關" then
                                    api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), poe2_api.toInt(env.player_info.world_z), 1)
                                else
                                    if interactive_object.path_name_utf8 ~= "Metadata/MiscellaneousObjects/Abyss/AbyssCrack" then
                                        if poe2_api.table_contains(text,my_game_info.Treasure_Chest) then
                                            api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), poe2_api.toInt(interactive_object.world_z), 1)
                                        else
                                            api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), poe2_api.toInt(interactive_object.world_z - 250), 1)
                                        end
                                        
                                    end
                                end
                            else
                                api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), poe2_api.toInt(interactive_object.world_z - 250), 1)
                            end
                        end
                    end
                end
                if text == "門" then
                    api_Sleep(400)
                    -- if self.is_click_z then
                    --     poe2_api.click_keyboard("z")
                    --     self.is_click_z = false
                    -- end
                    api_UpdateMapObstacles(100)
                end
                if text == "競技場" then
                    api_UpdateMapObstacles(100)
                end
                if poe2_api.table_contains(text,{"水閘門控制桿","把手"}) then
                    api_Sleep(500)
                    poe2_api.dbgp1("点击水闸门控制杆,等待目标")
                    poe2_api.dbgp1("wait_target: ",wait_target)
                    env.wait_target = true
                end
                local ok, value = pcall(function() 
                    return interactive_object.path_name_utf8 
                end)
                if ok and value ~= nil then
                    if string.find("Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable", interactive_object.path_name_utf8) then
                        env.afoot_altar = interactive_object
                    end
                    if interactive_object.path_name_utf8 == "Metadata/MiscellaneousObjects/Abyss/AbyssCrack" then
                        table.insert(env.interactive_permanent_id_list,interactive_object.id)
                        -- env.interactive_permanent_id_list
                    end 
                end
                poe2_api.print_log("清路径666")
                env.path_list = {}
                env.need_item = nil
                env.interactive = nil
                env.interaction_object = nil
                env.interactiontimeout = api_GetTickCount64()
                return bret.RUNNING
            end
            return bret.RUNNING
        end
    },

    -- 对话鉴定NPC
    Dialogue_Appraisal_NPC = {
        run = function(self, env)
            poe2_api.print_log("对话鉴定NPC...")
            local start_time = api_GetTickCount64()
            local player_info = env.player_info
            local attack_dis_map = env.map_level_dis
            local stuck_monsters = env.stuck_monsters
            local not_attack_mos = env.not_attack_mos
            local config = env.user_config
            
            local current_map_info = env.current_map_info
            
            local config_name = env.item_config_name
            local config_type = env.item_config_type
            
            if not poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout) then
                poe2_api.time_p("对话鉴定NPC... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            
            -- 创建反向字典
            local reverse_type_conversion = {}
            for k, v in pairs(my_game_info.type_conversion) do
                reverse_type_conversion[v] = k
                -- poe2_api.dbgp(string.format("类型转换表: %s -> %s", k, v))
            end

            local function convert_key(key)
                local converted = my_game_info.type_conversion[key] or reverse_type_conversion[key]
                -- poe2_api.dbgp(string.format("类型转换: %s -> %s", key, converted or "无对应转换"))
                return converted
            end

            local function convert_config_type(config_type_dict)
                if not config_type_dict then
                    poe2_api.dbgp("警告: 配置类型字典为空")
                    return {}
                end
                
                local converted_dict = {}
                -- poe2_api.dbgp("开始转换配置类型...")
                
                for chinese_type, info_list in pairs(config_type_dict) do
                    local english_type = my_game_info.type_conversion[chinese_type]
                    -- poe2_api.dbgp(string.format("处理类型: %s -> %s", chinese_type, english_type or "无对应英文"))
                    
                    if english_type then
                        -- 处理内嵌'類型'字段
                        if type(info_list) == "table" and info_list["類型"] then
                            -- poe2_api.dbgp("发现嵌套类型字段，开始处理...")
                            if type(info_list["類型"]) == "table" then
                                local converted_types = {}
                                for _, t in ipairs(info_list["類型"]) do
                                    local converted = my_game_info.type_conversion[t] or t
                                    table.insert(converted_types, converted)
                                    -- poe2_api.dbgp(string.format("转换嵌套类型: %s -> %s", t, converted))
                                end
                                info_list["類型"] = converted_types
                            else
                                local converted = my_game_info.type_conversion[info_list["類型"]] or info_list["類型"]
                                info_list["類型"] = {converted}
                                -- poe2_api.dbgp(string.format("转换单类型: %s -> %s", info_list["類型"], converted))
                            end
                        end
                        converted_dict[english_type] = info_list
                    else
                        poe2_api.dbgp(string.format("严重警告: 未找到类型 '%s' 的英文转换", chinese_type))
                    end
                end
                
                -- poe2_api.dbgp("配置类型转换完成")
                return converted_dict
            end

            -- 转换配置类型
            -- poe2_api.dbgp("开始转换主配置类型...")
            config_type = convert_config_type(config_type)
            -- poe2_api.dbgp(string.format("转换后配置类型条目数: %d", table.count(config_type)))

            if poe2_api.find_text({UI_info = env.UI_info, text = "繼續遊戲", click = 2}) then
                poe2_api.dbgp("发现'繼續遊戲'文本，点击处理中...")
                return bret.RUNNING
            end

            local appraisal_item_list = {}

            local function need_appraisal(bag_info)
                if not bag_info then
                    -- poe2_api.dbgp("城外鉴定: 背包信息为空")
                    return false
                end
                
                -- poe2_api.dbgp(string.format("开始检查背包物品，总数: %d", #bag_info))
                
                local function get_matched_config(bag)
                    -- 初始物品信息检查
                    -- poe2_api.dbgp("\n========== 开始物品匹配流程 ==========")
                    -- poe2_api.dbgp(string.format("[物品基本信息] 名称: %s | 类型: %s | 基础类型: %s | 颜色: %d", 
                    --     bag.name_utf8 or "nil", 
                    --     bag.category_utf8 or "nil", 
                    --     bag.baseType_utf8 or "nil", 
                    --     bag.color or -1))
                    
                    -- 检查config_type是否存在
                    if not config_type then
                        poe2_api.dbgp("[错误] config_type 配置表不存在！")
                        return nil
                    end
                
                    -- 1. 首先检查类型匹配
                    -- poe2_api.dbgp("\n=== 开始类型配置匹配 ===")
                    for config_name, item_config in pairs(config_type) do
                        -- poe2_api.dbgp(string.format("\n[检查配置组] 配置组名称: %s", config_name))
                        -- poe2_api.dbgp("[配置内容] %s", poe2_api.printTable(item_config))
                        -- poe2_api.printTable(item_config)

                        for idx, item in ipairs(item_config) do
                            -- poe2_api.dbgp("\n[检查配置项] 序号: %d", idx)
                            -- poe2_api.dbgp("------------------------------------------------------------------------")
                            if type(item) ~= "table" then
                                -- poe2_api.dbgp("[警告] 配置项不是table类型，跳过")
                                goto continue
                            end
                
                            -- 类型检查
                            local item_type = item["類型"]
                            -- poe2_api.dbgp(string.format("[类型检查] 配置类型: %s | 物品类型: %s", 
                            --     poe2_api.printTable(item_type), 
                            --     bag.category_utf8 or "nil"))
                
                            -- 处理类型匹配
                            local type_match = false
                            if type(item_type) == "table" and #item_type > 0 then
                                type_match = (item_type[1] == convert_key(bag.category_utf8))
                            elseif type(item_type) == "string" then
                                type_match = (item_type == convert_key(bag.category_utf8))
                            else
                                -- poe2_api.dbgp("[警告] 配置类型格式无效")
                            end
                
                            if not type_match then
                                -- poe2_api.dbgp("-> 类型不匹配，跳过")
                                goto continue
                            end
                            poe2_api.dbgp("-> 类型匹配通过")
                
                            -- 基础类型检查
                            local base_type = item["基礎類型名"] or "nil"
                            poe2_api.dbgp(string.format("[基础类型检查] 配置基础类型: %s | 物品基础类型: %s", base_type, bag.baseType_utf8 or "nil"))
                
                            if bag.baseType_utf8 ~= base_type and base_type ~= "全部物品" and not string.find(base_type, bag.baseType_utf8) then
                                -- poe2_api.dbgp("-> 基础类型不匹配，跳过")
                                goto continue
                            end

                            -- poe2_api.dbgp("-> 基础类型匹配通过")
                
                            -- 品质检查
                            local quality_check = {
                                white = item["白裝"],
                                blue = item["藍裝"],
                                yellow = item["黃裝"],
                                unique = item["暗金"]
                            }
                            -- poe2_api.dbgp(string.format("[品质检查] 配置要求: 白=%s 蓝=%s 黄=%s 暗金=%s | 物品颜色: %d",
                            --     tostring(quality_check.white),
                            --     tostring(quality_check.blue),
                            --     tostring(quality_check.yellow),
                            --     tostring(quality_check.unique),
                            --     bag.color or -1))
                
                            local quality_ok = false
                            if bag.color == 0 and quality_check.white then
                                quality_ok = true
                            elseif bag.color == 1 and quality_check.blue then
                                quality_ok = true
                            elseif bag.color == 2 and quality_check.yellow then
                                quality_ok = true
                            -- elseif bag.color == 3 and quality_check.unique then
                            elseif bag.color == 3 then
                                quality_ok = true
                            end
                
                            if not quality_ok then
                                -- poe2_api.dbgp("-> 品质不匹配，跳过")
                                goto continue
                            end
                            -- poe2_api.dbgp("-> 品质检查通过")
                            
                            -- 名称检查
                            if item["名稱"] ~= nil or item["基礎類型名"] then
                                poe2_api.dbgp(string.format("[名称检查] 配置名称: %s | 物品名称: %s", item["名稱"], bag.name_utf8 or "nil"))
                                if item["名稱"] ~= nil or item["基礎類型名"] == bag.baseType_utf8 or string.find(item["基礎類型名"], bag.baseType_utf8) then
                                    -- poe2_api.dbgp("-> 名称完全匹配，返回配置")
                                    -- poe2_api.dbgp("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item))
                                    return item
                                else
                                    -- poe2_api.dbgp("-> 名称不匹配，继续检查")
                                end
                            else
                                -- poe2_api.dbgp("[名称检查] 配置无名称要求，检查词缀")
                                
                                -- 词缀检查
                                if item["物品詞綴"] then
                                    poe2_api.dbgp("[词缀检查] 发现词缀配置")
                                    local affix_dict = item["物品詞綴"]
                                    
                                    if affix_dict and type(affix_dict) == "table" then
                                        for affix_name, v in pairs(affix_dict) do
                                            if type(v) == "table" and v["詞綴"] then
                                                -- poe2_api.dbgp(string.format("-> 发现有效词缀: %s", affix_name))
                                                -- poe2_api.dbgp(string.format("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item)))
                                                return item
                                            end
                                        end
                                    end
                                end
                            end
                            -- 如果前面都通过但没返回，检查基础类型名
                            -- poe2_api.dbgp("[最终检查] 基础类型名匹配检查")
                            if base_type == bag.baseType_utf8 or base_type == "全部物品" or string.find(base_type, bag.baseType_utf8) then
                                -- poe2_api.dbgp("-> 基础类型名匹配，返回配置")
                                -- poe2_api.dbgp(string.format("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item)))
                                return item
                            end
                
                            ::continue::
                        end
                    end
                    
                    -- 2. 检查名称匹配
                    poe2_api.dbgp("\n=== 开始名称配置匹配 ===")
                    if not config_name then
                        poe2_api.dbgp("[警告] config_name 配置表不存在")
                    else
                        for config_name, item_config in pairs(config_name) do
                            -- poe2_api.dbgp(string.format("\n[检查名称配置组] %s", config_name))
                            
                            for idx, item in ipairs(item_config) do
                                -- poe2_api.dbgp(string.format("[检查配置项] 序号: %d", idx))
                                
                                if type(item) == "table" then
                                    -- poe2_api.dbgp(string.format("[基础类型比较] 配置: %s | 物品: %s",
                                    --     item["基礎類型名"] or "nil", bag.baseType_utf8 or "nil"))
                                    
                                    -- if item["基礎類型名"] == bag.baseType_utf8 then
                                    if string.find(item["基礎類型名"] , bag.baseType_utf8) or item["基礎類型名"] == bag.baseType_utf8 or item["名稱"] ~= "" or item["名稱"] ~= nil then
                                        poe2_api.dbgp("-> 基础类型匹配")
                                        
                                        local type_ok = true
                                        if item["類型"] and item["類型"][1] then
                                            type_ok = (item["類型"][1] == bag.category_utf8)
                                            -- poe2_api.dbgp(string.format("[类型比较] 配置: %s | 物品: %s | 结果: %s",
                                            --     item["類型"][1], bag.category_utf8 or "nil",
                                            --     type_ok and "匹配" or "不匹配"))
                                        end
                                        
                                        if type_ok then
                                            -- poe2_api.dbgp("-> 所有条件匹配，返回配置")
                                            return item
                                        end
                                    end
                                end
                            end
                        end
                    end
                
                    poe2_api.dbgp("\n[匹配结果] 未找到匹配配置")
                    return nil
                end

                local items_to_identify = {}
                poe2_api.dbgp("开始扫描背包物品...")
                
                for i, bag in ipairs(bag_info) do
                    -- poe2_api.dbgp(string.format("\n物品 %d/%d: %s (类型: %s, 基础类型: %s, 颜色: %d, 已鉴定: %s)", 
                    --     i, #bag_info, bag.name_utf8 or "无名", bag.category_utf8 or "无类型", 
                    --     bag.baseType_utf8 or "无基础类型", bag.color or -1, 
                    --     tostring(not bag.not_identified)))
                    
                    -- 基础条件：未鉴定、未污染、不在排除列表
                    if not (bag.not_identified and
                            not poe2_api.table_contains(my_game_info.not_need_identify, bag.category_utf8)) then
                        -- poe2_api.dbgp("物品已鉴定或在不需鉴定列表中，跳过")
                        goto continue_item
                    end
                    
                    -- 特殊类别直接加入鉴定列表
                    if poe2_api.table_contains({"Map", "TowerAugmentation"}, bag.category_utf8) then
                        poe2_api.dbgp("特殊类别物品，直接加入鉴定列表")
                        table.insert(items_to_identify, bag)
                        goto continue_item
                    end

                    -- 获取匹配的配置
                    poe2_api.dbgp("开始匹配配置...")
                    local matched_config = get_matched_config(bag)
                    -- 检查物品詞綴配置
                    -- poe2_api.printTable(matched_config)
                    if matched_config and matched_config["物品詞綴"] or matched_config["名稱"] then
                        poe2_api.dbgp("找到匹配配置，检查词缀内容...")
                        local affix_dict = matched_config["物品詞綴"]
                        -- poe2_api.printTable(matched_config)
                        if matched_config["名稱"] ~= nil then
                            table.insert(items_to_identify, bag)
                            poe2_api.dbgp(string.format("发现有效名稱内容: %s", matched_config["名稱"]))
                        end
                        if affix_dict and type(affix_dict) == "table" then
                            local has_content = false
                            -- 遍历所有词缀组
                            for affix_group_name, affix_group in pairs(affix_dict) do
                                if type(affix_group) == "table" then
                                    -- 检查是否有"詞綴"数组且不为空
                                    local affix_array = affix_group["詞綴"]
                                    if affix_array and type(affix_array) == "table" and #affix_array > 0 then
                                        has_content = true
                                        poe2_api.dbgp(string.format("发现有效词缀内容，组: %s, 词缀数量: %d", 
                                                                affix_group_name, #affix_array))
                                        break  -- 找到一个有效组就足够
                                    end
                                    
                                end
                            end
                            
                            if has_content then
                                poe2_api.dbgp("配置中有词缀内容，加入鉴定列表")
                                table.insert(items_to_identify, bag)
                            else
                                poe2_api.dbgp("配置中无词缀内容，跳过")
                            end
                        else
                            poe2_api.dbgp("词缀配置格式无效")
                        end
                    else
                        poe2_api.dbgp("未找到匹配配置或配置无词缀要求")
                    end
                    ::continue_item::
                end

                if #items_to_identify > 0 then
                    poe2_api.dbgp(string.format("找到 %d 件需要鉴定的物品", #items_to_identify))
                    appraisal_item_list = items_to_identify
                    return items_to_identify
                end
                poe2_api.dbgp("未找到需要鉴定的物品")
                return false
            end

            poe2_api.dbgp("开始检查是否需要鉴定...")
            local bag_info = api_Getinventorys(1, 0)
            if not bag_info then
                poe2_api.dbgp("错误: 无法获取背包信息")
                return bret.SUCCESS
            end

            local items_to_identify = need_appraisal(bag_info)
            local total_items_to_identify = poe2_api.items_not_identified(bag_info)

            if items_to_identify then
                poe2_api.dbgp("开始检查是否需要鉴定...",#items_to_identify,"-->",#total_items_to_identify)
            end

            if not items_to_identify or (#items_to_identify ~= #total_items_to_identify) and not env.full_map then
                poe2_api.dbgp("当前没有需要鉴定的物品 或者背包有不需要鉴定的物品")
                if poe2_api.find_text({UI_info = env.UI_info, text = "鑑定物品"}) and not env.is_shop then
                    poe2_api.dbgp("发现鑑定物品界面且不在商店，点击关闭")
                    poe2_api.find_text({UI_info = env.UI_info, text = "再會", click = 2})
                    api_Sleep(100)
                end
                -- api_Sleep(10000000)
                return bret.SUCCESS
            else
                if env.user_config["全局設置"] and 
                    env.user_config["全局設置"]["剧情地图设置"] and 
                    env.user_config["全局設置"]["剧情地图设置"]["是否開啟"] then
                    env.interactive = "黑衣幽魂"
                else
                    env.interactive = "多里亞尼"
                end
                
                map_obj = poe2_api.check_in_map(current_map_info,env.interactive)
                range_obj = poe2_api.check_in_range(env.range_info, env.interactive)
                target_obj = map_obj or range_obj or nil
                poe2_api.dbgp(target_obj)
                if target_obj then
                    distance = poe2_api.point_distance(target_obj.grid_x,target_obj.grid_y,player_info)
                    poe2_api.dbgp("distance",distance)
                    if distance and distance > 25 then
                        poe2_api.dbgp("交互",env.interactive)
                        return bret.FAIL
                    else
                        if poe2_api.find_text({UI_info = env.UI_info, text = "重鑄台", min_x = 0}) 
                        and poe2_api.find_text({UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", min_x = 0}) then
                            poe2_api.dbgp("关闭重铸台界面")
                            poe2_api.dbgp1("SDGSFDGSFHBSFB")
                            poe2_api.click_keyboard("space")
                            return bret.RUNNING
                        end
                        api_Sleep(1000)
                        if not poe2_api.find_text({UI_info = env.UI_info, text = "鑑定物品"}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = "多里亞尼",click=2, refresh = true})
                            api_Sleep(500)
                            return bret.RUNNING
                        else
                            poe2_api.find_text({UI_info = env.UI_info, text = "鑑定物品", click = 2})
                            api_Sleep(500)
                            -- api_Sleep(50000)
                            return bret.RUNNING
                        end
                    end
                else
                    poe2_api.dbgp("当前没有多里亞尼")
                    return bret.FAIL
                end
            end
        end
    },

    -- 是否需要合成
    Is_Need_Conflate = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Is_Need_Conflate 检查")
            local bag_info = env.bag_info
            local map_info = env.current_map_info
            local config = env.user_config
            local need_synthesis = config["全局設置"]["刷图通用設置"]["自動合成地圖"]
            
            poe2_api.dbgp("自动合成地图设置:", need_synthesis)
            
            if not need_synthesis or env.full_map then
                poe2_api.dbgp("自动合成未开启，返回FAIL")
                if poe2_api.find_text({UI_info = env.UI_info, text = "重鑄台", min_x = 0}) 
                   and poe2_api.find_text({UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", min_x = 0}) then
                    poe2_api.dbgp("关闭重铸台界面")
                    poe2_api.dbgp1("SDGSFDGSFHBSFB")
                    poe2_api.click_keyboard("space")
                end
                return bret.SUCCESS
            end
            
            -- 检查宝藏金锤是否激活
            local hammer_active = nil
            if map_info then
                for _, item in ipairs(map_info) do
                    if item.name_utf8 == "TreasureVaultHammerActive" and item.flagStatus1 == 1 then
                        hammer_active = item
                        break
                    end
                end
            end
            
            local function check_in_range(object)
                for _, k in ipairs(env.range_info) do
                    if object then
                        if k.name_utf8 == object or k.path_name_utf8 == object then
                            return k
                        end
                    end
                end
                return false
            end

            hammer_active_range = check_in_range("重鑄台")
            
            if not hammer_active and not hammer_active_range then
                poe2_api.dbgp("重铸台未激活")
                if poe2_api.find_text({UI_info = env.UI_info, text = "重鑄台", min_x = 0}) 
                   and poe2_api.find_text({UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", min_x = 0}) then
                    poe2_api.dbgp("关闭重铸台界面")
                    poe2_api.dbgp1("SDGSFDGSFHBSFB")
                    poe2_api.click_keyboard("space")
                end
                return bret.SUCCESS
            end
            
            -- 检查是否可以合成
            local function check_synthesis_possible(bag_info)
                poe2_api.dbgp("开始检查合成可能性")
                local item_counts = {}
                
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        if item.baseType_utf8 and string.find(item.baseType_utf8, "地圖鑰匙") 
                           and not item.contaminated and not item.not_identified 
                           and item.baseType_utf8 ~= "地圖鑰匙（階級 15）" 
                           and item.baseType_utf8 ~= "地圖鑰匙（階級 16）" then
                            item_counts[item.baseType_utf8] = (item_counts[item.baseType_utf8] or 0) + 1
                        end
                    end
                end
                
                poe2_api.dbgp("地图钥匙统计:", item_counts)
                
                -- 检查是否有至少3个相同的物品
                for _, count in pairs(item_counts) do
                    if count >= 3 then
                        poe2_api.dbgp("找到可合成的地图钥匙")
                        return true
                    end
                end
                
                poe2_api.dbgp("未找到足够的地图钥匙进行合成")
                return false
            end
            
            if not check_synthesis_possible(bag_info) then
                if poe2_api.find_text({UI_info = env.UI_info, text = "重鑄台", min_x = 0}) 
                   and poe2_api.find_text({UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", min_x = 0}) then
                    poe2_api.dbgp("关闭重铸台界面")
                    poe2_api.dbgp1("SDGSFDGSFHBSFB")
                    poe2_api.click_keyboard("space")
                end
                return bret.SUCCESS
            end
            
            poe2_api.dbgp("满足合成条件，返回FAIL")
            return bret.FAIL
        end
    },

    -- 打开合成界面
    Open_Conflate_page = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Open_Conflate_page - 打开合成界面")
            local current_time = api_GetTickCount64()
            local bag_info = env.bag_info
            local map_info = env.current_map_info
            local player_info = env.player_info
            local config = env.user_config
            
            
            
            -- 检查重铸台是否激活
            local hammer_active = nil
            if map_info then
                for _, item in ipairs(map_info) do
                    if item.name_utf8 == "TreasureVaultHammerActive" and item.flagStatus1 == 1 then
                        hammer_active = item
                        break
                    end
                end
            end

            local function check_in_range(object)
                if not env.range_info then
                    return false
                end
                for _, k in ipairs(env.range_info) do
                    if object then
                        if k.name_utf8 == object or k.path_name_utf8 == object then
                            return k
                        end
                    end
                end
                return false
            end

            hammer_active_range = check_in_range("重鑄台")
            
            if not hammer_active and not hammer_active_range then
                poe2_api.dbgp("重铸台未激活")
                return bret.SUCCESS
            end
            
            -- 检查是否可以合成
            local function check_synthesis_possible(bag_info)
                poe2_api.dbgp("检查合成可能性")
                local item_counts = {}
                
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        if item.baseType_utf8 and string.find(item.baseType_utf8, "地圖鑰匙") 
                        and not item.contaminated and not item.not_identified 
                        and item.baseType_utf8 ~= "地圖鑰匙（階級 15）" then
                            item_counts[item.baseType_utf8] = (item_counts[item.baseType_utf8] or 0) + 1
                        end
                    end
                end
                
                poe2_api.dbgp("地图钥匙统计:", item_counts)
                
                -- 检查是否有至少3个相同的物品
                for _, count in pairs(item_counts) do
                    if count >= 3 then
                        return true
                    end
                end
                return false
            end
            
            if not check_synthesis_possible(bag_info) then
                poe2_api.dbgp("未找到足够的地图钥匙进行合成")
                if poe2_api.find_text({UI_info = env.UI_info, text = "重鑄台", min_x = 0}) 
                and poe2_api.find_text({UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", min_x = 0}) then
                    poe2_api.dbgp("关闭重铸台界面")
                    poe2_api.find_text({UI_info = env.UI_info, 
                        text = "重鑄台",
                        click = 2,
                        add_x = 211,
                        min_x = 0
                    })
                end
                return bret.FAIL
            end
            
            -- 检查天赋重置界面
            if poe2_api.find_text({UI_info = env.UI_info, text = "重置天賦點數", min_x = 0}) 
            and poe2_api.find_text({UI_info = env.UI_info, text = "返還輿圖天賦", min_x = 0}) then
                poe2_api.dbgp("关闭天赋重置界面")
                poe2_api.find_text({UI_info = env.UI_info, text = "再會", click = 2})
                return bret.RUNNING
            end
            
            -- 尝试打开合成界面
            if not (poe2_api.find_text({UI_info = env.UI_info, text = "重鑄台", min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", min_x = 0})) then
                poe2_api.dbgp("未找到合成界面，设置交互对象为重铸台")
                env.interactive = "重鑄台"
                return bret.SUCCESS
            else
                poe2_api.dbgp("合成界面已打开，返回")
                return bret.FAIL
            end
        end
    },

    -- 点击物品进行合成
    Click_On_The_Item_To_Synthesize = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Click_On_The_Item_To_Synthesize")
            local map_info = env.current_map_info
            local bag_info = env.bag_info
            

            if not (poe2_api.find_text({UI_info = env.UI_info, text = "重鑄台", min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", min_x = 0})) then
                poe2_api.dbgp("未找到合成界面，返回")
                return bret.RUNNING
            end
            
            -- 检查是否可以合成
            local function check_synthesis_possible(bag_info)
                poe2_api.dbgp("检查合成可能性")
                local item_counts = {}
                
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        if item.baseType_utf8 and string.find(item.baseType_utf8, "地圖鑰匙") 
                        and not item.contaminated and not item.not_identified 
                        and item.baseType_utf8 ~= "地圖鑰匙（階級 15）" then
                            item_counts[item.baseType_utf8] = (item_counts[item.baseType_utf8] or 0) + 1
                        end
                    end
                end
                
                poe2_api.dbgp("地图钥匙统计:", item_counts)
                -- 检查是否有至少3个相同的物品
                for _, count in pairs(item_counts) do
                    if count >= 3 then
                        return true
                    end
                end
                return false
            end
            
            if not check_synthesis_possible(bag_info) then
                poe2_api.dbgp("未找到足够的地图钥匙进行合成")
                if poe2_api.find_text({UI_info = env.UI_info, text = "重鑄台", min_x = 0}) 
                and poe2_api.find_text({UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", min_x = 0}) then
                    poe2_api.dbgp("关闭重铸台界面")
                    poe2_api.dbgp1("DNDBSGSDGVSDCVSDCV")
                    poe2_api.click_keyboard("space")
                end
                return bret.FAIL
            end
            
            -- 罗马数字验证函数
            local function is_valid_roman_numeral(s)
                local roman_to_int_map = {
                    I = 1, V = 5, X = 10, L = 50,
                    C = 100, D = 500, M = 1000
                }
                
                local total = 0
                for i = 1, #s do
                    if not roman_to_int_map[s:sub(i,i)] then
                        return false
                    end
                end
                
                local i = 1
                while i <= #s do
                    if i + 1 <= #s and roman_to_int_map[s:sub(i,i)] < roman_to_int_map[s:sub(i+1,i+1)] then
                        total = total + roman_to_int_map[s:sub(i+1,i+1)] - roman_to_int_map[s:sub(i,i)]
                        i = i + 2
                    else
                        total = total + roman_to_int_map[s:sub(i,i)]
                        i = i + 1
                    end
                end
                
                return total >= 1 and total <= 15
            end
            
            -- 获取所有物品名称并统计出现次数
            local item_counts = {}
            local item_counts_infos = {}
            if bag_info then
                for _, actor in ipairs(bag_info) do
                    if not actor.not_identified and actor.baseType_utf8 and string.find(actor.baseType_utf8, "地圖鑰匙") 
                    and not actor.contaminated and actor.baseType_utf8 ~= "地圖鑰匙（階級 15）" then
                        item_counts[actor.baseType_utf8] = (item_counts[actor.baseType_utf8] or 0) + 1
                        table.insert(item_counts_infos,actor)
                    end
                end
            end

            local ROMAN_NUMERALS = {
                "I", "II", "III", "IV", "V",
                "VI", "VII", "VIII", "IX", "X",
                "XI", "XII", "XIII", "XIV", "XV", "XVI"
            }
            -- 找到可以合成的物品名称
            for item_name, count in pairs(item_counts) do
                if count >= 3 then
                    poe2_api.dbgp("找到可合成的地图钥匙:", item_name, "数量:", count)
                    
                    -- 查找献祭按钮位置
                    local start_pos = poe2_api.find_text({UI_info = env.UI_info, text = "獻祭", position = 3})
                    if start_pos then
                        local start_x = start_pos[1] + 15
                        local start_y = start_pos[2] - 325
                        
                        poe2_api.find_text({UI_info = env.UI_info, text = ROMAN_NUMERALS, click = 4, min_x = start_x, min_y = start_y, max_y = 590, max_x = 1030})
                    end
                    
                    api_Sleep(80)
                    
                    -- 获取合成槽中的物品
                    local compositing_map = api_Getinventorys(0x48, 0)
                    if compositing_map then
                        -- 检查各个槽位并点击相应位置
                        for _, item in ipairs(compositing_map) do
                            if item.start_x == 0 and item.start_y == 0 then
                                poe2_api.find_text({UI_info = env.UI_info, 
                                    text = "獻祭", 
                                    click = 4,
                                    add_x = -107,
                                    add_y = -143
                                })
                                api_Sleep(80)
                            elseif item.start_x == 2 and item.start_y == 0 then
                                poe2_api.find_text({UI_info = env.UI_info, 
                                    text = "獻祭", 
                                    click = 4,
                                    add_y = -143
                                })
                                api_Sleep(80)
                            elseif item.start_x == 4 and item.start_y == 0 then
                                poe2_api.find_text({UI_info = env.UI_info, 
                                    text = "獻祭", 
                                    click = 4,
                                    add_x = 107,
                                    add_y = -143
                                })
                                api_Sleep(80)
                            end
                        end
                    end
                    
                    poe2_api.dbgp("准备合成:", item_name)

                    -- 筛选出名称相同的物品
                    if item_counts_infos then
                        local clicked_count = 0  -- 已点击计数器
                        
                        -- 遍历所有物品信息
                        for _, item_info in ipairs(item_counts_infos) do
                            -- 检查物品名称是否匹配
                            if item_info.baseType_utf8 == item_name then

                                center = poe2_api.get_center_position({item_info.start_x,item_info.start_y},{item_info.end_x,item_info.end_y})
                                
                                -- 点击物品（两种方式可选）
                                -- 方式1：使用坐标点击
                                poe2_api.dbgp("点击物品:", item_name, "位置:", center[1], center[2])
                                poe2_api.ctrl_left_click(center[1], center[2])
                                
                                clicked_count = clicked_count + 1
                                api_Sleep(50)  -- 短暂延迟
                                
                                -- 点击满3次就停止
                                if clicked_count >= 3 then
                                    break
                                end
                            end
                        end
                        
                        if clicked_count < 3 then
                            poe2_api.dbgp("警告: 只找到", clicked_count, "个", item_name, "无法完成合成")
                        end
                    end

                    api_Sleep(500)

                    if not poe2_api.find_text({UI_info = env.UI_info, text = '獻祭', click=2, min_x = 0}) then
                        return bret.RUNNING
                    end
                    
                    api_Sleep(1000)

                    -- 处理合成后的物品
                    poe2_api.find_text({UI_info = env.UI_info, 
                        text = "摧毀三個相似的物品，重鑄為一個新的物品",
                        click = 4,
                        add_y = 140,
                        min_x = 0
                    })
                    api_Sleep(100)
                    
                    poe2_api.dbgp("合成操作完成:", item_name)
                    return bret.RUNNING
                end
            end
            
            -- 如果没有找到可合成的物品，关闭重铸台界面
            if poe2_api.find_text({UI_info = env.UI_info, text = "重鑄台", min_x = 0}) 
            and poe2_api.find_text({UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", min_x = 0}) then
                poe2_api.find_text({UI_info = env.UI_info, 
                    text = "重鑄台",
                    click = 2,
                    add_x = 211,
                    min_x = 0
                })
            end
            
            return bret.SUCCESS
        end
    },

    -- 异界是否需要传送
    Otherworld_Is_Need_Teleport = {
        run = function(self, env)
            poe2_api.dbgp("开始执行异界传送判断函数")
            local current_time = api_GetTickCount64()

            -- 检查是否在目标区域里
            poe2_api.dbgp("检查是否在目标区域里")
            local current_map_info = env.current_map_info
            
            -- 定义检查是否有传送点的函数
            local function Is_Have_Waypoint()
                poe2_api.dbgp("检查当前地图是否有传送点")
                if next(current_map_info) then
                    for _, v in ipairs(current_map_info) do
                        -- poe2_api.dbgp(v.name_utf8)
                        if v.name_utf8 == "Waypoint" then
                            poe2_api.dbgp("找到传送点")
                            return true
                        end
                    end
                    poe2_api.dbgp("未找到传送点")
                    return false
                end
            end
            
            -- 初始化副本地图信息
            if self.copy_map_info == nil then
                poe2_api.dbgp("初始化copy_map_info为false")
                self.copy_map_info = false
            end
            
            -- 如果没有传送点，直接返回成功
            if not Is_Have_Waypoint() then 
                poe2_api.dbgp("当前地图没有传送点，无需传送")
                return bret.SUCCESS
            end
            
            poe2_api.dbgp("当前地图有传送点，继续处理")
            
            local player_info = env.player_info
            local config = env.user_config
            local user_map_info = nil
            
        
            -- 根据任务类型设置目标地图
            local user_map_info = poe2_api.format_map_data(config)
            if not user_map_info then
                poe2_api.dbgp("无剧情地图")
                return bret.SUCCESS
            end

            local is_map_complete = env.is_map_complete
            local target_chapter_name = user_map_info[1]
            local target_map_name = user_map_info[2]
            
            poe2_api.dbgp("当前玩家位置:", player_info.current_map_name_utf8)
            poe2_api.dbgp("目标章节:", target_chapter_name)
            poe2_api.dbgp("目标地图:", target_map_name)
            
            -- 如果用户地图信息为空且玩家在藏身处且靠近传送点
            if not user_map_info and poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout) 
                and poe2_api.check_pos_dis("Waypoint", current_map_info, player_info) then
                poe2_api.dbgp('user_map_info为nil且玩家在藏身处靠近传送点，设置默认目标')
                target_chapter_name = '<red>{第三章}'
                target_map_name = '高地神塔庇護所'
            end

            -- 如果有目标章节和地图名称
            if target_chapter_name and target_map_name then 
                poe2_api.dbgp("有明确的目标章节和地图名称")
                local result = poe2_api.get_map_data(target_chapter_name, target_map_name)
                poe2_api.printTable(result)
                
                if result then
                    -- poe2_api.dbgp("目标地区完成状态为：", result[2])
                    
                    -- 检查玩家是否已在目标地图
                    if player_info.current_map_name_utf8 ~= result[1] or is_map_complete then 
                        poe2_api.dbgp("人物当前位置不在目标地图")
                        env.chapter_name = target_chapter_name
                        env.map_name = result
                        poe2_api.dbgp("需要传送，目标地图:", target_map_name)
                        return bret.FAIL
                    else
                        poe2_api.dbgp("已在目标地图且地图未完成")
                        return bret.SUCCESS
                    end
                end
                poe2_api.dbgp("未能获取目标地图完成状态")
                return bret.RUNNING
            else
                poe2_api.dbgp("没有明确的目标章节和地图名称，检查副本地图信息")
                
                if self.copy_map_info and user_map_info then
                    local found = false
                    for _,map_info in ipairs(self.copy_map_info) do
                        local result = poe2_api.get_map_data(map_info[1], map_info[2])
                        if result and result[2] then
                            if player_info.current_map_name_utf8 == result[1][2] then
                                found = true
                                poe2_api.dbgp("玩家已在副本地图:", map_info[2])
                                
                                if is_map_complete then
                                    poe2_api.dbgp("地图", map_info[2], "已完成，需要移除")
                                    env.chapter_name = target_chapter_name
                                    env.map_name = result
                                    poe2_api.dbgp("进入传送逻辑，目标地图:", target_map_name)
                                    poe2_api.time_p("进入传送逻辑(FAIL)(is_map_complete) -->", api_GetTickCount64() - current_time)
                                    return bret.FAIL
                                else
                                    poe2_api.dbgp("地图", map_info[2], "未完成")
                                    return bret.SUCCESS
                                end
                            end
                        end
                    end
                    
                    if not found then 
                        poe2_api.dbgp("玩家不在任何副本地图中，寻找可传送地图")
                        for _,map_info in ipairs(self.copy_map_info) do
                            local result = poe2_api.get_map_data(map_info[1], map_info[2])
                            if result and result[2] then
                                env.chapter_name = map_info[1]
                                env.map_name = result
                                poe2_api.dbgp("进入传送逻辑，目标地图:", map_info[2])
                                poe2_api.time_p("进入传送逻辑(FAIL)(not found) -->", api_GetTickCount64() - current_time)
                                return bret.FAIL
                            end
                        end
                        poe2_api.dbgp("没有可传送地图")
                        return bret.RUNNING
                    end 
                else
                    if not self.copy_map_info and user_map_info then
                        poe2_api.dbgp("初始化副本地图信息")
                        self.copy_map_info = user_map_info
                        return bret.RUNNING
                    end
                    poe2_api.dbgp("无需传送")
                    return bret.SUCCESS
                end
            end
        end
    },

    -- 异界点击地图传送
    Otherworld_Click_Map_To_Area_Teleport = {
        run = function(self, env)
            poe2_api.print_log("开始执行异界点击地图传送...")
            local current_time = api_GetTickCount64()
            
            -- 获取环境变量
            local map_name = env.map_name
            local chapter_name = env.chapter_name
            local waypoint_open = env.waypoint
            local current_map_info = env.current_map_info
            local player_info = env.player_info
            local range_info = env.range_info
            local is_map_complete = env.is_map_complete
            
            poe2_api.dbgp("环境变量:", 
                "map_name", map_name,
                "chapter_name", chapter_name,
                "waypoint_open", waypoint_open,
                "is_map_complete", is_map_complete)

            -- 检查传送点距离
            local function check_pos_dis(name, map_info, player)
                poe2_api.dbgp("检查传送点距离...")
                for _, item in ipairs(map_info) do
                    if item.name_utf8 == name then
                        local dis = poe2_api.point_distance(item.grid_x, item.grid_y, player)
                        poe2_api.dbgp(string.format("传送点距离: %.2f", dis))
                        return dis
                    end
                end
                return false
            end

            -- 获取非地图物品
            local function get_not_map(range_info)
                poe2_api.dbgp("查找非地图交互对象...")
                for _, item in ipairs(range_info) do
                    if item.type == 5 and item.name_utf8 ~= '' and item.name_utf8 ~= "傳送點" and item.name_utf8 ~= '異界之門' then
                        poe2_api.dbgp("找到非地图对象:", item.name_utf8)
                        return item
                    end
                end
                poe2_api.dbgp("未找到非地图对象")
                return false
            end

            -- 获取地面UI层级
            local function switch_ground()
                poe2_api.dbgp("获取地面UI层级...")
                local controls = poe2_api.get_game_control_by_rect({
                    UI_info = env.UI_info, 
                    min_x = 1525, 
                    min_y = 230, 
                    max_x = 1600,
                    max_y = 560
                })
                
                -- 使用表来筛选符合条件的控件
                local filtered_controls = {}
                for _, control in ipairs(controls) do
                    if control.name_utf8 == "" and control.left == 1544.25 then
                        table.insert(filtered_controls, control)
                    end
                end
                
                if #filtered_controls == 0 then
                    poe2_api.dbgp("未找到符合条件的UI控件")
                    return false
                end
                
                -- 使用排序方法找到最小top值
                table.sort(filtered_controls, function(a, b)
                    return a.top < b.top
                end)
                
                local min_top = filtered_controls[1].top
                poe2_api.dbgp("最小top值:", min_top)
                return min_top
            end

            -- 主逻辑
            if not check_pos_dis("Waypoint", current_map_info, player_info) then
                poe2_api.dbgp("传送点不在范围内或不存在")
                return bret.FAIL
            end
            -- poe2_api.dbgp("map_name:",map_name," , map_name[2]:",map_name[2])

            if map_name then
                local task_area_name = map_name[1][1]
                poe2_api.dbgp("任务区域名称:", task_area_name)

                if poe2_api.click_text_UI({UI_info = env.UI_info, text = "loading_screen_tip_label"}) then
                    poe2_api.dbgp("检测到加载界面，等待5秒...")
                    api_Sleep(5000)
                    return bret.RUNNING
                end

                if player_info.current_map_name_utf8 ~= map_name[1] or is_map_complete then
                    if not poe2_api.find_text({UI_info = env.UI_info, text = "傳送", min_x = 700, max_y = 40, max_x = 830, refresh = true}) then
                        if not string.find(player_info.current_map_name_utf8, "town") and not poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                            if check_pos_dis("Waypoint", current_map_info, player_info) > 180 then
                                local door = get_not_map(range_info)
                                if door then
                                    poe2_api.dbgp("距离传送点过远，尝试通过门传送...")
                                    poe2_api.find_text({UI_info = env.UI_info, text = door.name_utf8, click = 2})
                                    api_Sleep(500)
                                    return bret.RUNNING
                                end
                                poe2_api.dbgp("移动到默认位置...")
                                api_ClickScreen(1230, 815, 0)
                                api_ClickScreen(1230, 815, 1)
                                api_Sleep(500)
                            end
                        end

                        poe2_api.dbgp("设置交互对象为传送点")
                        env.interactive = "Waypoint"
                        return bret.FAIL
                    elseif poe2_api.find_text({UI_info = env.UI_info, text = "傳送", min_x = 700, max_y = 40, max_x = 830}) then
                        local min_top = switch_ground()
                        if not min_top then
                            poe2_api.dbgp("未找到地面UI层级")
                            return bret.RUNNING
                        end

                        poe2_api.dbgp("点击章节名称:", chapter_name)
                        poe2_api.find_text({UI_info = env.UI_info, text = chapter_name, click = 2})
                        
                        if poe2_api.table_contains(chapter_name, {"第 1 章", "<red>{第一章}"}) and not poe2_api.find_text({UI_info = env.UI_info, text = "奧格姆郡，約恆曆", min_x = 0, match = 2, refresh = true}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = chapter_name, click = 2, refresh = true})
                            poe2_api.dbgp("再次点击章节名称:", chapter_name)
                            return bret.RUNNING
                        elseif poe2_api.table_contains(chapter_name, {"第 2 章", "<red>{第二章}"}) and not poe2_api.find_text({UI_info = env.UI_info, text = "七大水域之地", min_x = 0, match = 2, refresh = true}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = chapter_name, click = 2, refresh = true})
                            poe2_api.dbgp("再次点击章节名称:", chapter_name)
                            return bret.RUNNING
                        elseif poe2_api.table_contains(chapter_name, {"第 3 章"}) and not poe2_api.find_text({UI_info = env.UI_info, text = "奧札爾區域草稿 #", min_x = 0, match = 2, refresh = true}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = chapter_name, click = 2, refresh = true})
                            poe2_api.dbgp("再次点击章节名称:", chapter_name)
                            return bret.RUNNING
                        elseif poe2_api.table_contains(chapter_name, {"<red>{第三章}"}) and not poe2_api.find_text({UI_info = env.UI_info, text = "古奧札爾草稿", min_x = 0, match = 2, refresh = true}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = chapter_name, click = 2, refresh = true})
                            poe2_api.dbgp("再次点击章节名称:", chapter_name)
                            return bret.RUNNING
                        end

                        poe2_api.dbgp("获取传送点信息")
                        if not poe2_api.find_text({UI_info = env.UI_info, text = "新副本", click = 2, min_x = 0}) then
                            env.waypoint = api_GetTeleportationPoint()
                        end
                        if not env.waypoint then
                            poe2_api.dbgp("获取传送点信息失败")
                            return bret.RUNNING
                        else
                            poe2_api.printTable(env.waypoint)
                            poe2_api.dbgp("获取传送点信息成功")
                        end

                        local function findNameC(targetName)
                            local results = {}
                            for i, item in ipairs(env.waypoint) do
                                if item.name == targetName then
                                    -- if not item.is_open then
                                    --     return false, false
                                    -- end
                                    return (item.left + item.right)/2, (item.top + item.bottom)/2
                                end
                            end
                            return false, false
                        end

                        local screen_x, screen_y = findNameC(map_name[1])
                        poe2_api.dbgp("map_name[1]", map_name[1])
                        if not screen_x and not screen_y then
                            poe2_api.dbgp("传送点未开启或者信息有误")
                            return bret.RUNNING
                        end
                        poe2_api.dbgp("两点坐标：", screen_x," ,  ", screen_y)
                        -- api_Sleep(100000)
                        
                        -- poe2_api.printTable(env.waypoint)

                        if poe2_api.find_text({UI_info = env.UI_info, text = "奧格姆郡，約恆曆", min_x = 0, match = 2}) or 
                        poe2_api.find_text({UI_info = env.UI_info, text = "七大水域之地", min_x = 0, match = 2}) or 
                        poe2_api.find_text({UI_info = env.UI_info, text = "奧札爾區域草稿 #", min_x = 0, match = 2}) or 
                        poe2_api.find_text({UI_info = env.UI_info, text = "古奧札爾草稿", min_x = 0, match = 2}) then
                            if not poe2_api.find_text({UI_info = env.UI_info, text = task_area_name}) then
                                poe2_api.dbgp("移动到地图位置:", screen_x, screen_y)
                                api_ClickScreen(screen_x, screen_y, 0)
                                api_Sleep(1000)

                                if #map_name < 2 then
                                    if not poe2_api.find_text({UI_info = env.UI_info, text = "副本管理員"}) and not string.find(map_name[1], "own") and map_name[1] ~= "G1_7" then
                                        poe2_api.dbgp("按下Ctrl键点击...")
                                        poe2_api.click_keyboard("ctrl", 1)
                                        api_Sleep(1000)
                                        api_ClickScreen(screen_x, screen_y, 1)
                                        api_Sleep(1000)
                                        poe2_api.click_keyboard("ctrl", 2)
                                    end
                                    poe2_api.find_text({UI_info = env.UI_info, text = "新副本", click = 2, min_x = 0})
                                    env.is_map_complete = false
                                    api_Sleep(2000)
                                else
                                    poe2_api.dbgp("点击一层...")
                                    api_Sleep(1000)
                                    api_ClickScreen(screen_x, screen_y, 1)
                                    api_Sleep(1000)
                                end
                            else
                                poe2_api.dbgp("点击地面UI...")
                                api_ClickScreen(1567, min_top + 22, 0)
                                api_ClickScreen(1567, min_top + 22, 1)
                                api_Sleep(2000)
                                return bret.RUNNING
                            end

                            poe2_api.dbgp("33333333333333333:")

                            if #map_name > 1 then
                                poe2_api.dbgp("处理第二个地图位置...")
                                api_ClickScreen(screen_x, screen_y, 0)
                                api_Sleep(1000)
                                local task_two_area_name = map_name[2][1]
                                poe2_api.dbgp("二次获取传送点信息")
                                env.waypoint = api_GetTeleportationPoint()
                                poe2_api.dbgp("二次获取传送点信息成功", map_name[2][2])
                                local screen_x, screen_y = findNameC(map_name[2][2])
                                api_ClickScreen(screen_x, screen_y, 0)
                                api_Sleep(1000)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = task_two_area_name, min_x = 0, refresh = true}) then
                                    poe2_api.dbgp1("GDSBSDBCXVAFSEAD")
                                    poe2_api.click_keyboard("space")
                                    return bret.RUNNING
                                end

                                if not poe2_api.find_text({UI_info = env.UI_info, text = "副本管理員"}) and not string.find(map_name[1], "own") and map_name[1] ~= "G1_7" then
                                    poe2_api.dbgp("按下Ctrl键点击第二个位置...")
                                    poe2_api.click_keyboard("ctrl", 1)
                                    api_Sleep(1000)
                                    api_ClickScreen(screen_x, screen_y, 1)
                                    api_Sleep(1000)
                                    poe2_api.click_keyboard("ctrl", 2)
                                end
                                api_Sleep(1000)
                                poe2_api.find_text({UI_info = env.UI_info, text = "新副本", click = 2, min_x = 0, refresh = true})
                                env.is_map_complete = false
                                api_ClickScreen(screen_x, screen_y, 1)
                                api_Sleep(2000)
                            end
                            env.map_name = nil
                            env.is_map_complete = false
                            return bret.RUNNING
                        end
                        poe2_api.dbgp("未找到章节标志")
                        return bret.RUNNING
                    end
                else
                    poe2_api.dbgp("已在目标地图中")
                    return bret.SUCCESS
                end
            else
                poe2_api.dbgp("传送点未开启或地图名称无效")
                return bret.RUNNING
            end
        end
    },

    
     -- 判断是否需要交互
    Is_Interactive = {
        run = function(self, env)
            poe2_api.print_log("判断是否需要交互...")
            local current_time = api_GetTickCount64()
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.timeout = 0
                self.number = 0
                self.id1 = nil
                self.not_id = nil
                -- env.not_match_id = nil
                self.interactive_timeout = 0
                -- env.interactive_id = nil
                -- env.interactive_id_list = {}
                -- env.interactive_replytime = 0
                -- env.interactive_permanent_id_list = {}
                -- env.obj_color = nil
                self.wait = false
                self.wait_time = 0
                self.currte_time = 0
                self.bool = true
            end
            -- local range_info = env.range_info
            local player_info = env.player_info
            local stuck_monsters = env.stuck_monsters
            if not next(player_info) then
                poe2_api.dbgp("Is_Interactive 没有玩家信息")
                poe2_api.time_p("判断是否需要交互（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if not env.range_info or not next(env.range_info) then
                poe2_api.dbgp("Is_Interactive 没有周围对象信息")
                poe2_api.time_p("判断是否需要交互（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local current_map_info = env.current_map_info
            -- 判断怪物
            local function is_monster(match_data)
                local range_info = match_data.range_info
                local mate = match_data.mate
                local distance = match_data.distance
                local index = match_data.index or 0
                if index ~= 0 and distance > env.min_attack_dis then
                    distance = env.min_attack_dis  
                end
                -- for _, i in ipairs(range_info) do
                --     if i.name_utf8 == "" then
                --         goto continue
                --     end
                --     if index == 0 then
                --         if string.find("蠕蟲隧道破壞者",i.name_utf8) then
                --             return i
                --         end
                --     else
                --         if i.type == 1 
                --          and not i.is_friendly 
                --          and i.life > 0 
                --          and not poe2_api.table_contains(i.name_utf8,my_game_info.not_attact_mons_CN_name) 
                --          and i.isActive 
                --          and not string.find(i.name_utf8,"神殿") 
                --          and i.hasLineOfSight 
                --          and i.is_selectable 
                --          and not poe2_api.table_contains(stuck_monsters,i.id) then
                --             local dis = poe2_api.point_distance(i.grid_x,i.grid_y,mate)
                --             if dis and dis <= distance then
                --                 if index == 1 then
                --                     if i.rarity ~= 3 then
                --                         return i
                --                     end 
                --                 else
                --                     return i
                --                 end
                --             end
                --         end
                --     end
                --     ::continue::
                -- end
                for _, i in ipairs(range_info) do
                    -- 调试打印当前检查的怪物信息
                    -- poe2_api.dbgp("检查怪物: ID="..i.id..", 名称="..i.name_utf8..", 类型="..i.type..", 生命="..i.life..", 稀有度="..i.rarity)
                    
                    -- 跳过名称为空的怪物
                    if i.name_utf8 == "" then
                        -- poe2_api.dbgp("跳过: 怪物名称为空")
                        goto continue
                    end
                    
                    -- 特殊处理index=0的情况(寻找特定怪物)
                    if index == 0 then
                        poe2_api.dbgp("模式0: 寻找特定怪物")
                        if string.find("蠕蟲隧道破壞者", i.name_utf8) then
                            poe2_api.dbgp("找到目标怪物: "..i.name_utf8)
                            return i
                        end
                    else
                        -- 普通怪物筛选条件
                        -- poe2_api.dbgp("模式"..index..": 普通怪物筛选")
                        
                        -- 类型检查(1表示怪物)
                        if i.type ~= 1 then
                            -- poe2_api.dbgp("跳过: 类型不是怪物(类型="..i.type..")")
                            goto continue
                        end
                        
                        -- 友好性检查
                        if i.is_friendly then
                            -- poe2_api.dbgp("跳过: 是友方单位")
                            goto continue
                        end
                        
                        -- 生命值检查
                        if i.life <= 0 then
                            -- poe2_api.dbgp("跳过: 生命值为0或更低")
                            goto continue
                        end
                        
                        -- 不攻击名单检查
                        if poe2_api.table_contains(i.name_utf8, my_game_info.not_attact_mons_CN_name) then
                            -- poe2_api.dbgp("跳过: 在不攻击名单中")
                            goto continue
                        end
                        
                        -- 活动状态检查
                        if not i.isActive then
                            -- poe2_api.dbgp("跳过: 不处于活动状态")
                            goto continue
                        end
                        
                        -- 神殿怪物排除
                        if string.find(i.name_utf8, "神殿") then
                            -- poe2_api.dbgp("跳过: 是神殿怪物")
                            goto continue
                        end
                        
                        -- 视线检查
                        if not i.hasLineOfSight then
                            -- poe2_api.dbgp("跳过: 没有视线")
                            goto continue
                        end
                        
                        -- 可选性检查
                        if not i.is_selectable then
                            -- poe2_api.dbgp("跳过: 不可选")
                            goto continue
                        end
                        
                        -- 卡住怪物检查
                        if poe2_api.table_contains(stuck_monsters, i.id) then
                            -- poe2_api.dbgp("跳过: 怪物被标记为卡住")
                            goto continue
                        end
                        
                        -- 距离计算
                        local dis = poe2_api.point_distance(i.grid_x, i.grid_y, mate)
                        -- poe2_api.dbgp("距离计算: "..tostring(dis).." (最大允许距离: "..distance..")")
                        
                        if dis and dis <= distance then
                            -- 模式1特殊处理(排除稀有怪物)
                            if index == 1 then
                                if i.rarity ~= 3 then
                                    poe2_api.dbgp("找到合适怪物(模式1): "..i.name_utf8..", 稀有度="..i.rarity)
                                    return i
                                else
                                    -- poe2_api.dbgp("跳过: 模式1排除稀有怪物(稀有度=3)")
                                end
                            else
                                -- 其他模式直接返回
                                poe2_api.dbgp("找到合适怪物(模式"..index.."): "..i.name_utf8)
                                return i
                            end
                        else
                            -- poe2_api.dbgp("跳过: 距离超出范围或距离计算失败")
                        end
                    end
                    
                    ::continue::
                end
                return false
            end
            -- -- 判断有无地图装置
            -- local function is_map_device(obj_list)
            --     if not obj_list or #obj_list == 0 then
            --         return false
            --     end
            --     for _, i in ipairs(obj_list) do
            --         if i.name_utf8 == "MapDevice" then
            --             return true
            --         end
            --     end
            --     return false
            -- end
            -- 判断小地图最终boss图标是否显示
            local function is_boss_map(mini_map_info)
                if not mini_map_info or #mini_map_info == 0 then
                    return false
                end
                for _, v in ipairs(mini_map_info) do
                    if v.name_utf8 == "UniqueMonsterAlive" and v.flagStatus == 1 then
                        return true
                    end
                end
                return false
            end
            -- 判断小地图精髓图标是否显示
            local function is_essence_map(mini_map_info)
                for _, v in ipairs(mini_map_info) do
                    if v.name_utf8 == "Essence" then
                        return true
                    end
                end
                return false
            end
            -- 判断小地图是否精英怪显示
            local function is_elite_monster(mini_map_info)
                for _, v in ipairs(mini_map_info) do
                    if v.name_utf8 == "RareMonsterAlive" and v.flagStatus == 1 then
                        return true
                    end
                end
                return false
            end
            -- 判断人物boss距离和竞技场boss距离
            local function get_arena_boss_distance(range_info,inter)
                local is_boss = nil
                for _, v in ipairs(range_info) do
                    if v.rarity ==3 and v.type==1 and v.life>0 then
                        is_boss = v
                        break
                    end
                end
                if is_boss and player_info.current_map_name_utf8 ~= "MapVaalFoundry" then
                    local distance1 = poe2_api.point_distance(is_boss.grid_x,is_boss.grid_y,inter)
                    local distance2 = poe2_api.point_distance(is_boss.grid_x,is_boss.grid_y,player_info)
                    if distance1 and distance2 then
                        if distance1 - distance2 > 20 then
                            return true
                        end
                    end
                end
                return false
            end
            
            
            -- 等待特定交互对象时间间隔
            if env.wait_target 
             and not poe2_api.find_text({UI_info = env.UI_info, text = "把手",min_x=300,max_x=1100})
             and not poe2_api.find_text({UI_info = env.UI_info, text = "水閘門控制桿",min_x=300,max_x=1100}) then
                if self.timeout == 0 then
                    self.timeout = api_GetTickCount64()
                end
                if api_GetTickCount64() - self.timeout < 5000 then
                    poe2_api.dbgp("等待交互把手或者水閘門控制桿时间到达")
                    poe2_api.time_p("判断是否需要交互（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                env.wait_target = false
                self.timeout = 0
            end
            -- 清空不交互对象id列表
            if env.interactive_replytime ~=0 then
                if api_GetTickCount64() - env.interactive_replytime > 15000 then
                    env.interactive_id_list = {}
                    env.interactive_replytime = 0
                    poe2_api.dbgp("交互回复时间到达,清空不交互列表id")
                    poe2_api.time_p("判断是否需要交互（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            -- 获取地图等级对应的箱子颜色
            local config = env.user_config
            local map_config = config['刷圖設置']["地圖鑰匙"]
            local missions = config["執行任務"] or ""
            if missions == "劇情地圖" then
                env.obj_color = 0
            end
            if env.obj_color == nil then
                
                if not poe2_api.find_text({UI_info = env.UI_info, text = my_game_info.game_region,max_x=1800}) then
                    poe2_api.click_keyboard("tab")
                    api_Sleep(500)
                    poe2_api.time_p("判断是否需要交互（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local text = poe2_api.find_text({UI_info = env.UI_info, text = "怪物等級：",min_x = 0,min_y = 0,max_x = 1600,max_y = 900,match = 2,position = 2})
                if text then
                    local color_invert_int = {
                        ["黄"]=2,
                        ["蓝"]=1,
                        ["白"]=0
                    }
                    local level = string.match(text.text_utf8, "：(.*)")
                    local map_config_level = my_game_info.ui_level_map[tostring(level)]
                    local tiers = {}
                    for _, v in ipairs(map_config) do
                        table.insert(tiers,v["階級"])
                    end
                    -- poe2_api.printTable(tiers)
                    poe2_api.dbgp("地图等级:",#tiers)
                    local color = "蓝"
                    if poe2_api.table_contains(poe2_api.toInt(map_config_level),tiers) then
                        for _, v in ipairs(map_config) do
                            if v["階級"] == poe2_api.toInt(map_config_level) then
                                color = v["開箱子"]
                            end
                        end
                    else
                        -- poe2_api.printTable(tiers)
                        poe2_api.dbgp("地图等级:",#tiers)

                        local max_tier =  math.max(table.unpack(tiers))
                        for _, v in ipairs(map_config) do
                            if v["階級"] == poe2_api.toInt(max_tier) then
                                color = v["開箱子"]
                            end
                        end
                    end
                    if color == "" or not color then
                        env.obj_color = 10
                    else
                        env.obj_color = color_invert_int[color]
                    end
                else
                    env.obj_color = 1
                end
            end
            -- 判断自身一定范围内是否有激活怪
            local is_target = is_monster({range_info = env.range_info, mate = player_info, distance = 50, index = 2})
            -- local is_target = type(is_target) ~= "boolean" or true
            poe2_api.dbgp("is_target:",is_target)
            -- 判断自身一定范围内是否有激活怪，不包含特殊boss
            local is_target1 = is_monster({range_info = env.range_info, mate = player_info, distance = 50, index = 1})
            
            local is_bass = is_boss_map(current_map_info)
            local is_essence = is_essence_map(current_map_info)
            local function get_range(range_info)
                local range_sorted = poe2_api.get_sorted_list(env.range_info, env.player_info)
                -- poe2_api.printTable(range_sorted)
                -- api_Sleep(10000000)
                local function is_click()
                    local click_lt = nil
                    for _, i in ipairs(range_sorted) do
                        if i.name_utf8 ~="" and i.name_utf8 == "記錄點" 
                         and not string.find(i.path_name_utf8,"Boss") and i.grid_x and i.grid_y and i.grid_x ~= 0 and i.grid_y ~= 0 then
                            click_lt = i
                            break
                        end
                    end
                    if click_lt then
                        return true
                    end
                    return false
                end
                local currency = nil
                -- for _,v in ipairs(range_sorted) do
                --     if string.find(v.path_name_utf8,"Metadata/MiscellaneousObjects/Abyss") then
                --         poe2_api.printTable(v)
                --     end
                -- end
                -- api_Sleep(10000000)
                for _, i in ipairs(range_sorted) do
                    -- if i.path_name_utf8 ~= "Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable" then
                    -- if not string.find(i.path_name_utf8,"Metadata/Monsters/LeagueDelirium/DoodadDaemons/DoodadDaemonShardPack") then
                    --     goto continue
                    -- end
                    -- poe2_api.printTable(i)
                    -- poe2_api.dbgp("开始检查对象: "..(i.name_utf8 or "无名").." (ID:"..(i.id or "无ID")..")")
                    
                    -- 基础条件检查
                    local basic_checks = i.grid_x and i.grid_y and i.grid_x ~= 0 and i.grid_y ~= 0
                    -- poe2_api.dbgp("基础坐标检查: "..tostring(basic_checks).." (x:"..(i.grid_x or "nil")..", y:"..(i.grid_y or "nil")..")")
                    
                    local id_check = (not env.interactive_id_list or not next(env.interactive_id_list) or not poe2_api.table_contains(env.interactive_id_list,i.id))
                    -- poe2_api.dbgp(poe2_api.table_contains({},i.id))
                    -- poe2_api.dbgp("----------------------")
                    -- poe2_api.printTable(env.interactive_id_list)
                    -- poe2_api.dbgp("----------------------")
                    -- poe2_api.dbgp("ID检查: "..tostring(id_check)," (ID列表: ",(env.interactive_id_list and "存在" or "nil"),", 包含检查: ",(not poe2_api.table_contains(env.interactive_id_list,i.id or 0)))
                    
                    local perm_id_check = (not env.interactive_permanent_id_list or not next(env.interactive_permanent_id_list) or not poe2_api.table_contains(env.interactive_permanent_id_list,i.id))
                    -- poe2_api.dbgp("永久ID检查: "..tostring(perm_id_check).." (永久ID列表: "..(env.interactive_permanent_id_list and "存在" or "nil")..", 包含检查: "..tostring(not poe2_api.table_contains(env.interactive_permanent_id_list or {},i.id or 0)))
                    
                    if basic_checks and id_check and perm_id_check then
                        -- poe2_api.dbgp("通过基础检查，开始详细条件检查")
                        
                        -- 定义各种条件检查
                        local condition1 = (i.name_utf8 and i.name_utf8 ~= "" and poe2_api.table_contains(i.name_utf8,{"先行者烽塔","石陣祭壇",'蠕蟲隧道破壞者','寶藏束縛靈魂'}) and i.isActive and i.is_selectable and not is_target and not player_info.isInBossBattle)
                        if condition1 then
                            -- poe2_api.dbgp("条件1匹配: 特定名称对象 ("..i.name_utf8..")")
                            currency = i
                            break
                        end
                        
                        local condition2 = (i.name_utf8 and i.name_utf8 ~= "" and i.name_utf8 == "競技場" and i.isActive and i.is_selectable and i.hasLineOfSight and not is_target and not player_info.isInBossBattle)
                        if condition2 then
                            -- poe2_api.dbgp("条件2匹配: 竞技场")
                            currency = i
                            break
                        end
                        
                        -- local condition3 = (string.find(i.path_name_utf8,"Metadata/Monsters/TormentedSpirits/TormentedSpiritofthe") and i.life>0 and not is_target and not player_info.isInBossBattle)
                        -- if condition3 then
                        --     -- poe2_api.dbgp("条件3匹配: 受折磨的灵魂 ("..(i.path_name_utf8 or "无路径")..")")
                        --     currency = i
                        --     break
                        -- end
                        
                        local condition4 = (i.name_utf8 and i.name_utf8 ~= "" and i.name_utf8 == "門" and i.isActive and i.is_selectable and ((poe2_api.point_distance(i.grid_x,i.grid_y,player_info)>30 and not is_target) or poe2_api.point_distance(i.grid_x,i.grid_y,player_info)<30) and not player_info.isInBossBattle)
                        if condition4 then
                            -- poe2_api.dbgp(string.format("条件4匹配: 门 (距离:%.1f)", poe2_api.point_distance(i.grid_x,i.grid_y,player_info)))
                            currency = i
                            break
                        end
                        
                        local condition5 = (i.name_utf8 and i.name_utf8 ~= "" and i.name_utf8 == "聖潔神殿" and i.isActive and i.is_selectable and ((poe2_api.point_distance(i.grid_x,i.grid_y,player_info)>60 and not is_target) or poe2_api.point_distance(i.grid_x,i.grid_y,player_info)<60) and not player_info.isInBossBattle)
                        if condition5 then
                            -- poe2_api.dbgp(string.format("条件5匹配: 圣洁神殿 (距离:%.1f)", poe2_api.point_distance(i.grid_x,i.grid_y,player_info)))
                            currency = i
                            break
                        end
                        
                        local condition6 = (i.name_utf8 and i.name_utf8 ~= "" and i.name_utf8 == "把手" and i.isActive and i.is_selectable and next(i.stateMachineList) and (i.stateMachineList["lever_pull"] == 0 or i.stateMachineList["lever_pulled"] == 0) and ((poe2_api.point_distance(i.grid_x,i.grid_y,player_info)>30 and not is_target) or poe2_api.point_distance(i.grid_x,i.grid_y,player_info)<30) and not player_info.isInBossBattle)
                        if condition6 then
                            -- poe2_api.dbgp(string.format("条件6匹配: 把手 (距离:%.1f, 状态: pull=%s, pulled=%s)", 
                            --     poe2_api.point_distance(i.grid_x,i.grid_y,player_info),
                            --     tostring(i.stateMachineList["lever_pull"]),
                            --     tostring(i.stateMachineList["lever_pulled"])))
                            currency = i
                            break
                        end
                        
                        local condition7 = (i.name_utf8 and i.name_utf8 ~= "" and i.name_utf8 == "水閘門控制桿" and i.isActive and i.is_selectable and next(i.stateMachineList) and (i.stateMachineList["lever_pull"] == 0 or i.stateMachineList["lever_pulled"] == 0) and not is_target and not player_info.isInBossBattle)
                        if condition7 then
                            -- poe2_api.dbgp("条件7匹配: 水闸门控制杆 (状态: pull="..tostring(i.stateMachineList["lever_pull"])..", pulled="..tostring(i.stateMachineList["lever_pulled"])..")")
                            currency = i
                            break
                        end
                        
                        local condition8 = (i.name_utf8 and i.name_utf8 ~= "" and i.name_utf8 == "開關" and i.isActive and i.is_selectable and not is_target)
                        if condition8 then
                            -- poe2_api.dbgp("条件8匹配: 开关")
                            currency = i
                            break
                        end
                        
                        local condition9 = (i.name_utf8 and i.name_utf8 ~= "" and poe2_api.table_contains(i.name_utf8,my_game_info.Treasure_Chest) and (i.name_utf8 ~= "保險箱" or not string.find(i.path_name_utf8,"Metadata/Chests/StrongBoxes/BasicStrongbox")) and (poe2_api.table_contains(i.name_utf8,{"裂痕君王的抑制之手","抑制之手"}) or i.rarity >= env.obj_color ) and not i.chestIsOpen and not is_target and not player_info.isInBossBattle)
                        if condition9 then
                            -- poe2_api.dbgp("条件9匹配: 宝箱 (名称:"..i.name_utf8..", 稀有度:"..(i.rarity or "无")..", 颜色阈值:"..(env.obj_color or "无")..")")
                            currency = i
                            break
                        end
                        
                        local condition10 = (i.name_utf8 and i.name_utf8 ~= "" and i.name_utf8 == "符文之印" and i.isActive and i.is_selectable)
                        if condition10 then
                            -- poe2_api.dbgp("条件10匹配: 符文之印")
                            currency = i
                            break
                        end
                        
                        local condition11 = (not i.isActive and i.is_selectable and i.rarity ==3 and i.type==1 and i.life>0 and (((player_info.current_map_name_utf8 == "MapVaalFoundry" and -150 < player_info.world_z - i.world_z and player_info.world_z - i.world_z < 150) or (player_info.current_map_name_utf8 == "MapWetlands" and not is_monster({range_info=env.range_info,index = 0})) and is_bass) or not poe2_api.table_contains(player_info.current_map_name_utf8,{"MapVaalFoundry",'MapWetlands'})) and not is_target and not poe2_api.find_text({UI_info = env.UI_info, text="符文之印",min_x=0}) and not poe2_api.table_contains(i.name_utf8,{'芭芭拉的精魂','帕拉薩之魂'}) and ((not player_info.isInBossBattle and not is_elite_monster(current_map_info)) or player_info.isInBossBattle))
                        if condition11 then
                            -- poe2_api.dbgp("条件11匹配: 非活跃稀有怪物 (地图:"..(player_info.current_map_name_utf8 or "无")..", Z轴差:"..(player_info.world_z - (i.world_z or 0))..")")
                            currency = i
                            break
                        end
                        
                        local condition12 = (i.isActive and i.is_selectable and i.rarity ==3 and i.type==1 and i.life>0 and ((player_info.current_map_name_utf8 == "MapVaalFoundry" and is_bass) or player_info.current_map_name_utf8 ~= "MapVaalFoundry") and not is_target1 and not poe2_api.find_text({UI_info = env.UI_info,text="符文之印",min_x=0}) and not poe2_api.table_contains(i.name_utf8 ,{'芭芭拉的精魂','帕拉薩之魂'}))
                        if condition12 then
                            -- poe2_api.dbgp("条件12匹配: 活跃稀有怪物 (地图:"..(player_info.current_map_name_utf8 or "无")..")")
                            currency = i
                            break
                        end
                        
                        local condition13 = (i.name_utf8 and i.name_utf8 == "樓梯" and not is_click() and not is_target and not player_info.isInBossBattle)
                        if condition13 then
                            -- poe2_api.dbgp("条件13匹配: 楼梯")
                            currency = i
                            break
                        end
                        
                        local condition14 = (i.path_name_utf8 == "Metadata/MiscellaneousObjects/Monolith" and is_essence and not is_target and not player_info.isInBossBattle)
                        if condition14 then
                            -- poe2_api.dbgp("条件14匹配: 精髓")
                            currency = i
                            break
                        end
                        
                        local condition15 = (i.path_name_utf8 == "Metadata/Terrain/Gallows/Leagues/Delirium/Objects/DeliriumInitiator" and next(i.stateMachineList) and i.stateMachineList["interacted"] == 0 and not is_target and not player_info.isInBossBattle)
                        if condition15 then
                            -- poe2_api.dbgp("条件15匹配: 谵妄之镜 (交互状态:"..tostring(i.stateMachineList["interacted"])..")")
                            currency = i
                            break
                        end
                        
                        
                        local condition16 = (string.find(i.path_name_utf8,"Metadata/Monsters/LeagueDelirium/DoodadDaemons/DoodadDaemonShardPack") and next(i.stateMachineList) and i.stateMachineList["detonate"] == 0  and not player_info.isInBossBattle)
                        if condition16 then
                            -- poe2_api.dbgp("判断： ",not is_target)
                            -- api_Sleep(1000)
                            -- poe2_api.dbgp("条件16匹配: 谵妄破碎之镜")
                            currency = i
                            break
                        end
                        
                        local condition17 = (i.path_name_utf8 == "Metadata/MiscellaneousObjects/Breach/BreachObject" and not is_target and not player_info.isInBossBattle)
                        if condition17 then
                            -- poe2_api.dbgp("条件17匹配: 裂痕之手")
                            currency = i
                            break
                        end
                        
                        local condition18 = (i.path_name_utf8 == "Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable" and next(i.stateMachineList) and i.stateMachineList.current_state == 1 and i.stateMachineList.interaction_enabled == 1 and not is_target and not player_info.isInBossBattle and env.not_more_ritual)
                        if condition18 then
                            -- poe2_api.dbgp("条件18匹配: 祭坛 (状态:"..tostring(i.stateMachineList.current_state)..", 交互启用:"..tostring(i.stateMachineList.interaction_enabled)..")")
                            currency = i
                            break
                        end
                        
                        local condition19 = (string.find(i.path_name_utf8,"Metadata/Chests/StrongBoxes") and (i.name_utf8 ~= "研究者的保險箱" or (i.name_utf8 == "研究者的保險箱" and i.rarity ~=3)) and next(i.stateMachineList) and i.stateMachineList["started"] == 0 and i.stateMachineList["opened"] == 0 and not is_target and not player_info.isInBossBattle)
                        if condition19 then
                            -- poe2_api.dbgp("条件19匹配: 玩法保险箱 (名称:"..(i.name_utf8 or "无")..", 状态: started="..tostring(i.stateMachineList["started"])..", opened="..tostring(i.stateMachineList["opened"])..")")
                            currency = i
                            break
                        end
                        
                        local condition20 = (string.find(i.path_name_utf8,"Metadata/Chests/StrongBoxes") and i.name_utf8 == "研究者的保險箱" and i.rarity == 3 and next(i.stateMachineList) and ((i.stateMachineList["started"] == 0 and i.stateMachineList["opened"] == 0) or (i.stateMachineList["started"] == 1 and i.stateMachineList["opened"] == 0)) and not is_target and not player_info.isInBossBattle)
                        if condition20 then
                            -- poe2_api.dbgp("条件20匹配: 研究者保险箱 (稀有度:"..(i.rarity or "无")..", 状态: started="..tostring(i.stateMachineList["started"])..", opened="..tostring(i.stateMachineList["opened"])..")")
                            currency = i
                            break
                        end

                        -- local condition21 = (i.isActive and i.is_selectable and i.rarity ==2 and i.type==1 and i.life>0 and not poe2_api.table_contains(player_info.current_map_name_utf8,{"MapAugury","MapAugury_NoBoss"}))
                        -- if condition21 then
                        --     -- poe2_api.dbgp("条件21匹配: 活跃稀有怪物 (地图:"..(player_info.current_map_name_utf8 or "无")..")")
                        --     currency = i
                        --     break
                        -- end

                        local condition22 = string.find(i.path_name_utf8,"Metadata/Chests/Abyss/Abyss") and i.is_selectable and (not next(i.stateMachineList) or (next(i.stateMachineList) and i.stateMachineList["unlocked"] == 1)) and not is_target and not player_info.isInBossBattle 
                        if condition22 then
                            -- poe2_api.dbgp("条件22匹配: 深淵寶箱")
                            currency = i
                            break
                        end
                        local condition23 = i.name_utf8 == "符文豐碑" and i.is_selectable and not is_target and not player_info.isInBossBattle 
                        if condition23 then
                            -- poe2_api.dbgp("条件23匹配: 符文豐碑")
                            currency = i
                            break
                        end

                        -- local condition24 = i.path_name_utf8 == "Metadata/MiscellaneousObjects/Abyss/AbyssCrack" and not i.MinimapIconActive and not is_target and not player_info.isInBossBattle 
                        -- if condition24 then
                        --     -- poe2_api.dbgp("条件24匹配: 深淵裂缝小点")
                        --     currency = i
                        --     break
                        -- end

                        local condition24 = next(i.stateMachineList) and i.stateMachineList["doomepk"] == 0 and i.life > 0 and i.type == 1 and not is_target and not player_info.isInBossBattle 
                        if condition24 then
                            -- poe2_api.dbgp("条件24匹配: 深淵裂缝怪物")
                            currency = i
                            break
                        end

                        local condition25 = i.path_name_utf8 == "Metadata/MiscellaneousObjects/Abyss/AbyssSubAreaTransition" and not is_target and not player_info.isInBossBattle and not env.is_abyss_complete 
                        if condition25 then
                            -- poe2_api.dbgp("条件25匹配: 深淵地圖")
                            currency = i
                            break
                        end

                        local condition26 = i.name_utf8 == "魔幻石陣" and i.is_selectable and not is_target 
                        if condition26 then
                            -- poe2_api.dbgp("条件26匹配: 魔幻石陣")
                            currency = i
                            break
                        end

                        local condition27 = i.path_name_utf8 == "Metadata/MiscellaneousObjects/Abyss/AbyssCrack" and not is_target and not player_info.isInBossBattle 
                        if condition27 then
                            -- poe2_api.dbgp("条件27匹配: 深淵裂缝小点")
                            currency = i
                            break
                        end
                        local condition28 = i.name_utf8 == "石棺" and i.is_selectable and not is_target and not player_info.isInBossBattle 
                        if condition28 then
                            -- poe2_api.dbgp("条件23匹配: 符文豐碑")
                            currency = i
                            break
                        end
                        -- local function get_Abyss_AbyssCrack()
                        --     for i, v in ipairs(env.range_info) do
                        --         if v.path_name_utf8 == "Metadata/MiscellaneousObjects/Abyss/AbyssCrack" and not v.MinimapIconActive then
                        --             return true
                        --         end
                        --     end
                        --     return false
                        -- end
                        -- local condition25 = i.path_name_utf8 == "Metadata/MiscellaneousObjects/Abyss/AbyssFinalNodeBase" and not i.MinimapIconActive and not is_target and not player_info.isInBossBattle and not get_Abyss_AbyssCrack()
                        -- if condition25 then
                        --     -- poe2_api.dbgp("条件24匹配: 深淵裂缝坑")
                        --     currency = i
                        --     break
                        -- end
                        -- local condition22 = (i.path_name_utf8 == "Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable" and next(i.stateMachineList) and i.stateMachineList.current_state == 0 and i.stateMachineList.interaction_enabled == 0 and not is_target and not player_info.isInBossBattle and env.not_more_ritual)
                        -- if condition22 then
                        --     -- poe2_api.dbgp("条件18匹配: 未激活祭坛 (状态:"..tostring(i.stateMachineList.current_state)..", 交互启用:"..tostring(i.stateMachineList.interaction_enabled)..")")
                        --     currency = i
                        --     break
                        -- end
                        
                        -- 检查是否有任何条件匹配
                        -- if condition1 or condition2 or condition3 or condition4 or condition5 or condition6 or condition7 or condition8 or condition9 or condition10 or
                        --    condition11 or condition12 or condition13 or condition14 or condition15 or condition16 or condition17 or condition18 or condition19 or condition20 then
                        --     currency = i
                        --     -- poe2_api.dbgp("对象匹配成功: "..(i.name_utf8 or "无名").." (ID:"..(i.id or "无ID").."), 类型:"..
                        --     --     (condition1 and "1" or "")..(condition2 and "2" or "")..(condition3 and "3" or "")..
                        --     --     (condition4 and "4" or "")..(condition5 and "5" or "")..(condition6 and "6" or "")..
                        --     --     (condition7 and "7" or "")..(condition8 and "8" or "")..(condition9 and "9" or "")..
                        --     --     (condition10 and "10" or "")..(condition11 and "11" or "")..(condition12 and "12" or "")..
                        --     --     (condition13 and "13" or "")..(condition14 and "14" or "")..(condition15 and "15" or "")..
                        --     --     (condition16 and "16" or "")..(condition17 and "17" or "")..(condition18 and "18" or "")..
                        --     --     (condition19 and "19" or "")..(condition20 and "20" or ""))
                        --     break
                        -- end
                    else
                        -- poe2_api.dbgp("对象未通过基础检查")
                    end
                    ::continue::
                end
                -- api_Sleep(1000000)
                if currency then
                    poe2_api.dbgp("最终选择对象: "..(currency.name_utf8 or "无名").." (ID:"..(currency.id or "无ID")..")")
                    env.interaction_object = currency
                    env.interactive = currency
                    return true
                else
                    poe2_api.dbgp("没有找到符合条件的对象")
                    return false
                end
            end
            local function get_range1(range_info)
                local range_sorted = poe2_api.get_sorted_list(env.range_info, env.player_info)
                for i, v in ipairs(range_sorted) do
                    local function get_boss_turret()
                        local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 443,min_y = 770,max_x = 639,max_y = 872})
                        for i, v in ipairs(lock) do
                            if v.name_utf8 == "quest_state_changed_button" then
                                return true
                            end
                        end
                        return false
                    end
                    local condition = v.name_utf8 == "砲塔" and player_info.isInBossBattle and get_boss_turret()
                    if condition then
                        -- poe2_api.dbgp("条件26匹配: Boss砲塔")
                        env.interaction_object = v
                        env.interactive = v
                        return true
                    end
                end
                return false
            end
            local interaction_object = env.interaction_object
            if not interaction_object then
                local interactive = get_range(env.range_info)
                local interactive1 = get_range1(env.range_info)
                if not interactive then
                    if not interactive1 then
                        env.interactive_id = nil
                        env.interactiontimeout = 0
                        poe2_api.dbgp("无需要交互的对象")
                        poe2_api.time_p("无需要交互的对象(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                        return bret.SUCCESS
                    end
                end
            end
            local interaction_object = env.interaction_object
            if string.find(player_info.current_map_name_utf8,"Abyss") and interaction_object.path_name_utf8 == "Metadata/MiscellaneousObjects/Abyss/AbyssSubAreaTransition" then
                env.interactiontimeout = 0
                env.interaction_object = nil
                env.interactive_id = nil
                poe2_api.time_p("人物在深渊地图清楚交互对象(RUNNING)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.RUNNING
            end
            if interaction_object then
                if poe2_api.table_contains(interaction_object.name_utf8,my_game_info.Treasure_Chest) then
                    local obj = nil
                    for _, v in ipairs(env.range_info) do
                        if poe2_api.table_contains(v.path_name_utf8,{"Metadata/MiscellaneousObjects/Monolith",'Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable'}) then -- and v.stateMachineList["current_state"] == 2 and v.stateMachineList["interaction_enabled"] == 0
                            local distance = poe2_api.point_distance(v.grid_x,v.grid_y,interaction_object)
                            if distance and distance <= 35 then
                                obj = v
                                break
                            end
                        end
                    end
                    if obj then
                        poe2_api.dbgp("交互对象为宝箱之类，并且在祭坛附近，不交互")
                        table.insert(env.interactive_permanent_id_list,interaction_object.id)
                        env.interaction_object = nil
                        poe2_api.time_p("判断是否需要交互（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                end
                local is_altar = env.afoot_altar
                if interaction_object.path_name_utf8 ~= "Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable"  then -- and is_altar
                    local target = nil
                    for _, v in ipairs(env.range_info) do
                        if v.path_name_utf8 == "Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable" then
                            if v.stateMachineList and next(v.stateMachineList) then
                                if (v.stateMachineList["current_state"] == 2 and v.stateMachineList["interaction_enabled"] == 0) then
                                    target = v
                                    
                                    break
                                end
                            end
                        end
                    end
                    if target then
                        local distance = poe2_api.point_distance(target.grid_x,target.grid_y,player_info)
                        if distance and distance < 105 then
                            local dis = poe2_api.point_distance(interaction_object.grid_x,interaction_object.grid_y,target)
                            if dis and dis > 97 or not poe2_api.table_contains(interaction_object.name_utf8,{"門","開關","把手","聖潔神殿","石棺"}) then
                                poe2_api.dbgp("人物在祭坛内，物品在祭坛外不交互")
                                env.interactiontimeout = 0
                                env.interaction_object = nil
                                env.interactive_id = nil
                                poe2_api.time_p("人物在祭坛内(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                                return bret.SUCCESS
                            end
                        else
                            if not poe2_api.table_contains(interaction_object.name_utf8,{"門","開關","把手","聖潔神殿","砲塔","石棺"}) then
                                env.interactiontimeout = 0
                                env.interaction_object = nil
                                env.interactive_id = nil
                                poe2_api.dbgp("人物在祭坛外，交互对象不是門，開關，把手，聖潔神殿，不交互")
                                poe2_api.time_p("人物在祭坛外，交互对象不是門，開關，把手，聖潔神殿，不交互(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                                return bret.SUCCESS
                            end
                        end
                    end
                    -- local distance = poe2_api.point_distance(is_altar.grid_x,is_altar.grid_y,player_info)
                    
                end
                if not env.interactive_id then
                    env.interactive_id = interaction_object.id
                    env.interactiontimeout = api_GetTickCount64()
                end
                if env.interactive_id ~= interaction_object.id then
                    env.interactive_id = interaction_object.id
                    env.interactiontimeout = api_GetTickCount64()
                end
                if interaction_object.is_selectable and interaction_object.rarity ==3 and interaction_object.type==1 and interaction_object.life>0 then
                    if is_target1 then
                        env.interactiontimeout = 0
                        env.interaction_object = nil
                        env.interactive_id = nil
                        env.interactive_timeout = nil
                        poe2_api.dbgp("交互对象为boss,但自身附近有怪，不交互")
                        poe2_api.time_p("交互对象为boss,但自身附近有怪，不交互(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                        return bret.SUCCESS
                    end
                else
                    if not poe2_api.table_contains(interaction_object.name_utf8,{"門","聖潔神殿"}) or (interaction_object.name_utf8 == "門" and poe2_api.point_distance(interaction_object.grid_x,interaction_object.grid_y,player_info)>30) or (interaction_object.name_utf8 == "聖潔神殿" and poe2_api.point_distance(interaction_object.grid_x,interaction_object.grid_y,player_info)>60) then
                        if is_target and interaction_object.name_utf8 ~= "砲塔" then
                            env.interactiontimeout = 0
                            env.interaction_object = nil
                            env.interactive_id = nil
                            env.interactive_timeout = nil
                            poe2_api.dbgp("交互对象为门或聖潔神殿，但自身附近有怪，不交互")
                            poe2_api.time_p("交互对象为boss,但自身附近有怪，不交互(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                            return bret.SUCCESS
                        end
                    end
                end
                if self.wait then
                    if api_GetTickCount64() - self.current_time < self.wait_time then
                        poe2_api.dbgp("等待中")
                        poe2_api.time_p("判断是否需要交互（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    self.wait = false
                end
                local interaction_object = env.interaction_object
                if env.not_match_id then
                    if env.not_match_id == interaction_object.id then
                        env.interactive = nil
                        env.interaction_object = nil
                        env.interactiontimeout = 0
                        poe2_api.time_p("isNeeee(SUCCESS111)... 耗时 --> ", api_GetTickCount64() - current_time)
                        return bret.SUCCESS
                    end
                end
                if interaction_object.isActive and interaction_object.is_selectable and interaction_object.rarity ==3 and interaction_object.type==1 and interaction_object.life>0 then
                    local distance = poe2_api.point_distance(interaction_object.grid_x,interaction_object.grid_y,player_info)
                    if distance and distance <= 50 then
                        env.interaction_object = nil
                        env.interactiontimeout = 0
                        env.interactive_id = nil
                        env.interactive_timeout = nil
                        poe2_api.dbgp("在已激活boss附近，不交互")
                        poe2_api.time_p("在已激活boss附近，不交互(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                        return bret.SUCCESS
                    end
                elseif poe2_api.table_contains(interaction_object.name_utf8,{"競技場","水閘門控制桿","把手","石陣祭壇"}) and poe2_api.find_text({UI_info = env.UI_info,text="地圖完成"}) then
                    env.interaction_object = nil
                    env.interactiontimeout = 0
                    env.interactive_id = nil
                    
                    poe2_api.dbgp("交互对象竞技场，水閘門控制桿，把手，石陣祭壇附近，地圖完成不交互")
                    poe2_api.time_p("交互对象竞技场(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                elseif interaction_object.name_utf8 == "競技場" and player_info.isInBossBattle then
                    env.interaction_object = nil
                    env.interactiontimeout = 0
                    env.interactive_id = nil
                    poe2_api.dbgp("交互对象竞技场,boss战，或者已在竞技场，不交互")
                    poe2_api.time_p("交互对象竞技场,boss战(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                elseif interaction_object.name_utf8 == "樓梯" then
                    if env.is_find_boss then
                        local click_lt = nil
                        for _, v in ipairs(env.range_info) do
                            if v.name_utf8 ~= "" and v.name_utf8 == "記錄點" and v.grid_x and v.grid_y and v.grid_x ~= 0 and v.grid_y ~= 0 then
                                click_lt = v
                                break
                            end
                        end
                        if interaction_object.id ~= self.not_id and not click_lt then
                            env.not_interactive = interaction_object
                            env.is_find_boss = false
                            poe2_api.time_p("判断是否需要交互（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end
                    if env.not_interactive then
                        if env.not_interactive.id == interaction_object.id then
                            env.interactive = nil
                            env.end_point = {}
                            env.interactiontimeout = 0
                            env.interaction_object = nil
                            env.interactive_id = nil
                            poe2_api.time_p("交互对象(樓梯)(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                            return bret.SUCCESS
                        end
                    end
                    -- Boss记录点
                    local boss_jdl = nil
                    for _, v in ipairs(env.range_info) do
                        if string.find(v.path_name_utf8,"Boss") and v.name_utf8 == "記錄點" then
                            local distance = poe2_api.point_distance(v.grid_x,v.grid_y,interaction_object)
                            if distance and distance <= 100 then
                                boss_jdl = v
                                break
                            end
                        end
                    end
                    if boss_jdl then
                        self.not_id = interaction_object.id
                        env.is_find_boss = true
                    end
                end
                if not poe2_api.table_contains(interaction_object.name_utf8,{"水閘門控制桿","把手"}) then
                    env.wait_target = false
                end
                local distance = poe2_api.point_distance(interaction_object.grid_x,interaction_object.grid_y,player_info)
                if distance and distance < 25 then
                    if interaction_object.path_name_utf8 == "Metadata/Terrain/Leagues/Ritual/RitualRuneLight" or interaction_object.rarity == 3 then
                        local index = math.random(100,200)
                        api_Sleep(index)
                    end
                    if self.number >= 30 then
                        poe2_api.dbgp1("超出次数，随机移动======================================================================")
                        local point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 40)
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), poe2_api.toInt(player_info.world_z - 70), 0)
                            poe2_api.click_keyboard("space")
                            self.number = 0
                            poe2_api.time_p("判断是否需要交互（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end
                    
                    if not player_info.isMoving then
                        poe2_api.dbgp1(self.number)
                        if not self.id1 then
                            self.id1 = interaction_object.id
                            env.interactive_timeout = api_GetTickCount64()
                        else
                            if self.id1 == interaction_object.id then
                                self.number = self.number + 1
                                if not env.interactive_timeout then
                                    env.interactive_timeout = api_GetTickCount64()
                                end
                            else
                                self.number = 0
                                self.id1 = interaction_object.id
                                env.interactive_timeout = api_GetTickCount64()
                            end
                        end
                    end
                    if env.interactive_timeout and api_GetTickCount64() - env.interactive_timeout > 60000 then
                        if (interaction_object.type == 1 and poe2_api.table_contains(interaction_object.rarity,{2,3})) then
                            for _, i in ipairs(env.range_info) do
                                if i.name_utf8 ~= "" and i.type == 5 and poe2_api.table_contains(i.name_utf8,my_game_info.hideout_CH) then
                                    local dis = poe2_api.point_distance(i.grid_x, i.grid_y, player_info)
                                    if dis and dis < 25 then
                                        poe2_api.find_text({text = i.name_utf8,UI_info = env.UI_info,min_x=0,min_y=200,click=2})
                                        api_Sleep(200)
                                        env.is_map_complete = true
                                        poe2_api.time_p("判断是否需要交互（RUNNING8）... 耗时 --> ", api_GetTickCount64() - start_time)
                                        -- env.need_item = nil
                                        return bret.RUNNING
                                    end
                                end
                            end  
                            api_ClickMove(poe2_api.toInt(player_info.grid_x),poe2_api.toInt(player_info.grid_y),poe2_api.toInt(player_info.world_z),7)
                            api_Sleep(300) 
                            -- 先设置随机种子（只需执行一次）
                            math.randomseed(os.time())
                            -- 生成 [0, 25) 范围内的随机浮点数
                            local x = 0 + (25 - 0) * math.random()
                            -- 生成 [0, 25) 范围内的随机浮点数
                            local y = 0 + (25 - 0) * math.random()
                            api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),1)
                            self.wait = true
                            self.current_time = api_GetTickCount64()
                            self.wait_time = 1000
                            poe2_api.dbgp("等待回城")
                            poe2_api.time_p("判断是否需要交互（RUNNING9）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                        -- env.is_map_complete = true
                        -- env.need_ReturnToTown = true
                        -- table.insert(env.not_interactive_object_list,interaction_object)
                        -- env.interactiontimeout = 0
                        -- env.interaction_object = nil
                        -- env.interactive_id = nil
                        -- env.not_interactive_id_list 
                        -- env.interactive_timeout = nil
                        
                    end
                elseif distance < 45 then
                    if interaction_object.path_name_utf8 == "Metadata/Terrain/Leagues/Ritual/RitualRuneLight" or (interaction_object.rarity == 3 and interaction_object.type==1 and not interaction_object.isActive) then
                        local index = math.random(100,200)
                        api_Sleep(index)
                    end
                elseif interaction_object.type==1 and interaction_object.rarity == 3 and interaction_object.isActive and distance < 70 then
                    env.interactiontimeout = 0
                    env.interaction_object = nil
                    env.interactive_id = nil
                    env.interactive_timeout = nil
                    poe2_api.dbgp("已在已激活boss附近，不交互")
                    poe2_api.time_p("交互对象(已激活boss)(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                    return bret.SUCCESS

                -- elseif interaction_object.path_name_utf8 == "Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable" and interaction_object.stateMachineList["current_state"] == 0 and interaction_object.stateMachineList["interaction_enabled"] == 0 and distance < 110 then
                --     env.interactiontimeout = 0
                --     env.interaction_object = nil
                --     env.interactive_id = nil
                --     poe2_api.dbgp("已在未激活祭坛附近，不交互")
                --     poe2_api.time_p("交互对象(未激活祭坛)(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                --     return bret.SUCCESS
                end
                if string.find(interaction_object.path_name_utf8,"Metadata/Chests/StrongBoxes") and interaction_object.name_utf8 == "研究者的保險箱" and interaction_object.rarity == 3 then
                    -- local stateMachineList = interaction_object:GetStateMachineList()
                    if interaction_object.stateMachineList and next(interaction_object.stateMachineList) then
                        if interaction_object.stateMachineList["started"] == 0 and interaction_object.stateMachineList["opened"] == 0 then 
                            if next(interaction_object.magicProperties) then
                                local gold = 0
                                local pattern = "消耗%s*(%d+)%s*金幣開啟"  -- Lua 匹配模式
                                poe2_api.dbgp("人物金币："..player_info.gold)
                                for _, v in ipairs(interaction_object.magicProperties) do
                                    if v:match(pattern) then
                                        gold = v:match(pattern)
                                        -- poe2_api.dbgp(gold)
                                        -- api_Sleep(100000000)
                                    end
                                end
                                if gold ~= 0 then
                                    local mini = poe2_api.toInt(gold)
                                    if player_info.gold == 0 or mini / player_info.gold > 0.2 then
                                        env.not_match_id = interaction_object.id
                                        env.interaction_object = nil
                                        env.interactiontimeout = 0
                                        env.interactive_id = nil
                                        poe2_api.time_p("判断是否需要交互（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                                        return bret.SUCCESS
                                    end
                                end
                            end
                            
                        end

                    end
                end
                local crrut_time = api_GetTickCount64()
                local interactiontimeout = env.interactiontimeout
                if crrut_time - interactiontimeout > 30000 then
                    table.insert(env.interactive_id_list, interaction_object.id)
                    env.interaction_object = nil
                    env.interactive_replytime = api_GetTickCount64()
                    poe2_api.time_p("判断是否需要交互（RUNNING10）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                env.interactive = interaction_object
                poe2_api.dbgp("交互对象: "..interaction_object.name_utf8.."路径名： "..interaction_object.path_name_utf8)
                poe2_api.printTable(interaction_object)
                poe2_api.time_p("判断是否需要交互（FAIL2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            env.wait_target = false
            env.interactiontimeout = 0
            env.interactive_id = nil
            poe2_api.time_p("交互对象(return bret.SUCCESS)(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
            return bret.SUCCESS
        end
    },
    -- 是否有未激活/黑雾祭坛
    Has_Black_Mist_Altar = {
        run = function(self, env)
            poe2_api.print_log("是否有未激活/黑雾祭坛...")
            local start_time = api_GetTickCount64()
            local player_info = env.player_info
            -- local range_info = env.range_info
            if not next(player_info) then
                poe2_api.dbgp("[Has_Black_Mist_Altar] 错误：玩家信息为空")
                poe2_api.time_p("是否有未激活/黑雾祭坛（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if not env.range_info  or not next(env.range_info)  then
                poe2_api.dbgp("[Has_Black_Mist_Altar] 错误：周围对象信息为空")
                poe2_api.time_p("是否有未激活/黑雾祭坛（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            
            -- 判断祭坛  
            -- index  1 未激活|黑雾  0 黑雾  2 比对周围祭坛有无记录的祭坛 
            local function get_altar(range_info,index,afoot_altar)
                -- local altar_target = {}
                for _, v in ipairs(range_info) do
                    if v.path_name_utf8 == "Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable" then
                        -- local stateMachineList = v:GetStateMachineList()
                        if v.stateMachineList and next(v.stateMachineList) then
                            if index == 1 then
                                if (v.stateMachineList["current_state"] == 2 and v.stateMachineList["interaction_enabled"] == 0)
                                 or (v.stateMachineList["current_state"] == 0 and v.stateMachineList["interaction_enabled"] == 0) then
                                    -- table.insert(altar_target, {
                                    --     obj = v,                    -- userdata
                                    --     stateMachineList = stateMachineList  -- 关联的 table
                                    -- })
                                    -- v["stateMachineList"] = stateMachineList
                                    -- altar_target = v
                                    return v
                                end
                            elseif index == 0 then
                                if (v.stateMachineList["current_state"] == 2 and v.stateMachineList["interaction_enabled"] == 0) then
                                    -- table.insert(altar_target, {
                                    --     obj = v,                    -- userdata
                                    --     stateMachineList = stateMachineList  -- 关联的 table
                                    -- })
                                    return v
                                end
                            elseif index == 2 then
                                if v.id == afoot_altar.id then
                                    if (v.stateMachineList["current_state"] == 2 and v.stateMachineList["interaction_enabled"] == 0)
                                    or (v.stateMachineList["current_state"] == 0 and v.stateMachineList["interaction_enabled"] == 0) then
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end
                return false
            end
            local current_map_info = env.current_map_info
            
            -- 判断小地图上有无祭坛图标显示
            local function get_mini_altar(mini_map_info)
                for _, v in ipairs(mini_map_info) do
                    if poe2_api.table_contains(v.name_utf8,{'RitualRune','RitualRuneFinished'}) then
                        return true
                    end
                end
                return false
            end

            -- 判断怪物
            local function is_monster(macth_data)
                local range_info = macth_data.range_info
                local mate = macth_data.mate
                local distance = macth_data.distance
                local objter = macth_data.objter or nil
                for _, v in ipairs(range_info) do
                    if v.type == 1 and not v.is_friendly and v.life > 0
                     and not poe2_api.table_contains(v.name_utf8,my_game_info.not_attact_mons_CN_name)
                     and v.isActive and not string.find(v.name_utf8,"神殿") and v.hasLineOfSight and v.is_selectable then
                        local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                        if dis and dis < distance then
                            if objter then
                                local dis = poe2_api.point_distance(v.grid_x, v.grid_y,objter)
                                if dis and dis > 99 then
                                    return true
                                end
                            else
                                return true
                            end 
                        end
                    end
                end
                return false
            end
            
            
            if not env.not_more_ritual and not get_altar(env.range_info,0) then 
                poe2_api.dbgp("已无祭坛物品可买，不再主动打祭坛")
                env.afoot_altar = nil
                env.center_radius = 0
                env.center_point = {}
                env.prestore_list = {}
                poe2_api.time_p("是否有未激活/黑雾祭坛（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            local is_altar = nil
            if not env.afoot_altar then
                is_altar = get_altar(env.range_info,1)
            else
                is_altar = env.afoot_altar
            end
            if not is_altar then
                env.center_radius = 0
                env.center_point = {}
                poe2_api.dbgp("未找到祭坛")
                poe2_api.time_p("是否有未激活/黑雾祭坛（FAIL2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            else
                if player_info.isInBossBattle then
                    env.center_radius = 0
                    env.center_point = {}
                    env.prestore_list = {}
                    poe2_api.dbgp("Boss战，不再主动打祭坛")
                    poe2_api.time_p("是否有未激活/黑雾祭坛（FAIL3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                end
                if not get_mini_altar(current_map_info) then
                    poe2_api.dbgp("地图改变，已无祭坛")
                    env.center_radius = 0
                    env.center_point = {}
                    env.prestore_list = {}
                    env.afoot_altar = nil
                    poe2_api.time_p("是否有未激活/黑雾祭坛（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local get_altar_ongoing = get_altar(env.range_info,0)
                
                if get_altar_ongoing then
                    local distance = poe2_api.point_distance(get_altar_ongoing.grid_x, get_altar_ongoing.grid_y, player_info)
                    if distance and distance < 102 then
                        is_altar = get_altar_ongoing
                    end
                end
                if env.afoot_altar then
                    local distance = poe2_api.point_distance(env.afoot_altar.grid_x, env.afoot_altar.grid_y, player_info)
                    if distance and distance < 120 then 
                        if not get_altar(env.range_info,2,env.afoot_altar) then
                            poe2_api.dbgp("该祭坛已打完，更新数据")
                            api_RestoreOriginalMap()
                            api_UpdateMapObstacles(100)
                            env.center_radius = 0
                            env.center_point = {}
                            env.prestore_list = {}
                            env.afoot_altar = nil
                            poe2_api.time_p("是否有未激活/黑雾祭坛（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end
                end
                local distance = poe2_api.point_distance(is_altar.grid_x, is_altar.grid_y, player_info)
                if distance then
                    poe2_api.dbgp("人物与祭坛的距离： "..distance)
                end
                if distance > 105 and is_monster({range_info=env.range_info,mate=player_info,distance=60,objter=is_altar}) then
                    env.center_radius = 0
                    env.center_point = {}
                    env.prestore_list = {}
                    poe2_api.time_p("是否有未激活/黑雾祭坛（FAIL4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                end
                if distance < 100 then
                    api_UpdateMapObstacles(150)
                end
                env.afoot_altar = is_altar
                poe2_api.time_p("是否有未激活/黑雾祭坛（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
        end
    },

    -- 是否需要移动祭坛
    Is_Move_Altar = {
        run = function(self, env)
            poe2_api.print_log("是否需要移动祭坛...")
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.object1 = nil
                self.time = 0
                self.break_object_list = {}
                self.target = nil
                self.target1 = nil
                self.target2 = nil
                self.bool = true
            end
            local player_info = env.player_info
            local afoot_altar = env.afoot_altar
            -- local range_info = env.range_info
            local current_map_info = env.current_map_info
            local path_list = env.path_list
            -- 判断路径
            local function is_point(grid_x,grid_y)
                local point = api_FindNearestReachablePoint(math.floor(grid_x),math.floor(grid_y),15,0)
                local ralet = api_FindPath(player_info.grid_x,player_info.grid_y,math.floor(point.x),math.floor(point.y))
                return ralet
            end
            -- 判断怪物
            local function is_monster(macth_data)
                local index = macth_data.index or 0
                local range_info = nil
                local mate = macth_data.mate
                local distance = macth_data.distance
                if index == 0 then
                    range_info = macth_data.range_info
                else
                    range_info = poe2_api.get_sorted_list(env.range_info,mate)
                end
                -- poe2_api.dbgp("怪物列表: "..#range_info)
                -- poe2_api.dbgp("index: "..index)
                local target_list = {}
                local cutt1 = api_GetTickCount64()
                for _, v in ipairs(range_info) do
                    if v.type == 1 and not v.is_friendly and v.life > 0
                     and not poe2_api.table_contains(v.name_utf8,my_game_info.not_attact_mons_CN_name)
                     and not string.find(v.name_utf8,"神殿") then
                        if index == 0 then
                            
                            -- poe2_api.dbgp("怪物: "..v.name_utf8)
                            -- poe2_api.dbgp("可视: "..tostring(v.hasLineOfSight))
                            -- poe2_api.dbgp("激活: "..tostring(v.isActive))
                            -- poe2_api.dbgp("========================================")
                            -- poe2_api.dbgp("距离: "..dis)
                            if v.hasLineOfSight and v.isActive then
                                poe2_api.dbgp("有视野")
                                poe2_api.dbgp("怪物: ",v.name_utf8)
                                
                                local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                                
                                poe2_api.dbgp("距离: "..dis)
                                if dis and dis < distance then
                                    local is_path = is_point(v.grid_x, v.grid_y)
                                    if is_path and next(is_path) then
                                        poe2_api.time_p("算距离耗时1... 耗时 --> ", api_GetTickCount64() - cutt1)
                                        return v
                                    end
                                end
                            end
                        elseif index == 1 then
                            poe2_api.time_p("算距离耗时... 耗时 --> ", 22222222222222)
                            if (not v.hasLineOfSight or not v.isActive) and (not poe2_api.table_contains(v.name_utf8,{"赤陶士兵","石兵","鮮明水母"}) and not string.find(v.path_name_utf8,"Metadata/Monsters/TormentedSpirits/TormentedSpiritofthe")) then
                                poe2_api.dbgp("无视野，或者未激活")
                                local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                                poe2_api.dbgp("距离: "..dis)
                                if dis and dis < distance then
                                    if not self.break_object_list or not next(self.break_object_list) then
                                        local is_path = is_point(v.grid_x, v.grid_y)
                                        if is_path and next(is_path) then
                                        -- if is_point(v.grid_x, v.grid_y) then
                                            return v
                                        end
                                    else
                                        if not poe2_api.table_contains(self.break_object_list,v.id) then
                                            local is_path = is_point(v.grid_x, v.grid_y)
                                            if is_path and next(is_path) then
                                            -- if is_point(v.grid_x, v.grid_y) then
                                                return v
                                            end
                                        end
                                    end 
                                end
                            end
                        elseif index == 2 then
                            if v.hasLineOfSight and v.isActive then
                                poe2_api.dbgp("有视野")
                                poe2_api.dbgp("怪物: ",v.name_utf8)
                                
                                local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                                
                                poe2_api.dbgp("距离: "..dis)
                                if dis and dis < distance then
                                    -- if is_point(v.grid_x, v.grid_y) then
                                    poe2_api.time_p("算距离耗时1... 耗时 --> ", api_GetTickCount64() - cutt1)
                                    table.insert(target_list,v)
                                        -- return v
                                    -- end
                                end
                            end
                        -- else
                        --     if v.hasLineOfSight and v.isActive then
                        --         poe2_api.dbgp("有视野")
                        --         poe2_api.dbgp("怪物: ",v.name_utf8)
                                
                        --         local dis = poe2_api.point_distance(v.grid_x, v.grid_y,player_info)
                        --         local distance1 = 50
                        --         if distance1 > env.min_attack_dis then
                        --             distance1 = env.min_attack_dis  
                        --         end
                        --         poe2_api.dbgp("距离: "..dis)
                        --         if dis and dis < distance1 then
                        --             if is_point(v.grid_x, v.grid_y) then
                        --                 poe2_api.time_p("算距离耗时1... 耗时 --> ", api_GetTickCount64() - cutt1)
                        --                 return v
                        --                 -- return v
                        --             end
                        --         end
                        --     end
                        end
                    end
                end
                poe2_api.time_p("算距离耗时2... 耗时 --> ", api_GetTickCount64() - cutt1)
                if index == 2 then
                    if target_list and next(target_list) then
                        return target_list
                    end
                end
                return false
            end
            -- 判断精粹
            local function is_crystal(macth_data)
                local range_info = macth_data.range_info
                local mate = macth_data.mate
                local distance = macth_data.distance
                local current_map_info = macth_data.current_map_info
                local function get_mini_crystal()
                    for _, v in ipairs(current_map_info) do
                        if v.name_utf8 == 'Essence' then
                            return true
                        end
                    end
                    return false
                end
                for _,v in ipairs(range_info) do
                    if v.path_name_utf8 == "Metadata/MiscellaneousObjects/Monolith" and get_mini_crystal() then
                        local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                        if dis and dis < distance then
                            return v
                        end
                    end
                end
                return false
            end
            -- 判断怪物是否存在
            local function get_monster(range_info,mate,index)
                local index1 = index or 0
                for _,v in ipairs(range_info) do
                    if v.type == 1 and v.id == mate.id and v.life > 0 then
                        if index1 == 0 then
                            if v.hasLineOfSight and v.isActive then
                                return v
                            end
                        else
                            return v
                        end
                        
                    end
                end
                return false
            end
            local distance = poe2_api.point_distance(afoot_altar.grid_x, afoot_altar.grid_y, player_info)
            if distance then
                if distance > 100 then
                    if self.target then
                        if not get_monster(env.range_info,self.target) then
                            self.target = nil
                        end
                    end
                    if not self.target then
                        local is_target = is_monster({range_info=env.range_info,mate=afoot_altar,distance=105})
                        if not is_target then
                            if env.path_list and next(env.path_list) then
                                poe2_api.dbgp("祭坛已有路径，先完成原先路径")
                                return bret.SUCCESS
                            end
                            local point = api_FindNearestReachablePoint(afoot_altar.grid_x,afoot_altar.grid_y,50,0)
                            env.end_point = {point.x,point.y}
                            poe2_api.dbgp("人物在祭坛附近，移动到祭坛1")
                            poe2_api.time_p("是否需要移动祭坛（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        else
                            local distance = poe2_api.point_distance(is_target.grid_x, is_target.grid_y, player_info)
                            if distance and distance > env.min_attack_dis then
                                poe2_api.dbgp("怪物超出攻击距离，移动")
                                env.end_point = {is_target.grid_x,is_target.grid_y}
                                poe2_api.time_p("是否需要移动祭坛（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                                return bret.SUCCESS
                            end
                            env.center_radius = 105
                            env.center_point = {afoot_altar.grid_x,afoot_altar.grid_y}
                            poe2_api.dbgp("攻击附近的怪")
                            poe2_api.time_p("是否需要移动祭坛（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.FAIL
                        end
                    else
                        local distance = poe2_api.point_distance(is_target.grid_x, is_target.grid_y, player_info)
                        if distance and distance > env.min_attack_dis then
                            poe2_api.dbgp("怪物超出攻击距离，移动")
                            env.end_point = {is_target.grid_x,is_target.grid_y}
                            poe2_api.time_p("是否需要移动祭坛（SUCCESS8）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        end
                        env.center_radius = 105
                        env.center_point = {afoot_altar.grid_x,afoot_altar.grid_y}
                        poe2_api.dbgp("攻击附近的怪")
                        poe2_api.time_p("是否需要移动祭坛（FAIL4）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.FAIL
                    end
                    
                else
                    if afoot_altar.stateMachineList["current_state"] == 2 and afoot_altar.stateMachineList["interaction_enabled"] == 0 then
                        if env.target_point and next(env.target_point) then
                            local distance = poe2_api.point_distance(env.target_point[1],env.target_point[2],afoot_altar)
                            if distance and distance >= 99 then
                                env.target_point = {}
                                if env.path_list and next(env.path_list) then
                                    table.remove(env.path_list,1)
                                end
                                poe2_api.dbgp("人物在黑雾祭坛中，当前目标点在黑雾外，移除路径")
                                poe2_api.time_p("是否需要移动祭坛（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                                return bret.RUNNING
                            end
                        end
                    end
                    if self.target1 then
                        if not get_monster(env.range_info,self.target1) then
                            self.target1 = nil
                        end
                    end
                    if not self.target1 then
                        local cutt = api_GetTickCount64()
                        local target_list = is_monster({range_info=env.range_info,mate=afoot_altar,distance=105,index = 2})
                        if target_list and next(target_list) then
                            local target_sorted_list = poe2_api.get_sorted_list(target_list,player_info)
                            for _,v in ipairs(target_sorted_list) do
                                if is_point(v.grid_x, v.grid_y) then
                                    self.target1 = v
                                    break
                                end
                            end
                        else
                            self.target1 = nil
                        end
                        poe2_api.time_p("是否需要移动祭坛找怪物... 耗时 --> ", api_GetTickCount64() - cutt)
                    end
                    
                    -- api_Sleep(10000)
                    if not self.target1 then
                        poe2_api.dbgp("人物在黑雾祭坛中，没有激活的怪物")
                        local crystal = is_crystal({range_info =env.range_info,mate = afoot_altar,distance = 99,current_map_info = current_map_info})
                        if crystal then
                            poe2_api.dbgp("人物在黑雾祭坛中，没有激活的怪物，移动到精髓")
                            env.end_point = {crystal.grid_x,crystal.grid_y}
                            local dis = poe2_api.point_distance(crystal.grid_x, crystal.grid_y,player_info)
                            if dis and dis < 25 then
                                api_ClickMove(poe2_api.toInt(crystal.grid_x), poe2_api.toInt(crystal.grid_y), poe2_api.toInt(player_info.world_z), 1)
                                poe2_api.time_p("是否需要移动祭坛（FAIL2）... 耗时 --> ", api_GetTickCount64() - start_time)
                                return bret.FAIL
                            end
                            poe2_api.dbgp("人物在黑雾祭坛，移动到精髓")
                            poe2_api.time_p("是否需要移动祭坛（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        end
                        if self.target2 then
                            if not get_monster(env.range_info,self.target2,1) then
                                self.target2 = nil
                            end
                        end
                        if not self.target2 then
                            self.target2 = is_monster({range_info=env.range_info,mate=afoot_altar,distance=99,index = 1})
                        end
                        if self.target2 then
                            poe2_api.dbgp("人物在黑雾祭坛中，没有激活的怪物，移动到未激活附近怪")
                            poe2_api.printTable(self.target2)
                            if not self.object1 then
                                self.object1 = self.target2
                            end
                            if self.object1.id ~= self.target2.id then
                                self.object1 = self.target2
                                self.time = 0
                            else
                                if self.time == 0 then
                                    self.time = api_GetTickCount64()
                                end
                                if api_GetTickCount64() - self.time > 3000 then
                                    table.insert(self.break_object_list,self.target2.id)
                                    self.time = 0
                                end
                            end
                            env.end_point = {self.target2.grid_x,self.target2.grid_y}
                            local dis = poe2_api.point_distance(self.target2.grid_x,self.target2.grid_y,player_info)
                            if dis and dis < 25 then
                                api_ClickMove(poe2_api.toInt(self.target2.grid_x), poe2_api.toInt(self.target2.grid_y), poe2_api.toInt(player_info.world_z), 7)
                                poe2_api.time_p("是否需要移动祭坛（SUCCESS7）... 耗时 --> ", api_GetTickCount64() - start_time)
                                return bret.FAIL
                            end
                            poe2_api.dbgp("人物在黑雾祭坛，移动到未激活附近怪")
                            poe2_api.time_p("是否需要移动祭坛（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        else
                            if not env.prestore_list or not next(env.prestore_list) then
                                local result_list = api_GetCalculateCircleGridPoints(poe2_api.toInt(afoot_altar.grid_x),poe2_api.toInt(afoot_altar.grid_y),98,math.floor(10))
                                if result_list then
                                    env.prestore_list = result_list
                                    poe2_api.time_p("是否需要移动祭坛（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                                    return bret.RUNNING
                                else
                                    local point = api_FindRandomWalkablePosition(math.floor(afoot_altar.grid_x),math.floor(afoot_altar.grid_y),80)
                                    if point then
                                        env.end_point = {point.x,point.y}
                                    end
                                    poe2_api.dbgp("获取圆形范围内均匀分布的网格点失败,随机移动")
                                    poe2_api.time_p("是否需要移动祭坛（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                                    return bret.SUCCESS
                                end
                            else
                                local distance = poe2_api.point_distance(env.prestore_list[1].x,env.prestore_list[1].y,player_info)
                                if distance and distance < 15 then
                                    table.remove(env.prestore_list,1)
                                    poe2_api.time_p("是否需要移动祭坛（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                                    return bret.RUNNING
                                end
                                -- if not path_list or not next(path_list) then
                                --     local ralet = api_FindPath(player_info.grid_x,player_info.grid_y,env.prestore_list[1].x,env.prestore_list[1].y)
                                --     if not ralet then
                                --         table.remove(env.prestore_list,1)
                                --         local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),80)
                                --         api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), poe2_api.toInt(player_info.world_z), 7)
                                --         poe2_api.click_keyboard("space")
                                --         poe2_api.dbgp("人物在黑雾祭坛，计算到圆形范围内第一个点失败")
                                --         return bret.RUNNING
                                --     end
                                -- end
                                env.end_point = {env.prestore_list[1].x,env.prestore_list[1].y}
                                poe2_api.dbgp("人物在黑雾祭坛，移动到圆形范围内第一个点")
                                poe2_api.time_p("是否需要移动祭坛（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
                                return bret.SUCCESS
                            end
                        end
                    end
                    poe2_api.printTable(self.target1)
                    local distance = poe2_api.point_distance(self.target1.grid_x,self.target1.grid_y,player_info)
                    if distance and distance > 180 then

                        poe2_api.dbgp("怪物超出攻击距离，移动")
                        env.end_point = {self.target1.grid_x,self.target1.grid_y}
                        poe2_api.time_p("是否需要移动祭坛（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.SUCCESS
                    end
                    poe2_api.dbgp(distance)
                    self.break_object_list = {}
                    env.center_radius = 105
                    env.center_point = {afoot_altar.grid_x,afoot_altar.grid_y}
                    poe2_api.dbgp("人物在黑雾祭坛，攻击附近怪")
                    poe2_api.time_p("是否需要移动祭坛（FAIL3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL

                end
            end
            -- return bret.SUCCESS
        end
    },

    

    -- 判断地图钥匙是否需要强化
    Is_Map_Strengthened = {
        run = function(self, env)
            poe2_api.print_log("判断地图钥匙是否需要强化...")
            local start_time = api_GetTickCount64()
            local config1 = env.user_config
            if not self.bool then
                self.wait = false
                self.dq_time = 0
                self.bool = true
            end
            local player_info = env.player_info
            local current_map_info = env.current_map_info
            if not next(player_info) then
                poe2_api.dbgp("玩家信息不存在,地图钥匙强化")
                poe2_api.time_p("判断地图钥匙是否需要强化（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING 
            end
            
            local bag_info = env.bag_info
            local is_strengthened_map = env.is_strengthened_map
            local not_use_map = env.not_use_map
            local priority_map = env.priority_map
            -- 获取背包中不打词条的地图钥匙
            local function get_map_not_entry(map)
                -- 词条过滤
                local function match_item_suffixes(item_suffixes, config_suffixes)
                    if not item_suffixes or not next(item_suffixes) then
                        return false
                    end
                    if not config_suffixes or not next(config_suffixes) then
                        return false
                    end
                    for _, v in ipairs(item_suffixes) do
                        for _, v1 in ipairs(config_suffixes) do
                            if v.name_utf8 == v1 then
                                return true
                            end
                        end
                    end
                    return false
                end
                if map then
                    if map.color > 0 and not map.not_identified and match_item_suffixes(api_GetObjectSuffix(map.mods_obj),not_use_map) then
                        return true
                    end
                end
                return false
            end
            if env.one_other_map then
                poe2_api.dbgp("已开图，不强化")
                env.is_public_warehouse = true
                env.strengthened_map_obj = nil
                poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local max_map = poe2_api.select_best_map_key({inventory=bag_info,key_level_threshold=env.user_map,not_use_map = not_use_map,priority_map = priority_map})
            if not max_map then
                poe2_api.dbgp("没有最优地图，不强化地图钥匙")
                env.is_public_warehouse = true
                env.strengthened_map_obj = nil
                poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if max_map.not_identified then
                poe2_api.dbgp("最优地图，未鉴定不强化")
                env.is_public_warehouse = true
                env.strengthened_map_obj = nil
                poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS22）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local config = env.user_config["刷圖設置"]["地圖鑰匙"] or {}
            if not config and next(config) then
                poe2_api.dbgp("未配置地图钥匙，不强化")
                env.is_public_warehouse = true
                env.strengthened_map_obj = nil
                poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local max_map_config = nil
            for _, v in pairs(config) do
                if v["階級"] == poe2_api.extract_level(max_map.baseType_utf8) then
                    -- 先判断 v["使用通貨"] 是否存在且是表
                    if v["使用通貨"] and type(v["使用通貨"]) == "table" then
                        -- 再判断 ["是否開啟"] 是否存在
                        if v["使用通貨"]["是否開啟"] then
                            max_map_config = v["使用通貨"]
                        end
                    end
                end
            end
            if not max_map_config then
                poe2_api.dbgp("未配置最优地图的通貨或者为开启使用通货，不强化地图钥匙")
                env.is_public_warehouse = true
                env.strengthened_map_obj = nil
                poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if max_map.contaminated then
                poe2_api.dbgp("最优地图已污染，不强化地图钥匙")
                if not env.streng_map_flushed_switch then
                    env.is_public_warehouse = true
                    env.strengthened_map_obj = nil
                    poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
            end
            
            if not is_strengthened_map and not env.streng_map_flushed_switch then
                poe2_api.dbgp("不需要强化")
                env.is_public_warehouse = true
                env.strengthened_map_obj = nil
                poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if max_map.color == 2 and max_map_config["崇高石"] == 0 and max_map_config["瓦爾寶珠"] == 0 then
                poe2_api.dbgp("已达到强化需求不强化111")
                if not env.streng_map_flushed_switch then
                    env.is_public_warehouse = true
                    env.strengthened_map_obj = nil
                    poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS7）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
                
            end
            if max_map.fixedSuffixCount >= 6 and max_map_config["瓦爾寶珠"] == 0 then
                poe2_api.dbgp("已达到强化需求不强化2222")
                if not env.streng_map_flushed_switch then
                    env.is_public_warehouse = true
                    env.strengthened_map_obj = nil
                    poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS8）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
            end
            -- 蛻變
            local tb = max_map_config["蛻變石"]
            -- 增幅
            local zf = max_map_config["增幅石"]
            -- 富豪
            local fh = max_map_config["富豪石"]
            -- 點金
            local dj = max_map_config["點金石"]
            -- 崇高
            local cg = max_map_config["崇高石"]
            -- 瓦爾
            local wr = max_map_config["瓦爾寶珠"]
            local text = nil
            if max_map.color == 0 and dj ~= 0 and not max_map.contaminated and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,"點金石")) then
                text = "點金石"
            elseif max_map.color == 0 and tb ~= 0 and not max_map.contaminated and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,"蛻變石")) then
                text = "蛻變石"
            elseif max_map.color == 1 and zf ~= 0 and not max_map.contaminated and max_map.fixedSuffixCount < 2 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,"增幅石")) then
                text = "增幅石"
            elseif  max_map.color == 1 and fh ~= 0 and not max_map.contaminated and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,"富豪石")) then
                text = "富豪石"
            elseif max_map.color == 2 and cg ~= 0 and not max_map.contaminated and max_map.fixedSuffixCount < 6 and env.supreme_use_count < cg and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,"崇高石")) then
                text = "崇高石"
            elseif wr and not max_map.contaminated and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,"瓦爾寶珠")) then
                text = "瓦爾寶珠"
            else
                if not env.warehouse_type_interactive or env.warehouse_type_interactive == "公仓" then
                    if get_map_not_entry(max_map) then
                        env.is_public_warehouse = true
                        env.is_strengthened_map = true
                        env.supreme_use_count = 0
                        poe2_api.time_p("判断地图钥匙是否需要强化（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    env.is_public_warehouse = true
                end
                env.is_strengthened_map = false
                env.streng_map_flushed_switch = false
                poe2_api.time_p("判断地图钥匙是否需要强化（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            
            env.strengthened_map_obj = max_map
            
            if text then
                local items_info = poe2_api.get_items_config_info(config1)
                local is_text = nil
                for _,item in ipairs(items_info) do
                    if item["類型"] == "通貨" and item['存倉頁名'] and not item["不撿"] and poe2_api.table_contains(item['基礎類型名'],text) then
                        is_text = item
                        break
                    end
                end
                if is_text then
                    if is_text["工會倉庫"] then
                        env.warehouse_type_interactive = "公仓"
                        env.is_public_warehouse = false
                    else
                        env.warehouse_type_interactive = "个仓"
                    end
                else
                    local unique_storage_pages = nil
                    for _,item in ipairs(items_info) do
                        if item["類型"] == "通貨" and item['存倉頁名'] and not item["不撿"] and item['基礎類型名'] == "全部物品" and not item["工會倉庫"] then
                            unique_storage_pages = item
                            break
                        end
                    end
                    if unique_storage_pages then
                        env.warehouse_type_interactive = "个仓"
                    else
                        env.warehouse_type_interactive = "公仓"
                        env.is_public_warehouse = false
                    end
                end
            end
            poe2_api.time_p("判断地图钥匙是否需要强化（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end 
    },

    -- 强化地图钥匙找通货
    StrengthenMapKeyFindCurrency = {
        run = function(self, env)
            poe2_api.print_log("开始执行强化地图钥匙找通货...")
            local start_time = api_GetTickCount64()
            local not_use_map = env.not_use_map
            -- 获取背包中不打词条的地图钥匙
            local function get_map_not_entry(map)
                -- 词条过滤
                local function match_item_suffixes(item_suffixes, config_suffixes)
                    if not item_suffixes or not next(item_suffixes) then
                        return false
                    end
                    if not config_suffixes or not next(config_suffixes) then
                        return false
                    end
                    for _, v in ipairs(item_suffixes) do
                        for _, v1 in ipairs(config_suffixes) do
                            if v.name_utf8 == v1 then
                                return true
                            end
                        end
                    end
                    return false
                end
                if map then
                    if map.color > 0 and not map.not_identified and match_item_suffixes(api_GetObjectSuffix(map.mods_obj),not_use_map) then
                        return true
                    end
                end
                return false
            end
            if env.warehouse_type_interactive == "个仓" then
                -- text = "倉庫"
                if poe2_api.find_text({text = "強調物品",UI_info = env.UI_info,min_x = 250,min_y = 700}) 
                and poe2_api.find_text({text = "公會倉庫",UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=81}) then
                    -- poe2_api.click_keyboard("space")
                    poe2_api.find_text({UI_info = env.UI_info, text = "公會倉庫", min_x = 0, click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("强化地图钥匙找通货（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            elseif env.warehouse_type_interactive == "公仓" then

                -- text = "公會倉庫"
                if poe2_api.find_text({text = "強調物品",UI_info = env.UI_info,min_x = 250,min_y = 700}) 
                and poe2_api.find_text({text = "倉庫",UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=81}) then
                    -- poe2_api.click_keyboard("space")
                    poe2_api.find_text({UI_info = env.UI_info, text = "倉庫", min_x = 0, click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("强化地图钥匙找通货（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if get_map_not_entry(env.strengthened_map_obj) then
                    env.is_public_warehouse = true
                    env.is_strengthened_map = true
                    env.supreme_use_count = 0
                    poe2_api.time_p("强化地图钥匙找通货（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            else
                error("碑牌未知的仓库类型")
            end
            if not poe2_api.find_text({text = "強調物品",UI_info = env.UI_info,min_x = 250,min_y = 700})  then
            -- and poe2_api.find_text({text = text,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=81}) then
                poe2_api.time_p("强化地图钥匙找通货（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            -- 参数赋值
            local function data_assignment()
                if env.warehouse_type_interactive == "公仓" then
                    env.is_public_warehouse = true
                end
                env.streng_map_flushed_switch = false
                env.is_strengthened_map = false
            end
            poe2_api.print_log("强化地图钥匙找通货...")
            local strengthened_map_obj = env.strengthened_map_obj
            local config = env.user_config["刷圖設置"]["地圖鑰匙"]
            local max_map_config = nil
            for _, v in pairs(config) do
                if v["階級"] == poe2_api.extract_level(strengthened_map_obj.baseType_utf8) then
                    -- 先判断 v["使用通貨"] 是否存在且是表
                    if v["使用通貨"] and type(v["使用通貨"]) == "table" then
                        -- 再判断 ["是否開啟"] 是否存在
                        if v["使用通貨"]["是否開啟"] then
                            max_map_config = v["使用通貨"]
                        end
                    end
                end
            end
            -- 蛻變
            local tb = max_map_config["蛻變石"]
            -- 增幅
            local zf = max_map_config["增幅石"]
            -- 富豪
            local fh = max_map_config["富豪石"]
            -- 點金
            local dj = max_map_config["點金石"]
            -- 崇高
            local cg = max_map_config["崇高石"]
            -- 瓦爾
            local wr = max_map_config["瓦爾寶珠"]
            local item_name = ""
            if strengthened_map_obj.color == 0 then
                if dj ~= 0 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,"點金石")) then
                    item_name = "點金石"
                elseif tb ~= 0 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,"蛻變石")) then
                    item_name = "蛻變石"
                elseif wr ~= 0 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,"瓦爾寶珠")) then
                    item_name = "瓦爾寶珠"
                else
                    data_assignment()
                    poe2_api.time_p("强化地图钥匙找通货（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            elseif strengthened_map_obj.color == 1 then
                if zf ~= 0 and strengthened_map_obj.fixedSuffixCount < 2 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,"增幅石")) then
                    item_name = "增幅石"
                elseif fh == 0 and wr == 0 then
                    data_assignment()
                    poe2_api.time_p("强化地图钥匙找通货（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                elseif fh ~= 0 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,"富豪石")) then
                    item_name = "富豪石"
                elseif wr ~= 0 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,"瓦爾寶珠")) then
                    item_name = "瓦爾寶珠"
                else
                    data_assignment()
                    poe2_api.time_p("强化地图钥匙找通货（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            elseif strengthened_map_obj.color == 2 then
                if cg ~= 0 and strengthened_map_obj.fixedSuffixCount < 6 and env.supreme_use_count <cg and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,"崇高石")) then
                    item_name = "崇高石"
                elseif wr ~= 0 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,"瓦爾寶珠")) then
                    item_name = "瓦爾寶珠"
                else
                    data_assignment()
                    poe2_api.time_p("强化地图钥匙找通货（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            env.currency_name = item_name  
            poe2_api.time_p("强化地图钥匙找通货（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 判断是否强化碑牌
    Is_Update_Plaque = {
        run = function(self, env)
            poe2_api.print_log("判断是否强化碑牌...")
            local start_time = api_GetTickCount64()
            local is_insert_stone = env.is_insert_stone
            if not is_insert_stone then
                poe2_api.dbgp("未开启插碑，不判断")
                poe2_api.time_p("判断是否强化碑牌（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local player_info = env.player_info
            local bag_info = env.bag_info
            local current_map_info = env.current_map_info
            if not player_info or not next(player_info) then
                poe2_api.dbgp("玩家信息为空,判断强化碑牌")
                poe2_api.time_p("判断是否强化碑牌（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            -- 判断背包是否有需要强化的碑牌
            local function get_bag_plaque(bag_info)
                local function plaque_color(plaque_info)
                    for _, i in ipairs(plaque_info) do
                        if i.color == 0 or (i.color == 1 and i.fixedSuffixCount < 2) then
                            return i
                        end
                    end
                    return false
                end
                local plaque_index = {}
                for _, v in pairs(bag_info) do
                    if v.category_utf8 == "TowerAugmentation" then
                        table.insert(plaque_index,v)
                    end
                end
                if #plaque_index > 0 then
                    local plaque = plaque_color(plaque_index)
                    if plaque then
                        return plaque
                    end
                end
                return false
            end
            -- 判断有无地图装置
            local function is_map_device(obj_list)
                if not obj_list or #obj_list == 0 then
                    return false
                end
                for _, i in ipairs(obj_list) do
                    if i.name_utf8 == "MapDevice" then
                        return true
                    end
                end
                return false
            end
            local map_device = is_map_device(current_map_info)
            -- 不在城区
            if not string.match(player_info.current_map_name_utf8,"town") 
             and ( not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.hideout) or not map_device) then
                env.is_public_warehouse_plaque = true
                env.is_update_plaque = false
                poe2_api.dbgp("不在城区, 不强化碑牌")
                poe2_api.time_p("判断是否强化碑牌（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS      
            end
            if not bag_info or not next(bag_info) then
                poe2_api.dbgp("背包为空, 不强化碑牌")
                env.is_public_warehouse_plaque = true
                poe2_api.time_p("判断是否强化碑牌（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not env.is_have_stone then
                poe2_api.dbgp("没有可插的塔, 不强化碑牌")
                env.is_public_warehouse_plaque = true
                poe2_api.time_p("判断是否强化碑牌（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local plaque = get_bag_plaque(bag_info)
            if not plaque then
                poe2_api.dbgp("背包没有需要强化的碑牌, 不强化碑牌")
                env.is_public_warehouse_plaque = true
                poe2_api.time_p("判断是否强化碑牌（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not env.is_update_plaque then
                poe2_api.dbgp("不需要强化碑牌")
                env.is_public_warehouse_plaque = true
                poe2_api.time_p("判断是否强化碑牌（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local config = env.user_config
            local text = ""
            if plaque.color == 0 then
                text = "蛻變石"
            elseif plaque.color == 1 then
                text = "增幅石"
            end
            
            if text then
                local items_info = poe2_api.get_items_config_info(config)
                local is_text = nil
                for _,item in ipairs(items_info) do
                    if item["類型"] == "通貨" and item['存倉頁名'] and not item["不撿"] and poe2_api.table_contains(item['基礎類型名'],text) then
                        is_text = item
                        break
                    end
                end
                if is_text then
                    if is_text["工會倉庫"] then
                        env.warehouse_type_interactive = "公仓"
                        env.is_public_warehouse_plaque = false
                    else
                        env.warehouse_type_interactive = "个仓"
                    end
                else
                    local unique_storage_pages = nil
                    for _,item in ipairs(items_info) do
                        if item["類型"] == "通貨" and item['存倉頁名'] and not item["不撿"] and item['基礎類型名'] == "全部物品" and not item["工會倉庫"] then
                            unique_storage_pages = item
                            break
                        end
                    end
                    if unique_storage_pages then
                        env.warehouse_type_interactive = "个仓"
                    else
                        env.warehouse_type_interactive = "公仓"
                        env.is_public_warehouse_plaque = false
                    end
                end
            end
            env.currency_name = text
            env.strengthened_map_obj = plaque
            poe2_api.time_p("判断是否强化碑牌（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end
    },

    -- 判断是否需要强化地图钥匙（腐化圣域）
    Is_Update_Map_Key = {
        run = function(self, env)
            poe2_api.print_log("判断是否需要强化地图钥匙（腐化圣域）...")
            local start_time = api_GetTickCount64() -- 开始时间
            local the_update_map = env.the_update_map
            local is_insert_stone = env.is_insert_stone
            local entry_length_take_map = env.entry_length_take_map
            local map_update_to =env.map_update_to
            local user_map = env.user_map
            local map_up = env.map_up
            local priority_map = env.priority_map
            local not_have_stackableCurrency = env.not_have_stackableCurrency
            if the_update_map then
                local map_level = poe2_api.select_best_map_key({inventory = env.bag_info,key_level_threshold=user_map,priority_map = priority_map,vall = true})
                if map_level then
                    if (map_level.color > 0 and map_level.fixedSuffixCount >= map_update_to) or (next(env.lack_of_currency) and poe2_api.table_contains(env.lack_of_currency,"崇高石")) then
                        env.map_up = false
                        env.entry_length_take_map = false
                        env.the_update_map = nil
                    end
                end
            end
            local map_up = env.map_up
            if not map_up then
                env.not_have_stackableCurrency = false
                poe2_api.time_p("    Is_Update_Map_Key(SUCCESS1)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not entry_length_take_map then
                env.not_have_stackableCurrency = false
                poe2_api.time_p("    Is_Update_Map_Key(SUCCESS2)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not env.player_info or not next(env.player_info) then
                poe2_api.time_p("    Is_Update_Map_Key(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if not is_insert_stone then
                env.not_have_stackableCurrency = false
                poe2_api.time_p("    Is_Update_Map_Key(SUCCESS3)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not env.bag_info or not next(env.bag_info) then
                env.not_have_stackableCurrency = false
                env.entry_length_take_map = true
                poe2_api.time_p("    Is_Update_Map_Key(SUCCESS4)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not the_update_map then
                env.not_have_stackableCurrency = false
                env.entry_length_take_map = true
                poe2_api.time_p("    Is_Update_Map_Key(SUCCESS5)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not_have_stackableCurrency then
                poe2_api.time_p("    Is_Update_Map_Key(SUCCESS6)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local config = env.user_config
            local items_info = poe2_api.get_items_config_info(config)
            local is_text = nil
            for _,item in ipairs(items_info) do
                if item["類型"] == "通貨" and item['存倉頁名'] and not item["不撿"] and poe2_api.table_contains(item['基礎類型名'],"崇高石") then
                    is_text = item
                    break
                end
            end
            if is_text then
                if is_text["工會倉庫"] then
                    env.warehouse_type_interactive = "公仓"
                    -- env.is_public_warehouse_plaque = false
                else
                    env.warehouse_type_interactive = "个仓"
                end
            else
                local unique_storage_pages = nil
                for _,item in ipairs(items_info) do
                    if item["類型"] == "通貨" and item['存倉頁名'] and not item["不撿"] and item['基礎類型名'] == "全部物品" and not item["工會倉庫"] then
                        unique_storage_pages = item
                        break
                    end
                end
                if unique_storage_pages then
                    env.warehouse_type_interactive = "个仓"
                else
                    env.warehouse_type_interactive = "公仓"
                    -- env.is_public_warehouse_plaque = false
                end
            end
            env.currency_name = "崇高石"
            env.strengthened_map_obj = the_update_map
            poe2_api.time_p("    Is_Update_Map_Key(FAIL)... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end
    },

    -- 是否有激活的暗金保险箱
    Gameplay_Safe_Box = {
        run = function(self, env)
            poe2_api.print_log("访问游戏保险箱...")
            local start_time = api_GetTickCount64() -- 开始时间
            local player_info = env.player_info
            if not player_info or not next(player_info) then
                poe2_api.dbgp("访问游戏保险箱,玩家信息不存在")
                poe2_api.time_p("是否有激活的暗金保险箱（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if not env.range_info or not next(env.range_info) then
                poe2_api.dbgp("访问游戏保险箱,周围对象信息不存在")
                poe2_api.time_p("是否有激活的暗金保险箱（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if env.afoot_altar then
                poe2_api.time_p("是否有激活的暗金保险箱（FAIL3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            local current_map_info = env.current_map_info
            -- -- 判断有无地图装置
            -- local function is_map_device(obj_list)
            --     if not obj_list or #obj_list == 0 then
            --         return false
            --     end
            --     for _, i in ipairs(obj_list) do
            --         if i.name_utf8 == "MapDevice" then
            --             return true
            --         end
            --     end
            --     return false
            -- end
            -- local map_device = is_map_device(current_map_info)
            -- -- 在城区
            -- if  string.match(player_info.current_map_name_utf8,"town") 
            --  or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.hideout) and map_device) then
            --     env.afoot_box = nil
            --     poe2_api.dbgp("在城区, 无玩法保险箱")
            --     return bret.SUCCESS      
            -- end
            local function get_box()
                for _, v in ipairs(env.range_info) do
                    -- if v.name_utf8 ~= "" then
                    --     poe2_api.dbgp("v.name_utf8",v.name_utf8)
                    --     poe2_api.dbgp("v.type",v.type)
                    --     poe2_api.dbgp("v.rarity",v.rarity)
                    --     poe2_api.dbgp("v.started",v.stateMachineList["started"])
                    --     poe2_api.dbgp("v.opened",v.stateMachineList["opened"])
                    -- end
                    
                    if string.find(v.path_name_utf8,"Metadata/Chests/StrongBoxes") 
                    --  and v.type == -1
                     and poe2_api.table_contains(v.type,{-1,6})    
                     and v.rarity == 3
                     and v.stateMachineList["started"] == 1 
                     and v.stateMachineList["opened"] == 0 
                     and not poe2_api.table_contains(v.name_utf8,{"研究者的保險箱","護甲鍛造師的保險箱","保險箱"}) then
                        return v
                    end
                end
                return false
            end
            local is_box = get_box()
            if not is_box then
                poe2_api.dbgp("周围无激活玩法保险箱")
                env.center_radius = 0
                env.center_point = {}
                env.afoot_box = nil
                poe2_api.time_p("是否有激活的暗金保险箱（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            else
                -- 判断怪物
                local function is_monster(data)
                    local mate = data.mate
                    local distance = data.distance
                    if distance > env.min_attack_dis then
                        distance = env.min_attack_dis  
                    end
                    for _, v in ipairs(env.range_info) do
                        if v.type == 1 and not v.is_friendly and v.life > 0
                         and not poe2_api.table_contains(v.name_utf8,my_game_info.not_attact_mons_CN_name)
                         and v.isActive and not string.find(v.name_utf8,"神殿") and v.hasLineOfSight and v.is_selectable then
                            local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                            if dis and dis < distance then
                                return true
                            end 
                        end
                    end
                end
                local distance = poe2_api.point_distance(is_box.grid_x,is_box.grid_y,player_info)
                if distance > 100 and is_monster({mate = player_info,distance = 50}) then
                    env.center_radius = 0
                    env.center_point = {}
                    poe2_api.time_p("是否有激活的暗金保险箱（FAIL2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                end
                env.afoot_box = is_box
                poe2_api.time_p("是否有激活的暗金保险箱（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
        end
    },

    -- 是否需要移动玩法保险箱
    Is_Move_Safe_Box = {
        run = function(self, env)
            poe2_api.print_log("移动到玩法保险箱...")
            local start_time = api_GetTickCount64() -- 开始时间
            local afoot_box = env.afoot_box
            local player_info = env.player_info
            local distance = poe2_api.point_distance(afoot_box.grid_x,afoot_box.grid_y,player_info)
            if distance and distance > 100 then
                env.end_point = {afoot_box.grid_x,afoot_box.grid_y}
                poe2_api.time_p("是否需要移动玩法保险箱（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            else
                local function is_monster(mate,distance,index)
                    for _, v in ipairs(env.range_info) do
                        if v.type == 1 and not v.is_friendly and v.life > 0
                         and not poe2_api.table_contains(v.name_utf8,my_game_info.not_attact_mons_CN_name)
                         and not string.find(v.name_utf8,"神殿")  and v.is_selectable then
                            if index == 0 then
                                if v.isActive and v.hasLineOfSight then
                                    local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                                    if dis and dis < distance then
                                        return v
                                    end 
                                end
                            else
                                if not v.isActive or not v.hasLineOfSight then
                                    local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                                    if dis and dis < distance then
                                        return v
                                    end 
                                end
                            end
                        end
                    end
                end
                local is_target = is_monster(player_info,100,0)
                if not is_target then
                    local target = is_monster(player_info,100,1)
                    if target then
                        env.end_point = {target.grid_x,target.grid_y}
                        poe2_api.time_p("是否需要移动玩法保险箱（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.SUCCESS
                    else
                        local point = api_FindRandomWalkablePosition(afoot_box.grid_x,afoot_box.grid_y, 100)
                        env.end_point = {point.x,point.y}
                        poe2_api.time_p("是否需要移动玩法保险箱（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.SUCCESS
                    end
                end
                env.center_radius = 100
                env.center_point = {afoot_box.grid_x,afoot_box.grid_y}
                poe2_api.time_p("是否需要移动玩法保险箱（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
        end
    },

    -- 检查是否到达点(别名)
    Is_Arrive = {
        run = function(self, env)
            poe2_api.print_log("检查是否到达目标点(Is_Arrive)...")
            poe2_api.dbgp("正在前往目标点...111111")
            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            local is_arrive_end_dis = 15 -- 默认值

            if player_info.life == 0 then
                env.end_point = nil
                env.run_point = nil
                env.path_list = nil
                env.is_arrive_end = false
                env.target_point = {}
                -- return bret.FAIL
                poe2_api.dbgp("正在前往目标点...111222")
                return bret.RUNNING
            end
            
            -- 检查空路径
            if env.empty_path then
                env.is_arrive_end = true
                env.empty_path = false
                -- return bret.SUCCESS
                poe2_api.dbgp("正在前往目标点...111111")
                return bret.RUNNING
            end
            
            -- 检查是否到达终点
            local point = env.end_point
            poe2_api.printTable(point)
            if point and #point > 0 then
                local path_list = env.path_list
                if path_list ~= nil and next(path_list) ~= nil and next(path_list) > 2 then
                    -- poe2_api.time_p("检查是否到达目标点(Is_Arrive)(SUCCESS2)... 耗时 --> ", api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                end
                dis = poe2_api.point_distance(point[1], point[2], player_info)
                if api_HasObstacleBetween(point[1], point[2]) and dis and ( dis < is_arrive_end_dis ) then
                    poe2_api.dbgp1("有路径，有射线")
                    env.is_arrive_end = true
                    env.end_point = nil
                    env.path_list = nil
                    env.run_point = nil
                    poe2_api.time_p("检查是否到达目标点(Is_Arrive)(RUNNING1)... 耗时 --> ", api_GetTickCount64() - current_time)
                    return bret.RUNNING
                end
                env.is_arrive_end = false
                poe2_api.time_p("检查是否到达目标点(Is_Arrive)(SUCCESS2)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            else
                env.is_arrive_end = false
                env.path_list = nil
                poe2_api.time_p("检查是否到达目标点(mydian)(RUNNING)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.RUNNING
            end
        end
    },

    -- 获取路径
    GET_Path = {
        initialize = function(self)
            self.last_point = nil
            self.FAIL_count = 0 -- 路径计算失败计数器
        end,

        run = function(self, env)
            poe2_api.print_log("获取路径...")
            local start_current_time = api_GetTickCount64()

            local player_info = env.player_info
            

            -- 辅助函数：检测祭坛
            -- local function get_altar(range_info)
            --     for _, entity in ipairs(env.range_info) do
            --         if entity.path_name_utf8 ==
            --             "Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable" and
            --             entity.stateMachineList.current_state == 2 and
            --             entity.stateMachineList.interaction_enabled == 0 then
            --             return entity
            --         end
            --     end
            --     return nil
            -- end
            
            -- 检查终点是否存在
            local point = env.end_point
            poe2_api.dbgp("终点")
            poe2_api.printTable(env.end_point)
            if not point or not next(point) then
                poe2_api.dbgp("[GET_Path] 错误：未设置终点")
                return bret.FAIL
            end

            -- 如果已有路径，使用下一个路径点
            local path_list = env.path_list
            
            if path_list and #path_list > 1 then
                poe2_api.dbgp("路径点数env.path_list: ", #env.path_list)

                local dis = poe2_api.point_distance(path_list[1].x, path_list[1].y, player_info)
                local sight = api_HasObstacleBetween(path_list[1].x, path_list[1].y)
                if dis and dis < 20 and sight then
                    env.target_point = {path_list[1].x, path_list[1].y}
                    -- poe2_api.dbgp("len 5465 移除已使用的点")
                    -- table.remove(path_list, 1) -- 移除已使用的点
                end
                poe2_api.time_p("已有路径(SUCCESS) 耗时 -->", api_GetTickCount64() - start_current_time)
                return bret.SUCCESS
            end
            
            -- 计算最近可到达的点
            point = api_FindNearestReachablePoint(point[1],point[2], 50, 0)
            poe2_api.dbgp("计算最近可到达的点")
            poe2_api.dbgp(point.x, point.y)
            poe2_api.dbgp("yuasnhi")
            poe2_api.dbgp(env.end_point[1],env.end_point[2])

            -- 计算起点
            player_position = api_FindNearestReachablePoint(player_info.grid_x, player_info.grid_y, 50, 0)

            local result = api_FindPath(player_position.x, player_position.y, point.x, point.y)
            poe2_api.time_p("计算路径成功 耗时 -->", api_GetTickCount64() - start_current_time,"两点：{"..player_position.x..","..player_position.y.."} -> {"..point.x..","..point.y.."}")
            
            if result and #result > 0 then
                -- 处理路径结果
                local result_start_current_time = api_GetTickCount64()
                result = poe2_api.extract_coordinates(result, 18)
                if #result > 1 then
                    table.remove(result, 1) -- 移除起点
                    poe2_api.dbgp("移除起点")
                    env.path_list = result
                    env.target_point = {result[1].x, result[1].y}
                    -- table.insert(result, {x = env.end_point[1], y = env.end_point[2]}) -- 替换end_x,end_y为实际坐标
                    table.insert(result, {x = env.end_point[1], y = env.end_point[2]}) -- 替换end_x,end_y为实际坐标

                    poe2_api.dbgp("[GET_Path] 路径计算成功，点数: ", #result)
                end
                poe2_api.time_p("处理路径结果 耗时 -->", api_GetTickCount64() - result_start_current_time)
                return bret.SUCCESS
            else
                -- 路径计算失败处理
                -- 找黑雾祭坛
                local function get_altar(range_info)
                    if not range_info or not next(range_info) then
                        return false
                    end
                    for _, i in ipairs(range_info) do
                        if i.path_name_utf8 and i.path_name_utf8 ~= "" and string.find("Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable",i.path_name_utf8) then
                            -- local stateMachineList = i:GetStateMachineList()
                            if i.stateMachineList and next(i.stateMachineList) then
                                local current_state = (i.stateMachineList or {}).current_state or 5
                                local interaction_enabled = (i.stateMachineList or {}).interaction_enabled or 5
                                if current_state == 2 and interaction_enabled == 0 then
                                    return i
                                end
                            end
                            
                        end
                    end
                    return false
                end
                -- 路径计算失败处理
                -- local altar = get_altar(env.range_info)
                -- if altar then
                --     if poe2_api.point_distance(altar.grid_x, altar.grid_y,player_info) > 110 then
                api_RestoreOriginalMap()
                api_UpdateMapObstacles(100)
                --     end
                -- else
                --     api_RestoreOriginalMap()
                -- end
                if self.FAIL_count == nil then
                    self.FAIL_count = 0
                end
                self.FAIL_count = self.FAIL_count + 1
                env.find_path_FAIL = self.FAIL_count
                poe2_api.dbgp("[GET_Path] 错误：找不到路径 --> " , point[1], ",", point[2])
                -- player_position = api_FindNearestReachablePoint(player_info.grid_x, player_info.grid_y, 50, 0)
                -- api_ClickMove(poe2_api.toInt(player_position.x), poe2_api.toInt(player_position.y), poe2_api.toInt(player_info.world_z), 7)
                -- poe2_api.dbgp1("BFDSXBFDBSDBGSDFB")
                -- poe2_api.click_keyboard("space")
                -- poe2_api.time_p("错误：找不到路径 耗时 -->", api_GetTickCount64() - start_current_time)
                -- poe2_api.print_log("清路径777")
                -- env.path_list = nil
                -- env.target_point = {}
                -- env.is_arrive_end = true
                -- env.end_point = nil
                return bret.RUNNING
            end
        end
    },

    -- 点击移动
    Move_To_Target_Point = {
        run = function(self, env)
            -- 初始化逻辑直接放在 run 函数开头
            poe2_api.dbgp("点击移动 节点...")
            local start_time = api_GetTickCount64()
            
            if not self.last_move_time then
                poe2_api.dbgp("初始化 Move_To_Target_Point 节点...")
                self.last_move_time = api_GetTickCount64()
                self.last_point = nil
                return bret.RUNNING  -- 初始化后返回 RUNNING，等待下一帧继续执行
            end

            -- 正常执行移动逻辑
            poe2_api.dbgp("移动到目标点...")
            local point = env.target_point
            if not point then 
                poe2_api.dbgp("[Move_To_Target_Point] 错误：未设置目标点")
                return bret.RUNNING
            end
    
            local player_info = env.player_info
            if not player_info then
                poe2_api.dbgp("[Move_To_Target_Point] 错误：未设置玩家信息")
                return bret.RUNNING
            end
    
            
            -- 检查终点是否变化
            local end_point = env.end_point
            if not self.last_point and end_point then
                poe2_api.dbgp("设置last_point")
                self.last_point = end_point
            end
            
            -- 如果终点变化超过阈值，重置路径
            if self.last_point and end_point and env.path_list then
                local last_path_point = env.path_list[#env.path_list]
                local dis = poe2_api.point_distance(
                    self.last_point[1], self.last_point[2],
                    {end_point[1], end_point[2]}
                )
                if dis and dis > 25 then
                    self.last_point = end_point
                    poe2_api.print_log("清路径888")
                    env.path_list = nil
                    env.target_point = {}
                    env.is_arrive_end = true
                    env.end_point = nil
                    poe2_api.time_p("执行移动(RUNNING1) 耗时 -->", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end

            local current_time = api_GetTickCount64()
            local move_interval = math.random() * 0.2 + 0.2  -- 随机间隔 0.1~0.2 秒
            
            -- 如果终点变化超过阈值，重置路径
            if self.last_point and end_point and env.path_list then
                local last_path_point = env.path_list[#env.path_list]
                local dis = poe2_api.point_distance(
                    self.last_point[1], self.last_point[2],
                    {end_point[1], end_point[2]}
                )
                if dis and dis > 25 then
                    self.last_point = end_point
                    poe2_api.print_log("清路999")
                    env.path_list = nil
                    env.target_point = {}
                    env.is_arrive_end = true
                    env.end_point = nil
                    poe2_api.time_p("执行移动(RUNNING2) 耗时 -->", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            
            -- 执行移动（按时间间隔）
            if current_time - self.last_move_time >= move_interval * 800 then
                if point then
                    local dis = poe2_api.point_distance(point[1], point[2], player_info)
                    poe2_api.dbgp(point[1], ",", point[2], ",", dis)
                    poe2_api.dbgp("player_info -->", player_info.grid_x, ",", player_info.grid_y)
                    if dis and dis > 70 then
                        poe2_api.print_log("清路径10101")
                        env.path_list = nil
                        env.target_point = {}
                        env.is_arrive_end = true
                        env.end_point = nil
                        poe2_api.time_p("执行移动(RUNNING3) 耗时 -->", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    -- api_ClickMove(poe2_api.toInt(point[1]), poe2_api.toInt(point[2]), poe2_api.toInt(player_info.world_z), 0)
                    -- poe2_api.dbgp("-------")
                    poe2_api.dbgp("----点击移动----")
                    if not api_ClickMove(poe2_api.toInt(point[1]), poe2_api.toInt(point[2]), poe2_api.toInt(player_info.world_z), 7) then
                        env.path_list = nil
                        env.target_point = {}
                        env.is_arrive_end = true
                        env.end_point = nil
                        poe2_api.time_p("执行移动(RUNNING4) 耗时 -->", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end

                    if not string.find(player_info.current_map_name_utf8,"Claimable") then
                        api_SetExplorationArea(env.radius)
                    end

                    self.last_move_time = current_time
                end
            end

            -- 检查是否到达目标点
            if point then
                local dis = poe2_api.point_distance(point[1], point[2], player_info)
                poe2_api.dbgp("检查是否到达目标点距离：", dis)
                poe2_api.dbgp("player_info---->>", player_info.grid_x, ",", player_info.grid_y)
                if dis and dis < 25 then
                    if env.path_list and #env.path_list > 0 then
                        env.target_point = {env.path_list[1].x, env.path_list[1].y}
                        -- poe2_api.dbgp("len 5604 移除已使用的点")
                        table.remove(env.path_list, 1)
                    end
                    poe2_api.time_p("执行移动(RUNNING4) 耗时 -->", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            poe2_api.time_p("执行移动 耗时 -->", api_GetTickCount64() - start_time)
            return bret.RUNNING
        end
    },

    -- 点击队长传送
    Click_Leader_To_Teleport = {
        run = function(self, env)
            poe2_api.dbgp("点击队长传送...")
            local player_info = env.player_info
            local UI_info = env.UI_info

            local leaders = poe2_api.check_pos_dis(env.leader_name, env.range_info, env.player_info)

            local leader_area = poe2_api.party_pos(env.leader_name,env.team_info)
            poe2_api.dbgp("player_info.current_map_name_utf8 -->", player_info.current_map_name_utf8)
            poe2_api.dbgp("leader_area -->", leader_area)
            poe2_api.dbgp("leaders -->", leaders)
            poe2_api.dbgp("env.leader_name -->", env.leader_name)
            poe2_api.printTable(env.team_info)
            if poe2_api.find_text({text = "你確定要傳送至此玩家的位置？", UI_info = UI_info, min_x = 0}) then
                poe2_api.dbgp("你確定要傳送至此玩家的位置？")
                poe2_api.find_text({text = "確定", UI_info = UI_info, min_x = 0, click = 2})
                return bret.RUNNING
            end

            if poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout) and (player_info.current_map_name_utf8 == leader_area or leaders ~= nil) then
                poe2_api.dbgp("当前地图与队长地图一致,在藏身处")
                return bret.RUNNING
            elseif player_info.current_map_name_utf8 == leader_area or leaders ~= nil then
                poe2_api.dbgp("当前地图与队长地图一致")
                return bret.FAIL
            elseif poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout) then
                poe2_api.dbgp("在藏身处")
                return bret.FAIL
            end

            -- local leader_area_name = poe2_api.task_area_list_data(leader_area)[1][2]

            -- if poe2_api.find_text({text = leader_area_name, UI_info = UI_info, min_x = 0, min_y = 0, max_x = 195, max_y = 590}) then
            if poe2_api.find_text({text = "你確定要傳送至此玩家的位置？", UI_info = UI_info, min_x = 0}) then
                poe2_api.dbgp("你確定要傳送至此玩家的位置？")
                poe2_api.find_text({text = "確定", UI_info = UI_info, min_x = 0, click = 2})
                return bret.RUNNING
            end
            local leader_teleport_point = poe2_api.find_text({text = env.leader_name, UI_info = UI_info, min_x = 75, min_y = 0, max_x = 400, max_y = 666, position = 3})
            if leader_teleport_point then
                poe2_api.dbgp("找到队长传送点")
                local rand_x = 14 + math.random(-7, 7)
                local rand_y = leader_teleport_point[2] + 21 + math.random(-7, 7)
                api_ClickScreen(poe2_api.toInt(rand_x), poe2_api.toInt(rand_y), 1)
                api_Sleep(300)
                return bret.RUNNING
            end
            -- end
            poe2_api.dbgp("未找到队长")
            return bret.RUNNING 
        end
    },

    -- 点击队长传送
    Check_Leader_Position = {
        run = function(self, env)
            poe2_api.dbgp("检查大号位置...")
            local leaders = poe2_api.check_pos_dis(env.leader_name, env.range_info, env.player_info, true)
            local current_time = api_GetTickCount64()
            if leaders ~= nil then
                env.center_radius = 100
                env.center_point = {leaders[2][1], leaders[2][2]}
                if leaders[1] > 60 then
                    poe2_api.dbgp("11111111111")
                    poe2_api.dbgp(leaders[2][1], leaders[2][2])
                    -- poe2_api.printTable(leaders[2])
                    env.end_point = {leaders[2][1], leaders[2][2]}
                    return bret.SUCCESS
                else
                    poe2_api.dbgp("3434334")
                    if not self.last_move_time then
                        self.last_move_time = api_GetTickCount64()
                        return bret.RUNNING
                    end
                    local move_interval = math.random() * 0.2 + 0.2  -- 随机间隔 0.1~0.2 秒
                    if current_time - self.last_move_time >= move_interval * 1000 then
                        api_ClickMove(poe2_api.toInt(leaders[2][1]), poe2_api.toInt(leaders[2][2]), poe2_api.toInt(env.player_info.world_z), 7)
                        self.last_move_time = current_time
                    end
                    poe2_api.dbgp("22222222")
                    return bret.RUNNING 
                end
            elseif poe2_api.table_contains(env.player_info.current_map_name_utf8,my_game_info.hideout) then
                return bret.FAIL
            end
            poe2_api.dbgp("检查大号位置失败")
            return bret.RUNNING 
        end
    },

    -- 跟随交互
    Follow_Interactive = {
        run = function(self, env)
            poe2_api.print_log("跟随交互...")

            if not poe2_api.table_contains(env.player_info.current_map_name_utf8,my_game_info.hideout) then
                return bret.FAIL 
            end

            -- 获取符合条件的非地图物品（传送点/异界之门除外）
            local function get_not_map(num)
                num = num or 1
                local valid_items = {}
                
                for _, item in ipairs(env.range_info) do
                    if item.type == 5 and item.name_utf8 ~= '' and item.name_utf8 ~= "傳送點" and item.name_utf8 ~= '異界之門' then
                        table.insert(valid_items, item)
                    end
                end
                
                -- 检查是否达到阈值数量
                if #valid_items < num then
                    return false
                end
                
                -- 按距离排序，返回最近的物品
                if #valid_items > 0 then
                    table.sort(valid_items, function(a, b)
                        a_dis = poe2_api.point_distance(a.grid_x, a.grid_y, player_info)
                        b_dis = poe2_api.point_distance(b.grid_x, b.grid_y, player_info)
                        if a_dis and b_dis then
                            return a_dis < b_dis
                        else
                            return false
                        end
                    end)
                    
                    -- -- 打印排序后的结果（调试用）
                    -- for i, item in ipairs(valid_items) do
                    --     local distance = poe2_api.point_distance(item.grid_x, item.grid_y, player_info)
                    --     poe2_api.dbgp(string.format("[dbgp] #%d: %s 距离=%.2f", i, item.name_utf8, distance))
                    -- end
                    
                    return valid_items[1]
                end
                
                return false
            end

            local items = get_not_map()
            local click_counter = 0
            local player_info = env.player_info 
            if items and not poe2_api.table_contains({items.name_utf8}, not_enter_map) and not poe2_api.table_contains({items.name_utf8}, my_game_info.hideout) then
                poe2_api.dbgp("items: ", items.name_utf8)

                if poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", min_x = 0}) or 
                poe2_api.find_text({UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", min_x = 0}) then
                    poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖", min_x = 0, click = 2, add_x = 216})
                    env.click_grid_pos = true
                    return bret.RUNNING
                end

                dis = poe2_api.point_distance(items.grid_x, items.grid_y, player_info)
                if dis and dis > 30 then
                    env.end_point = {items.grid_x, items.grid_y}
                    return bret.SUCCESS
                else
                    env.enter_map_click_counter = click_counter + 1
                    if env.click_grid_pos then
                        api_ClickMove(poe2_api.toInt(items.grid_x), poe2_api.toInt(items.grid_y), poe2_api.toInt(items.world_z - 100), 1)
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    
                    if player_info.isMoving then
                        poe2_api.dbgp("等待静止")
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    poe2_api.find_text({UI_info = env.UI_info, text = items.name_utf8, click = 2, sorted = true, min_x = 0})
                    api_Sleep(1000)
                    if not poe2_api.find_text({UI_info = env.UI_info, text = items.name_utf8, click = 2, sorted = true, min_x = 0}) then
                        api_ClickMove(poe2_api.toInt(items.grid_x), poe2_api.toInt(items.grid_y), poe2_api.toInt(items.world_z - 100), 1)
                        api_Sleep(1000)
                    end
                    
                    return bret.RUNNING
                end
            end
            return bret.FAIL 
        end
    }

}

local all_nodes = {}
for k, v in pairs(base_nodes) do all_nodes[k] = v end
for k, v in pairs(custom_nodes) do all_nodes[k] = v end

-- 注册自定义节点
local behavior_node = require 'script.lualib.behavior3.behavior_node'
behavior_node.process(all_nodes)

-- 创建行为树环境
local env_params = {
    -- 可以在这里添加需要的环境变量
    user_config = nil, -- 用户配置
    user_info = nil, -- 用户信息
    user_map = nil, -- 地图
    player_class = nil, -- 職業
    player_spec = nil, -- 专精
    space = nil, -- 躲避
    space_monster = nil, -- 躲避怪物
    space_time = nil, -- 躲避时间
    protection_settings = nil, -- 普通保護設置
    emergency_settings = nil, -- 紧急設置
    login_state = nil, -- 登录状态，初始值为nil
    speel_ip_number = 0, -- 設置当前IP地址的数量，初始值为0
    is_game_exe = false, -- 游戏是否正在执行，初始值为false
    shouting_number = 0, -- 喊话次数，初始值为0
    area_list = {}, -- 存储区域列表，初始值为空列表
    account_state = nil, -- 账户状态，初始值为nil
    switching_lines = 0, -- 线路切换状态，初始值为0
    time_out = 0, --  超时时间，初始值为0
    skill_name = nil, -- 当前技能名称，初始值为nil
    skill_pos = nil, -- 当前技能位置，初始值为nil
    is_need_check = false, -- 是否需要检查，初始值为false
    item_name = nil, -- 当前物品名称，初始值为nil
    item_pos = nil, -- 当前物品位置，初始值为nil
    -- blackboard.set("user_config", parser)  # 用户配置
    check_all_points = false, -- 是否检查所有点，初始值为false
    path_list = {}, -- 存储路径列表，初始值为空列表
    empty_path = false, -- 路径是否为空，初始值为false
    boss_name = my_game_info.boss_name,  -- 当前boss名称，初始值为nil
    map_name = nil, -- 当前地图名称，初始值为nil
    interaction_object = nil, -- 交互对象，初始值为nil
    item_move = false, -- 物品是否移动，初始值为false
    item_end_point = {}, -- 物品的终点位置，初始值为[0, 0]
    ok = false, -- 是否确认，初始值为false
    not_need_wear = false, -- 是否不需要装备，初始值为false
    currency_check = false, -- 是否进行货币检查，初始值为false
    sell_end_point = {}, -- 卖物品的终点位置，初始值为[0,0]
    is_better = false, -- 是否更好，初始值为false
    mos_out = 0, -- 显示的数量，初始值为0
    is_arrive_end = false, -- 是否到达终点，初始值为false
    not_need_pick = false, -- 是否不需要拾取，初始值为false
    is_not_ui = false, -- 是否不是UI界面，初始值为false
    entrancelist = {}, -- 入口位置列表
    creat_new_role = false, -- 新角色
    Level_reach = false, -- 是否要刷级
    changer_leader = false, -- 是否要换队长
    send_message = false, -- 是否要发信息
    obtain_message = false, -- 是否要换接收信息
    no_item_wear = false,
    my_role = nil,
    is_set = false,
    end_point = {},
    teleport_area = nil,
    teleport = nil,
    follow_role = nil,
    map_count = 0,
    task_name = nil,
    subtask_name = nil,
    special_map_point = nil, -- 第二章任务地圖特殊點
    mate_info = nil, -- 已死队员信息信息
    monster_info = nil, -- 怪物信息
    range_info = nil, -- 周围对象信息信息
    bag_info = nil, -- 背包信息
    range_item_info = nil, -- 周围装备信息
    shortcut_skill_info = nil, -- 快捷栏技能信息
    allskill_info = nil, -- 全部技能信息
    selectableskill_info = nil, -- 可选技能技能控件信息
    skill_gem_info = nil, -- 技能宝石列表信息
    team_info = nil, -- 获取队伍信息
    player_info = nil, -- 人物信息
    skill_number = 0, -- 放技能次数
    path_bool = false, -- 跟隨超距離判斷
    interaction_object_map_name = nil,
    not_need_active = false,
    target_point = {},
    grid_x = nil,
    grid_y = nil,
    target_point_follow = nil,
    is_timeout = false,
    special_relife_point = false,
    need_identify = false,
    one_other_map = nil,
    current_map_info = nil,
    need_item = false, -- 异界可拾取对象
    discard_item = nil, -- 丢弃对象
    store_item = nil, -- 存储对象
    interactive = nil, -- 交互对象
    is_shop = false, -- 是否购买
    is_map_complete = false, -- 是否是地图完成
    pick_up_timeout = {}, -- 拾取物品超时
    wait_target = false, -- 等待交互
    start_time = nil, -- 設置黑板变量 开始时间，初始化为 nil
    life_time = nil, -- 設置黑板变量 復活时间，初始化为 nil
    last_end_point = {}, -- 設置黑板变量 終點，初始化为 0
    last_exception_time = nil,
    need_ReturnToTown = false,
    need_SmallRetreat = false,
    waypoint = nil,
    retry_count = 0,
    last_retreat_time = 0,
    is_arrive_end_dis = nil,
    map_level_dis = nil,
    is_have_map = nil,
    is_strengthened_map = true, -- 是否需要强化地图
    strengthened_map_obj = nil, -- 地图强化对象22
    chapter_name = nil, -- 章节名称
    target_chapter_name = nil, -- 传送地图名
    tar_clear_name = nil,
    radius = nil, -- 范围
    
    -- 是否需要滴注
    dist_ls  = false, --- 是否需要滴注
    dizhu_end = false, -- 滴注操作
    is_need_strengthen = false, -- 是否需要合成
    priority_map = nil, -- 優先打地圖詞綴
    is_over = false , -- 是否完成滴注
    refining_list = {}, --精炼列表
    key_level = nil, -- 钥匙等级
    check_map_key = false, -- 点击地图钥匙
    exists_key = false, -- 存在地图钥匙
    map_key_name = nil, -- 地图钥匙名
    missing_refinement = {},-- # 缺少的精炼
    is_refinement = nil, --是否精炼
    key_ok = false, -- 钥匙是否可用
    warehouse_type = nil, -- 仓库类型（滴注）
    formula_list = {}, -- 配方列表（滴注）
    -- not_use_map = config['刷圖設置']["異界地圖"]["不打地圖詞綴"],
    -- -- 玩法優先級
    -- map_priority = config["刷圖設置"]["玩法優先級"],
    -- map_sorted_items = sorted((k, v) for k, v in map_priority.items() if v and type(v) == int),
    -- map_sorted_items_sort = sorted(map_sorted_items, key=lambda x: x[1]),
    -- map_sorted_keys = [item[0] for item in map_sorted_items_sort if item[1] > 0],
    -- -- 玩法順序是否開啓
    -- if map_priority.get('是否開啟') then
    --     blackboard.set("sorted_map",map_sorted_keys)
    -- else
    --     blackboard.set("sorted_map",nil)
    -- end
    sorted_map = nil,

    -- 碑牌順序
    -- play_priority = config["刷圖設置"]["碑牌優先級"],
    -- -- 根据值排序并排除值为0的元素
    -- sorted_items = sorted((k, v) for k, v in play_priority.items() if v and type(v) == int),
    -- sorted_items_sort = sorted(sorted_items, key=lambda x: x[1]),
    -- -- 只保留键,
    -- sorted_keys = [item[0] for item in sorted_items_sort],
    -- result = [my_game_info.map_type[key] for key in sorted_keys if key in my_game_info.map_type],
    -- -- 是否需要插入碑牌
    -- blackboard.set("is_insert_stone",play_priority.get('是否開啟')),
    -- -- 插牌顺序
    -- blackboard.set("stone_order",result),
    stone_order = nil,
    is_insert_stone = nil,

    not_exist_stone = {}, -- 不存在的碑牌
    is_have_stone = true, -- 是否有可插入的塔
    stone_info = nil, -- 塔信息
    not_use_stone = {}, -- 无用之塔
    -- is_insert_stone = nil,
    enter_map_click_counter = 0,
    is_get_plaque = false, -- 是否需要取碑牌
    is_find_boss = false, -- 是否找到boss記錄點
    not_interactive = nil, -- 不交互對象
    afoot_altar = nil, -- 进行中的祭坛
    center_radius = 0, -- 半径
    center_point = {}, -- 中心点
    run_point = nil, -- 逃跑點
    valid_monsters = nil, -- 最近怪物
    stuck_monsters = nil,
    -- 人物自身装备 --
    item2 = nil,
    item3 = nil,
    item4 = nil,
    item5 = nil,
    item6 = nil,
    item7 = nil,
    item8 = nil,
    item9 = nil,
    item0xa = nil,
    item0xb = nil,
    not_attack_mos = nil,
    pick_up_number = 0, -- 取碑牌数量
    is_public_warehouse = true, -- 共倉點金是否存儲
    is_get_plaque_node = true, -- 取碑牌节点，专用是否需要取碑牌
    launch_timeout = 0, -- 启动超时
    min_attack_range = nil,
    is_public_warehouse_plaque = true, -- 共倉點金碑牌是否存儲
    afoot_box = nil, -- 进行中的保险箱
    entry_length_take_map = false,
    the_update_map = nil,
    map_update_to = nil,
    amplification_use_count = 0, -- 增幅使用次数
    supreme_use_count = 0, -- 崇高使用次数
    map_up = false,
    sacrificial_refresh = 0,
    have_ritual = false,
    last_position_time = nil,
    last_position = nil,
    boss_drop = false, -- 等待boss掉落
    esc_click = 0,
    error_kill = false,
    error_other_map = {},
    available_oils = nil,
    missing_oils = nil,
    oil_map = nil,
    last_exp_check_move = api_GetTickCount64(),
    last_exp_check = api_GetTickCount64(),
    last_exp_value_move = 0,
    last_exception_time_move = 0,

    interactiontimeout = 0, -- 记录交互超时时间
    available_configs = nil,
    find_path_FAIL = 0,

    false_times = 0,
    not_have_stackableCurrency = false,
    is_update_plaque = false, -- 是否强化碑牌
    boss_drop_time = 0, -- 等待boss掉落时间
    is_dizhu = false,
    take_rest = false,
    minimap_info = nil, -- 小地图对象记录
    buy_items = false,
    kill_process = false,
    boss_id_list = {}, -- 已等bossID列表
    drop_items = false, -- 回城时丢弃
    exchange_ratio = nil, -- 通货兑换组
    currency_ratios = {}, -- 物品对应数量组
    enough_currency = true, -- 是否足够兑换
    -- 兑换列表
    owned_currencies = {}, -- 拥有
    needed_currencies = {}, -- 需要
    E_D_ratio = nil, -- E_D比例
    prestore_list = {}, -- 预存列表
    C_D_ratio = nil, -- C_E
    return_town = false, -- 回城
    map_start_time = nil, -- 地图开始时间

    error_back = false, -- 意外退出
    map_recorded = false, -- 地图状态记录
    mouse_check = true, -- 检查鼠标技能
    click_grid_pos = false, -- 补丁视角处理
    current_pair_index = 0, -- 初始化当前兑换索引
    last_execution_time = 0, -- 初始化当前兌換時間
    not_more_ritual = true, -- 取消后续祭坛
    warehouse_full = nil, -- 个仓某页是否已满
    exchange_status = false, -- 是否兌換完成（存仓用）
    not_items_buy = false, -- 祭祀无物品购买
    open_map_UI = false, -- 地图ui是否打开

    warehouse_type_interactive = nil,  -- 仓库类型交互（个仓/公仓/nil）
    hwrd_time = 0, -- 获取窗口句柄间隔
    game_window = 0,  -- 暂存的窗口句柄
    streng_map_flushed_switch = false, -- 强化地图刷新开关
    currency_name = nil, -- 使用通货物品名称
    need_sale_map = false, -- 是否需要卖地图
    full_map = false, -- 地图是否已满
    min_attack_dis = nil,
    in_exchange = false, --在兑换状态
    operated_plaque = false, -- 是否操作过碑牌
    lack_of_currency = {}, -- 缺少通货

    clear_bool = false, -- 清除节点的状态记录
    not_match_id = nil,
    interactive_id = nil,
    interactive_id_list = {},
    interactive_replytime = 0,
    interactive_permanent_id_list = {},
    obj_color = nil,
    map_page_full = nil,
    interactive_timeout = nil,
    not_need_take = false,
    is_bird = false, -- 骑鸟
    is_abyss_complete = false,  -- 深渊地图是否完成
    is_abyss_time = false,  -- 是否需要等待深渊掉落
    abyss_time = 0, -- 深渊掉落时间
    page_full_list = {},

    -- 新增性能监控配置
    debug_tree_time = true,      -- 打印整棵树耗时
    debug_all_nodes = false,     -- 不打印所有节点调试信息(避免日志过多)
    suppress_node_debug = true   -- 抑制节点调试输出
}

-- 导出模块接口 
local otherworld_bt = {}

-- 创建行为树
function otherworld_bt.create()

    local missions = nil

    local file = io.open(json_path, "r") -- 打开文件
    if not file then error("Failed to open config file: " .. path) end
    local content = file:read("*a") -- 读取全部内容 
    file:close()
    config = json.decode(content)

    if config then
        if config["全局設置"] then
            if config["全局設置"]["剧情地图设置"] and config["全局設置"]["剧情地图设置"]["是否開啟"] then
                missions = "main_story_map"
            elseif config["全局設置"]["跟随设置"] and config["全局設置"]["跟随设置"]["是否開啟"] then
                missions = "follows"
            else
                if config["全局設置"]["内存模式"] then
                    missions = "attack_target_inside"
                else
                    missions = "attack_target"
                end
            end
        else
            if config["全局設置"]["内存模式"] then
                missions = "attack_target_inside"
            else
                missions = "attack_target"
            end
        end
    end
    -- local bt = behavior_tree.new("attack_target 2", env_params)
    local bt = behavior_tree.new(missions, env_params)
    -- local bt = behavior_tree.new("out_id", env_params)
    return bt
end

-- 辅助函数
local function sleep(n)
    if n > 0 then
        os.execute("ping -n " .. tonumber(n + 1) .. " localhost > NUL")
    end
end

return otherworld_bt