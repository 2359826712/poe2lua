local package_path = api_GetExecutablePath()
local script_dir = package_path:match("(.*[/\\])") .. "script\\"

local behavior_tree = require 'script.lualib.behavior3.behavior_tree'
local bret = require 'script.lualib.behavior3.behavior_ret'

api_Log("清除 poe2api 模块的缓存")
package.loaded['script\\poe2api'] = nil
package.loaded['script\\game_str'] = nil
package.loaded['json'] = nil

-- 加载基础节点类型
local base_nodes = require 'script.lualib.behavior3.sample_process'
local my_game_info = require 'script\\my_game_info'
local game_str = require 'script\\game_str'
local main_task = require 'script\\main_task'

local script_dir = api_GetExecutablePath()
-- api_Log(script_dir)
local json_path = script_dir .."\\config.json"
local user_info_path = script_dir .."\\config.ini"
local json = require 'script.lualib.json'



local poe2_api = require "script\\poe2api"
local json = require 'script.lualib.json'

local file = io.open(json_path, "r") -- 打开文件
-- if not file then error("Failed to open config file: " .. path) end
local content = file:read("*a") -- 读取全部内容 
file:close()
local config = json.decode(content)
-- poe2_api.dbgp(game_str.tab_list_button)
-- poe2_api.dbgp("========================")

-- 自定义节点实现
local custom_nodes = {
    -- 获取用户配置信息
    Get_User_Config_Info = {
        run = function(self, env)
            poe2_api.print_log("获取用户配置信息...")
            local start_time = api_GetTickCount64() -- 开始时间

            -- 解析单个词缀字符串的函数（最少一个参数，空参数填0）
            local function parse_map_modifier(modifier_str)
                local parts = {}
                for part in modifier_str:gmatch("[^==]+") do
                    table.insert(parts, part)
                end
                
                if #parts < 1 then
                    return nil, "格式错误：需要至少一个部分（名称）"
                end
                
                local name_utf8 = parts[1]
                local value_list = {}
                
                -- 解析参数（空参数填0）
                for i = 2, #parts do
                    if parts[i] == "" then
                        -- 空参数，填充0
                        table.insert(value_list, 0)
                    else
                        local num = tonumber(parts[i])
                        table.insert(value_list, num or parts[i]) -- 如果转换失败，保留原始字符串
                    end
                end
                
                -- 如果只有一个参数，添加默认值0
                if #value_list == 0 then
                    table.insert(value_list, 0)
                end
                
                return {
                    name_utf8 = name_utf8,
                    value_list = value_list
                }
            end

            -- 主解析函数
            local function parse_map_modifiers_config(modifier_list)
                local result = {}
                
                for i, modifier_str in ipairs(modifier_list) do
                    if type(modifier_str) == "string" then
                        local modifier, err = parse_map_modifier(modifier_str)
                        if modifier then
                            table.insert(result, modifier)
                        else
                            print("解析错误 [" .. i .. "]: " .. err .. " - " .. modifier_str)
                        end
                    end
                end
                
                return result
            end

            if not env.user_config then
                local config = poe2_api.load_config(json_path)
                local user_info = poe2_api.load_ini(user_info_path)["UserInfo"]
                -- 玩法優先級
                local map_priority = config["刷圖設置"]["玩法優先級"]
                local map_sorted_items_sort = poe2_api.sort_map_by_key(map_priority)
                poe2_api.printTable(map_priority)
                if map_priority ~= nil and next(map_priority) then
                    env.sorted_map = map_priority
                    env.first_map = map_priority[1]
                    poe2_api.dbgp(env.first_map)
                else
                    env.sorted_map = nil
                    env.first_map = nil
                end
                poe2_api.dbgp("1111111111...")
                 
                env.user_config = config
                env.user_info = user_info
                -- env.stone_order = result
                -- env.is_insert_stone = play_priority["是否開啟"]

                -- 界域之门
                if config["全局設置"]["界域之门"] then
                    env.special_mode_enabled = config["全局設置"]["界域之门"]["是否開啟"]
                    env.special_storage_type = config["全局設置"]["界域之门"]["倉庫類型"]
                    env.special_map_type = config["全局設置"]["界域之门"]["地图类型"]

                    env.special_map_tier = config["全局設置"]["界域之门"]["难度等级"]
                    if env.special_map_tier == 1 then
                        env.special_map_tier = 50
                        env.special_map_tier_text = "x50"
                    elseif env.special_map_tier == 2 then
                        env.special_map_tier = 100
                        env.special_map_tier_text = "x100"
                    elseif env.special_map_tier == 3 then
                        env.special_map_tier = 150
                        env.special_map_tier_text = "x150"
                    end

                    
                    if env.special_map_type == "迷霧" then
                        env.special_map_type = "幻像斷片"
                        env.special_map_door_name = "皆伐伐木場"
                    elseif env.special_map_type == "帝王" then
                        env.special_map_type = "願力斷片"
                        env.special_map_door_name = "無量困境"
                    elseif env.special_map_type == "裂痕" then
                        env.special_map_type = "裂痕裂片"
                        env.special_map_door_name = "扭曲領域"
                    elseif env.special_map_type == game_str.Skull_Mark_TWCH then
                        env.special_map_type = game_str.The_Invitation_of_Skeleton_Mark_TWCH
                        env.special_map_door_name = game_str.Invitation_to_showcase_Skeleton_Mark_TWCH
                        env.special_map_tier = 1
                    end
                end

                -- 检查是否需要售卖地图
                env.need_sale_map = config["全局設置"]["刷图通用設置"]["自动清理地图(个人仓库)"]
                env.settings_cfg_plaque = config["刷圖設置"]["插碑牌設置"] or {}
                local result = {}
                if next(env.settings_cfg_plaque) then
                    for _, v in ipairs(env.settings_cfg_plaque) do
                        table.insert(result, v["基礎類型名"])
                    end
                else
                    result = {"祭祀碑牌","先行者碑牌","總督的先行者碑牌","裂痕碑牌","譫妄碑牌"}
                end
                env.stone_order = result
                local item_filters = config["物品過濾"] or {}  -- 获取物品过滤配置数组
                -- 两种独立的分类表
                local item_config_by_type = {}      -- 按【類型】分类
                local item_config_by_base_type = {} -- 按【基礎類型名】分类

                for _, filter in ipairs(item_filters) do
                    if not filter["不撿"] then
                        -- ========== 按【類型】分类 ==========
                        local item_type = filter["類型"] or "未分类"
                        if not item_config_by_type[item_type] then
                            item_config_by_type[item_type] = {}
                        end
                        table.insert(item_config_by_type[item_type], filter)  -- 直接引用原数据

                        -- ========== 按【基礎類型名】分类 ==========
                        local base_type = filter["基礎類型名"] or "全部物品"
                        if not item_config_by_base_type[base_type] then
                            item_config_by_base_type[base_type] = {}
                        end
                        table.insert(item_config_by_base_type[base_type], filter)  -- 直接引用原数据
                    end
                end

                env.item_config_name = item_config_by_base_type
                env.item_config_type = item_config_by_type

                env.not_use_map = (config['刷圖設置'] or {})["不打地圖詞綴"] or {}

                -- 滴注操作
                local map_cfg = config['刷圖設置'] or {}
                poe2_api.process_void_maps(map_cfg)
                env.dist_ls = config["刷圖設置"]['異界地圖索引']["涂油设置"] or {}
                -- 更新地图相关设置（添加空值保护）
                env.user_map = (config["刷圖設置"] or {})[game_str.Map_Key_CH] or ""
                -- poe2_api.printTable(env.user_map)
                -- api_Sleep(100000)
                

                env.not_enter_map = (config["刷圖設置"] or {})["不打地圖名"] or {}

                -- 处理怪物躲避设置（添加空值保护）
                local global_settings = config["全局設置"] or {}
                local common_settings = global_settings["刷图通用設置"] or {}
                local monster_avoid = common_settings["怪物近距離躲避"] or {}

                env.space = monster_avoid["是否開啟"] or false
                env.space_time = monster_avoid["閾值"] or 0
                env.space_config = monster_avoid
                env.is_open_gameplay_safe = config["全局設置"]["刷图通用設置"]["是否开启玩法保险箱"] or false
                env.is_click_essence = config["全局設置"]["刷图通用設置"]["是否点击精髓"] or false
                env.is_open_crack = config["全局設置"]["刷图通用設置"]["是否开启裂痕之手"] or false
                env.is_deception_delusion = config["全局設置"]["刷图通用設置"]["是否开启诡妄之镜"] or false
                env.is_sacrifice_shopping = config["全局設置"]["刷图通用設置"]["是否使用内置祭祀购买"] or false

                local space_monster = {}

                -- 检查每种怪物类型是否存在，不存在则默认为false
                if monster_avoid["白"] then
                    table.insert(space_monster, 0)
                end
                if monster_avoid["藍"] then
                    table.insert(space_monster, 1)
                end
                if monster_avoid["黃"] then
                    table.insert(space_monster, 2)
                end
                if monster_avoid[game_str.Boss_EN] then
                    table.insert(space_monster, 3)
                end

                env.space_monster = space_monster

                env.is_bird = env.user_config["全局設置"]["刷图通用設置"]["是否骑鸟"] or false

                env.enter_city = env.user_config["全局設置"]["刷图通用設置"]["是否刷城寨"] or false

                -- 处理保护设置
                local protection_cfg = config["全局設置"]["保護設置"] or {}
                
                -- 解析保护配置的辅助函数
                local function parse_protection(item_cfg)
                    item_cfg = item_cfg or {}
                    local enable_flag = item_cfg["是否開啟"]
                    
                    -- 处理启用标志
                    local enabled
                    if type(enable_flag) == "boolean" then
                        enabled = enable_flag
                    elseif type(enable_flag) == "string" then
                        enabled = (enable_flag:lower():gsub("%s+", "") == "true" or 
                                enable_flag == "1" or 
                                enable_flag:lower() == "yes")
                    else
                        enabled = false
                    end
                    
                    -- 处理数值
                    local function parse_number(value, default)
                        if value == nil then return default end
                        local num = tonumber(value)
                        return num or default
                    end
                    
                    return {
                        enable = enabled,
                        threshold = parse_number(item_cfg["閾值"], 0),
                        interval = parse_number(item_cfg["使用間隔"], 0)
                    }
                end
                
                -- 解析保护设置
                local protection_settings = {
                    health_recovery = parse_protection(protection_cfg["血少回血"]),
                    mana_recovery = parse_protection(protection_cfg["藍少回藍"]),
                    shield_recovery = parse_protection(protection_cfg["盾少回血"])
                }
                
                -- 解析紧急设置
                local emergency_settings = {
                    low_health = parse_protection(protection_cfg["血少逃跑"]),
                    low_mana = parse_protection(protection_cfg["藍少逃跑"]),
                    low_shield = parse_protection(protection_cfg["盾少逃跑"]),
                }
                
                -- 设置到黑板
                env.protection_settings = protection_settings
                env.emergency_settings = emergency_settings

                -- 查找最小攻击距离
                local skill_config = config["技能設置"]
                local min_distance = 1000  -- 初始化为一个很大的数

                for _, v in pairs(skill_config) do 
                    -- if v["启用"] and v["技能屬性"] == "攻击技能" and (v["白怪"] or v["藍怪"] or v["黃怪"] or v[game_str.Boss_EN]) and v["釋放對象"] == "敵對" then
                    if v["启用"] and v["技能屬性"] == "攻击技能" and (v["白怪"] or v["藍怪"] or v["黃怪"]) and v["釋放對象"] == "敵對" then
                        -- poe2_api.printTable(v)
                        if v["攻擊距離"] < min_distance then
                            min_distance = v["攻擊距離"]
                        end
                    end
                end

                -- 边走边释放技能
                env.keep_distance = env.user_config["全局設置"]["刷图通用設置"]["是否保持距离"] or false

                -- 如果没有找到符合条件的技能，设置默认值
                if min_distance == 1000 or min_distance == 0 then
                    min_distance = 70  -- 默认攻击距离
                    print("警告：未找到符合条件的攻击技能，使用默认攻击距离：" .. min_distance)
                end

                env.min_attack_dis = min_distance
                poe2_api.dbgp("env.min_attack_dis ==>>", env.min_attack_dis)
                -- api_Sleep(1000000)

                -- 加载躲避技能

                if not env.open_mos_skill then
                    env.open_mos_skill = true
                    local skills = config["全局設置"]["刷图通用設置"]["是否躲避技能"]
                    if skills then
                        -- 圆形
                        for _,k in ipairs(my_game_info.MonitoringSkills_Circle) do
                            -- poe2_api.dbgp(k[2])
                            api_RegisterCircle(k[2] , k[3])
                        end

                        -- 扇形
                        for _,k in ipairs(my_game_info.MonitoringSkills_Sector) do
                            -- poe2_api.dbgp(k[2])
                            api_RegisterSector(k[1] , k[2], k[3], 1)
                        end

                        -- 矩形
                        for _,k in ipairs(my_game_info.MonitoringSkills_Rect) do
                            -- poe2_api.dbgp(k[2])
                            api_RegisterRect(k[1], k[2], k[3])
                        end
                    end
                    -- # 高傷害技能
                    for _,k in ipairs(my_game_info.High_Damage_Skill) do
                        api_RegisterCircle(k[2] , k[3], 2)
                    end
                end

                --  获取配置中的大号名字
                env.leader_name = config["全局設置"]["跟随设置"]["大号名称"] or nil
                env.follow_move = config["全局設置"]["跟随设置"]["是否開啟"] or false
            end
            poe2_api.time_p("Get_User_Config_Info... 耗时 --> ", api_GetTickCount64() - start_time)

            -- player_info = api_GetLocalPlayer()
            -- danger = api_IsPointInAnyActive(player_info.grid_x , player_info.grid_y , 100)
            -- poe2_api.printTable(danger)
            -- api_ClickMove(danger.safeTile.x, danger.safeTile.y, player_info.world_z, 0)
            -- poe2_api.printTable(api_GetTeleportationPoint())

            -- bag_info = api_Getinventorys(1,0)
            -- poe2_api.printTable(env.user_map)
            -- maps =  poe2_api.select_best_map_key({inventory = bag_info, key_level_threshold = env.user_map, not_use_map = env.not_use_map})
            
            -- if maps then 
            --     poe2_api.printTable(maps)
            --     poe2_api.printTable(api_GetObjectSuffix(maps.mods_obj))
            -- end

            -- local start_time = api_GetTickCount64()
            -- local danger = api_IsPointInAnyActive(player_info.grid_x , player_info.grid_y , 100)
            -- poe2_api.dbgp("耗时 === 》》》",api_GetTickCount64() - start_time)
            -- poe2_api.printTable(danger)

            if not self.open_map_count then
                self.open_map_count = env.open_map_count or 0
            end
            local open_map_count = (self.open_map_count or 0) + (env.open_map_count or 0)

            if not self.death_times then
                self.death_times = env.death_times or 0
            end
            local death_times = (self.death_times or 0) + (env.death_times or 0)
            api_SetStatusText("开图次数:"..(open_map_count or 0))
            -- api_SetStatusText("开图次数:"..(env.open_map_count or 0))

            -- api_UpdateMapObstacles(1000)

            -- while true do
            --     Actors:Update() 
            --     api_Sleep(100)
            --     return bret.RUNNING
            -- end

            return bret.SUCCESS
        end
    },

    -- 判断游戏窗口 poe2_api.time_p("判断游戏窗口... 耗时 --> ", api_GetTickCount64() - current_time)
    Is_Game_Windows={
        run = function(self, env)
            poe2_api.print_log("判断游戏窗口")
            local current_time = api_GetTickCount64()

            if not env.user_info then
                local user_info = poe2_api.load_ini(user_info_path)["UserInfo"]
                env.user_info = user_info
            end
            local game_path = env.user_info["gamedir"]
            poe2_api.dbgp("game_path:"..game_path)
            local process_name = string.find(game_path:lower(), "steam.exe") and "PathOfExileSteam.exe" or "PathOfExile.exe"
            if not env.config_file then
                -- 获取文档目录路径
                env.documents_path = os.getenv('USERPROFILE') .. '\\Documents'
                -- 构建配置目录路径
                env.config_dir = env.documents_path .. '\\My Games\\Path of Exile 2'
                -- 构建配置文件路径
                env.config_file = env.config_dir .. '\\poe2_production_Config.ini'
            end
            

            -- local elapsed_ms = (api_GetTickCount64()) - start_time
            -- poe2_api.dbgp("构建配置文件路径:"..string.format( elapsed_ms))
            -- if env.hwrd_time ~=0 then
            --     poe2_api.dbgp("时间差值：:"..api_GetTickCount64() - env.hwrd_time)
            -- end
            poe2_api.dbgp("hwrd_time1:"..env.hwrd_time)
            if env.hwrd_time == 0 or os.time() - env.hwrd_time >= 60 then
                env.game_window = api_FindWindowByProcess("","Path of Exile 2",process_name,0)
                poe2_api.dbgp("game_window:"..env.game_window)
                env.hwrd_time = os.time()
                poe2_api.dbgp("------------------")
                poe2_api.dbgp("hwrd_time2:"..env.hwrd_time)
                -- api_Sleep(5000)
                -- elapsed_ms = (api_GetTickCount64()) - start_time
                -- poe2_api.dbgp("获取窗口句柄:"..string.format( elapsed_ms))
            end
            
            
            -- 判断游戏窗口
            if (not env.game_window or env.game_window == 0) and not env.error_kill then
                poe2_api.dbgp("窗口不存在==================================================")
                -- 判断游戏配置文件是否存在
                local file = io.open(env.config_file, "r")
                if file then
                    file:close()
                    if poe2_api.check_NCStorageLocalData_config(env.config_dir) then
                        poe2_api.print_log("游戏配置文件异常,替换配置文件")
                        poe2_api.set_NCStorageLocalData_config(env.config_file)
                        poe2_api.time_p("判断游戏窗口(RUNNING)... 耗时 --> ", api_GetTickCount64() - current_time)
                        return bret.RUNNING
                    end
                end
                env.is_set = false
                env.take_rest =false
                env.game_window = 0
                env.hwrd_time = 0
                -- error("窗口不存在=")
                -- api_Sleep(5000)
                -- elapsed_ms = (api_GetTickCount64()) - start_time
                -- poe2_api.dbgp("判断游戏窗口:"..string.format( elapsed_ms))
                poe2_api.time_p("判断游戏窗口(FAIL)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.FAIL
            end
            poe2_api.time_p("判断游戏窗口(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
            return bret.SUCCESS
        end
    },

    -- 加入游戏异界
    Join_Game_Otherworld = {
        run = function(self, env)
            poe2_api.print_log("加入异界游戏...")
            if not self.bool then
                self.config_exe = false
                self.bool = true
            end
            local start_time = api_GetTickCount64()  -- 转换为 ms

            local game_path = env.user_info["gamedir"]
            poe2_api.dbgp("game_path:"..game_path)
            local process_name = string.find(game_path:lower(), "steam.exe") and "PathOfExileSteam.exe" or "PathOfExile.exe"
            
            
            if env.time_out == 0 then
                env.time_out = os.time()
            end
            -- 判断是否关闭游戏
            if env.speel_ip_number >= 50 
            or env.error_kill 
            or env.is_set 
            or env.switching_lines>=120 
            or poe2_api.find_text({text = game_str.the_account_to_be_logged_in, UI_info = env.UI_info})
            or poe2_api.find_text({text = game_str.Unable_to_deserialise, UI_info = env.UI_info,min_x = 0}) then
                poe2_api.dbgp("error_kill:", env.error_kill)
                poe2_api.dbgp("speel_ip_number:" , env.speel_ip_number)
                poe2_api.dbgp("is_set:", env.is_set)
                poe2_api.dbgp("switching_lines:", env.switching_lines)
                poe2_api.dbgp("find_test (to be logged in.):", poe2_api.find_text({text = game_str.the_account_to_be_logged_in, UI_info = env.UI_info}))
                poe2_api.dbgp("find_test (packet with pid):", poe2_api.find_text({text = game_str.Unable_to_deserialise, UI_info = env.UI_info,min_x = 0}))
                env.is_game_exe = false
                env.login_state = nil
                env.speel_ip_number = 0
                env.switching_lines = 0
                env.account_state = nil
                env.time_out = 0
                env.error_kill = false
                
                env.hwrd_time = 0
                local pid = api_EnumProcess(process_name)
                
                if pid and next(pid) and pid[1]~=0 then
                    api_SetWindowState(env.game_window, 13)
                    env.game_window = 0
                    -- poe2_api.terminate_process(pid)
                    api_Sleep(10000)
                    return bret.RUNNING
                end
                
                -- error("关闭游戏===============")
                -- api_Sleep(5000)
                poe2_api.time_p("关闭游戏(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local elapsed_ms = (api_GetTickCount64()) - start_time
            poe2_api.dbgp("判断是否关闭游戏:"..string.format( elapsed_ms))
             -- 加载中
            if poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.loading_screen_tip_label}) then
                env.last_exp_check = api_GetTickCount64()
                env.last_exception_time = 0
                env.need_SmallRetreat = false
                env.need_ReturnToTown = false
                env.enter_map_click_counter = 0
                env.sacrificial_refresh = 0
                env.have_ritual = false
                env.find_path_failure = 0
                env.stuck_monsters = nil
                env.is_dizhu = false
                env.dizhu_end = false
                env.click_grid_pos = false
                env.need_item = nil
                env.interaction_object = nil
                env.interactive = nil
                env.not_items_buy = false
                env.open_map_UI = false -- 重置地图UI信息
                env.not_need_take = 0 --要不要拿油
                env.take_still_times = 0 --拿油次数
                env.is_dizhu_times = 0 --油次数
                env.false_times = 0
                env.is_over = false 
                env.exp_add_bool = false
                local current_time = api_GetTickCount64()
                env.last_exception_time_move = 0.0
                env.last_exp_check_move = current_time
                if env.player_info and env.player_info.grid_x ~=0 then
                    env.last_exp_value = env.player_info.currentExperience
                    env.last_exp_value_move = env.player_info.currentExperience
                end
                poe2_api.dbgp("已重置所有经验监控状态") 
                api_Sleep(2000)
                env.switching_lines =  env.switching_lines + 1
                poe2_api.time_p("加载中(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            -- if poe2_api.find_text({text = "選擇一種位移類型",UI_info = env.UI_info}) then
            --     poe2_api.find_text({text = "滑鼠",UI_info = env.UI_info, click = 2})
            --     poe2_api.time_p("Join_Game_Otherworld(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
            --     return bret.RUNNING
            -- end
            elapsed_ms = (api_GetTickCount64()) - start_time
            poe2_api.dbgp("判断文本:"..string.format( elapsed_ms))
            if poe2_api.click_text_UI({text = game_str.life_orb,UI_info = env.UI_info})
             or poe2_api.click_text_UI({text = game_str.resume_game,UI_info = env.UI_info})
             or poe2_api.find_text({text = game_str.Wish_list,UI_info = env.UI_info,min_x = 0,min_y = 0,max_x = 400}) then
                local player_info = env.player_info
                local changer_leader = env.changer_leader
                env.kill_process = true
                env.switching_lines = 0
                if not env.config_exe then
                    local file = io.open(env.config_file, "r")
                    if file then
                        file:close()
                        if poe2_api.check_NCStorageLocalData_config(env.config_dir) then
                            poe2_api.print_log("游戏配置文件异常,需要关闭游戏")
                            env.is_set = true
                            poe2_api.time_p("游戏配置文件异常,需要关闭游戏(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        else
                            env.config_exe = true
                        end
                    end
                end
                
                if player_info and next(player_info) then
                    if poe2_api.table_contains(player_info.current_map_name_utf8,{game_str.MapAugury_MDANA,game_str.MapAugury_NoBoss_MDANA,"MapAzmerianRanges_NoBoss","MapAzmerianRanges",game_str.Abyss_Pinnacle_MDANA,"MapSeepage","MapSeepage_NoBoss"}) then
                    -- 自动刷新屏障开关接口(缺失) 开
                    api_UpdateMapObstacles(100)
                    poe2_api.dbgp("自动刷新屏障开关接口(缺失) 开==================")
                --    else
                --     -- 自动刷新屏障开关接口(缺失) 关
                --     api_UpdateMapObstacles(false)
                   end
                end
                poe2_api.dbgp("已进入游戏")
                -- 计算当前 Tick 耗时（毫秒）
                poe2_api.time_p("已进入游戏耗时(SUCCESS)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if poe2_api.find_text({UI_info = env.UI_info,text = game_str.Steam_Copy_Login_Request_TWCH,min_x = 0}) then
                poe2_api.find_text({text = game_str.confirm,UI_info = env.UI_info,min_x = 0,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            end
            if poe2_api.find_text({text = game_str.login_fail_text_list,UI_info = env.UI_info,min_x = 0}) then
                poe2_api.find_text({text = game_str.confirm,UI_info = env.UI_info,min_x = 0,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            end
            if poe2_api.find_text({UI_info = env.UI_info,text = game_str.IP_blocked_CH,min_x = 0}) then
                poe2_api.find_text({text = game_str.confirm,UI_info = env.UI_info,min_x = 0,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            end
            -- if poe2_api.find_text({text = "Steam：未連接到 Steam",UI_info = env.UI_info}) then
            --     poe2_api.find_text({text = game_str.confirm,UI_info = env.UI_info,min_x = 0,click = 2})
            --     api_Sleep(1000)
            --     return bret.RUNNING
            -- end

            if poe2_api.find_text({text = game_str.Server_maintenance,UI_info = env.UI_info,min_x = 0}) then
                api_Sleep(1000)
                error("服务器维护中,已停止运行")
            end
            if poe2_api.find_text({text = game_str.Account_banned,UI_info = env.UI_info}) then
                api_Sleep(1000)
                error("封号!!!")
            end
            if poe2_api.find_text({text = game_str.Login_error,UI_info = env.UI_info}) then
                api_Sleep(1000)
                error("账号或者密码错误")
            end
            if poe2_api.find_text({text = game_str.Official_login_error,UI_info = env.UI_info,min_x = 0}) then
                api_Sleep(1000)
                error("请手动处理邮箱验证")
            end
            if poe2_api.find_text({text = game_str.Account_Other_used,UI_info = env.UI_info}) then
                api_Sleep(1000)
                error("此帳號已被其他使用者登入。")
            end
            
            if poe2_api.find_text({text = game_str.first_log_text_list,UI_info = env.UI_info}) then
                poe2_api.find_text({text = game_str.confirm,UI_info = env.UI_info,min_x = 0,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            end
            if poe2_api.find_text({text = game_str.IP_blocked_EN,UI_info = env.UI_info}) then
                env.speel_ip_number = env.speel_ip_number + 1
                poe2_api.find_text({text = game_str.confirm,UI_info = env.UI_info,min_x = 0,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING       
            end
            if poe2_api.find_text({text = game_str.agree,UI_info = env.UI_info}) then
                poe2_api.find_text({text = game_str.agree,UI_info = env.UI_info,min_x = 0,add_x = 150,click = 2,times = 500})
                poe2_api.find_text({text = game_str.continue,UI_info = env.UI_info,min_x = 800,min_y = 450,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            end
            if poe2_api.find_text({text = game_str.Create_Account,UI_info = env.UI_info,min_x = 0,max_y = 790})
            or poe2_api.find_text({text = game_str.To_use_Steam_To_log_in,UI_info = env.UI_info,min_x = 0}) then
                poe2_api.find_text({text = game_str.Account_name,UI_info = env.UI_info,min_x = 0,add_x = 161,click = 2,times = 500})
                api_Sleep(500)
                local text = poe2_api.generate_random_string(math.random(8, 10))
                
                poe2_api.paste_text(text)
                api_Sleep(500)
                poe2_api.find_text({text = game_str.Account_name,UI_info = env.UI_info,min_x = 0,add_x = 110,add_y = 53,click = 2,times = 500})
                api_Sleep(500)
                return bret.RUNNING
            end
            local account = env.user_info["account"]
            local password = env.user_info["password"]
            if poe2_api.click_text_UI({text = game_str.username_textbox,UI_info = env.UI_info}) and not poe2_api.find_text({text = account,UI_info = env.UI_info,min_x = 646,min_y = 572,max_x = 953,max_y = 609}) then
                poe2_api.click_text_UI({text = game_str.username_textbox,UI_info = env.UI_info,click = 1})
                api_Sleep(500)
                poe2_api.paste_text(account)
                api_Sleep(500)
                return bret.RUNNING
            end
            if poe2_api.click_text_UI({text = game_str.password_textbox,UI_info = env.UI_info}) and not poe2_api.find_text({text = password,UI_info = env.UI_info,min_x = 646,min_y = 623,max_x = 953,max_y = 660}) then
                poe2_api.click_text_UI({text = game_str.password_textbox,UI_info = env.UI_info,click = 1})
                api_Sleep(500)
                poe2_api.paste_text(password)
                api_Sleep(500)
                return bret.RUNNING
            end
            if poe2_api.click_text_UI({text = game_str.login_button,UI_info = env.UI_info}) then
                poe2_api.find_text({text = game_str.log_in,UI_info = env.UI_info,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            end
            if poe2_api.find_text({text = game_str.Verified,UI_info = env.UI_info,min_x = 0})
            and poe2_api.find_text({text = game_str.Start_the_game,UI_info = env.UI_info}) then
                poe2_api.dbgp1("dsgvfsdvsdzvdv")
                poe2_api.click_keyboard("space")
                return bret.RUNNING
            end
            -- if poe2_api.find_text({text = "Standard",UI_info = env.UI_info}) then
            --     poe2_api.find_text({text = "Standard",UI_info = env.UI_info,click = 2,times = 500})
            --     api_Sleep(1000)
            --     return bret.RUNNING
            -- end
            -- 登入至城鎮或藏身處
            if poe2_api.find_text({text = game_str.Log_in_town_or_hideout,UI_info = env.UI_info}) then
                poe2_api.find_text({text = game_str.confirm,UI_info = env.UI_info, click = 2})
                api_Sleep(500)
                return bret.RUNNING
            end

            local creat_new_role = env.creat_new_role
            if poe2_api.find_text({text = game_str.Start_the_game,UI_info = env.UI_info}) 
            and not creat_new_role then
                if env.player_info_name and env.initiative_SmallRetreat then
                    local position = poe2_api.find_text({text = env.player_info_name,UI_info = env.UI_info, refresh = true, position = 1})
                    local hideout_button = {}
                    if position then
                        poe2_api.dbgp("找到角色名:",env.player_info_name)
                        local l = position[1] + 241
                        local t = position[2] - 10
                        local r = position[1] + 282
                        local b = position[2] + 35
                        hideout_button = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = l,min_y = t,max_x = r,max_y = b, round_rect = 15})
                    end
                    poe2_api.dbgp("hideout_button:")
                    poe2_api.printTable(hideout_button)
                    if not hideout_button or #hideout_button ~= 1 then
                        poe2_api.find_text({text = game_str.Start_the_game,UI_info = env.UI_info,click = 2,times = 500})
                        api_Sleep(1000)
                        return bret.RUNNING
                    else
                        poe2_api.dbgp("点击回城重生")
                        local x = (hideout_button[1].left + hideout_button[1].right) / 2
                        local y = (hideout_button[1].bottom + hideout_button[1].top) / 2
                        poe2_api.click_position(x, y)
                        api_Sleep(500)
                        return bret.RUNNING
                    end
                    poe2_api.dbgp("找到角色名:",env.player_info_name)
                    -- -- poe2_api.find_text({text = env.player_info_name,UI_info = env.UI_info,click = 2,times = 500, refresh = true})
                    -- while true do
                    --     api_Sleep(1000)
                    -- end
                    -- api_Sleep(1000)
                end
                poe2_api.find_text({text = game_str.Start_the_game,UI_info = env.UI_info,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            else
                poe2_api.find_text({text = game_str.Establish_roles,UI_info = env.UI_info,click = 2,times = 500})
                api_Sleep(1000)
                return bret.RUNNING
            end 
            poe2_api.dbgp("UI未找到任何元素") 
            return bret.RUNNING 
        end
    },

    -- 官方加入游戏
    Official_Join_Game = {
        run = function(self, env)
            poe2_api.print_log("通过官方渠道加入游戏...")
            local current_time = api_GetTickCount64()

            local function launch_poe2(game_path, game_dir)
                --[[
                专门用于启动Path of Exile 2的函数
                
                参数:
                    game_path: PoE2主程序路径
                    game_dir: PoE2安装目录
                返回:
                    bool: 启动是否成功
                ]]--
                
                -- 检查文件和目录是否存在
                local file = io.open(game_path, "r")
                if not file then
                    poe2_api.dbgp(string.format("游戏程序未找到: %s", game_path))
                    return false
                end
                file:close()
                
                -- 检查目录是否存在
                local dir_handle = io.popen('cd "'..game_dir..'" 2>&1')
                local dir_result = dir_handle:read("*a")
                dir_handle:close()
                if dir_result:find("系统找不到指定的路径") or dir_result:find("cannot find the path") then
                    poe2_api.dbgp(string.format("游戏目录未找到: %s", game_dir))
                    return false
                end
                
                -- 启动游戏
                
                local command = string.format('start "" /D "%s" "%s"', game_dir, game_path)
                local launch_ok = os.execute(command)
                
                -- 检查启动结果
                if launch_ok then
                    poe2_api.print_log("游戏启动成功")
                    return true
                else
                    poe2_api.dbgp(string.format("游戏启动失败: %s", launch_ok))
                    return false
                end
            end
            local function get_dirname(path)
                -- 处理 Windows 路径分隔符
                path = path:gsub("/", "\\")
                -- 移除末尾的斜杠（如果有）
                path = path:gsub("[\\/]+$", "")
                -- 获取最后一个斜杠之前的部分
                local dir = path:match("^(.*)[\\/]") or "."
                return dir
            end
            local launch_timeout = env.launch_timeout
            local game_path = env.user_info["gamedir"]
            local is_steam_version = string.find(game_path:lower(), "steam.exe")
            -- 判断官方/steam
            if is_steam_version then
                poe2_api.print_log("steam版本============================================")
                return bret.FAIL
            end
            if launch_timeout ~= 0 and launch_timeout then
                if os.time() - launch_timeout > 120 then
                    poe2_api.print_log("官方游戏启动超时2分钟，重新启动")
                    local pid = api_EnumProcess("PathOfExile.exe")
                    local game_window = api_FindWindowByProcess("","Path of Exile 2","PathOfExile.exe",0)
                    if pid and next(pid) and pid[1] ~= 0 and game_window and game_window ~= 0 then
                        api_SetWindowState(game_window, 13)
                        -- poe2_api.terminate_process(pid)
                        env.game_window = 0
                        env.hwrd_time = 0
                        api_Sleep(10000)
                        return bret.RUNNING
                    end
                    env.kill_process=false
                    env.launch_timeout = 0
                    return bret.RUNNING
                else 
                    poe2_api.print_log("等待游戏窗口")
                    return bret.RUNNING
                end
            end
            -- 判断游戏窗口
            -- local pid = nil
            local pid1 = false

            local window_handlesteam = api_FindWindowByProcess("","Path of Exile 2","PathOfExileSteam.exe",0)
            if window_handlesteam and window_handlesteam ~= 0 then
                pid1 = true
                
            end

            local window_handle = api_FindWindowByProcess("","Path of Exile 2","PathOfExile.exe",0)
            if window_handle and window_handle ~= 0 then
                pid1 = true
                
            end
            if pid1 then
                poe2_api.print_log("第一次启动,清理游戏进程")
                if window_handlesteam and window_handlesteam ~= 0 then
                    api_SetWindowState(window_handlesteam, 13)
                    env.game_window = 0
                    env.hwrd_time = 0
                    api_Sleep(10000)
                    return bret.RUNNING
                end
                if window_handle and window_handle ~= 0 then
                    api_SetWindowState(window_handle, 13)
                    env.game_window = 0
                    env.hwrd_time = 0
                    api_Sleep(10000)
                    return bret.RUNNING
                end
                -- poe2_api.terminate_process(pid)
                
            end

            -- 启动游戏
            local game_dir = get_dirname(game_path)
            local launch_result = launch_poe2(game_path, game_dir)
            if launch_result then
                poe2_api.print_log("游戏启动成功")
                if launch_timeout == 0 then
                    env.launch_timeout = os.time()
                end
                api_Sleep(5000)
            else
                poe2_api.print_log("游戏启动失败")
            end
            return bret.RUNNING
        end
    },

    -- 通过Steam启动游戏
    Launch_Game_Steam = {
        run = function(self, env)
            poe2_api.print_log("通过Steam启动游戏...")
            -- local login_state = env.login_state
            local game_path = env.user_info["gamedir"]
            if not self.last_time then
                self.last_time = 0
                return bret.RUNNING
            end
            poe2_api.dbgp("login_state: "..tostring(env.login_state))
            if not env.login_state then
                poe2_api.print_log("清空数据")
                env.kill_process=false
                env.game_window = 0
                env.hwrd_time = 0
                poe2_api.delete_steam_account_history(game_path)
                local steam_pid = api_EnumProcess("steam.exe")
                poe2_api.dbgp(tostring(#steam_pid.."==========================="))
                poe2_api.dbgp(tostring(steam_pid[1].."==========================="))
                -- for k, v in pairs(steam_pid) do
                --     poe2_api.dbgp(tostring(k) .. tostring(v))
                -- end
                poe2_api.dbgp("steam_pid: "..tostring(steam_pid))
                if steam_pid and next(steam_pid) and steam_pid[1] ~= 0 then
                    poe2_api.exec_cmd("taskkill /f /im steam.exe")
                    api_Sleep(2000)
                    return bret.RUNNING
                end
                local steamwebhelper_pid = api_EnumProcess("steamwebhelper.exe")
                poe2_api.dbgp(tostring(#steamwebhelper_pid.."===========================1111"))
                if steamwebhelper_pid and next(steamwebhelper_pid) and  steamwebhelper_pid[1] ~= 0 then
                    poe2_api.exec_cmd("taskkill /f /im steamwebhelper.exe")
                    api_Sleep(2000)
                    return bret.RUNNING
                end
                env.login_state = "启动登录窗口"
                if self.last_time == 0 then
                    self.last_time = os.time()
                end
                return bret.RUNNING
            end
            if env.login_state == "启动登录窗口" then
                -- local start_path = string.format("%s -applaunch %d", game_path, 2694490)
                local start_cmd = string.format('start "" "%s" -applaunch %d', game_path, 2694490)
                local steam_pid = api_EnumProcess("steam.exe")
                if not steam_pid or not next(steam_pid) or steam_pid[1] == 0 then
                    poe2_api.exec_cmd(start_cmd)
                    poe2_api.dbgp("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
                    api_Sleep(5000)
                    env.login_state = "等待登录窗口"
                    self.last_time = os.time()
                    return bret.RUNNING
                end
            end
            if env.login_state == "等待登录窗口" then
                local steam_login_hwnd = api_FindWindow("SDL_app", "登录 Steam",0)
                if steam_login_hwnd and steam_login_hwnd ~= 0 then
                    env.login_state = "输入帳號"
                    self.last_time = os.time()
                    return bret.RUNNING
                end
                poe2_api.print_log("等待登录窗口")
                if os.time() - self.last_time > 120 then
                    poe2_api.print_log("等待登录窗口超时")
                    env.login_state = nil
                    self.last_time = 0
                    return bret.RUNNING
                end
                api_Sleep(2000)
                return bret.RUNNING
            end
            if env.login_state == "输入帳號" then
                local account = env.user_info["account"]
                local password = env.user_info["password"]
                -- local steam_login_hwnd = api_FindWindow("Chrome_RenderWidgetHostHWND","Chrome Legacy Window",0)
                local steam_login_hwnd = api_FindWindow("SDL_app", "登录 Steam",0)
                -- poe2_api.dbgp("111:",steam_login_hwnd)
                -- api_Sleep(10000000)
                if steam_login_hwnd and steam_login_hwnd ~= 0 then
                    api_SetWindowState(steam_login_hwnd, 8)
                    api_Sleep(1000)
                    -- api_SetWindowState(steam_login_hwnd, 9)
                    -- api_Sleep(1000)
                    local left, top, right, bottom = api_GetWindowRect(steam_login_hwnd)
                    api_ClickScreen(poe2_api.toInt(left + 345),poe2_api.toInt(top + 140) , 1)
                    api_Sleep(1000)
                    poe2_api.paste_text(account)
                    api_Sleep(1000)
                    api_ClickScreen(poe2_api.toInt(left + 345), poe2_api.toInt(top + 206) , 1)
                    api_Sleep(1000)
                    poe2_api.paste_text(password)
                    api_Sleep(1000)
                    poe2_api.click_keyboard("enter",0)     
                    env.login_state = "等待steam主窗口"
                    self.last_time = os.time()
                    return bret.RUNNING

                else
                    poe2_api.print_log("登录窗口不存在")
                    env.login_state = nil
                    self.last_time = 0
                    return bret.RUNNING
                end
                
                -- 根据窗口句柄 获取窗口坐标
                return bret.RUNNING
            end
            if env.login_state == "等待steam主窗口" then
                poe2_api.print_log("等待steam主窗口")
                local steam_login_hwnd = api_FindWindowByProcess("","Steam","steamwebhelper.exe",0)
                if steam_login_hwnd and steam_login_hwnd ~= 0 then
                    env.login_state = "等待游戏窗口"
                    self.last_time = os.time()
                    return bret.RUNNING
                end
                if os.time() - self.last_time > 120 then
                    poe2_api.print_log("等待steam主窗口超时")
                    env.login_state = nil
                    self.last_time = 0
                    return bret.RUNNING
                end
                api_Sleep(2000)
                return bret.RUNNING
            end
            if env.login_state == "等待游戏窗口" then
                poe2_api.print_log("等待steam游戏窗口")
                if os.time() - self.last_time > 120 then
                    poe2_api.print_log("等待steam游戏窗口超时")
                    env.login_state = nil
                    self.last_time = 0
                    return bret.RUNNING
                end
                api_Sleep(2000)
                return bret.RUNNING
            end
            return bret.RUNNING
        end
    },

    -- 获取UI信息
    Get_UI_Info = {
        run = function(self, env)
            poe2_api.print_log("获取UI信息...")
            local start_time = api_GetTickCount64() -- 开始时间
            env.UI_info = UiElements:Update()
            -- poe2_api.printTable(env.UI_info)
            if #env.UI_info < 1 then
                api_Sleep(4000)
                return bret.RUNNING
            end
            -- poe2_api.dbgp("------------------")
            -- -- poe2_api.printTable(a)
            -- -- api_Sleep(4000)
            -- for _,k in ipairs(env.UI_info) do
            --     -- poe2_api.printTable(env.UI_info)
            --     -- if k.left > 977 
            --     if k.text_utf8 ~= "" then
            --         poe2_api.dbgp("------------------")
            --         poe2_api.dbgp(k.text_utf8)
            --         poe2_api.dbgp(k.left, k.right)
            --         poe2_api.dbgp(k.top, k.bottom)
            --     end
            -- end
            -- poe2_api.dbgp("------------------")
            poe2_api.time_p("Get_UI_Info... 耗时 --> ", api_GetTickCount64() - start_time)
            -- api_Sleep(4000)
            return bret.SUCCESS
        end
    },

    -- 获取信息
    Get_Info = {
        run = function(self, env)
            poe2_api.print_log("获取游戏信息...")
            local start_time = api_GetTickCount64() -- 开始时间

            -- local selectable_skills = api_GetSelectableSkillControls()
            -- local allskill_info = api_GetAllSkill()
            -- local skill_slots = api_GetSkillSlots()
            -- poe2_api.dbgp("1111")
            -- poe2_api.printTable(selectable_skills)
            -- poe2_api.dbgp("2222")
            -- poe2_api.printTable(allskill_info)
            -- poe2_api.dbgp("3333")
            -- poe2_api.printTable(skill_slots)

            local player_info_start_time = api_GetTickCount64()
            -- api_Log("+++++++++++++++++++++++++++++++++++++++++++++")
            env.player_info = api_GetLocalPlayer()
            local player_info_start_time = api_GetTickCount64()  -- 记录开始时间(毫秒)
            if not env.player_info_name and env.player_info and env.player_info.name_utf8 then
                env.player_info_name = env.player_info.name_utf8
            end

            -- if not self.player_info_last_check then
            --     self.player_info_last_check = player_info_start_time
            -- end
            -- if player_info_start_time - self.player_info_last_check > 5 or not env.player_info then 
            --     env.player_info = api_GetLocalPlayer()
            --     self.player_info_last_check = player_info_start_time
            --     -- if #env.player_info < 1 then
            --         -- poe2_api.dbgp("等待获取周围对象信息...")
            --     --     return bret.RUNNING
            --     -- end
            --     -- poe2_api.time_p("    获取周围对象信息... 耗时 --> ", api_GetTickCount64() - range_info_start_time)
            -- end
            -- poe2_api.printTable(env.player_info)
            -- api_Sleep(10000)
            
            -- api_Log(env.player_info.grid_x)
            -- api_Log(env.player_info.current_map_name_utf8)
            -- poe2_api.dbgp("player——pos ==>>", env.player_info.grid_x, env.player_info.grid_y)
            -- poe2_api.dbgp("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=")
            -- return bret.RUNNING
            if poe2_api.countTableItems(env.player_info) < 1 then
                poe2_api.dbgp("空人物信息")
                return bret.RUNNING
            end
            poe2_api.time_p("    获取人物信息... 耗时 --> ", api_GetTickCount64() - player_info_start_time)

            -- poe2_api.dbgp("死亡次数统计：", (env.death_times or 0))
            -- poe2_api.dbgp("开图次数统计：", (env.enter_map_times or 0))


            local range_info_start_time = api_GetTickCount64()  -- 记录开始时间(毫秒)
            if not self.last_check then
                self.last_check = range_info_start_time
            end
            if range_info_start_time - self.last_check > 5 or not env.range_info or #env.range_info < 1 then 
                env.range_info = Actors:Update()
                self.last_check = range_info_start_time
                if #env.range_info < 1 then
                    poe2_api.dbgp("等待获取周围对象信息...")
                    return bret.RUNNING
                end
                poe2_api.time_p("    获取周围对象信息... 耗时 --> ", api_GetTickCount64() - range_info_start_time)
            end
            
            -- api_GetMinimapActorInfo() - 获取小地图周围对象信息
            local current_map_info_start_time = api_GetTickCount64()
            env.current_map_info = api_GetMinimapActorInfo()
            
            -- if not env.current_map_info or not next(env.current_map_info) then
            --     poe2_api.dbgp("空小地图周围对象信息")
            --     return bret.RUNNING
            -- end
            -- poe2_api.dbgp("11111111111111111111111111")
            -- local a = poe2_api.get_sorted_list(env.current_map_info,env.player_info)
            -- for _,k in ipairs(a) do
            --     poe2_api.dbgp(k.name_utf8)
            --     poe2_api.dbgp(k.grid_x)
            --     poe2_api.dbgp(k.grid_y)
            --     poe2_api.dbgp(k.flagStatus)
            --     poe2_api.dbgp(k.flagStatus1)
            --     poe2_api.dbgp("==============================")
            -- end
            -- while true do
            --     api_Sleep(1000)
            -- end
            -- poe2_api.dbgp("22222222222222222222222222222222")
            -- poe2_api.printTable(env.current_map_info)
            poe2_api.time_p("    获取小地图周围对象信息... 耗时 --> ", api_GetTickCount64() - current_map_info_start_time)

            -- 周围装备信息
            local range_items_start_time = api_GetTickCount64()
            env.range_items = WorldItems:Update()
            -- poe2_api.printTable(env.range_items)
            poe2_api.time_p("    获取周围装备信息... 耗时 --> ", api_GetTickCount64() - range_items_start_time)
            
            -- 背包信息（主背包）
            local bag_info_start_time = api_GetTickCount64()
            env.bag_info = api_Getinventorys(1,0)
            -- poe2_api.printTable(env.bag_info)
            -- while true do
            --     api_Sleep(1000)
            -- end
            -- api_Sleep(10000)
            poe2_api.time_p("    获取背包信息信息... 耗时 --> ", api_GetTickCount64() - bag_info_start_time)

            local team_info_data_start_time = api_GetTickCount64()
            env.team_info = api_GetTeamInfo()
            poe2_api.time_p("    获取队伍信息信息... 耗时 --> ", api_GetTickCount64() - team_info_data_start_time)
            -- poe2_api.printTable(env.team_info)
            -- for _,i in ipairs(api_GetTeamInfo()) do
            --     poe2_api.dbgp("------------------")
            --     poe2_api.dbgp("i.roleStatus",i.roleStatus)
            --     poe2_api.dbgp("i.name_utf8",i.name_utf8)
            --     poe2_api.dbgp("i.current_map_name_utf8",i.current_map_name_utf8)
            -- end

            -- while true do
            --     api_Sleep(1000)
            -- end

            -- api_GetTeleportationPoint() - 获取传送点信息
            -- if not env.waypoint then
            --     local waypoint_start_time = api_GetTickCount64()
            --     env.waypoint = api_GetTeleportationPoint()
            --     poe2_api.printTable(env.waypoint)
            --     poe2_api.time_p("    获取传送点信息... 耗时 --> ", api_GetTickCount64() - waypoint_start_time)
            --     api_Sleep(1000000)
            -- end
            
            -- 测试函数
            local function dumpInventory(inventory)
                local itemFields = {
                    "name_utf8", "baseType_utf8", "start_x", "start_y", "end_x", "end_y",
                    "not_identified", "category_utf8", "color", "world_x", "world_y", "grid_x", "grid_y",
                    "skillGemLevel", "skillStoneLevel", "isWearable", "DemandStrength", "DemandAgility",
                    "DemandWisdom", "DemandLevel", "obj", "contaminated", "id", "tribute",
                    "totalDeferredConsumption", "fixedSuffixCount", "mods_obj", "stackCount"
                }
                
                for _, item in ipairs(inventory) do
                    api_Log("==============================")
                    -- local Suffix = api_GetObjectSuffix(item.mods_obj)
                    -- local Suffix1 = api_GetObjectSuffix(item.obj)
                    -- poe2_api.printTable(item.fixedSuffixCount)
                    -- poe2_api.printTable(Suffix)
                    -- poe2_api.printTable(Suffix1)
                    -- api_Log("Suffix")
                    -- api_Log(Suffix)
                    -- api_Log("Suffix1")
                    -- api_Log(Suffix1)
                    -- 遍历预定义的属性列表，确保按固定顺序输出
                    poe2_api.printTable(item)
                    -- for _, field in ipairs(itemFields) do
                    --     local value = item[field]
                    --     api_Log(string.format("%-25s: %s", field, tostring(value)))
                    -- end
                    
                    api_Log("----------------------------------")
                end
                
                api_Sleep(1000000)  -- 暂停程序（注意：长时间暂停可能导致游戏无响应）
            end

            -- 测试函数
            local function dumprange(inventory)
                inventory = poe2_api.get_sorted_list(inventory, env.player_info)
                for _, item in ipairs(inventory) do
                    
                    -- if item.name_utf8 == "" or item.life == 0 or not item.isActive then
                    --     goto continue
                    -- end
                    -- if item.name_utf8 == "" or item.life == 0 then
                    --     goto continue
                    -- end
                    if item.life == 0 then
                        goto continue
                    end
                    -- if item.type ~= 1 then
                    --     goto continue
                    -- end
                    if item.name_utf8 == "惡魔" then
                        goto continue
                    end
                    -- if item.MinimapIconActive ~= "Portal"then
                    --     goto continue
                    -- end
                    -- if item.name_utf8 == "" then
                    --     goto continue
                    -- end
                    api_Log("==============================")
                    -- 遍历预定义的属性列表，确保按固定顺序输出
                    -- for _, field in ipairs(itemFields) do
                    --     local value = item[field]
                    --     api_Log(string.format("%-25s: %s", field, tostring(value)))
                    -- end
                    poe2_api.printTable(item)
                    -- api_Log("====")
                    -- poe2_api.printTable(env.player_info)
                    dis1 = poe2_api.point_distance(item.grid_x, item.grid_y, {env.player_info.grid_x, env.player_info.grid_y})
                    api_ClickMove(item.grid_x, item.grid_y,0, item.world_z)
                    api_Log("dis-->>".. dis1)
                    -- GameCore_CastSkill(2231369792, item.id, 0, 0, 0, 0)
                    -- api_CastSkill(2231369792, 0, env.player_info.grid_x, env.player_info.grid_y, item.grid_x, item.grid_y)
                    api_Sleep(1000)
                    
                    api_Log("----------------------------------")
                    ::continue::
                end
                
                -- api_Sleep(1000000)  -- 暂停程序（注意：长时间暂停可能导致游戏无响应）
            end
            -- local pages = api_GetRepositoryPages(0)
            -- api_GetSkillSlots
            -- poe2_api.printTable(api_GetSelectableSkillControls())
            -- api_GetInventoryItemsInRect(5, 95, 545, 640)
            
            -- for _, page_info in ipairs(api_GetRepositoryPages(1)) do
            --     if page_info.type ~= 5 then
            --         poe2_api.printTable(api_Getinventorys(page_info.manage_index, 2))
            --     end
            -- end
            -- poe2_api.printTable(api_GetSkillSlots())

            -- id, title, progress, is_completed, rewards
            -- for _,i in ipairs(api_GetQuestList(1)) do
            --     poe2_api.dbgp("------------------")
            --     poe2_api.dbgp(i.id)
            --     poe2_api.dbgp(i.title)
            --     poe2_api.dbgp(i.progress)
            --     poe2_api.dbgp(i.is_completed)
            --     poe2_api.dbgp(i.rewards)
            -- end
            -- poe2_api.printTable(api_GetTeamInfo())
            -- for _,i in ipairs(api_GetTeamInfo()) do
            --     poe2_api.dbgp("------------------")
            --     poe2_api.dbgp("i.roleStatus",i.roleStatus)
            --     poe2_api.dbgp("i.name_utf8",i.name_utf8)
            --     poe2_api.dbgp("i.current_map_name_utf8",i.current_map_name_utf8)
            -- end

            -- poe2_api.dbgp("--=================================================----")
            -- -- poe2_api.printTable(a)
            -- api_EndgameNodeMove(0,0)
            -- api_Sleep(800)
            -- local a = poe2_api.get_map3({otherworld_info = api_GetEndgameMapNodes()})
            -- poe2_api.dbgp("==================================")
            -- while true do
            --     api_Sleep(1000)
            -- end 
            
            -- 调用函数
            -- dumpInventory(env.range_items)
            -- dumprange(env.range_info)
            -- poe2_api.dbgp("--=================================================----")
            -- poe2_api.dbgp("==================================")
            -- map_table = api_GetInventoryItemsInRect(15,268,545,640)
            -- poe2_api.printTable(map_table)
            -- -- -- api_Sleep(500000)
            -- local a = api_GetEndgameMapNodes()
            -- local point1, point2 = api_GetcurrentEndgameNodePoints()
            -- poe2_api.dbgp(point1, point2)
            -- api_Sleep(500)
            -- api_EndgameNodeMove(point1, point2)
            -- poe2_api.dbgp("==================================")
            -- -- poe2_api.dbgp("物品放置完成111111111111111")
            -- api_Sleep(10000) 

            -- 检查特定槽位(0 到 0 + 199) - 16进制表示
            -- for offset = 0x00, 0x00
            --  + 0xC7 do  -- 0xC7 = 199
            --     local slot_data = api_Getinventorys(offset, 0)
            --     if slot_data then
            --         poe2_api.dbgp("槽位:", string.format("0x%02X", offset))
            --         poe2_api.printTable(slot_data)
            --     end
            -- end
                        
            -- while true do
            --     api_Sleep(1000)
            -- end

            if env.wear_items == nil then
                env.wear_items = true
            end
            -- 其他物品栏信息（批量处理）
            if env.wear_items then
                local inventory_sections = {
                    {2, "item2"}, {3, "item3"}, {4, "item4"},
                    {5, "item5"}, {6, "item6"}, {7, "item7"},
                    {8, "item8"}, {9, "item9"}, {0xa, "item0xa"}, {0xb, "item0xb"}
                }
                for _, section in ipairs(inventory_sections) do
                    local section_id = section[1]
                    local section_name = section[2]
                    if not env[section_name] then
                        local items = api_Getinventorys(section_id,0)
                        env[section_name] = items
                    end
                end
                env.wear_items = false
            end

            poe2_api.time_p("Get_Info... 总耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 清理
    Clear = {
        run = function(self, env)
            poe2_api.print_log("执行清理...")
            local start_time = api_GetTickCount64()
            if not self.time then
                self.bool =false
                self.time = os.time()
                poe2_api.dbgp("初始化")
            end
            local player_info = env.player_info
            if not player_info or not next(player_info) then 
                poe2_api.dbgp("人物信息为空")
                return bret.RUNNING
            end 
            local current_map_info = env.current_map_info
            local function is_map_device(obj_list)
                if not obj_list or #obj_list == 0 then
                    return false
                end
                for _, i in ipairs(obj_list) do
                    if i.name_utf8 == game_str.MapDevice then
                        return true
                    end
                end
                return false
            end
            local map_device = is_map_device(current_map_info)
            if not string.match(player_info.current_map_name_utf8, game_str.town) 
            and (not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.hideout) or not map_device) then
                self.bool =false
                poe2_api.dbgp("不在城区")
                return bret.SUCCESS      
            end
            if not self.bool and  player_info.life ~= 0 and not poe2_api.click_text_UI({text=game_str.respawn_at_checkpoint_button,UI_info = env.UI_info,index = 1}) then
                if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.clear,min_x = 0 }) then
                    api_ClickMove(poe2_api.toInt(player_info.grid_x), poe2_api.toInt(player_info.grid_y),7)
                    api_Sleep(1000)
                    poe2_api.click_keyboard("enter",0)
                    api_Sleep(500)
                    poe2_api.paste_text(game_str.clear)
                    api_Sleep(500)
                    poe2_api.click_keyboard("enter",0)
                    api_Sleep(500)
                    self.bool = true
                    return bret.RUNNING
                end
            end  
            poe2_api.dbgp("完成")
            local elapsed_ms = (api_GetTickCount64()) - start_time
            poe2_api.time_p("执行清理... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 休息控制
    RestController = {
        run = function(self, env)
            poe2_api.print_log("执行休息控制...")
            poe2_api.dbgp("执行休息控制...")
            local start_time = api_GetTickCount64() -- 开始时间
            
            -- 初始化检查
            if not env._is_initialized_rest then
                poe2_api.dbgp("初始化休息控制器...")
                local config = env.user_config["全局設置"]["刷图通用設置"]["定時休息"] or {}
                
                -- 工作时间配置（单位：分钟→毫秒）
                local base_work = tonumber(config["運行時間"]) or 60  -- 默认60分钟
                local work_random_range = math.min(tonumber(config["工作時間隨機範圍"]) or 0.1, 0.3) -- 限制最大30%波动
                env.work_duration_ms_rest = math.floor(base_work * 60 * 1000 * (1 + (math.random() * work_random_range * 2 - work_random_range)))
                
                -- 休息时间配置（单位：分钟→毫秒）
                local base_rest = tonumber(config["休息時間"]) or 10  -- 默认10分钟
                local rest_random_range = math.min(tonumber(config["休息時間隨機範圍"]) or 0.1, 0.3) -- 限制最大30%波动
                env.rest_duration_ms_rest = math.floor(base_rest * 60 * 1000 * (1 + (math.random() * rest_random_range * 2 - rest_random_range)))

                -- 功能开关
                env.is_open_rest = config["是否開啟"] or false
                env.is_kill_game_rest = config["休息时是否关闭游戏"] or false
                
                -- 初始化状态（使用毫秒时间戳）
                local current_time_ms = api_GetTickCount64()
                env._is_resting_rest = false
                env._next_state_change_time_ms_rest = current_time_ms + env.work_duration_ms_rest
                env._last_update_time_ms_rest = current_time_ms
                env._is_initialized_rest = true
                
                poe2_api.dbgp("初始化完成 - 工作时间:%d分钟 休息时间:%d分钟", env.work_duration_ms_rest/(60*1000), env.rest_duration_ms_rest/(60*1000))
                return bret.RUNNING
            end

            -- 功能关闭直接返回成功
            if not env.is_open_rest then
                poe2_api.dbgp("休息功能未开启，直接返回SUCCESS")
                poe2_api.time_p("休息功能未开启... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            
            local current_time_ms = api_GetTickCount64()

            local function _perform_rest_actions()
                poe2_api.dbgp("执行休息操作...")
                if not (poe2_api.find_text({UI_info = env.UI_info, text = game_str.back_to_select}) or poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.exit_to_character_selection})) then
                    if poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.life_orb}) and poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.mana_orb}) then
                        poe2_api.click_keyboard("esc")
                    end
                end
                api_Sleep(1000)
            end

            local function _handle_state_transition()
                env._is_resting_rest = not env._is_resting_rest
                local duration_ms = env._is_resting_rest and env.rest_duration_ms_rest or env.work_duration_ms_rest
                env._next_state_change_time_ms_rest = current_time_ms + duration_ms
                env._last_update_time_ms_rest = current_time_ms
                
                -- 更新环境变量
                env.take_rest = env._is_resting_rest
                
                if env._is_resting_rest then
                    poe2_api.dbgp("切换到休息状态")
                    
                    local player_info = env.player_info
                    if not poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                        env.need_ReturnToTown = true
                        poe2_api.dbgp("不在藏身处，设置需要回城")
                        return bret.SUCCESS
                    end
                    
                    -- 进入休息状态
                    if env.is_kill_game_rest then
                        env.error_kill = true
                        poe2_api.dbgp("设置需要关闭游戏")
                    end
                    poe2_api.dbgp(string.format("工作时间到，开始休息 (%d分钟)", math.floor(env.rest_duration_ms_rest/(60*1000))))
                    -- _perform_rest_actions()
                    -- poe2_api.dbgp(string.format("工作时间到，开始休息 (%d分钟)", math.floor(env.rest_duration_ms_rest/(60*1000))))
                    -- api_Sleep(11000000)
                    return bret.RUNNING
                else
                    -- 返回工作状态
                    env.error_kill = false
                    poe2_api.dbgp(string.format("休息结束，开始工作 (%d分钟)",  math.floor(env.work_duration_ms_rest/(60*1000))))
                    env._is_initialized_rest = false
                    return bret.SUCCESS
                end
            end

            local function _update_status()
                local time_remaining_ms = math.max(0, env._next_state_change_time_ms_rest - current_time_ms)
                
                if env._is_resting_rest then
                    poe2_api.dbgp("当前处于休息状态")
                    local player_info = env.player_info
                    if not poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                        env.need_ReturnToTown = true
                        poe2_api.dbgp("不在藏身处，设置需要回城")
                        return bret.SUCCESS
                    end
                    
                    -- 休息状态更新（每分钟60000毫秒）
                    if current_time_ms - env._last_update_time_ms_rest >= 60000 then
                        env._last_update_time_ms_rest = current_time_ms
                        local mins = math.floor(time_remaining_ms/(60*1000))
                        local secs = math.floor((time_remaining_ms%(60*1000))/1000)
                        poe2_api.print_log(string.format("休息中... 剩余时间: %02d分%02d秒", mins, secs))
                        env.take_rest = true
                        
                        if not (poe2_api.find_text({UI_info = env.UI_info, text = game_str.back_to_select}) or 
                            poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.exit_to_character_selection})) and 
                            poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.life_orb}) and 
                            poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.mana_orb}) then
                            poe2_api.click_keyboard("esc")
                        end
                        api_Sleep(1000)
                    end
                    api_Sleep(2000)
                    return bret.RUNNING
                else
                    -- 工作状态更新（每5分钟300000毫秒）
                    if current_time_ms - env._last_update_time_ms_rest >= 300000 then
                        env._last_update_time_ms_rest = current_time_ms
                        local hours = math.floor(time_remaining_ms/(3600*1000))
                        local mins = math.floor((time_remaining_ms%(3600*1000))/(60*1000))
                        local secs = math.floor((time_remaining_ms%(60*1000))/1000)
                        poe2_api.print_log(string.format("工作中... 距离休息还有: %d小时%02d分钟%02d秒", hours, mins, secs))
                        env.take_rest = false
                    end
                    return bret.SUCCESS
                end
            end

            -- 状态切换检查（毫秒级比较）
            if current_time_ms >= env._next_state_change_time_ms_rest then
                poe2_api.dbgp("检测到状态切换时间到达")
                poe2_api.time_p("检测到状态切换时间到达... 耗时 --> ", api_GetTickCount64() - start_time)
                return _handle_state_transition()
            end
                
            -- 状态更新
            poe2_api.dbgp("更新当前状态...")
            poe2_api.time_p("更新当前状态... 耗时 --> ", api_GetTickCount64() - start_time)
            return _update_status()
        end
    },

    -- 小撤退
    SmallRetreat = {
        run = function(self, env)
            local current_time = api_GetTickCount64()
            
            local player_info = env.player_info
            if not env.need_SmallRetreat then
                poe2_api.dbgp("小退条件不满足")   
                self.error_kill_start_time = nil
                poe2_api.time_p("SmallRetreat... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
            if self.last_action_time == nil then
                self.init = true
                poe2_api.dbgp("初始化小撤退")
                self.last_action_time = 0 -- 记录上次操作时间
                self.action_interval = 2 -- 操作间隔时间
                self.error_kill_start_time = nil -- 超时计时器
            end
            local function reset_states()
                -- 统一状态重置方法
                local current_time = api_GetTickCount64()
                env.last_exception_time = 0
                env.last_exp_check = current_time
                env.last_exp_value = player_info.currentExperience
                -- logger.dbgp("已重置所有监控状态")
            end

            if not self.error_kill_start_time then
                self.error_kill_start_time = api_GetTickCount64()
            end
            -- 超时判断（10次点击约15秒）
            if self.error_kill_start_time and (current_time - self.error_kill_start_time) > 30*1000 then
                -- print("小退超时")
                env.error_kill = true
                self.error_kill_start_time = nil  -- 重置计时器
                env.need_SmallRetreat = false
                
                return bret.RUNNING
            else
                env.error_kill = false
            end
            if env.need_SmallRetreat then
                poe2_api.print_log("清路径111")
                env.path_list = {}
                
                if current_time - self.last_action_time >= self.action_interval then
                    -- # 点击返回
                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.back_to_select, click=2}) then
                        if self.error_kill_start_time == nil then
                            self.error_kill_start_time = current_time  --# 开始计时
                        end
                        api_Sleep(6000)
                        return bret.RUNNING
                    elseif poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.exit_to_character_selection, click=1 , index=1}) then
                        if self.error_kill_start_time == nil  then
                            self.error_kill_start_time = current_time
                        end
                        api_Sleep(6000)
                        return bret.RUNNING
                    end
                    -- # 打开选项菜单
                    if not (poe2_api.find_text({UI_info = env.UI_info,  text = game_str.back_to_select}) or 
                           poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.exit_to_character_selection})) and 
                           poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.life_orb}) and 
                           poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.mana_orb}) then
                        if self.error_kill_start_time == nil then
                            self.error_kill_start_time = current_time
                        end
                        poe2_api.click_keyboard("esc")
                        api_Sleep(1000)
                        self.last_action_time = current_time + 2
                        return bret.RUNNING
                    end
                    -- # 成功执行后重置超时计时器
                    self.error_kill_start_time = false
                    env.last_exp_check = current_time
                    self.last_exception_time = 0
                    env.need_SmallRetreat = false
                    reset_states()
                    return bret.RUNNING
                else
                    return bret.RUNNING
                end
            end
            return bret.SUCCESS
        end
    },

    -- 返回城镇
    ReturnToTown = {
        run = function(self, env)
            poe2_api.print_log("执行返回城镇...")
            poe2_api.dbgp("开始执行返回城镇")
            local current_time = api_GetTickCount64()
            local player_info = env.player_info
             
            local find_path_failure = env.find_path_failure or 0
            if not env.need_ReturnToTown or player_info.life == 0 then

                poe2_api.dbgp("返回城镇条件不满足") 
                self.current_time = current_time
                poe2_api.time_p("ReturnToTown... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end  
            nomarl_monster = poe2_api.is_have_mos({range_info = env.range_info, player_info = player_info, stuck_monsters = env.stuck_monsters})
            poe2_api.dbgp("nomarl_monster -- > ", nomarl_monster)

            if nomarl_monster then
                poe2_api.dbgp("返回城镇条件不满足") 
                self.current_time = current_time
                poe2_api.time_p("ReturnToTown... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end

            -- 初始化时间
            self.timeout = 20 * 1000 -- 超时时间（秒）
            if self.current_time == nil and env.need_ReturnToTown then
                poe2_api.dbgp("初始化返回城镇") -- 初始化时间
                self.current_time = current_time
                return bret.RUNNING
            end

            local function reset_states()
                -- 统一状态重置方法
                local current_time = api_GetTickCount64()
                env.last_exception_time_move = 0
                env.last_exp_check_move = current_time
                env.last_exp_value_move = env.player_info.currentExperience
                -- logger.dbgp("已重置所有经验监控状态")
            end

            local spcify_monsters = function()
                if env.range_info then
                    for _, monster in ipairs(env.range_info) do
                        if monster.name_utf8 == game_str.snake_king and monster.life > 0 then
                            return true
                        end
                    end
                end
                return false
            end
            -- 检查是否超时
            if (current_time - self.current_time) > self.timeout then
                poe2_api.dbgp("返回城镇超时")
                env.need_ReturnToTown = false
                env.need_SmallRetreat = true
                env.initiative_SmallRetreat = true
                return bret.RUNNING
            end

            if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8)  then
                poe2_api.dbgp("已返回城镇")
                env.need_ReturnToTown = false
                env.find_path_failure = 0
                return bret.SUCCESS
            end

            
            if self.last_action_time == nil then
                self.last_action_time = api_GetTickCount64()
                self.action_interval = 1000
                self.false_times = 0
                self.is_wait = false
                self.dq = 0
                return bret.RUNNING
            end

            
            if env.need_ReturnToTown or find_path_failure > 10 then
                if current_time - self.last_action_time >= self.action_interval then
                    poe2_api.print_log("清路径222")
                    env.path_list = {}
                    if find_path_failure > 10 then
                        env.is_map_complete = true
                    end
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.you_cannot_use_this_item_while_the_game_is_paused, min_x = 0}) then
                        poe2_api.dbgp("发现暂停")
                        poe2_api.dbgp1("dsgvsgbbgtyjngn")
                        poe2_api.click_keyboard("space")
                        api_Sleep(500)
                        if not poe2_api.find_text({text = game_str.clear, UI_info = env.UI_info, min_x = 0}) then
                            poe2_api.click_keyboard("enter")
                            api_Sleep(500)
                            poe2_api.paste_text(game_str.clear)
                            api_Sleep(500)
                            poe2_api.click_keyboard("enter")
                            api_Sleep(1000)
                            
                            return bret.RUNNING
                        end
                    end
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN, min_x = 0})  then
                        poe2_api.dbgp("发现恩賜之物")
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN, min_x = 0, click = 2, add_x = 272})
                        return bret.RUNNING
                    end
                    
                    if player_info.isInBossBattle then
                        poe2_api.dbgp("在boss战")
                        env.need_ReturnToTown = false
                        env.need_SmallRetreat = true
                        env.initiative_SmallRetreat = true
                        return bret.RUNNING
                    end
                    
                    if poe2_api.is_have_mos({range_info = env.range_info, player_info}) or spcify_monsters() then
                        poe2_api.dbgp("发现怪物")
                        return bret.SUCCESS
                    end
                    
                    if not string.find(player_info.current_map_name_utf8, game_str.town) and not poe2_api.table_contains(my_game_info.hideout_CH, player_info.current_map_name_utf8) then
                        if poe2_api.find_text({UI_info = env.UI_info,  text = game_str.teleportation, min_x = 700, max_y = 40, max_x = 830}) then
                            poe2_api.dbgp("发现传送")
                            poe2_api.dbgp1("dsgvfsdvsyuijytjnedrhgwsegdzvdv")
                            poe2_api.click_keyboard("space")
                            return bret.RUNNING
                        end
                        poe2_api.dbgp("回城")
                        for _, k in ipairs(env.range_info) do
                            if k.name_utf8 ~= '' and k.type == 5 and poe2_api.table_contains(my_game_info.hideout_CH, k.name_utf8) then
                                if poe2_api.point_distance(k.grid_x, k.grid_y, player_info) < 25 then
                                    poe2_api.dbgp("发现城镇UI")
                                    if not poe2_api.find_text({UI_info = env.UI_info, text = k.name_utf8, click = 2}) then
                                        poe2_api.dbgp("点击城镇UI失败")
                                        api_ClickMove(poe2_api.toInt(k.grid_x), poe2_api.toInt(k.grid_y), 7)
                                    end
                                    return bret.RUNNING
                                end
                            end
                        end
                        
                        -- 点击传送
                        poe2_api.dbgp("点击传送")
                        api_ClickMove(poe2_api.toInt(player_info.grid_x), poe2_api.toInt(player_info.grid_y), 7)
                        api_Sleep(500)
                        api_ClickScreen(1230, 815,0)
                        api_Sleep(200)
                        api_ClickScreen(1230, 815,1)
                        self.last_action_time = current_time + 2000
                        return bret.RUNNING
                    else
                        local point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 50)
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), 7)
                        end
                        
                        -- 仅在完全回城后重置状态
                        if string.find(player_info.current_map_name_utf8, game_str.town) or my_game_info.hideout[player_info.current_map_name_utf8] then
                            env.last_exp_check = api_GetTickCount64()
                            env.last_exception_time = 0
                            env.need_ReturnToTown = false
                            reset_states()
                            
                            return bret.SUCCESS
                        end
                        return bret.RUNNING
                    end
                end
                return bret.RUNNING
            end
            return bret.SUCCESS
        end
    },

    -- 检查长时间未增长经验
    Check_LongTime_EXP_Add = {
        run = function(self, env)
            poe2_api.print_log("开始执行长时间经验检查...")
            if not env.exp_add_bool then
                self.number = 0
                env.exp_add_bool = true
            end
            -- env.need_SmallRetreat = true
            -- while true do
            --     return bret.RUNNING
            -- end

            if (env.in_exchange or env.take_rest) and poe2_api.table_contains(env.player_info.current_map_name_utf8, my_game_info.hideout) then
                poe2_api.dbgp("通货兑换开启，跳过检测流程")
                return bret.SUCCESS
            end
            
            local current_time = api_GetTickCount64()
            local take_rest = env.take_rest
            local buy_items = env.buy_items
            local config = env.user_config
            local player_info = env.player_info
            
            --- 辅助函数
            -- 检查是否处于停滞移动状态
            local function _check_stagnant_movement(range)
                local last_pos = env.last_position
                local distance = poe2_api.point_distance(last_pos.x, last_pos.y, env.player_info)
                
                -- 更新位置记录
                env.last_position = {x = env.player_info.grid_x, y = env.player_info.grid_y}
                
                poe2_api.dbgp(string.format("移动距离检查: %.2f ", distance))
                if range and range > 0 then
                    return distance < range
                end
                return distance < 5
            end
            
            -- 检查至少有一个异常处理功能启用
            local function _check_feature_enabled()
                -- 经验相关功能
                local exp_town_enabled = config['全局設置']['異常處理']['沒有經驗回城']['是否開啟']
                local exp_retreat_enabled = config['全局設置']['異常處理']['沒有經驗小退']['是否開啟']
                
                -- 移动相关功能
                local move_town_enabled = config['全局設置']['異常處理']['不動回城']['是否開啟']
                local move_retreat_enabled = config['全局設置']['異常處理']['不動小退']['是否開啟']
                
                -- 任一功能启用即为true
                local enabled = exp_town_enabled or exp_retreat_enabled or move_town_enabled or move_retreat_enabled
                poe2_api.dbgp(string.format("功能启用检查 - 经验回城:%s, 经验小退:%s, 移动回城:%s, 移动小退:%s", 
                    tostring(exp_town_enabled), tostring(exp_retreat_enabled), 
                    tostring(move_town_enabled), tostring(move_retreat_enabled)))
                
                return enabled
            end

            -- 重置经验检查状态
            local function reset_states_exp()
                local current_time = api_GetTickCount64()
                env.last_exception_time = 0.0
                env.last_exp_check = current_time
                env.last_exp_value = env.player_info.currentExperience
                poe2_api.dbgp("已重置所有经验监控状态")
            end

            -- 重置移动检查状态
            local function reset_states_move()
                local current_time = api_GetTickCount64()
                env.last_exception_time_move = 0.0
                env.last_exp_check_move = current_time
                env.last_exp_value_move = env.player_info.currentExperience
                env.last_position = {x = env.player_info.grid_x, y = env.player_info.grid_y}
                poe2_api.dbgp("已重置所有移动监控状态")
            end

            -- 获取可交互对象
            local function get_range()
                
                -- 对范围对象进行排序
                local sorted_range = poe2_api.get_sorted_list(env.range_info, env.player_info)
                if not sorted_range then
                    poe2_api.dbgp("警告: 无法获取排序后的范围列表")
                    return false
                end

                -- 遍历查找符合条件的对象
                for _, obj in ipairs(sorted_range) do
                    if obj.name_utf8 and 
                    poe2_api.table_contains(game_str.exp_add_valid_objects, obj.name_utf8) and
                    obj.isActive and 
                    obj.is_selectable and
                    obj.grid_x and obj.grid_y then
                        
                        local distance = poe2_api.point_distance(obj.grid_x, obj.grid_y, player_info)
                        if distance then
                            poe2_api.dbgp(string.format("对象 %s 距离: %.2f", obj.name_utf8, distance))
                            
                            if distance <= 20 then
                                poe2_api.dbgp("找到符合条件的交互对象: ", obj.name_utf8)
                                return obj
                            end
                        end
                    end
                end
                
                poe2_api.dbgp("未找到符合条件的交互对象")
                return false
            end
            
            -- 执行移动恢复操作
            local function perform_movement_recovery()
                poe2_api.print_log("执行移动恢复操作...")
                
                -- 清空路径信息
                env.path_list = nil
                env.end_point = nil
                env.target_point = nil
                env.is_arrive_end = true

                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN, min_x = 0})  then
                    poe2_api.dbgp("发现恩賜之物")
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN, min_x = 0, click = 2, add_x = 272})
                    return bret.RUNNING
                end

                -- 随机移动到附近位置
                local point = api_FindRandomWalkablePosition(env.player_info.grid_x, env.player_info.grid_y, 50)
                if point then
                    api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), 7)
                end
                -- 按下空格键尝试恢复
                poe2_api.click_keyboard("space")
                api_Sleep(100)
                
                -- 尝试与附近可交互对象互动
                if env.range_info and player_info then
                    local target = get_range()
                    if target then
                        api_ClickMove(poe2_api.toInt(target.grid_x), poe2_api.toInt(target.grid_y), 0)
                        api_Sleep(500)
                        api_ClickMove(poe2_api.toInt(target.grid_x), poe2_api.toInt(target.grid_y), 1)
                        api_Sleep(500)
                        poe2_api.find_text({UI_info = env.UI_info, text = target.name_utf8, click = 2, refresh = true, min_x = 0})
                        api_Sleep(500)
                    end
                    
                    -- 随机移动到附近位置
                    local point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 50)
                    if point then
                        api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), 7)
                    end
                    api_Sleep(500)
                end
                
                -- 在藏身处额外执行移动
                if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                    local point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 50)
                    if point then
                        api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), 7)
                    end
                    api_Sleep(500)
                    poe2_api.click_keyboard("space")
                    api_Sleep(500)
                end
                
                -- 重置移动检查状态
                -- reset_states_move()
                poe2_api.print_log("移动恢复操作完成")
            end
            
            -- 每20秒按一次alt键
            if self.last_alt_press_time == nil or api_GetTickCount64() - self.last_alt_press_time >= 20000 and not poe2_api.find_text({UI_info = env.UI_info, text = game_str.Currency_exchange, min_x = 0, max_y = 200}) then
                poe2_api.dbgp("执行ALT键检查")
                api_ClickScreen(100, 850, 0)
                poe2_api.click_keyboard("alt")
                api_Sleep(100)
                poe2_api.click_keyboard("alt", 2)
                api_Sleep(100)
                poe2_api.click_keyboard("alt", 2)
                self.last_alt_press_time = api_GetTickCount64()
            end

            -- 初始化位置记录
            if not env.last_position then
                env.last_position = {x = env.player_info.grid_x, y = env.player_info.grid_y}
                return bret.RUNNING
            end

            -- 获取配置参数
            local no_exp_to_town = config['全局設置']['異常處理']['沒有經驗回城']['是否開啟']
            local no_exp_to_town_time = config['全局設置']['異常處理']['沒有經驗回城']['閾值'] * 60 * 1000
            if not no_exp_to_town then
                no_exp_to_town = true
                no_exp_to_town_time = 5 * 60 * 1000
            end

            local no_exp_to_change = config['全局設置']['異常處理']['沒有經驗小退']['是否開啟']
            local no_exp_to_change_time = config['全局設置']['異常處理']['沒有經驗小退']['閾值'] * 60 * 1000

            local no_move_to_town = config['全局設置']['異常處理']['不動回城']['是否開啟']
            local no_move_to_town_time = config['全局設置']['異常處理']['不動回城']['閾值'] * 1000
            if not no_move_to_town then
                no_move_to_town = true
                no_move_to_town_time = 3 * 60 * 1000
            end

            local no_move_to_change = config['全局設置']['異常處理']['不動小退']['是否開啟']
            local no_move_to_change_time = config['全局設置']['異常處理']['不動小退']['閾值'] * 1000

            -- 经验增长时重置状态
            if player_info.currentExperience ~= env.last_exp_value then
                poe2_api.dbgp("经验值变化，重置经验检查状态")
                reset_states_exp()
            end
            
            -- 初始化首次检查
            if env.last_exp_check == 0 or env.last_exp_check == nil then
                poe2_api.dbgp("初始化经验检查状态")
                env.last_exp_value = player_info.currentExperience
                env.last_exp_check = api_GetTickCount64()
                env.last_position = {x = env.player_info.grid_x, y = env.player_info.grid_y}
                return bret.SUCCESS
            end

            -- 根据场景设置不同的超时时间
            local space_time = 6
            local map_strenght = env.strengthened_map_obj
            local return_town = env.return_town
            
            if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0}) then
                    return bret.SUCCESS
                end
                space_time = 30
            elseif map_strenght then
                space_time = 120
            elseif return_town then
                space_time = 15
            elseif buy_items then
                space_time = 60
            end

            -- 计算真实停滞时间
            local real_stagnation_time = current_time - (env.last_exp_check or 0)
            local real_stagnation_time_move = current_time - (env.last_exp_check_move or 0)
            
            poe2_api.dbgp(string.format("经验停滞时间: %.2f秒, 移动停滞时间: %.2f秒", real_stagnation_time / 1000, real_stagnation_time_move / 1000))
            -- poe2_api.dbgp("经验停滞fangunshijian ==> ", space_time)

            -- 处理长时间未移动情况（优化后的逻辑）
            if real_stagnation_time_move > space_time * 1000 then
                if env.boss_drop and not string.find(env.player_info.current_map_name_utf8, game_str.Delirium_) then
                    env.last_exp_check_move = api_GetTickCount64()
                    return bret.SUCCESS
                end
                
                -- 检查移动状态
                local is_stagnant = _check_stagnant_movement()
                poe2_api.dbgp("移动状态检查: ", is_stagnant and "停滞" or "正常移动")
                
                if is_stagnant then
                    poe2_api.dbgp(string.format("检测到移动停滞(%.2f秒 > %d秒)，执行恢复操作", real_stagnation_time_move / 1000, space_time))
                    
                    -- 只有在不需要小退或回城时才执行移动恢复
                    if not env.need_SmallRetreat and not env.need_ReturnToTown and not take_rest and self.number < 30 then
                        perform_movement_recovery()
                        self.number = self.number + 1
                        return bret.RUNNING
                    else
                        poe2_api.dbgp("已有回城或小退指令，跳过移动恢复")
                    end
                else
                    self.number = 0
                    -- 正常移动，重置移动检查状态
                    reset_states_move()
                end
            end

            -- 检查功能是否启用
            if not _check_feature_enabled() or string.find(env.player_info.current_map_name_utf8, game_str.Delirium_) then
                poe2_api.dbgp("所有异常处理功能未启用，跳过检测流程")
                return bret.SUCCESS
            end

            -- 检查触发条件
            local trigger_town = nil
            local trigger_retreat = nil
            local trigger_town_move = nil
            local trigger_retreat_move = nil
            
            if no_exp_to_town then
                local town_th = no_exp_to_town_time or math.huge
                trigger_town = real_stagnation_time >= town_th
                poe2_api.dbgp(string.format("经验回城检查: %.2f >= %.2f = %s", 
                    real_stagnation_time, town_th, tostring(trigger_town)))
            end
            
            if no_exp_to_change then
                local retreat_th = no_exp_to_change_time or math.huge
                trigger_retreat = real_stagnation_time >= retreat_th
                poe2_api.dbgp(string.format("经验小退检查: %.2f >= %.2f = %s", 
                    real_stagnation_time, retreat_th, tostring(trigger_retreat)))
            end

            if no_move_to_town then
                local town_th_move = no_move_to_town_time or math.huge
                trigger_town_move = real_stagnation_time_move >= town_th_move
                poe2_api.dbgp(string.format("移动回城检查: %.2f >= %.2f = %s", 
                    real_stagnation_time_move, town_th_move, tostring(trigger_town_move)))
            end
            
            if no_move_to_change then
                local retreat_th_move = no_move_to_change_time or math.huge
                trigger_retreat_move = real_stagnation_time_move >= retreat_th_move
                poe2_api.dbgp(string.format("移动小退检查: %.2f >= %.2f = %s", 
                    real_stagnation_time_move, retreat_th_move, tostring(trigger_retreat_move)))
            end

            -- 处理触发条件（优化后的优先级逻辑）
            if trigger_town or trigger_retreat or trigger_town_move or trigger_retreat_move then
                poe2_api.dbgp(string.format("触发异常处理条件 - 经验停滞:%.2f秒, 移动停滞:%.2f秒", 
                    real_stagnation_time / 1000, real_stagnation_time_move / 1000))
                
                -- 优先级：回城 > 小退
                local should_return_town = (trigger_town and no_exp_to_town) or (trigger_town_move and no_move_to_town)
                local should_retreat = (trigger_retreat and no_exp_to_change) or (trigger_retreat_move and no_move_to_change)
                
                if should_return_town then
                    if not poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                        env.is_map_complete = true
                        env.need_ReturnToTown = true
                        poe2_api.print_log("触发回城条件 - 长时间无经验或无移动")
                        return bret.SUCCESS
                    else
                        poe2_api.dbgp("已在藏身处，跳过回城")
                    end
                end
                
                if should_retreat then
                    env.is_map_complete = true
                    env.need_SmallRetreat = true
                    env.initiative_SmallRetreat = true
                    poe2_api.print_log("触发小退条件 - 长时间无经验或无移动")
                    return bret.SUCCESS
                end
            end
            
            poe2_api.time_p("Check_LongTime_EXP_Add(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
            return bret.SUCCESS
        end
    },

    -- 检查异界死亡
    Is_Deth_Otherworld = {
        run = function(self, env)
            poe2_api.print_log("死亡初始化(异界)")
            poe2_api.dbgp("死亡初始化(异界)")
            local start_time = api_GetTickCount64()
            local player_info = env.player_info
            
            if not self.respawn_wait_start then
                self.respawn_wait_start = 0
            end
            if not player_info then
                poe2_api.dbgp("玩家信息不存在，跳过死亡初始化")
                return bret.RUNNING
            end

            -- 初始化死亡统计相关状态
            if not self.death_state then
                self.death_state = {
                    last_life = env.player_info.life,  -- 假设初始生命值
                    is_counted = false
                }
            end
            
            -- 检测生命值从非0变为0（死亡事件）
            if self.death_state.last_life > 0 and player_info.life == 0 then
                if not self.death_state.is_counted then
                    env.death_times = (env.death_times or 0) + 1
                    self.death_state.is_counted = true
                    -- poe2_api.print_log("检测到死亡事件，当前死亡次数: " .. (env.death_times or 0))
                end
            -- 检测生命值从0变为非0（复活事件）
            elseif self.death_state.last_life == 0 and player_info.life > 0 then
                self.death_state.is_counted = false
                -- poe2_api.dbgp("玩家已复活，重置死亡计数状态")
            end

            -- local a = 0
            if player_info.life == 0 and poe2_api.find_text({UI_info = env.UI_info, text = game_str.death_text}) then
            -- if a == 0 then
                
                -- api_ClickScreen(point[1], point[2], 0)
                -- api_Sleep(1000)
                -- api_ClickScreen(point[1], point[2], 1)
                
                env.teleport =  nil
                env.area_list = {}
                env.is_need_check = false
                env.stuck_monsters = nil
                env.item_name = nil
                env.item_pos = nil
                env.check_all_points = false
                env.empty_path = false
                env.map_name = nil
                env.interactive = nil
                env.item_move = false
                env.item_end_point = {0, 0}
                env.attack_move = false
                env.ok = false
                env.not_need_wear = false
                env.currency_check = false
                env.sell_end_point = {0, 0}
                env.is_better = false
                env.mos_out = 0
                env.is_arrive_end = false
                env.not_need_pick = false
                env.is_not_ui = false
                env.no_item_wear = false
                env.my_role = nil
                env.is_set = false
                env.end_point = nil
                env.path_list = nil
                env.run_point = nil
                env.teleport_area = nil
                env.teleport = nil
                env.follow_role = nil
                env.one_other_map = nil
                env.need_item = nil
                env.center_radius = 0
                env.center_point = {}
                env.prestore_boss_list = {}

                -- poe2_api.printTable(env.team_info)
                if string.find(player_info.current_map_name_utf8,game_str.Abyss) and player_info.current_map_name_utf8 ~= game_str.Abyss_Pinnacle_MDANA and env.team_info and #env.team_info > 1 then
                -- if string.find(player_info.current_map_name_utf8,game_str.Abyss) then
                    env.abyss_relife = true
                    env.is_abyss_complete = true
                    if not poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.exit_to_character_selection, min_x = 0}) then
                        poe2_api.click_keyboard("esc")
                        api_Sleep(800)
                        return bret.RUNNING
                    end
                    poe2_api.dbgp("死亡初始化(异界)-->",game_str.exit_to_character_selection)
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.back_to_select, min_x = 0,click = 2})
                    api_Sleep(1000)
                    return bret.RUNNING
                else
                    env.abyss_relife = false
                    if poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.respawn_at_checkpoint_button}) then
                        poe2_api.dbgp1("rewyrejhgfdbnsdbvs")
                        poe2_api.click_keyboard("space")
                    end
                end

                poe2_api.dbgp("点击确认")
                poe2_api.find_text({UI_info = env.UI_info, text = game_str.confirm, click=2, min_x=0})
                api_ClickScreen(915, 490,1)
                local point = poe2_api.find_text({UI_info = env.UI_info, text = game_str.relife_text, min_x = 0, click = 2})
                if not point then
                    poe2_api.time_p("Is_Deth_Otherworld(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                
                
                if self.respawn_wait_start == 0 then
                    self.respawn_wait_start = api_GetTickCount64()
                    return bret.RUNNING
                elseif api_GetTickCount64() - self.respawn_wait_start < 2 then
                    return bret.RUNNING
                else
                    self.respawn_wait_start = 0
                end
            end
            poe2_api.time_p("Is_Deth_Otherworld... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 检查低血量/蓝量
    CheckLowHpMp_Otherworld = {
        run = function(self, env)
            local start_time = api_GetTickCount64()
            poe2_api.dbgp("开始执行蓝血检查:")
            
            local player = env.player_info
            local prot = env.protection_settings
            local emerg = env.emergency_settings
            
            -- 初始化计时器（如果不存在）
            if self.last_health_recovery_time == nil then
                self.last_health_recovery_time = api_GetTickCount64()
                self.last_mana_recovery_time = api_GetTickCount64()
                self.last_shield_recovery_time = api_GetTickCount64()
                self._emergency_cooldown = 0
                poe2_api.dbgp("初始化计时器完成")
            end
            
            -- 检查玩家信息
            if not player then
                poe2_api.dbgp("错误: 玩家信息为空")
                return bret.RUNNING
            end

            local function _handle_regular_recovery(player, prot, now)
                poe2_api.dbgp("开始处理常规恢复...")
                poe2_api.dbgp("当前生命值:", player.life, "/", player.max_life)
                poe2_api.dbgp("当前法力值:", player.mana, "/", player.max_mana)
                poe2_api.dbgp("当前护盾值:", player.shield, "/", player.max_shield)
                
                -- 血量恢复
                local hp_cfg = prot.health_recovery or {}
                if hp_cfg.enable then
                    local threshold = player.max_life * (hp_cfg.threshold / 100)
                    local interval = (hp_cfg.interval or 0) / 1000
                    
                    poe2_api.dbgp(string.format("血量检查: 当前 %.1f < 阈值 %.1f (%.1f%%) 且冷却 %.1fs >= 间隔 %.1fs", 
                        player.life, threshold, hp_cfg.threshold, 
                        start_time - self.last_health_recovery_time, interval))
                    
                    if player.life < threshold and now - self.last_health_recovery_time >= interval then
                        poe2_api.dbgp("触发血量恢复 - 按下1键")
                        poe2_api.click_keyboard("1")
                        self.last_health_recovery_time = now
                    end
                end
                
                -- 蓝量恢复
                local mp_cfg = prot.mana_recovery or {}
                if mp_cfg.enable then
                    local threshold = player.max_mana * (mp_cfg.threshold / 100)
                    local interval = (mp_cfg.interval or 0) / 1000
                    
                    poe2_api.dbgp(string.format("蓝量检查: 当前 %.1f < 阈值 %.1f (%.1f%%) 且冷却 %.1fs >= 间隔 %.1fs", 
                        player.mana, threshold, mp_cfg.threshold, 
                        now - self.last_mana_recovery_time, interval))
                    
                    if player.mana < threshold and now - self.last_mana_recovery_time >= interval then
                        poe2_api.dbgp("触发蓝量恢复 - 按下2键")
                        poe2_api.click_keyboard("2")
                        self.last_mana_recovery_time = now
                    end
                end
                
                -- 护盾恢复
                local shield_cfg = prot.shield_recovery or {}
                if shield_cfg.enable then
                    local threshold = player.max_shield * (shield_cfg.threshold / 100)
                    local interval = (shield_cfg.interval or 0) / 1000
                    
                    poe2_api.dbgp(string.format("护盾检查: 当前 %.1f < 阈值 %.1f (%.1f%%) 且冷却 %.1fs >= 间隔 %.1fs", 
                        player.shield, threshold, shield_cfg.threshold, 
                        now - self.last_shield_recovery_time, interval))
                    
                    if player.shield < threshold and now - self.last_shield_recovery_time >= interval then
                        poe2_api.dbgp("触发护盾恢复 - 按下1键")
                        poe2_api.click_keyboard("1")
                        self.last_shield_recovery_time = now
                    end
                end
                
                return bret.SUCCESS
            end
            
            -- 检查是否在安全区域
            if poe2_api.table_contains(my_game_info.hideout, player.current_map_name_utf8) or 
            string.find(player.current_map_name_utf8, game_str.town) then
                poe2_api.dbgp("在安全区域，跳过检查")
                return bret.SUCCESS
            end
            
            -- 处理常规恢复
            local regular_status = _handle_regular_recovery(player, prot, start_time)
            if regular_status ~= bret.SUCCESS then
                poe2_api.dbgp("常规恢复处理返回:", regular_status)
                return regular_status
            end

            poe2_api.time_p("CheckLowHpMp_Otherworld... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 逃跑 ------------------------------------------------------------------------------------------------
    Escape = {
        run = function(self, env)
            poe2_api.print_log("开始执行逃跑检查...")
            poe2_api.dbgp("开始执行逃跑检查...")
            local current_time = api_GetTickCount64()
            local start_time = current_time
            local now = current_time
            local player_info = env.player_info
            
            local emerg = env.emergency_settings
            local run_point = env.run_point
            local valid_monsters = env.valid_monsters
            local afoot_altar = env.afoot_altar
            
            if not player_info then
                poe2_api.dbgp("错误: 玩家信息为空")
                return bret.RUNNING
            end
            
            if player_info.isInBossBattle or afoot_altar then
                poe2_api.dbgp("在Boss战或祭坛中，跳过逃跑检查")
                return bret.SUCCESS
            end

            -- 检查祭坛
            -- local is_altar = _get_altar(range_info)
            -- if is_altar then
            --     poe2_api.dbgp("发现祭坛，检查周围怪物...")
            --     api_UpdateAutomaticUpdateBarrier(false)
            --     local dis = poe2_api.point_distance(is_altar.grid_x, is_altar.grid_y, player_info)
            --     if dis < 96 and _is_monster(range_info, player_info, 60, is_altar) then
            --         poe2_api.dbgp("祭坛附近有怪物，不执行逃跑")
            --         return bret.SUCCESS
            --     end
            -- end

            local function _is_monster(mate, dis, objter)
                for _, i in ipairs(env.range_info) do
                    if i.type == 1 and not i.is_friendly and i.life > 0 and 
                    not poe2_api.table_contains(my_game_info.not_attact_mons_CN_name, i.name_utf8) and 
                    i.isActive and not string.find(i.name_utf8, game_str.temple) and 
                    i.hasLineOfSight and i.is_selectable then
                        local dist1 = poe2_api.point_distance(mate.grid_x, mate.grid_y, {i.grid_x, i.grid_y})
                        local dist2 = poe2_api.point_distance(objter.grid_x, objter.grid_y, {i.grid_x, i.grid_y})
                        if dist1 and dist2 and dist1 <= dis and (not objter or dist2 > 99) then
                            poe2_api.dbgp(string.format("发现怪物: %s, 距离: %.1f", i.name_utf8, dist))
                            return i
                        end
                    end
                end
                return false
            end
    
            -- function _get_altar(range_info)
            --     for _, i in ipairs(range_info) do
            --         if i.path_name_utf8 == game_str.Ritual_PATH and 
            --         i.stateMachineList and i.stateMachineList.current_state == 2 and 
            --         i.stateMachineList.interaction_enabled == 0 then
            --             poe2_api.dbgp("发现祭坛")
            --             return i
            --         end
            --     end
            --     return nil
            -- end
    
            local function _handle_space_action(monster, space_time)
                poe2_api.dbgp("执行空格键躲避动作...")
                local player_info = api_GetLocalPlayer()
                if not player_info then
                    poe2_api.dbgp("错误: 获取玩家信息失败")
                    return
                end
                
                space_time = space_time or 1.5
                space_time = space_time / 1000
                
                if monster and api_GetTickCount64() - (self.last_space_time or 0) >= space_time and math.random() < 0.8 then
                    poe2_api.dbgp(string.format("躲避怪物: %s", monster.name_utf8))
                    local result = api_GetNextCirclePosition(
                        monster.grid_x, monster.grid_y, 
                        player_info.grid_x, player_info.grid_y, 80
                    )
                    api_ClickMove(result.x, result.y, 0)
                    api_Sleep(100)
                    poe2_api.dbgp1("xzvxbsgaesgfgbhfbs")
                    poe2_api.click_keyboard("space")
                    self.last_space_time = api_GetTickCount64() + math.random(-0.05, 0.05)
                end
            end
    
            local function _handle_regular_space(player, prot, now, run_point, valid_monsters)
                poe2_api.dbgp("处理常规逃跑逻辑...")
                local point = {}
                local current_time = api_GetTickCount64()
                
                -- 血量逃跑
                local hp_cfg = prot.low_health or {}
                if hp_cfg.enable then
                    local threshold = player.max_life * (hp_cfg.threshold / 100)
                    poe2_api.dbgp(string.format("血量逃跑检查: 当前 %.1f/%.1f, 阈值 %.1f", 
                        player.life, player.max_life, threshold))
                    
                    if player.life < threshold then
                        if not run_point then
                            poe2_api.dbgp("血量过低，寻找安全区域...")
                            local ret = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 60, 10, 0, 0.5)
                            if ret and ret.x ~= -1 and ret.y ~= -1 then
                                point = {ret.x, ret.y}
                            end
                            
                            if next(point) ~= nil then
                                poe2_api.dbgp("找到安全点，设置逃跑路径")
                                env.run_point = point
                            else
                                poe2_api.dbgp("未找到安全点，执行躲避动作")
                                _handle_space_action(valid_monsters)
                                return bret.RUNNING
                            end
                        else
                            poe2_api.dbgp("已有逃跑路径，设置终点")
                            env.end_point = run_point
                            return bret.FAIL
                        end
                    else
                        env.run_point = nil
                    end
                end
    
                -- 蓝量逃跑
                local mp_cfg = prot.low_mana or {}
                if mp_cfg.enable then
                    local threshold = player.max_mana * (mp_cfg.threshold / 100)
                    poe2_api.dbgp(string.format("蓝量逃跑检查: 当前 %.1f/%.1f, 阈值 %.1f", 
                        player.mana, player.max_mana, threshold))
                    
                    if player.mana < threshold then
                        poe2_api.dbgp("蓝量过低，寻找安全区域...")
                        if not run_point then
                            local ret = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 60, 10, 0, 0.5)
                            if ret and ret.x ~= -1 and ret.y ~= -1 then
                                point = {ret.x, ret.y}
                            end
                            
                            if next(point) ~= nil then
                                poe2_api.dbgp("找到安全点，设置逃跑路径")
                                env.end_point = point
                                return bret.FAIL
                            else
                                poe2_api.dbgp("未找到安全点，执行躲避动作")
                                _handle_space_action(valid_monsters)
                            end
                        else
                            poe2_api.dbgp("已有逃跑路径，设置终点")
                            env.end_point = run_point
                            return bret.FAIL
                        end
                    else
                        env.run_point = nil
                    end
                end
    
                -- 护盾逃跑
                local shield_cfg = prot.low_shield or {}
                if shield_cfg.enable then
                    local threshold = player.max_shield * (shield_cfg.threshold / 100)
                    poe2_api.dbgp(string.format("护盾逃跑检查: 当前 %.1f/%.1f, 阈值 %.1f", 
                        player.shield, player.max_shield, threshold))
                    
                    if player.shield < threshold then
                        poe2_api.dbgp("护盾过低，寻找安全区域...")
                        if not run_point then
                            local ret = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 60, 10, 0, 0.5)
                            if ret and ret.x ~= -1 and ret.y ~= -1 then
                                point = {ret.x, ret.y}
                            end
                            
                            if next(point) ~= nil then
                                poe2_api.dbgp("找到安全点，设置逃跑路径")
                                env.run_point = point
                            else
                                poe2_api.dbgp("未找到安全点，执行躲避动作")
                                _handle_space_action(valid_monsters)
                            end
                        else
                            poe2_api.dbgp("已有逃跑路径，设置终点")
                            env.end_point = run_point
                            return bret.FAIL
                        end
                    else
                        env.run_point = nil
                    end
                end
    
                return bret.SUCCESS
            end

            -- 处理常规逃跑
            poe2_api.dbgp("处理常规逃跑")
            local status = _handle_regular_space(player_info, emerg, now, run_point, valid_monsters)
            poe2_api.dbgp("常规逃跑处理返回状态:", status)
            if status and status ~= bret.SUCCESS then
                poe2_api.dbgp("常规逃跑处理返回状态:", status)
                return status
            end
            poe2_api.time_p("Escape... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 检查是否在主页面
    Not_Main_Page_Otherworld = {
        run = function(self, env)
            poe2_api.print_log("检查是否在主页面...")
            local strat_time = api_GetTickCount64()

            local current_map_info = env.current_map_info
            local player_info = env.player_info
            env.initiative_SmallRetreat = false
            
            -- if player_info then
            --     return bret.SUCCESS
            -- end
            if env.abyss_relife then
                return bret.SUCCESS
            end
            
            if poe2_api.find_text{UI_info = env.UI_info, text = game_str.Continue_Game, add_x = 0, add_y = 0, click = 2} then
                return bret.RUNNING
            end

            if poe2_api.find_text{UI_info = env.UI_info, text = game_str.Received_team_invitation} then
                poe2_api.find_text{UI_info = env.UI_info, text = game_str.Refuse, max_x = 1600, click = 2}
                return bret.RUNNING
            end

            local a = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 985,min_y = 5,max_x = 1034,max_y = 47})
            if poe2_api.find_text({UI_info = env.UI_info, text=game_str.Check_point, add_x = 213, max_y = 50}) and a and next(a) then
                poe2_api.find_text({UI_info = env.UI_info, text=game_str.Check_point, click=2, add_x = 213, max_y = 50})
                return bret.RUNNING
            end

            if  poe2_api.find_text{UI_info = env.UI_info, text = game_str.Wish_list,min_x = 0,min_y = 0} then
                poe2_api.click_keyboard("space")
                return bret.RUNNING
            end

            if player_info and poe2_api.table_contains(my_game_info.hideout,player_info.current_map_name_utf8) then
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Missions_text, click = 2}) then
                    api_Sleep(500)  -- Equivalent to time.Sleep(0.5)
                    return bret.RUNNING
                end

                if poe2_api.find_text({UI_info = env.UI_info,  text = game_str.teleportation, min_x = 700, max_y = 40, max_x = 830}) and (not env.interactive or ((type(env.interactive)== "string" and not poe2_api.table_contains(env.interactive,{game_str.Waypoint,game_str.Transfer_point_CH})) or type(env.interactive) ~= "string")) then
                    poe2_api.dbgp("发现传送")
                    poe2_api.click_keyboard("space")
                    return bret.RUNNING
                end

                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.You_can_t_throw_this_item, min_x = 0, min_y = 0}) then
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Reserved, min_x = 0, min_y = 0, click = 2})
                    return bret.RUNNING
                end

                local item = api_Getinventorys(0xd,0)
                if item and next(item) then
                    local width = item[1].end_x - item[1].start_x
                    local height = item[1].end_y - item[1].start_y
                    if poe2_api.table_contains(item[1].category_utf8,game_str.Item_category) then
                        poe2_api.dbgp("检测到物品，将执行点击操作111111")
                        local index_list ={2,3,4,5,6,7,8,9,0xa,0xb}
                        local point_list = {
                            [2] = {1320,250},
                            [3] = {1151,191},
                            [4] = {1493,191},
                            [5] = {1322,133},
                            [6] = {1410,201},
                            [7] = {1237,255},
                            [8] = {1410,255},
                            [9] = {1213,330},
                            [0xa] = {1431,330},
                            [0xb] = {1322,353},
                        }
                        local point = nil
                        for _, v in ipairs(index_list) do
                            if poe2_api.table_contains(v,{10,11}) then
                                v = string.format("0x%x", v)
                            end
                            local item_player = env["item"..v]
                            if item_player and next(item_player) then
                                if item[1].baseType_utf8 == item_player[1].baseType_utf8 
                                and item[1].DemandStrength == item_player[1].DemandStrength
                                and item[1].DemandAgility == item_player[1].DemandAgility
                                and item[1].DemandWisdom == item_player[1].DemandWisdom
                                and item[1].DemandLevel == item_player[1].DemandLevel
                                and item[1].not_identified == item_player[1].not_identified
                                and item[1].category_utf8 == item_player[1].category_utf8
                                and item[1].quality == item_player[1].quality
                                and item[1].sockets == item_player[1].sockets
                                and item[1].color == item_player[1].color then
                                    local current_item = api_Getinventorys(v,0)
                                    if current_item and next(current_item) then
                                        if current_item[1].baseType_utf8 == item_player[1].baseType_utf8 
                                        and current_item[1].DemandStrength == item_player[1].DemandStrength
                                        and current_item[1].DemandAgility == item_player[1].DemandAgility
                                        and current_item[1].DemandWisdom == item_player[1].DemandWisdom
                                        and current_item[1].DemandLevel == item_player[1].DemandLevel
                                        and current_item[1].not_identified == item_player[1].not_identified
                                        and current_item[1].category_utf8 == item_player[1].category_utf8
                                        and current_item[1].quality == item_player[1].quality
                                        and current_item[1].sockets == item_player[1].sockets
                                        and current_item[1].color == item_player[1].color then
                                        else
                                            point = point_list[v]
                                            break
                                        end
                                    else
                                        point = point_list[v]
                                        break
                                    end
                                end
                            else
                                point = point_list[v]
                                break
                            end
                        end
                        if point then
                            if poe2_api.find_text({text = game_str.backpack,UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                                api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                                api_Sleep(500)
                                poe2_api.time_p("开背包,城区附着... 耗时 --> ", api_GetTickCount64() - strat_time)
                                return bret.RUNNING
                            else
                                poe2_api.dbgp("开背包,城区附着")
                                poe2_api.click_keyboard("i")
                                api_Sleep(300)
                                poe2_api.time_p("开背包,城区附着1... 耗时 --> ", api_GetTickCount64() - strat_time)
                                return bret.RUNNING
                            end
                        end
                    end
                    local point = poe2_api.get_space_point({width = width, height = height, info = env.bag_info})
                    
                    poe2_api.dbgp(string.format("物品尺寸: 宽%d, 高%d", width, height))
                    poe2_api.dbgp(point[1],point[2])
                    if point then
                        poe2_api.dbgp(string.format("获取到空间点: (%d, %d)", poe2_api.toInt(point[1]), poe2_api.toInt(point[2])))
                        
                        if poe2_api.find_text({UI_info = env.UI_info, text = game_str.backpack,min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                            poe2_api.dbgp("检测到背包文字，将执行点击操作")
                            api_ClickScreen(point[1], point[2])
                            api_Sleep(100)
                            api_ClickScreen(point[1], point[2],1)
                            api_Sleep(500)
                        else
                            poe2_api.dbgp("未检测到背包文字，将按I键打开背包")
                            poe2_api.click_keyboard("i")
                            api_Sleep(500)
                        end
                        return bret.RUNNING
                    else
                        poe2_api.dbgp("警告: 无法获取物品空间点")
                    end
                end


                local item = api_Getinventorys(0xd,0)
                if item and #item > 0 then
                    local point = poe2_api.get_space_point({width = item[1].end_x - item[1].start_x,height = item[1].end_y - item[1].start_y})
                    if point then
                        if poe2_api.find_text({UI_info = env.UI_info, text = game_str.backpack, min_x = 1020}) then
                            api_ClickScreen(poe2_api.toInt(point[1]), poe2_api.toInt(point[2]),1)
                            api_Sleep(500)
                            return bret.RUNNING
                        else
                            poe2_api.click_keyboard("i")
                            api_Sleep(500)
                            return bret.RUNNING
                        end
                    end
                end
            end

            poe2_api.time_p("Not_Main_Page_Otherworld 耗时 -->", api_GetTickCount64() - strat_time)
            return bret.SUCCESS
        end
    },

    Set_Base_Skill1 = {
        run = function(self, env)
            return bret.SUCCESS
        end
    },

    -- 设置基础技能
    Set_Base_Skill= {
        run = function(self, env)
            poe2_api.print_log("设置基础技能...")
            poe2_api.dbgp("设置基础技能...")
            local start_time = api_GetTickCount64()

            if not self.is_initialized then
                poe2_api.dbgp("初始化设置基础技能")
                self.bool = false  -- 初始化时间戳
                self.bool1 = false
                self.is_initialized = true
            end

            local skill_location = function(skill_name, skill_pos, selectable_skills)
                if not selectable_skills then
                    return false
                end
                -- 获取指定位置
                poe2_api.dbgp("skill_location", skill_name, skill_pos, selectable_skills)
                local point = my_game_info.skill_pos[skill_pos]
                -- 将所有 text_utf8 属性的值存储在一个集合中
                local skill_names = {}
                for _, skill_control in ipairs(selectable_skills) do
                    if skill_control.text_utf8 then
                        skill_names[skill_control.text_utf8] = true
                    end
                end
                
                -- 检查 skill_name 是否在集合中
                if not skill_names[skill_name] then
                    return false
                end
                
                -- 遍历所有可选择的技能控件
                for _, skill_control in ipairs(selectable_skills) do
                    if skill_name == skill_control.text_utf8 then
                        -- 计算中间位置
                        local center_x = (skill_control.left + skill_control.right) / 2
                        local center_y = (skill_control.top + skill_control.bottom) / 2
                        
                        -- 检查位置是否在指定范围内
                        if point[1] - 5 < center_x and center_x < point[1] + 5 and 
                        point[2] - 5 < center_y and center_y < point[2] + 5 then
                            return true
                        end
                    end
                end
                return false
            end

            local get_move_skill = function(selectable_skills)
                poe2_api.dbgp("get_move_skill", selectable_skills)
                if not skill_location("", "MIDDLE", selectable_skills) then
                    return false
                end
                return true
            end
            
            local set_pos = function(skill_name, rom_x, rom_y, selectable_skills)
                poe2_api.dbgp("set_pos", skill_name, rom_x, rom_y, selectable_skills)
                if not selectable_skills then
                    return false
                end
                for _, k in ipairs(selectable_skills) do
                    if 1104 <= k.left and k.left <= 1597 and k.bottom <= 770 and skill_name == k.text_utf8 then
                        local center_x = (k.left + k.right) / 2 + rom_x
                        local center_y = (k.top + k.bottom) / 2 + rom_y
                        api_ClickScreen(math.floor(center_x), math.floor(center_y),1)
                        api_Sleep(500)
                        return true
                    end
                end
                return false
            end
            
            local cancel_left_skill = function(selectable_skills)
                poe2_api.dbgp("cancel_left_skill", selectable_skills)
                if not selectable_skills then
                    return false
                end
                for _, k in ipairs(selectable_skills) do
                    if 1277 <= k.left and k.left <= 1285 and k.top > 790 and k.bottom <= 832 and k.right < 1316 then
                        return true
                    end
                end
                return false
            end

            if not env.mouse_check then
                poe2_api.dbgp("mouse_check", mouse_check)
                poe2_api.time_p("mouse_check... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end

            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Continue_Game, click = 2}) then
                poe2_api.dbgp("发现'繼續遊戲'文本，点击处理中...")
                return bret.RUNNING
            end

            if not (poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.life_orb})
             or poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.resume_game})
             or poe2_api.find_text({text = game_str.Wish_list,UI_info = env.UI_info,min_x = 0,min_y = 0,max_x = 400})) then
                poe2_api.print_log("未找到游戏界面")
                return bret.RUNNING
            end
            if poe2_api.find_text({text = game_str.Wish_list,UI_info = env.UI_info,min_x = 0,min_y = 0,max_x = 400}) then
                poe2_api.click_keyboard("space")
                api_Sleep(500)
                return bret.RUNNING
            end
            poe2_api.dbgp("获取技能")
            local selectable_skills = api_GetSelectableSkillControls()
            local allskill_info = api_GetAllSkill()
            local skill_slots = api_GetSkillSlots()
            -- poe2_api.dbgp("1111")
            -- poe2_api.printTable(selectable_skills)
            -- poe2_api.dbgp("2222")
            -- poe2_api.printTable(allskill_info)
            -- poe2_api.dbgp("3333")
            -- poe2_api.printTable(skill_slots)
            
            if not selectable_skills then
                poe2_api.print_log("获取可选技能技能控件信息失败")
                return bret.RUNNING
            end
            if not allskill_info then
                poe2_api.print_log("获取全部技能信息失败")
                return bret.RUNNING
            end
            if not skill_slots then
                poe2_api.print_log("获取快捷栏技能信息失败")
                return bret.RUNNING
            end
            self.bool = cancel_left_skill( selectable_skills)
            self.bool1 = get_move_skill(selectable_skills)
            poe2_api.print_log("self.bool",self.bool)
            if not self.bool1 then
                poe2_api.dbgp("未设鼠标中键")
                if not set_pos("", 0, 0, selectable_skills) then
                    local point = my_game_info.skill_pos["MIDDLE"]
                    api_ClickScreen(math.floor(point[1]), math.floor(point[2]),1)
                    api_Sleep(500)
                end
                return bret.RUNNING
            end
            
            if self.bool then
                poe2_api.dbgp("取消鼠标左键技能")
                if not set_pos('', 50, 0, selectable_skills) then
                    local point = my_game_info.skill_pos["P"]
                    api_ClickScreen(math.floor(point[1]), math.floor(point[2]),1)
                    api_Sleep(500)
                end
                return bret.RUNNING
            end
            poe2_api.time_p("检查基础技能... 耗时 --> ", api_GetTickCount64() - start_time)
            env.mouse_check = false
            return bret.SUCCESS
        end
    },

    -- 使用任务道具
    Use_Task_Props = {
        run = function(self, env)
            poe2_api.print_log("使用任务道具...")
            local start_time = api_GetTickCount64()
            local bag = env.bag_info
            local player_info = env.player_info
            -- local current_map_info = env.current_map_info
            if not next(player_info) then
                return bret.RUNNING
            end
           
            local function is_props(bag)
                local text_list = game_str.Task_prop_text
                for _, i in ipairs(bag) do
                    if i.category_utf8 == game_str.QuestItem then
                        for _, v in ipairs(text_list) do
                            if string.match(i.baseType_utf8,v) then
                                return i
                            end
                            
                        end
                    end
                end
                return false
            end
            
            if bag and next(bag) then
                local props = is_props(bag)
                if props then
                    if not poe2_api.find_text({text = game_str.backpack, min_x = 1020, min_y = 32, max_x = 1600, max_y=78}) then
                        poe2_api.click_keyboard("i")
                        poe2_api.dbgp("关背包1")
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    local point = poe2_api.get_center_position({props.start_x,props.start_y},{props.end_x,props.end_y})
                    if point and next(point) then
                        poe2_api.right_click(point[1],point[2])
                        return bret.RUNNING 
                    end
                end
            end
            local elapsed_ms = (api_GetTickCount64()) - start_time
            poe2_api.dbgp("使用任务道具耗时:"..string.format( elapsed_ms))
            return bret.SUCCESS
        end
    },

    -- 对话分解NPC
    Dialogue_Break_Down_NPC = {
        run = function(self, env)
            poe2_api.dbgp("开始执行对话分解NPC...")
            local current_time = api_GetTickCount64()
            local bag_info = env.bag_info
            local player_info = env.player_info
            local config = env.user_config
            
            
            poe2_api.dbgp(string.format("当前地图: %s", player_info.current_map_name_utf8 or "未知"))
            poe2_api.dbgp(string.format("背包物品数量: %d", bag_info and #bag_info or 0))

            -- 不在藏身处直接返回
            if not poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                poe2_api.dbgp("不在藏身处，跳过分解流程")
                return bret.SUCCESS
            end
            
            local break_down = config["全局設置"]["刷图通用設置"]["是否分解暗金"]
            -- local break_down = fasle
            poe2_api.dbgp(string.format("分解暗金设置: %s", tostring(break_down)))
            
            -- 检查是否有可分解物品
            local function check_brak_items()
                poe2_api.dbgp("开始检查可分解物品...")
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        if poe2_api.table_contains(my_game_info.sell_list, item.category_utf8) and item.color ~= 0 then
                            poe2_api.dbgp(string.format("找到可分解物品: %s (类型: %s, 颜色: %d)", 
                                item.baseType_utf8 or "无名", item.category_utf8 or "无类型", item.color or -1))
                            return true
                        end
                    end
                end
                poe2_api.dbgp("未找到可分解物品")
                return false
            end
            
            
            poe2_api.dbgp("当前在藏身处")
            
            -- 获取物品配置信息
            local function get_items_config_info()
                poe2_api.dbgp("开始解析物品过滤配置...")
                local item_configs = config["物品過濾"] or {}
                local processed_configs = {}
                
                for i, cfg in ipairs(item_configs) do
                    -- poe2_api.dbgp(string.format("处理配置项 %d: 类型=%s, 基础类型=%s", 
                    --     i, cfg["類型"] or "无", cfg["基礎類型名"] or "无"))
                    
                    local processed = {
                        ["類型"] = cfg["類型"] and type(cfg["類型"]) == "table" and cfg["類型"] or {cfg["類型"]},
                        ["名稱模式"] = cfg["基礎類型名"] and cfg["基礎類型名"] == "全部物品" and "all" or "specific",
                        ["匹配名稱"] = cfg["基礎類型名"] and cfg["基礎類型名"] ~= "全部物品" and {cfg["基礎類型名"]} or {},
                        ["颜色"] = {}
                    }
                    
                    if cfg["白裝"] then table.insert(processed["颜色"], 0) end
                    if cfg["藍裝"] then table.insert(processed["颜色"], 1) end
                    if cfg["黃裝"] then table.insert(processed["颜色"], 2) end
                    if cfg["暗金"] then table.insert(processed["颜色"], 3) end
                    
                    processed["不撿"] = cfg["不撿"]
                    processed["等級"] = cfg["等級"]
                    processed["名稱"] = cfg["名稱"]
                    processed["quality"] = cfg["quality"]
                    processed["sockets"] = cfg["sockets"]
                    
                    -- poe2_api.dbgp(string.format("配置项 %d 处理结果: 不捡=%s, 颜色条件=%s", 
                    --     i, tostring(processed["不撿"]), table.concat(processed["颜色"], ",")))
                    
                    table.insert(processed_configs, processed)
                end
                return processed_configs
            end
            
            local processed_configs = get_items_config_info()
            poe2_api.dbgp(string.format("共加载 %d 条物品过滤规则", #processed_configs))
            
            -- 提取等级
            local function extract_level(text)
                local level = string.match(text, "階級%s*(%d+)")
                poe2_api.dbgp(string.format("从文本 '%s' 中提取等级: %s", text, level or "无"))
                return level and tonumber(level) or nil
            end
            
            -- 匹配物品
            local function match_item(item, cfg)
                poe2_api.dbgp(string.format("开始匹配物品: %s (类型: %s)", item.baseType_utf8 or "无名", item.category_utf8 or "无类型"))
                
                if not cfg["類型"][1] or item.category_utf8 ~= my_game_info.type_conversion[cfg["類型"][1]] then
                    -- poe2_api.dbgp("类型不匹配，跳过")
                    return false
                end
                
                -- 名称匹配
                if cfg["名稱模式"] == "specific" then
                    if not cfg["匹配名稱"][1] or not poe2_api.table_contains(cfg["匹配名稱"], item.baseType_utf8) then
                        -- poe2_api.dbgp("名称不匹配，跳过")
                        return false
                    end
                end
                
                -- 等级检查
                local level = cfg["等級"]
                if level then
                    local item_type = level["type"]
                    poe2_api.dbgp(string.format("等级检查: 类型=%s", item_type))
                    
                    if item.category_utf8 == game_str.Map_EN then
                        local map_level = extract_level(item.baseType_utf8)
                        if item_type == "exact" then
                            local item_level = level["value"]
                            if map_level and map_level < item_level - 3 then
                                poe2_api.dbgp(string.format("地图等级 %d 低于要求 %d，跳过", map_level, item_level))
                                return false
                            end
                        else
                            local min_level = level["min"]
                            local max_level = level["max"]
                            if map_level and (map_level < min_level or map_level > max_level) then
                                poe2_api.dbgp(string.format("地图等级 %d 不在范围 %d-%d 内，跳过", map_level, min_level, max_level))
                                return false
                            end
                        end
                    elseif poe2_api.table_contains({game_str.UncutSkillGem_EN, game_str.UncutReservationGem_EN, game_str.UncutReservationGem_EN}, item.category_utf8) then
                        if item_type == "exact" then
                            local item_level = level["value"]
                            if item.skillGemLevel and (item.skillGemLevel < item_level or item.skillGemLevel > item_level) then
                                poe2_api.dbgp(string.format("宝石等级 %d 不符合要求 %d，跳过", item.skillGemLevel or 0, item_level))
                                return false
                            end
                        else
                            local min_level = level["min"]
                            local max_level = level["max"]
                            if item.skillGemLevel and (item.skillGemLevel < min_level or item.skillGemLevel > max_level) then
                                poe2_api.dbgp(string.format("宝石等级 %d 不在范围 %d-%d 内，跳过", item.skillGemLevel or 0, min_level, max_level))
                                return false
                            end
                        end
                    else
                        if item_type == "exact" then
                            local item_level = level["value"]
                            if item.DemandLevel and item.DemandLevel < item_level - 3 then
                                poe2_api.dbgp(string.format("物品需求等级 %d 低于要求 %d，跳过", item.DemandLevel or 0, item_level))
                                return false
                            end
                        else
                            local min_level = level["min"]
                            local max_level = level["max"]
                            if item.DemandLevel and min_level and max_level and (item.DemandLevel < min_level or item.DemandLevel > max_level) then
                                poe2_api.dbgp(string.format("物品需求等级 %d 不在范围 %d-%d 内，跳过", item.DemandLevel or 0, min_level, max_level))
                                return false
                            end
                        end
                    end
                end

                -- 通货排除黄金
                if item.category_utf8 == game_str.StackableCurrency and poe2_api.table_contains(game_str.Gold, item.baseType_utf8) then
                    poe2_api.dbgp("排除黄金货币，跳过")
                    return false
                end
                
                -- 颜色检查
                -- poe2_api.printTable(cfg["颜色"])
                -- 只有当颜色表存在且不为空时才检查
                if cfg["颜色"] and next(cfg["颜色"]) then
                    if not poe2_api.table_contains(cfg["颜色"], item.color) then
                        poe2_api.dbgp(string.format("颜色 %d 不符合条件 %s，跳过", item.color or -1, table.concat(cfg["颜色"], ",")))
                        return false
                    end
                end

                -- 品质检查
                if cfg["quality"] and cfg["quality"] ~= "" and not item.contaminated then
                    if item.quality < tonumber(cfg["quality"]) then
                        poe2_api.dbgp(string.format("物品品质 %d 低于要求 %s，跳过", item.quality or 0, cfg["quality"]))
                        return false
                    end 
                end

                -- 孔数检查
                if cfg["sockets"] and cfg["sockets"] ~= "" and not item.contaminated then
                    if item.sockets < tonumber(cfg["sockets"]) then
                        poe2_api.dbgp(string.format("物品孔数 %d 低于要求 %s，跳过", item.sockets or 0, cfg["sockets"]))
                        return false
                    end 
                end
                
                poe2_api.dbgp("物品匹配成功")
                return true
            end
            
            -- 检查是否不拾取
            local function is_do_without_pick_up(item)
                poe2_api.dbgp(string.format("检查物品 %s 是否设置为不拾取", item.baseType_utf8 or "无名"))
                
                local item_key = nil
                for k, v in pairs(my_game_info.type_conversion) do
                    if v == item.category_utf8 then
                        item_key = k
                        break
                    end
                end
                
                if item_key then
                    for _, cfg in ipairs(processed_configs) do
                        if cfg["類型"][1] == item_key then
                            if cfg["不撿"] and (cfg["基礎類型名"] == "全部物品" or item.baseType_utf8 == cfg["基礎類型名"]) then
                                poe2_api.dbgp("物品设置为不拾取")
                                return true
                            end
                        end
                    end
                end
                return false
            end
            
            -- 获取不需要的物品列表
            local function get_not_item(items)
                poe2_api.dbgp("开始筛选不需要的物品...")
                local break_list = {}
                
                local function get_not(item)
                    poe2_api.dbgp(string.format("检查物品: %s (类型: %s, 颜色: %d)", 
                        item.baseType_utf8 or "无名", item.category_utf8 or "无类型", item.color or -1))
                    
                    if item.category_utf8 == game_str.QuestItem and item.baseType_utf8 == game_str.The_Book_of_Knowledge then
                        poe2_api.dbgp("知识之书，保留")
                        return false
                    end
                    
                    if is_do_without_pick_up(item) then
                        return true
                    end
                    
                    for _, cfg in ipairs(processed_configs) do
                        if match_item(item, cfg) then
                            if cfg["不撿"] then
                                poe2_api.dbgp("配置标记为不捡")
                                return true
                            end

                            -- 如果没有颜色配置，则视为"三无物品"，直接返回true(分解)
                            if not cfg["颜色"] or not next(cfg["颜色"]) then
                                poe2_api.dbgp("三无物品，分解")
                                return true
                            end
                            
                            if item.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                local index = {}
                                for _, i in ipairs(items) do
                                    if i.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                        table.insert(index, i)
                                    end
                                end
                                if #index > 2 then
                                    -- poe2_api.dbgp("知识卷轴超过2个，标记为分解")
                                    return true
                                end
                            end
                            
                            if poe2_api.table_contains(my_game_info.equip_type, item.category_utf8) and item.color > 0 and not item.not_identified then
                                local suffixes = api_GetObjectSuffix(item.mods_obj)
                                if not suffixes then
                                    poe2_api.dbgp("无词缀物品，标记为分解")
                                    return {item}
                                end
                                if not poe2_api.filter_item(item, suffixes, config["物品過濾"] or {}) then
                                    poe2_api.dbgp("词缀不符合要求，标记为分解")
                                    return true
                                end
                            end
                            
                            poe2_api.dbgp(item.name_utf8)
                            if cfg["名稱"] ~= "" and cfg["名稱"] ~= nil and item.name_utf8 ~= cfg["名稱"] then
                                poe2_api.dbgp("名稱不一樣，分解")
                                return true
                            end

                            -- 品质检查
                            if cfg["quality"] and cfg["quality"] ~= "" and not item.contaminated then
                                if item.quality < tonumber(cfg["quality"]) then
                                    poe2_api.dbgp(string.format("物品品质 %d 低于要求 %s，分解", item.quality or 0, cfg["quality"]))
                                    return true
                                end 
                            end

                            -- 孔数检查
                            if cfg["sockets"] and cfg["sockets"] ~= "" and not item.contaminated then
                                if item.sockets < tonumber(cfg["sockets"]) then
                                    poe2_api.dbgp(string.format("物品孔數 %d 低于要求 %s，分解", item.quality or 0, cfg["sockets"]))
                                    return true
                                end 
                            end

                            poe2_api.dbgp("物品符合保留条件")
                            return false
                        end
                    end
                    poe2_api.dbgp("无匹配配置，默认保留")
                    return true
                end
                
                if not items then
                    poe2_api.dbgp("无物品数据")
                    return false
                end
                
                for _, item in ipairs(items) do
                    if not poe2_api.table_contains(my_game_info.sell_list, item.category_utf8) and item.color ~= 3 then
                        poe2_api.dbgp(string.format("物品 %s 不在分解列表中，跳过", item.baseType_utf8 or "无名"))
                        goto continue
                    end
                    
                    if item.color == 0 then
                        poe2_api.dbgp("白色物品，跳过")
                        goto continue
                    end
                    
                    local is_dis = get_not(item)
                    if is_dis then
                        poe2_api.dbgp("添加到分解列表")
                        table.insert(break_list, item)
                    end
                    
                    ::continue::
                end
                
                poe2_api.dbgp(string.format("共找到 %d 件需要分解的物品", #break_list))
                return break_list
            end
            
            local break_list = nil
            if break_down and check_brak_items() then
                if bag_info then
                    break_list = get_not_item(bag_info)
                    if not break_list or #break_list == 0 then
                        poe2_api.dbgp("没有需要分解的物品")
                        if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Demon_dispelling_items}) and not env.is_shop and not env.full_map then
                            poe2_api.dbgp("发现祛魔物品界面且不在商店，点击关闭")
                            poe2_api.find_text({UI_info = env.UI_info, text = game_str.Goodbye, click = 2})
                            api_Sleep(100)
                            return bret.RUNNING
                        end
                        return bret.SUCCESS
                    end
                end
                if current_time - (self.last_action_time or 0) >= (self.action_interval or 1) then
                    poe2_api.dbgp("检查UI界面...")
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.The_recast_platform, min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, min_x = 0}) then
                        poe2_api.dbgp("发现重铸台界面，按空格关闭")
                        poe2_api.dbgp1("dasvdbfhdsgaga")
                        poe2_api.click_keyboard("space")
                        self.last_action_time = current_time
                        return bret.RUNNING
                    end
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Reset_talent_points, min_x = 0, max_y = 200}) then
                        poe2_api.dbgp("发现天赋重置界面，按空格关闭")
                        poe2_api.dbgp1("qdsfvdsgvsdgbdfbd")
                        poe2_api.click_keyboard("space")
                        self.last_action_time = current_time
                        return bret.RUNNING
                    end
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Purchase_or_sell, min_x = 0, max_x = 800}) then
                        poe2_api.dbgp("发现商店界面，按空格关闭")
                        poe2_api.dbgp1("fnbfgnfgjhndfnbdfb")
                        poe2_api.click_keyboard("space")
                        self.last_action_time = current_time
                        return bret.RUNNING
                    end
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Reset_talent_points, min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Return_the_Map_Talent, min_x = 0}) then
                        poe2_api.dbgp("发现天赋重置确认界面，点击'再会'")
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Goodbye, click = 2})
                        self.last_action_time = current_time
                        return bret.RUNNING
                    end

                    local interactive_npc = nil
                    local interactive_text = nil
                    -- if env.player_info.current_map_name_utf8 == game_str.G_Endgame_Town_MDANA then
                    --     interactive_npc = "時間建造者．凱亞祖利"
                    --     interactive_text = "時間建造者．凱亞祖利 的物品"
                    -- else
                    if env.player_info.current_map_name_utf8 == "G2_town" then
                        interactive_npc = game_str.Break_NPC1
                        interactive_text = game_str.Break_NPC1_Text
                    else
                        interactive_npc = game_str.Break_NPC
                        interactive_text = game_str.Break_NPC_Text
                    end
                    -- end

                    if not poe2_api.find_text({UI_info = env.UI_info, text = interactive_text, min_x = 0}) then
                        env.interactive = interactive_npc
                        map_obj = poe2_api.check_in_map(current_map_info,env.interactive)
                        range_obj = poe2_api.check_in_range(env.range_info, env.interactive)
                        target_obj = map_obj or range_obj or nil
                        poe2_api.dbgp(target_obj)
                        if target_obj then
                            distance = poe2_api.point_distance(target_obj.grid_x,target_obj.grid_y,player_info)
                            poe2_api.dbgp("distance",distance)
                            if distance and distance > 25 then
                                poe2_api.dbgp("交互",env.interactive)
                                return bret.FAIL
                            else
                                api_Sleep(1000)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.Demon_dispelling_items}) then
                                    poe2_api.find_text({UI_info = env.UI_info, text = interactive_npc,click=2, refresh = true})
                                    api_Sleep(500)
                                    return bret.RUNNING
                                else
                                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Demon_dispelling_items, click = 2})
                                    api_Sleep(500)
                                    -- api_Sleep(50000)
                                    return bret.RUNNING
                                end
                            end
                        else
                            poe2_api.dbgp("当前没有分解NPC")
                            return bret.FAIL
                        end
                    else
                        if break_list and #break_list > 0 then
                            poe2_api.dbgp("开始分解物品...")
                            for _, item in ipairs(break_list) do
                                poe2_api.dbgp(string.format("分解物品: %s", item.baseType_utf8 or "无名"))
                                poe2_api.ctrl_left_click_bag_items(item.obj, bag_info)
                                api_Sleep(200)
                            end
                            poe2_api.dbgp("点击确认分解")
                            poe2_api.find_text({UI_info = env.UI_info, text = game_str.Accept, min_x = 315, min_y = 719, max_x = 443, max_y = 752, click = 2})
                            api_Sleep(200)
                        end
                    end
                else
                    poe2_api.dbgp(string.format("操作冷却中，剩余时间: %.1f秒", 
                        (self.action_interval or 1) - (current_time - (self.last_action_time or 0))))
                end
                return bret.RUNNING
            else
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Demon_dispelling_items}) and not env.is_shop and not env.full_map then
                    poe2_api.dbgp("发现祛魔物品界面且不在商店，点击关闭")
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Goodbye, click = 2})
                    api_Sleep(100)
                    return bret.RUNNING
                end
                poe2_api.dbgp("无需分解操作")
                poe2_api.time_p("分解... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
        end
    },

    -- 检查是否获得牌匾
    Is_Get_Plaque = {
        run = function(self, env)
            poe2_api.print_log("检查是否获得牌匾...")
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.wait = false
                self.dq_time = nil
                self.index = 1
                self.bool = true
                poe2_api.time_p("检查是否获得牌匾初始化（RUNNING）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            
            local function is_get_plaque(bag_info)
                if not bag_info or #bag_info == 0 then
                    return false
                end
                -- 需要查找的碑牌名称集合
                local required_plaques = game_str.required_plaques
                -- 从bag_info中提取所有碑牌名称
                local found_plaques = {}
                for _, item in ipairs(bag_info) do
                    if item.baseType_utf8 then
                        found_plaques[item.baseType_utf8] = true
                    end
                end
                -- 检查是否包含所有required_plaques
                for plaque, _ in pairs(required_plaques) do
                    if not found_plaques[plaque] then
                        return false
                    end
                end
            end
            local function plaque_bag(bag_info)
                if not bag_info or #bag_info == 0 then
                    return false
                end
                local plaque_index = 0
                for _, v in pairs(bag_info) do
                    if v.category_utf8 == game_str.TowerAugmentation and poe2_api.table_contains(env.stone_order,v.baseType_utf8) then
                        plaque_index = plaque_index + 1
                    end
                end
                if plaque_index > 0 then
                    return plaque_index
                end
                return false
            end
            local function deep_equal_unordered(a, b)
                if type(a) ~= type(b) then return false end
                if type(a) ~= "table" then return a == b end
                if #a ~= #b then return false end
                
                -- 统计 a 的元素（支持嵌套 table）
                local count = {}
                for _, v in ipairs(a) do
                    local key = type(v) == "table" and table.concat(v, ",") or tostring(v)
                    count[key] = (count[key] or 0) + 1
                end
            
                -- 检查 b 的元素
                for _, v in ipairs(b) do
                    local key = type(v) == "table" and table.concat(v, ",") or tostring(v)
                    if not count[key] then return false end
                    count[key] = count[key] - 1
                end
            
                return true
            end
            local function get_bag_plaque_index(plaque_type)
                for i, v in ipairs(env.bag_info) do
                    if v.baseType_utf8 == plaque_type then
                        return true
                    end
                end
                return false
            end
            local function get_missing_plaque()
                local missing_plaque = {}
                -- poe2_api.dbgp(14141414141414)
                local inserted_plaques = api_Getinventorys(77,0)
                -- poe2_api.dbgp(13131313131313)
                -- poe2_api.printTable(inserted_plaques)
                if next(env.settings_cfg_plaque) then
                    -- poe2_api.dbgp(151515151515151)
                    for _, v1 in ipairs(env.settings_cfg_plaque) do
                        if not next(inserted_plaques) then
                            table.insert(missing_plaque,v1["基礎類型名"]) 
                        end
                        -- if not poe2_api.table_contains(v1["基礎類型名"],inserted_plaques) then

                        --     table.insert(missing_plaque,v1["基礎類型名"]) 

                        -- end
                        local a = false
                        for _, v2 in ipairs(inserted_plaques) do
                            if v2.baseType_utf8 == v1["基礎類型名"] then
                                a = true
                                break
                            end
                        end
                        if not a then
                            table.insert(missing_plaque,v1["基礎類型名"]) 
                        end
                    end
                else
                    -- poe2_api.dbgp(1717171717)
                    if not next(inserted_plaques) then
                        -- poe2_api.dbgp(181818181818)
                        missing_plaque = env.stone_order
                        return missing_plaque
                    end
                    -- poe2_api.dbgp(191919)
                    poe2_api.dbgp(#env.stone_order)
                    poe2_api.printTable(env.stone_order)
                    -- while true do
                    --     api_Sleep(1000)
                    -- end
                    for i, v in ipairs(env.stone_order) do
                        local a = false
                        -- poe2_api.dbgp(v)
                        -- poe2_api.dbgp(i)
                        -- poe2_api.dbgp(#env.stone_order)
                        -- poe2_api.printTable(env.stone_order)
                        -- poe2_api.dbgp(2020202020)
                        if inserted_plaques and next(inserted_plaques) then
                            -- poe2_api.dbgp(3434343434343)
                            for _, v2 in ipairs(inserted_plaques) do
                                if v2.baseType_utf8 == v then
                                    a = true
                                    break
                                end
                            end
                        end
                        -- poe2_api.dbgp(21212121212121212)
                        if not a then
                            -- poe2_api.dbgp(#missing_plaque)
                            table.insert(missing_plaque,v)
                            -- poe2_api.dbgp(#missing_plaque)
                            -- poe2_api.dbgp(#env.stone_order)  
                        end  
                    end
                    -- poe2_api.dbgp(29292929)
                end
                -- poe2_api.dbgp(161616161616161)
                return missing_plaque
                        
            end
            

            -- poe2_api.printTable(missing_plaque)
            -- poe2_api.printTable(env.not_dark_gold_plaque_list)
            -- poe2_api.printTable(env.not_exist_stone)
            local function get_warehouse_type(items_list,missing_plaque)
                local warehouse_type = nil
                local function warehouse_plaque_missing(a,b)
                    if not next(a) or not next(b) then
                        return false
                    end
                    local bool = false
                    for _, v in ipairs(a) do
                        if not poe2_api.table_contains(v,b) then
                            bool = true
                            break
                        end
                    end
                    if bool then
                        return false
                    end
                    return true
                end
                local function get_missing_plaque_dark_gold(itme_type)
                    local inserted_plaques = api_Getinventorys(77,0)
                    if next(inserted_plaques) then
                        for _, v in ipairs(inserted_plaques) do
                            if v.baseType_utf8 == itme_type and v.color == 3 then
                                return true
                            end
                        end
                    end
                    return false
                end
                for _, v in ipairs(env.stone_order) do
                    if next(env.settings_cfg_plaque) then
                        for _, v1 in ipairs(env.settings_cfg_plaque) do
                            if v == v1["基礎類型名"] then
                                if (poe2_api.table_contains(v,missing_plaque) or warehouse_plaque_missing(missing_plaque,env.not_exist_stone))  then
                                    if not get_bag_plaque_index(v1["基礎類型名"]) and not poe2_api.table_contains(env.not_exist_stone,v1["基礎類型名"]) then
                                        if next(v1["物品詞綴"]) then
                                            if (not next(env.not_dark_gold_plaque_list) or not poe2_api.table_contains(v1["基礎類型名"],env.not_dark_gold_plaque_list)) and not get_missing_plaque_dark_gold(v) then
                                                for _, v2 in ipairs(items_list) do
                                                    if v2["類型"] == "碑牌" and v2["存倉頁名"] and v2["存倉頁名"] ~= "" and v2["暗金"] and not v2["不撿"] then
                                                        if v2["基礎類型名"] == v1["基礎類型名"] then
                                                            if not v2["工會倉庫"] then
                                                                warehouse_type = {game_str.Warehouse_text,v2["存倉頁名"],v,0}
                                                                -- env.plaque_page = 
                                                            else
                                                                warehouse_type = {game_str.Guild_Warehouse_text,v2["存倉頁名"],v,0}
                                                                -- warehouse_type = game_str.Guild_Warehouse_text
                                                                -- env.plaque_page = v1["存倉頁名"]
                                                            end
                                                            return warehouse_type
                                                        elseif v2["基礎類型名"] == "全部物品" then
                                                            if not v2["工會倉庫"] then
                                                                warehouse_type = {game_str.Warehouse_text,v2["存倉頁名"],v,0}
                                                                -- env.plaque_page = 
                                                            else
                                                                warehouse_type = {game_str.Guild_Warehouse_text,v2["存倉頁名"],v,0}
                                                                -- warehouse_type = game_str.Guild_Warehouse_text
                                                                -- env.plaque_page = v1["存倉頁名"]
                                                            end
                                                            return warehouse_type
                                                        end  
                                                    end
                                                end
                                            else
                                                for _, v2 in ipairs(items_list) do
                                                    if v2["類型"] == "碑牌" and v2["存倉頁名"] and v2["存倉頁名"] ~= "" and (v2["白裝"] or v2["藍裝"] or v2["黃裝"]) and not v2["不撿"] then
                                                        if v1["基礎類型名"] == v2["基礎類型名"] then
                                                            if not v2["工會倉庫"] then
                                                                warehouse_type = {game_str.Warehouse_text,v2["存倉頁名"],v,1}
                                                                -- env.plaque_page = 
                                                            else
                                                                warehouse_type = {game_str.Guild_Warehouse_text,v2["存倉頁名"],v,1}
                                                                -- warehouse_type = game_str.Guild_Warehouse_text
                                                                -- env.plaque_page = v1["存倉頁名"]
                                                            end
                                                            return warehouse_type
                                                        else
                                                            if not v2["工會倉庫"] then
                                                                warehouse_type = {game_str.Warehouse_text,v2["存倉頁名"],v,1}
                                                                -- env.plaque_page = 
                                                            else
                                                                warehouse_type = {game_str.Guild_Warehouse_text,v2["存倉頁名"],v,1}
                                                                -- warehouse_type = game_str.Guild_Warehouse_text
                                                                -- env.plaque_page = v1["存倉頁名"]
                                                            end
                                                            return warehouse_type
                                                        end
                                                    end
                                                end
                                            end
                                        else
                                            for _, v2 in ipairs(items_list) do
                                                if v2["類型"] == "碑牌" and v2["存倉頁名"] and v2["存倉頁名"] ~= "" and (v2["白裝"] or v2["藍裝"] or v2["黃裝"]) and not v2["不撿"] then
                                                    if v1["基礎類型名"] == v2["基礎類型名"] then
                                                        if not v2["工會倉庫"] then
                                                            warehouse_type = {game_str.Warehouse_text,v2["存倉頁名"],v,1}
                                                            -- env.plaque_page = 
                                                        else
                                                            warehouse_type = {game_str.Guild_Warehouse_text,v2["存倉頁名"],v,1}
                                                            -- warehouse_type = game_str.Guild_Warehouse_text
                                                            -- env.plaque_page = v1["存倉頁名"]
                                                        end
                                                        return warehouse_type
                                                    else
                                                        if not v2["工會倉庫"] then
                                                            warehouse_type = {game_str.Warehouse_text,v2["存倉頁名"],v,1}
                                                            -- env.plaque_page = 
                                                        else
                                                            warehouse_type = {game_str.Guild_Warehouse_text,v2["存倉頁名"],v,1}
                                                            -- warehouse_type = game_str.Guild_Warehouse_text
                                                            -- env.plaque_page = v1["存倉頁名"]
                                                        end
                                                        return warehouse_type
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                                
                            end
                        end
                    -- else
                    --     for _, v2 in ipairs(items_list) do
                    --         if v2["類型"] == "碑牌" and v2["存倉頁名"] and v2["存倉頁名"] ~= "" and (v2["白裝"] or v2["藍裝"] or v2["黃裝"]) and not v2["不撿"] then
                    --             if v == v2["基礎類型名"] then
                    --                 if not v2["工會倉庫"] then
                    --                     warehouse_type = {game_str.Warehouse_text,v2["存倉頁名"],v,1}
                    --                     -- env.plaque_page = 
                    --                 else
                    --                     warehouse_type = {game_str.Guild_Warehouse_text,v2["存倉頁名"],v,1}
                    --                     -- warehouse_type = game_str.Guild_Warehouse_text
                    --                     -- env.plaque_page = v1["存倉頁名"]
                    --                 end
                    --                 return warehouse_type
                    --             else
                    --                 if not v2["工會倉庫"] then
                    --                     warehouse_type = {game_str.Warehouse_text,v2["存倉頁名"],v,1}
                    --                     -- env.plaque_page = 
                    --                 else
                    --                     warehouse_type = {game_str.Guild_Warehouse_text,v2["存倉頁名"],v,1}
                    --                     -- warehouse_type = game_str.Guild_Warehouse_text
                    --                     -- env.plaque_page = v1["存倉頁名"]
                    --                 end
                    --                 return warehouse_type
                    --             end
                    --         end
                    --     end
                    end
                end
                for _, v in ipairs(env.stone_order) do
                    if not poe2_api.table_contains(env.not_exist_stone,v) then
                        for _, v1 in ipairs(items_list) do
                            if v1["類型"] == "碑牌" and v1["存倉頁名"] and v1["存倉頁名"] ~= "" and (v1["白裝"] or v1["藍裝"] or v1["黃裝"]) and not v1["不撿"] then
                                if v["基礎類型名"] == v1["基礎類型名"] then
                                    if not v1["工會倉庫"] then
                                        warehouse_type = {game_str.Warehouse_text,v1["存倉頁名"],v,1}
                                        -- env.plaque_page = 
                                    else
                                        warehouse_type = {game_str.Guild_Warehouse_text,v1["存倉頁名"],v,1}
                                        -- warehouse_type = game_str.Guild_Warehouse_text
                                        -- env.plaque_page = v1["存倉頁名"]
                                    end
                                    return warehouse_type
                                else
                                    if not v1["工會倉庫"] then
                                        warehouse_type = {game_str.Warehouse_text,v1["存倉頁名"],v,1}
                                        -- env.plaque_page = 
                                    else
                                        warehouse_type = {game_str.Guild_Warehouse_text,v1["存倉頁名"],v,1}
                                        -- warehouse_type = game_str.Guild_Warehouse_text
                                        -- env.plaque_page = v1["存倉頁名"]
                                    end
                                    return warehouse_type
                                end
                            end
                        end
                    end
                end
                -- for _, v in ipairs(items_list) do
                --     if v["類型"] == "碑牌" and v["存倉頁名"] and v["存倉頁名"] ~= "" and (v["白裝"] or v["藍裝"] or v["黃裝"]) and not v["工會倉庫"] and not v["不撿"]then
                --         warehouse_type = game_str.Warehouse_text
                --     end
                -- end
                -- if not warehouse_type then
                --     for _, v in ipairs(items_list) do
                --         if v["類型"] == "碑牌" and v["存倉頁名"] and v["存倉頁名"] ~= "" and (v["白裝"] or v["藍裝"] or v["黃裝"]) and v["工會倉庫"] and not v["不撿"]then
                --             warehouse_type = game_str.Guild_Warehouse_text
                --         end
                --     end
                -- end
                return warehouse_type
                
            end
            local player_info = env.player_info
            local bag_info = env.bag_info
            
            if not next(player_info) then
                return bret.RUNNING
            end
            -- local current_map_info = env.current_map_info
            local not_exist_stone = env.not_exist_stone
            local pick_up_number = env.pick_up_number
            
            -- if not env.is_insert_stone then
            --     poe2_api.dbgp("不需要茶杯")
            --     poe2_api.time_p("检查是否获得牌匾（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
            --     return bret.SUCCESS
            -- end
            -- poe2_api.dbgp("1111111")
            if not next(env.stone_order) then
                poe2_api.dbgp("未设置碑牌顺序，不需要取碑")
                poe2_api.time_p("检查是否获得牌匾（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            -- poe2_api.dbgp("22222222")
            if not env.is_get_plaque then
                poe2_api.dbgp("不需要去呗")
                poe2_api.time_p("检查是否获得牌匾（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            -- poe2_api.dbgp("33333333")
            if not env.is_get_plaque_node then
                poe2_api.dbgp("不需要公仓去呗")
                poe2_api.time_p("检查是否获得牌匾（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            -- poe2_api.dbgp("4444444")
            if is_get_plaque(bag_info) then
                env.is_get_plaque_node = false
                poe2_api.dbgp("不需要公仓去呗1")
                -- api_Sleep(10000000)
                poe2_api.time_p("检查是否获得牌匾（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            -- poe2_api.dbgp("555555")
            local plaque_index = plaque_bag(bag_info)
            -- poe2_api.dbgp("66666666")
            if pick_up_number ~= 0 and plaque_index and plaque_index == pick_up_number then
                env.is_get_plaque_node = false
                poe2_api.dbgp("不需要公仓去呗2")
                -- api_Sleep(10000000)
                poe2_api.time_p("检查是否获得牌匾（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            -- poe2_api.dbgp("777777777")
            if deep_equal_unordered(env.stone_order,env.not_exist_stone) then
                -- poe2_api.printTable(env.stone_order)
                poe2_api.dbgp("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$")
                -- poe2_api.printTable(env.not_exist_stone)
                env.is_get_plaque_node = false
                poe2_api.dbgp("不需要公仓去呗3")
                -- api_Sleep(10000000)
                poe2_api.time_p("检查是否获得牌匾（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            -- poe2_api.dbgp("888888888")
            local items_info = poe2_api.get_items_config_info(env.user_config)
            -- poe2_api.dbgp("9999999")
            local missing_plaque = get_missing_plaque()
            -- poe2_api.dbgp("101010101")
            poe2_api.printTable(missing_plaque)
            -- poe2_api.dbgp("121212121212121")
            -- api_Sleep(5000)
            local warehouse_type = get_warehouse_type(items_info,missing_plaque)
            if not warehouse_type then
                env.is_get_plaque_node = false
                poe2_api.dbgp("不需要公仓去呗4")
                -- api_Sleep(10000000)
                poe2_api.time_p("检查是否获得牌匾（SUCCESS7）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            -- env.warehouse_type_interactive = warehouse_type
            env.warehouse_type_interactive = warehouse_type[1]
            env.plaque_page = warehouse_type[2]
            env.plaque_type = {warehouse_type[3],warehouse_type[4]}
            -- poe2_api.dbgp("warehouse_type_interactive:",warehouse_type[1])
            -- poe2_api.dbgp("plaque_page:",warehouse_type[2])
            -- poe2_api.dbgp("plaque_type:",warehouse_type[3],warehouse_type[4])
            poe2_api.time_p("检查是否获得牌匾（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end
    },

    -- 取碑牌
    Take_The_Stele = {
        run = function(self, env)
            poe2_api.print_log("取碑牌...")
            local start_time = api_GetTickCount64()
            local text = ""
            if env.warehouse_type_interactive == game_str.Warehouse_text then
                text = game_str.Warehouse
                if poe2_api.find_text({text = game_str.Emphasize_the_item,UI_info = env.UI_info,min_x = 250,min_y = 700}) 
                and poe2_api.find_text({text = game_str.Guild_Warehouse,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=78}) then
                    -- poe2_api.click_keyboard("space")
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Guild_Warehouse, min_x=0,min_y=32,max_x=381,max_y=78, click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("取碑牌（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            elseif env.warehouse_type_interactive == game_str.Guild_Warehouse_text then
                text = game_str.Guild_Warehouse
                if poe2_api.find_text({text = game_str.Emphasize_the_item,UI_info = env.UI_info,min_x = 250,min_y = 700}) 
                and poe2_api.find_text({text = game_str.Warehouse,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=78}) then
                    poe2_api.find_text({text = game_str.Warehouse,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=78,click = 2,add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("取碑牌（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            else
                error("碑牌未知的仓库类型")
            end
            if not poe2_api.find_text({text = game_str.Emphasize_the_item,UI_info = env.UI_info,min_x = 250,min_y = 700})  then
            -- and poe2_api.find_text({text = text,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=78}) then
                poe2_api.time_p("取碑牌（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            poe2_api.dbgp("去呗，到达仓库")
            if not self.bool then
                self.is_wait = false
                self.wait_item = nil
                self.type = nil
                self.current = 0
                self.bool = true
            end
            if self.current == 0 then
                self.current = api_GetTickCount64()
            end
            if api_GetTickCount64() - self.current > 5000 then
                self.type = nil
                self.current = 0
            end
            local config = env.user_config
            local stone_order = env.stone_order
            -- 获取碑牌影响数量
            local function get_number_after_text(text, target)
                -- 获取指定文本后面的数字
                -- @param text: 完整文本（table数组）
                -- @param target: 要查找的目标文本
                -- @return: 数字或nil
                
                if not text or not next(text) then
                    return nil
                end
                poe2_api.dbgp("vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv")
                -- poe2_api.printTable(text)
                for _, item in ipairs(text) do
                    -- 检查是否包含目标文本
                    if item.name_utf8 and string.find(item.name_utf8, target) then
                        -- 返回第一个value_list的值（假设是数字）
                        if next(item.value_list) and #item.value_list > 0 then
                            return item.value_list[1]
                        end
                    end
                end
                
                return nil
            end
            -- 判断仓库有无指定物品
            local function get_currency(currency_info,items)
                for _,item in ipairs(items) do
                    local plaque_list = {}
                    local plaque_list_dark_gold = {}
                    -- poe2_api.dbgp("item_name:",item)
                    -- poe2_api.dbgp("plaque_type[2]:",env.plaque_type[2])
                    -- poe2_api.dbgp("item_name:",item)
                    for _, v in ipairs(currency_info) do
                        -- poe2_api.dbgp("v.baseType_utf8:",v.baseType_utf8)
                        if v.baseType_utf8 == item then
                            if env.plaque_type[2] == 0 and v.color == 3 and v.name_utf8 ~= game_str.Great_Plan_TWCH  then -- 
                                table.insert(plaque_list_dark_gold,v)
                            elseif env.plaque_type[2] == 1 and v.color < 3 then
                                table.insert(plaque_list,v)
                            end
                        end   
                    end
                    if #plaque_list_dark_gold > 0 then
                        if #plaque_list_dark_gold > 1 then
                            for i, v in ipairs(plaque_list_dark_gold) do
                                for _, v1 in ipairs(env.settings_cfg_plaque) do
                                    if v.baseType_utf8 == v1["基礎類型名"] then
                                        for i, v2 in ipairs(v1["物品詞綴"]) do
                                            for _,v3 in ipairs(api_GetObjectSuffix(v.mods_obj)) do
                                                -- for _, itemMod in ipairs(item1.mods) do
                                                if v2 == v3.name_utf8 then
                                                    return v
                                                    -- if next(v3.value_list) then
                                                    --     -- max_index = get_num_max(modText,plaque_list)
                                                    --     -- if max_index <= v3.value_list[1] then
                                                    --     --     table.insert(matchedThisRound, item1)
                                                    --     --     break  -- 这个物品已经匹配，不用检查其他mods
                                                    --     -- end
                                                    --     table.insert(matchedThisRound, item1)
                                                    --     break
                                                    -- else
                                                    --     table.insert(matchedThisRound, item1)
                                                    --     break  -- 这个物品已经匹配，不用检查其他mods
                                                    -- end
                                                end
                                                -- end
                                            end
                                        end
                                    end
                                end
                                    -- if item == v["基礎類型名"] then
                                    --     if next(v["物品詞綴"]) then
                                    --         local results = {}  -- 最终匹配到的物品

                                    --         -- 按优先级顺序遍历 a 表
                                    --         for i, modText in ipairs(v["物品詞綴"]) do
                            end
                            -- local max_plaque = nil
                            -- local max_index = nil
                            -- local index = nil
                            -- for _, v1 in ipairs(plaque_list_dark_gold) do
                            --     poe2_api.dbgp("ddddddddddddddddddddddddddddddddddddddddddddddd")
                            --     -- if string.find(item,"總督的先行者碑牌") then
                            --     --     index = get_number_after_text(api_GetObjectSuffix(v1.mods_obj),"範圍內最多")
                            --     -- else
                            --     --     index = get_number_after_text(api_GetObjectSuffix(v1.mods_obj),"範圍內")
                            --     -- end
                            --     index = get_number_after_text(api_GetObjectSuffix(v1.mods_obj),"剩餘")
                            --     poe2_api.dbgp("index:",index)
                            --     -- api_Sleep(1000000)
                            --     if index then
                            --         if not max_index or index > max_index then
                            --             max_index = index
                            --             max_plaque = v1
                            --         end
                            --     end  
                            -- end
                            -- if max_plaque then
                            --     poe2_api.dbgp("max_plaque:",max_plaque.baseType_utf8)
                            --     -- api_Sleep(1000000)
                            --     return max_plaque
                            -- end
                        else
                            poe2_api.dbgp("max_plaque:",plaque_list_dark_gold[1].baseType_utf8)
                            -- api_Sleep(1000000)
                            return plaque_list_dark_gold[1]
                        end
                    end
                    poe2_api.dbgp("plaque_list:",#plaque_list)
                    if #plaque_list > 0 then
                        if #plaque_list > 1 then
                            local max_plaque = nil
                            local max_index = nil
                            local index = nil
                            local a = false
                            local plaque_zuiyou_list = {}
                            -- for _, v1 in ipairs(plaque_list) do
                                
                            -- end
                            -- local function get_zuiyou_cizhui(cfg,item_obj)
                            --     for _, v2 in ipairs(cfg) do
                            --         for _, v3 in ipairs(api_GetObjectSuffix(item_obj.mods_obj)) do
                            --             if v2 == v3.name_utf8 then
                            --                 -- table.insert(plaque_zuiyou_list,item_obj)
                            --                 return item_obj
                            --             end
                            --         end 
                            --     end
                            -- end
                            local function get_num_max(item_cizhui,item_list)
                                local max_plaque = nil
                                local max_index = nil
                                local index = nil
                                for _, v1 in ipairs(item_list) do
                                    for _,v3 in ipairs(api_GetObjectSuffix(v1.mods_obj)) do
                                    -- for _, itemMod in ipairs(item1.mods) do
                                        if item_cizhui == v3.name_utf8 and next(v3.value_list) then
                                            
                                            if not max_index or v3.value_list[1] > max_index then
                                                max_index = v3.value_list[1]
                                                -- max_plaque = v1
                                            end
                                        end
                                    end
                                end
                                if max_index then
                                    -- poe2_api.dbgp("max_plaque:",max_plaque.baseType_utf8)
                                    -- api_Sleep(1000000)
                                    return max_index
                                end
                            end
                            if next(env.settings_cfg_plaque) then
                                for _, v in ipairs(env.settings_cfg_plaque) do
                                    if item == v["基礎類型名"] then
                                        if next(v["物品詞綴"]) then
                                            local results = {}  -- 最终匹配到的物品

                                            -- 按优先级顺序遍历 a 表
                                            for i, modText in ipairs(v["物品詞綴"]) do
                                                local matchedThisRound = {}  -- 这一轮匹配到的物品
                                                
                                                -- 查找所有包含当前优先级词缀的物品
                                                -- 该类型所有物品表
                                                for _, item1 in ipairs(plaque_list) do
                                                    -- 该物品词缀标
                                                    for _,v3 in ipairs(api_GetObjectSuffix(item1.mods_obj)) do
                                                        -- for _, itemMod in ipairs(item1.mods) do
                                                        if modText == v3.name_utf8 then
                                                            if next(v3.value_list) then
                                                                -- max_index = get_num_max(modText,plaque_list)
                                                                -- if max_index <= v3.value_list[1] then
                                                                --     table.insert(matchedThisRound, item1)
                                                                --     break  -- 这个物品已经匹配，不用检查其他mods
                                                                -- end
                                                                table.insert(matchedThisRound, item1)
                                                                break
                                                            else
                                                                table.insert(matchedThisRound, item1)
                                                                break  -- 这个物品已经匹配，不用检查其他mods
                                                            end
                                                            
                                                            
                                                        end
                                                        -- end
                                                    end
                                                end
                                                
                                                -- 如果这一轮找到了物品，就返回这些物品，不再继续查找低优先级的词缀
                                                if #matchedThisRound > 0 then
                                                    if #matchedThisRound > 1 then
                                                        for i1, v5 in ipairs(v["物品詞綴"]) do
                                                            if i1>i then
                                                                local matchedThisRound1 = {}  -- 这一轮匹配到的物品
                                                
                                                                -- 查找所有包含当前优先级词缀的物品
                                                                -- 该类型所有物品表
                                                                for _, item1 in ipairs(matchedThisRound) do
                                                                    -- 该物品词缀标
                                                                    for _,v3 in ipairs(api_GetObjectSuffix(item1.mods_obj)) do
                                                                        -- for _, itemMod in ipairs(item1.mods) do
                                                                        if v5 == v3.name_utf8 then
                                                                            if next(v3.value_list) then
                                                                                -- max_index = get_num_max(v5,matchedThisRound)
                                                                                -- if max_index <= v3.value_list[1] then
                                                                                --     table.insert(matchedThisRound1, item1)
                                                                                --     break  -- 这个物品已经匹配，不用检查其他mods
                                                                                -- end
                                                                                table.insert(matchedThisRound1, item1)
                                                                                break
                                                                            else
                                                                                table.insert(matchedThisRound1, item1)
                                                                                break  -- 这个物品已经匹配，不用检查其他mods
                                                                            end
                                                                        end
                                                                        -- end
                                                                    end
                                                                end
                                                                if #matchedThisRound1 > 0 then
                                                                    

                                                                    return matchedThisRound1[1]
                                                                    -- if #matchedThisRound1 > 1 then

                                                                    -- else
                                                                    --     return matchedThisRound1[1]
                                                                    -- end
                                                                end
                                                            end
                                                        end
                                                        return matchedThisRound[1]
                                                        -- for _, v4 in ipairs(matchedThisRound) do
                                                        
                                                        -- end
                                                    else
                                                        return matchedThisRound[1]
                                                    end
                                                    
                                                    -- results = matchedThisRound
                                                    -- break
                                                end
                                            end
                                            -- if #results > 0 then

                                            --     -- return results

                                            -- end
                                            -- for _, v1 in ipairs(plaque_list) do
                                            --     if get_zuiyou_cizhui(v["物品詞綴"],v1) then
                                            --         table.insert(plaque_zuiyou_list,v1)
                                            --     end
                                            -- end
                                        end
                                    end
                                end
                                -- if #plaque_zuiyou_list > 0 then
                                    
                                -- end
                            end
                            if not a then
                                for _, v1 in ipairs(plaque_list) do
                                
                                    poe2_api.dbgp("ddddddddddddddddddddddddddddddddddddddddddddddd")
                                    -- if string.find(item,"總督的先行者碑牌") then
                                    --     index = get_number_after_text(api_GetObjectSuffix(v1.mods_obj),"範圍內最多")
                                    -- else
                                    --     index = get_number_after_text(api_GetObjectSuffix(v1.mods_obj),"範圍內")
                                    -- end
                                    index = get_number_after_text(api_GetObjectSuffix(v1.mods_obj),game_str.Remaining)
                                    poe2_api.dbgp("index:",index)
                                    -- api_Sleep(1000000)
                                    if index then
                                        if not max_index or index > max_index then
                                            max_index = index
                                            max_plaque = v1
                                        end
                                    end  
                                end
                                if max_plaque then
                                    poe2_api.dbgp("max_plaque:",max_plaque.baseType_utf8)
                                    -- api_Sleep(1000000)
                                    return max_plaque
                                end
                            end
                            
                        else
                            poe2_api.dbgp("max_plaque:",plaque_list[1].baseType_utf8)
                            -- api_Sleep(1000000)
                            return plaque_list[1]
                        end
                    end
                end
                return false
            end
            -- 获取背包中不存在的碑牌
            -- @param bag_info: 背包物品信息表
            -- @return: 缺失的碑牌名称表
            local function get_not_plaque(bag_info)
                -- 需要查找的碑牌名称集合
                local required_plaques = game_str.required_plaques
                
                -- 结果表
                local missing_plaques = {}
                
                if bag_info and next(bag_info) then
                    -- 从bag_info中提取所有碑牌名称
                    local found_plaques = {}
                    for _, item in ipairs(bag_info) do
                        if item.category_utf8 == game_str.TowerAugmentation and item.baseType_utf8 then
                            found_plaques[item.baseType_utf8] = true
                        end
                    end
                    
                    -- 检查哪些required_plaques不在found_plaques中
                    for _, plaque in ipairs(required_plaques) do
                        if not found_plaques[plaque] then
                            table.insert(missing_plaques, plaque)
                        end
                    end
                else
                    -- 如果bag_info为空，返回所有required_plaques
                    missing_plaques = required_plaques
                end
                return missing_plaques
            end
            -- 获取对应配置仓库页
            local function get_config_warehouse_page(items_info,warehouse_type)
                local page_list = {}
                for _, v in ipairs(items_info) do
                    if string.find(v["類型"],"碑牌") and (v["白裝"] or v["藍裝"] or v["黃裝"]) and not v["不撿"] then
                        if warehouse_type == game_str.Warehouse_text and not v["工會倉庫"] then
                            table.insert(page_list,v["存倉頁名"])
                        elseif warehouse_type == game_str.Guild_Warehouse_text and v["工會倉庫"] then
                            table.insert(page_list,v["存倉頁名"])
                        end
                    end
                end
                return page_list
            end
            -- 获取对应仓库页数据
            local function get_warehouse(page,godown_info)
                for _, v in ipairs(godown_info) do
                    if v.name_utf8 == page then
                        return v
                    end
                end
                return false
            end
            
            local function removeDuplicates(arr, tab)
                -- 检查 tab 是否已包含 arr
                local exists = false
                for _, v in ipairs(tab) do
                    if v == arr then
                        exists = true
                        break
                    end
                end
            
                -- 如果不存在，则插入 arr
                if not exists then
                    table.insert(tab, arr)
                end
            end
                 
            -- local function removeDuplicates(arr)
            --     local hash = {}
            --     -- local res = {}
            --     for _, v in ipairs(arr) do
            --         if not hash[v] then
            --             table.insert(env.not_exist_stone, v)
            --             hash[v] = true
            --         end
            --     end
            --     -- return res
            -- end
            
            local items_info = poe2_api.get_items_config_info(config)
            local index = 0
            local warehouse_type_interactive = env.warehouse_type_interactive
            local godown_info = nil
            if warehouse_type_interactive == game_str.Warehouse_text then
                godown_info = api_GetRepositoryPages(0)
                index = 0
            else
                godown_info = api_GetRepositoryPages(1)
                index = 2
            end
            if not godown_info or not next(godown_info) then
                poe2_api.print_log("仓库数组数据异常......")
                poe2_api.time_p("取碑牌仓库数组数据异常（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end

            local page = env.plaque_page
            -- env.plaque_page
            poe2_api.dbgp("page:",page)
            -- local page = get_config_warehouse_page(items_info,warehouse_type_interactive)
            -- if page and next(page) then
            --     for _, v in ipairs(page) do
            --         poe2_api.dbgp(v)
            --     end
            -- end
            
            local bag_info = env.bag_info
            if self.wait then
                if api_GetTickCount64() - self.current < self.wait_item then
                    poe2_api.dbgp("等待间隔时间到达")
                    return bret.RUNNING
                end
                self.wait = false
            end
            if not poe2_api.find_text({text = game_str.backpack,UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                poe2_api.click_keyboard("i")
                api_Sleep(500)
                poe2_api.dbgp("开背包2")
                self.wait = true
                self.current = api_GetTickCount64()
                self.wait_item = 1000
                poe2_api.time_p("取碑牌开背包2（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local tab_list_button = poe2_api.click_text_UI({text = game_str.tab_list_button, UI_info = env.UI_info,ret_data = true})
            local precut_page = get_warehouse(page,godown_info)
            -- 背包操作
            local function bag_operate(data)
                if not precut_page then
                    error("未找到预设存仓页 ->", page, "<-,请检查预设存仓页与游戏仓库页是否一致")
                end
                poe2_api.dbgp("-=-=-=-=-=-=-=-=-=-==-=-=-==-=-=-=-=-=-=")
                poe2_api.dbgp("操作页：",page," | 预设页: ",precut_page.name_utf8)
                poe2_api.dbgp("manage_index:",precut_page.manage_index)
                if precut_page.manage_index == 0 then
                    if poe2_api.find_text({text = page,UI_info = env.UI_info,max_y=data.max_y,min_x=data.min_x,max_x=data.max_x,min_y=data.min_y,click = 2}) then
                        self.is_wait = true
                        self.current = api_GetTickCount64()
                        self.wait_item = 500 
                        self.type =page
                    end 
                    return false
                end
                poe2_api.dbgp("type:",self.type)
                local currency = api_Getinventorys(precut_page.manage_index,index)
                -- poe2_api.printTable(currency)
                if currency and next(currency) then
                    poe2_api.dbgp("llllllllllllllllllllllllllllllllllllllllllllllllll")
                    if self.type ~= page then
                        poe2_api.dbgp("type:",type(self.type))
                        poe2_api.dbgp("type:",type(page))
                        poe2_api.dbgp("uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu")
                        if poe2_api.find_text({text = page,UI_info = env.UI_info,max_y=data.max_y,min_x=data.min_x,max_x=data.max_x,min_y=data.min_y,click = 2}) then
                            self.is_wait = true
                            self.current = api_GetTickCount64()
                            self.wait_item = 500 
                            self.type =page
                        end
                        return false 
                    end
                    poe2_api.dbgp("ggggggggggggggggggggggggggggggggggggggggggggggggggggggs")
                    local get_index = false
                    local get_plaque = api_Getinventorys(77,0)
                    local placed_plaque = {}
                    if next(get_plaque) then
                        for _, v in ipairs(get_plaque) do
                            table.insert(placed_plaque,v.baseType_utf8)
                        end
                    end
                    -- poe2_api.printTable(stone_order)
                    for _, v in ipairs(stone_order) do
                        if next(placed_plaque) then
                            if not env.one_not_plaque then
                                if poe2_api.table_contains(placed_plaque,v) then
                                    goto continue
                                end
                                
                            end 
                        end
                        -- if not env.one_not_plaque then
                        --     if v == then
                        --         goto continue
                        --     end
                            
                        -- end 
                        local stele_number = 0
                        for _, v1 in ipairs(api_Getinventorys(1,0)) do
                            if v1.category_utf8 == game_str.TowerAugmentation and poe2_api.table_contains(env.stone_order,v1.baseType_utf8) then
                                stele_number = stele_number + 1
                            end
                        end
                        -- poe2_api.dbgp("数量： ",env.pick_up_number)
                        -- api_Sleep(10000)
                        if stele_number >= env.pick_up_number then
                            env.is_get_plaque_node = false
                            -- poe2_api.dbgp("数量================")
                            -- api_Sleep(1000000000000000000)
                            return true
                        end
                        local item = get_currency(currency,{env.plaque_type[1]})
                        -- poe2_api.dbgp("item:",item)
                        -- api_Sleep(10000)
                        if item then
                            poe2_api.dbgp("cccccccccccccccccccccccccccccccccccc")
                            -- api_Sleep(10000000)
                            local point = {}
                            local a = poe2_api.table_contains(precut_page.type,{0,1})
                            -- poe2_api.dbgp("a:",tostring(a))
                            -- api_Sleep(10000000)
                            if poe2_api.table_contains(precut_page.type,{0,1}) then
                                local point1 = poe2_api.get_center_position_store({item.start_x,item.start_y},{item.end_x,item.end_y})
                                poe2_api.dbgp("point1:",tostring(point1))
                                poe2_api.dbgp("point1:",point1[1])
                                poe2_api.dbgp("point1:",point[2])
                                if point1 and next(point1) then
                                    point = point1
                                end
                            -- elseif precut_page.type == 3 then
                            --     local key = item.start_x..","..item.start_y
                            --     point = my_game_info.currency_page[key]
                            elseif precut_page.type == 7 then
                                point = poe2_api.get_center_position_store_max({item.start_x,item.start_y},{item.end_x,item.end_y})
                            end
                            poe2_api.ctrl_left_click(point[1],point[2])
                            if index == 2 then
                                api_Sleep(1000)
                            else
                                api_Sleep(1000)
                            end
                            get_index = true
                            return false
                            -- table.insert(env.not_exist_stone,item)
                        else
                            if env.plaque_type[2] == 0 then
                                removeDuplicates(env.plaque_type[1],env.not_dark_gold_plaque_list)
                                return false
                                -- removeDuplicates(env.plaque_type[1])
                                -- table.insert(env.not_dark_gold_plaque_list,env.plaque_type[1])
                            end
                            if env.plaque_type[2] == 1 then
                                removeDuplicates(env.plaque_type[1],env.not_exist_stone)
                                return false
                                -- removeDuplicates(env.plaque_type[1])
                                -- table.insert(env.not_exist_stone,env.plaque_type[1])
                            end
                            -- removeDuplicates(v)
                            -- table.insert(env.not_exist_stone,v)
                            -- return false
                        end
                        ::continue::
                    end
                    if not get_index and env.one_not_plaque then
                        -- env.not_exist_stone = stone_order
                        if env.plaque_type[2] == 0 then
                            removeDuplicates(env.plaque_type[1],env.not_dark_gold_plaque_list)
                            -- removeDuplicates(env.plaque_type[1])
                            -- table.insert(env.not_dark_gold_plaque_list,env.plaque_type[1])
                        end
                        if env.plaque_type[2] == 1 then
                            removeDuplicates(env.plaque_type[1],env.not_exist_stone)
                            -- removeDuplicates(env.plaque_type[1])
                            -- table.insert(env.not_exist_stone,env.plaque_type[1])
                        end
                        return false
                    end
                    env.one_not_plaque = true
                else
                    -- env.not_exist_stone = stone_order
                    if env.plaque_type[2] == 0 then
                        removeDuplicates(env.plaque_type[1],env.not_dark_gold_plaque_list)
                        -- removeDuplicates(env.plaque_type[1])
                        -- table.insert(env.not_dark_gold_plaque_list,env.plaque_type[1])
                    end
                    if env.plaque_type[2] == 1 then
                        removeDuplicates(env.plaque_type[1],env.not_exist_stone)
                        -- removeDuplicates(env.plaque_type[1])
                        -- table.insert(env.not_exist_stone,env.plaque_type[1])
                    end
                    return false
                end
            end
            if not tab_list_button then
                if not bag_operate({godown_info=godown_info,max_y=90,min_x=10,max_x=500,min_y=0})then
                    poe2_api.time_p("取碑牌（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                poe2_api.time_p("取碑牌（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            else
                local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
                local lock_button = {}
                for _,v in ipairs(lock) do
                    if v.name_utf8 == "" and v.text_utf8 == "" then
                        table.insert(lock_button,v)
                    end
                end
                if not lock_button or not next(lock_button) then
                    api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                    api_Sleep(2000)
                    api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),1)
                    api_Sleep(1000)
                    poe2_api.time_p("取碑牌（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if not bag_operate({godown_info=godown_info,max_y=800,min_x=556,min_y=20,max_x=851})then
                    poe2_api.time_p("取碑牌（RUNNING8）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                poe2_api.time_p("取碑牌（RUNNING9）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            poe2_api.time_p("取碑牌（RUNNING10）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.RUNNING
        end
    },

    -- 是否要滴注
    Is_Need_Instill = {
        run = function(self, env)
            poe2_api.dbgp("是否要滴注")
            local start_time = api_GetTickCount64()
            local dist_ls = env.dist_ls
            local bag_info = env.bag_info
            local not_use_map = env.not_use_map
            -- 精炼表
            local formula_list = {}
            local warehouse_type = env.warehouse_type
            local player_info = env.player_info
            local user_map = env.user_map
            local is_dizhu = env.is_dizhu

            -- 非藏身处不滴注
            if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.hideout)then
                env.dizhu_end = false
                poe2_api.time_p("是否要滴注... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end

            if env.one_other_map then
                return bret.SUCCESS
            end

            local function shut_down_pages()
                if poe2_api.find_text({UI_info = env.UI_info, text=game_str.Dripping_in,min_x=200,max_x=1050,max_y=300})then
                    local re_instill = api_Getinventorys(0x25,0)
                    local re_map = api_Getinventorys(0x26,0)
                    if next(re_map) or next(re_instill) then
                        if not poe2_api.find_text({UI_info = env.UI_info, text=game_str.backpack, min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                            poe2_api.dbgp("打开背包页面")
                            poe2_api.click_keyboard("i")
                            api_Sleep(100)
                            return bret.RUNNING
                        end
                        -- 取出地图
                        if next(re_map)then
                            poe2_api.dbgp("取出地图")
                            poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_y = 134,min_x = 0,click = 4, refresh = true})
                            api_Sleep(300)
                            return bret.RUNNING
                        end
                        -- 取出液態
                        if next(re_instill) then
                            poe2_api.dbgp("取出液態")
                            for _,k in ipairs(re_instill) do
                                if k.start_x == 0 then
                                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_x=-73,add_y=246,min_x=0,click=4})
                                end
                                if k.start_x == 1 then
                                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_y=246,min_x=0,click=4})
                                end
                                if k.start_x == 2 then
                                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_x=73,add_y=246,min_x=0,click=4})
                                end
                            end
                            api_Sleep(300)
                            return bret.RUNNING
                        end
                    end
                    poe2_api.dbgp("关闭滴注页面")
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,min_x=200,max_x=1050,max_y=300,click=2,add_y=-10,add_x=156})
                    return bret.RUNNING
                end
                return bret.SUCCESS
            end

            -- 检查是否滴注过
            local function check_item_in_bag(bag_info, name, obj)
                if obj then
                    if obj.color == 0 then
                        poe2_api.dbgp("白色钥匙,不滴注")
                        return true
                    end
                    local suffixes = api_GetObjectSuffix(obj.mods_obj)
                    if suffixes then
                        -- 是否有【譫妄】
                        for _, s in ipairs(suffixes) do
                            if string.find(s.name_utf8, game_str.Delirium) then
                                -- 有词条，被滴注过
                                return true
                            end
                        end
                        -- 有词条，没滴注过
                        return false
                    end
                end

                for _, item in ipairs(bag_info) do
                    if item.baseType_utf8 == name then
                        if item.color == 0 then
                            goto continue
                        end

                        local suffixes = api_GetObjectSuffix(item.mods_obj)
                        if suffixes then
                            -- 是否有【譫妄】
                            local b = false
                            for _, s in ipairs(suffixes) do
                                if string.find(s.name_utf8, game_str.Delirium) then
                                    -- 有词条，被滴注过
                                    b = true
                                    break
                                end
                            end
                            -- 有词条，没滴注过
                            if not b then return item end
                        else
                            -- 没词条
                            if item.color ~= 0 then
                                -- 不是白色钥匙
                                -- 开背包
                                for i = 1, 10 do
                                    if poe2_api.find_text({UI_info = env.UI_info, min_x = 1020, min_y = 46, max_x = 1090, max_y = 70, text = game_str.backpack }) then
                                        break
                                    end
                                    poe2_api.click_keyboard("i")
                                    api_Sleep(300)
                                end

                                local b = false
                                local pos = poe2_api.get_center_position(
                                    {item.start_x, item.start_y},
                                    {item.end_x, item.end_y}
                                )
                                if pos then
                                    api_ClickScreen(pos[1], pos[2], 0)
                                    api_Sleep(1000)
                                    -- 再判断一次
                                    local suffixes = api_GetObjectSuffix(item.mods_obj)
                                    if suffixes then
                                        for _, s in ipairs(suffixes) do
                                            if string.find(s.name_utf8, game_str.Delirium) then
                                                -- 有词条，被滴注过
                                                b = true
                                                break
                                            end
                                        end
                                        if not b then return item end
                                    end
                                end
                                if b then break end
                            end
                        end
                    end
                    ::continue::
                end
                return false
            end

            -- 获取背包中不打词条的地图钥匙
            local function get_map_not_entry(map)
                -- 词条过滤
                local function match_item_suffixes(item_suffixes, config_suffixes)
                    if not item_suffixes or not next(item_suffixes) then
                        return false
                    end
                    if not config_suffixes or not next(config_suffixes) then
                        return false
                    end
                    for _, v in ipairs(item_suffixes) do
                        for _, v1 in ipairs(config_suffixes) do
                            if v.name_utf8 == v1 then
                                return true
                            end
                        end
                    end
                    return false
                end
                if map then
                    if map.color > 0 and not map.not_identified and match_item_suffixes(api_GetObjectSuffix(map.mods_obj),not_use_map) then
                        return true
                    end
                end
                return false
            end

            -- # 无精炼
            if env.dizhu_end or is_dizhu then
                return shut_down_pages()
            end

            -- poe2_api.printTable(formula_list)

            for k, dist in pairs(dist_ls) do
                -- 是否滴注
                if not dist["是否塗油"] or dist["是否塗油"] == false then
                    return shut_down_pages()
                end
                
                local level = string.gsub(game_str.Map_Key_Class_1, "1", tostring(k))
                if not poe2_api.check_item_in_inventory(level, bag_info ) then
                    goto continue
                end
                local map_level = poe2_api.select_best_map_key(
                {   
                    inventory = bag_info,
                    key_level_threshold = user_map,
                    not_use_map = not_use_map,
                    vall = true,
                    instill = true
                })
                -- poe2_api.printTable(map_level)
                -- poe2_api.printTable(api_GetObjectSuffix(map_level.mods_obj))
                -- api_Sleep(10000000)
                -- 是否滴注过 【譫妄】
                if map_level then
                    if get_map_not_entry(map_level) then
                        return bret.SUCCESS
                    end
                    if check_item_in_bag(bag_info, 1, map_level) then
                        poe2_api.dbgp("地图钥匙已滴注过")
                        return shut_down_pages()
                    end
                else
                    env.is_dizhu = true
                    poe2_api.dbgp("-- 无精炼")
                    return bret.SUCCESS
                end
                -- 钥匙存在，没滴注过
                
                for _, s in ipairs(dist["配方"]) do
                    if s ~= "无" then
                        table.insert(formula_list, s)
                    end
                end
                if #formula_list == 0 then
                    -- 钥匙符合条件，但未设置 配方
                    goto continue
                end
                -- 解析 倉庫類型
                local warehouse_type = dist['倉庫類型']
                env.warehouse_type = warehouse_type
                if warehouse_type == game_str.Warehouse then
                    env.warehouse_type_interactive = game_str.Warehouse_text
                else
                    
                    local function get_object(name,data_list)
                        for _, v in ipairs(data_list) do
                            if v.name_utf8 == name and v.grid_x ~= 0 and v.grid_y ~= 0 then
                                if v.flagStatus and v.flagStatus == 0 and v.flagStatus1 == 1 then
                                    poe2_api.dbgp("get_object 找到匹配对象(flagStatus):", v)
                                    return v
                                end
                                if v.life and v.is_selectable then
                                    poe2_api.dbgp("get_object 找到匹配对象(life):", v)
                                    return v
                                end
                            end
                        end
                        poe2_api.dbgp("get_object: 未找到匹配对象")
                        return false
                    end
                    local warehouse_obj = get_object(game_str.StashGuild_EN, env.current_map_info)
                    local warehouse_obj1 = get_object(game_str.Guild_Warehouse,env.range_info)
                    if not warehouse_obj and not warehouse_obj1 then
                        poe2_api.dbgp("错误: 找不到仓库对象")
                        error("滴注找不到公会仓库")
                    end

                    env.warehouse_type_interactive = game_str.Guild_Warehouse_text

                    local pages = api_GetRepositoryPages(1)
                    local warehouse_page = nil
                    if #pages > 0 then
                        for _, page in ipairs(pages) do
                            if page.manage_index ~= 0 or page.name_utf8 ~= "" or page.page_index ~=0 or page.type  ~= 22 then
                                warehouse_page = true
                            end
                        end
                    end
                    if not warehouse_page then
                        poe2_api.print_log("公会仓库无仓库页")
                        env.is_dizhu = true
                        return bret.SUCCESS
                    end
                end
                -- 地图钥匙等级
                local key_level = k
                env.key_level = key_level
                break
                ::continue::
            end

            -- # 是否操作过滴注
            if env.is_dizhu then
                return shut_down_pages()
            end

            poe2_api.printTable(formula_list)
            -- # 是否有精炼表
            if next(formula_list) then
                env.refining_list = formula_list
                if not env.is_over then
                    return bret.FAIL
                else
                    return bret.SUCCESS
                end
            else
                return shut_down_pages()
            end
        end
    },

    -- 检查背包
    Check_Bag = {
        run = function(self, env)
            poe2_api.print_log("检查背包")

            -- 所需的精炼
            local need_refining = env.refining_list
            local refining_list_copy = poe2_api.deepCopy(env.refining_list)
            
            -- 自定义补充精炼 优先级列表
            local Custom_refining_list = {
                "濃縮液態孤立",
                "濃縮液態苦難", 
                "濃縮液態恐懼",
                "液態絕望",
                "液態厭惡",
                "液態忌妒",
                "液態偏執",
                "稀釋的液態貪婪",
                "稀釋的液態罪惡",
                "稀釋的液態憤怒"
            }

            -- 改进的精炼检查函数：检查所有需要的精炼
            local function check_all_refinements(bag_info, required_list)
                local found_refinements = {}
                local missing_refinements = {}
                
                -- 检查每个需要的精炼是否在背包中
                for _, refining in ipairs(required_list) do
                    local found = false
                    for _, item in ipairs(bag_info) do
                        if refining == item.baseType_utf8 then
                            table.insert(found_refinements, refining)
                            found = true
                            break
                        end
                    end
                    if not found then
                        table.insert(missing_refinements, refining)
                    end
                end
                
                return found_refinements, missing_refinements
            end

            -- 自定义精炼查找（用于补充缺失的精炼类型）
            local function find_custom_refining(bag_info, custom_list)
                for _, refining in ipairs(custom_list) do
                    for _, item in ipairs(bag_info) do
                        if refining == item.baseType_utf8 then
                            return refining
                        end
                    end
                end
                return nil
            end

            -- 检查地图钥匙
            local key_level = env.key_level
            local key = string.gsub(game_str.Map_Key_Class_1, "1", tostring(key_level))
            if not env.check_map_key then
                env.exists_key = poe2_api.check_item_in_inventory(key, env.bag_info)
            end
            env.map_key_name = key

            -- 补充缺失的精炼类型配置
            for k, refining in ipairs(need_refining) do
                if not refining then
                    local c_refining = find_custom_refining(env.bag_info, Custom_refining_list)
                    if c_refining then
                        need_refining[k] = c_refining
                        poe2_api.dbgp("补充精炼类型: " .. tostring(k) .. " -> " .. c_refining)
                    end
                end
            end

            -- 检查所有需要的精炼
            local found_refinements, missing_refinement = check_all_refinements(env.bag_info, need_refining)
            
            poe2_api.dbgp(table.concat({
                "精炼检查结果: 需要", tostring(#need_refining), 
                "个, 找到", tostring(#found_refinements), 
                "个, 缺失", tostring(#missing_refinement), "个"
            }))

            -- 打印详细的精炼信息
            if #found_refinements > 0 then
                poe2_api.dbgp("找到的精炼: " .. table.concat(found_refinements, ", "))
            end
            if #missing_refinement > 0 then
                poe2_api.dbgp("缺失的精炼: " .. table.concat(missing_refinement, ", "))
            end

            -- 处理缺失精炼的情况
            if #missing_refinement > 0 and (env.not_need_take or 0) < 3 then
            -- if #missing_refinement > 0 then
                poe2_api.dbgp("需要从仓库取精炼")
                
                env.missing_refinement = missing_refinement
                env.found_refinements = found_refinements
                
                -- 如果找到了部分精炼，设置当前可用的精炼
                if #found_refinements > 0 then
                    env.is_refinement = found_refinements[1]
                    poe2_api.dbgp("使用找到的精炼: " .. env.is_refinement)
                else
                    env.is_refinement = false
                end
                
                return bret.SUCCESS
            end

            -- 所有精炼都已找到
            -- if #missing_refinement == 0 or env.not_need_take then
            if #missing_refinement == 0 then
                poe2_api.dbgp("所有精炼都已找到，无需取油")
                env.is_refinement = found_refinements[1] or false
                env.found_refinements = found_refinements
                return bret.FAIL
            end

            -- 没有找到精炼且不需要取油的情况
            if #found_refinements == 0 or (env.not_need_take or 0) > 3 then
                poe2_api.dbgp("没有找到精炼且不需要取油，结束流程")
                env.dizhu_end = true
                env.is_refinement = false
                return bret.SUCCESS
            end

            env.is_refinement = false
            return bret.FAIL
        end
    },

    -- 打开仓库(warehouse_type_interactive 为空情况在调用之前，提前处理)
    Open_Warehouse = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Open_Warehouse")
            local start_time = api_GetTickCount64()
            if poe2_api.find_text({text=game_str.Purchase_or_sell,UI_info=env.UI_info,min_x=0,max_x=800}) then
                poe2_api.click_keyboard('space')
                api_Sleep(500)
                poe2_api.time_p("打开仓库（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if poe2_api.find_text({text=game_str.Restructuring,UI_info=env.UI_info,min_x=200,max_x=1200}) then
                poe2_api.click_keyboard('space')
                api_Sleep(500)
                poe2_api.time_p("打开仓库（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if poe2_api.find_text({text=game_str.Recycling_equipment,UI_info=env.UI_info,min_x=200,max_x=1200}) then
                poe2_api.click_keyboard('space')
                api_Sleep(500)
                poe2_api.time_p("打开仓库（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            poe2_api.find_text({text = game_str.Goodbye,UI_info = env.UI_info,click =2,min_x=0})
            if poe2_api.find_text({text = {game_str.The_recast_platform}, UI_info=env.UI_info,min_x=0}) and poe2_api.find_text({text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, UI_info=env.UI_info,min_x=0}) then
                poe2_api.click_keyboard('space')
                api_Sleep(500)
                poe2_api.time_p("打开仓库（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            -- if poe2_api.find_text({text = {'世界地圖',game_str.Buy_or_Sell_items_CH}, UI_info=env.UI_info,min_x=0}) then
            if poe2_api.find_text({text = game_str.World_map, UI_info=env.UI_info,min_x=0}) then
                -- poe2_api.dbgp("999999999999999999999999999999999999999999")
                poe2_api.click_keyboard('space')
                api_Sleep(500)
                poe2_api.time_p("是否存储物品（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if not self.nubmer_index then
                self.nubmer_index = 0
                poe2_api.dbgp("初始化完成，设置 nubmer_index = 0")
                poe2_api.time_p("打开仓库（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            
            -- poe2_api.dbgp("打开仓库...")
            local obj = nil
            local text = nil 
            local warehouse = nil
            local current_map_info = env.current_map_info
            
            local player_info = env.player_info
            local warehouse_type_interactive = env.warehouse_type_interactive
            
            poe2_api.dbgp("环境变量检查:", {
                warehouse_type_interactive = warehouse_type_interactive,
                current_map_info = current_map_info and #current_map_info or "nil",
                player_info = player_info and "exists" or "nil"
            })

            local function get_object(name,data_list)
                for _, v in ipairs(data_list) do
                    if v.name_utf8 == name and v.grid_x ~= 0 and v.grid_y ~= 0 then
                        if v.flagStatus and v.flagStatus == 0 and v.flagStatus1 == 1 then
                            poe2_api.dbgp("get_object 找到匹配对象(flagStatus):", v)
                            return v
                        end
                        if v.life and v.is_selectable then
                            poe2_api.dbgp("get_object 找到匹配对象(life):", v)
                            return v
                        end
                    end
                end
                poe2_api.dbgp("get_object: 未找到匹配对象")
                return false
            end

            poe2_api.dbgp("仓库类型:", warehouse_type_interactive)
            
            if warehouse_type_interactive == game_str.Warehouse_text then
                poe2_api.dbgp("查找个人仓库...")
                local warehouse_obj = get_object(game_str.StashPlayer_EN, current_map_info)
                if warehouse_obj then
                    obj = game_str.StashPlayer_EN
                    text = game_str.Warehouse
                    warehouse = warehouse_obj
                    poe2_api.dbgp("找到 StashPlayer 仓库:", warehouse_obj)
                else
                    local warehouse_obj1 = get_object(game_str.Warehouse,env.range_info)
                    if warehouse_obj1 then
                        obj = game_str.Warehouse
                        text = game_str.Warehouse
                        warehouse = warehouse_obj1
                        poe2_api.dbgp("找到 倉庫 (备用):", warehouse_obj1)
                    end
                end
            elseif warehouse_type_interactive == game_str.Guild_Warehouse_text then
                poe2_api.dbgp("查找公会仓库...")
                local warehouse_obj = get_object(game_str.StashGuild_EN, current_map_info)
                if warehouse_obj then
                    obj = game_str.StashGuild_EN
                    text = game_str.Guild_Warehouse
                    warehouse = warehouse_obj
                    poe2_api.dbgp("找到 StashGuild 仓库:", warehouse_obj)
                else
                    local warehouse_obj1 = get_object(game_str.Guild_Warehouse,env.range_info)
                    if warehouse_obj1 then
                        obj = game_str.Guild_Warehouse
                        text = game_str.Guild_Warehouse
                        warehouse = warehouse_obj1
                        poe2_api.dbgp("找到 公會倉庫 (备用):", warehouse_obj1)
                    end
                end
            else
                poe2_api.dbgp("错误: 仓库类型未配置", warehouse_type_interactive)
                error("在配置物品过滤中,有物品的存仓页未配置")
            end

            if not warehouse then
                poe2_api.dbgp("错误: 找不到仓库对象")
                error("找不到仓库或者公会仓库")
            end

            poe2_api.dbgp("最终仓库对象:", 
                obj ,
                text,
                warehouse
            )
            if text == game_str.Guild_Warehouse then
                
                local pages = api_GetRepositoryPages(1)
                local warehouse_page = nil
                if #pages > 0 then
                    for _, page in ipairs(pages) do
                        if page.manage_index ~= 0 or page.name_utf8 ~= "" or page.page_index ~=0 or page.type  ~= 22 then
                            warehouse_page = true
                        end
                    end
                end
                if not warehouse_page then
                    error("公會倉庫内无仓库页，请修改相关配置！！！")
                    api_Sleep(1000)
                    return bret.RUNNING
                end
            end
            -- 检查是否已经打开仓库界面
            local emphasize_text = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Emphasize_the_item, min_x = 250, min_y = 700})
            local warehouse_text = poe2_api.find_text({UI_info = env.UI_info, text = text, min_x=0, min_y=32, max_x=381, max_y=78})
            
            poe2_api.dbgp("界面检查结果:", {
                emphasize_text = emphasize_text and "found" or "not found",
                warehouse_text = warehouse_text and "found" or "not found"
            })
            
            if emphasize_text and warehouse_text then
                poe2_api.dbgp("仓库界面已打开，返回SUCCESS")
                poe2_api.time_p("打开仓库（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end

            local distance = poe2_api.point_distance(warehouse.grid_x, warehouse.grid_y, player_info)
            poe2_api.dbgp("与仓库的距离:", distance)

            if distance > 25 then
                poe2_api.dbgp("距离仓库太远(", distance, ")，返回FAIL")
                env.interactive = obj
                poe2_api.time_p("打开仓库（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            else
                local continue_game = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Continue_Game, click = 2})
                if continue_game then
                    poe2_api.dbgp("发现'繼續遊戲'文本，返回RUNNING")
                    poe2_api.time_p("打开仓库（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end

                poe2_api.dbgp("尝试移动到仓库位置:", warehouse.grid_x, warehouse.grid_y)

                -- api_ClickMove(poe2_api.toInt(warehouse.grid_x), poe2_api.toInt(warehouse.grid_y), poe2_api.toInt(player_info.world_z), 1)
                poe2_api.find_text({text = text, UI_info = env.UI_info, min_x=200,max_y=750,max_x=1200,sorted = true, click=2})

                if self.nubmer_index >= 10 then
                    poe2_api.dbgp("尝试次数超过10次(", self.nubmer_index, ")，执行ESC并重置计数器")
                    poe2_api.click_keyboard("space")
                    api_Sleep(500)
                    self.nubmer_index = 0
                end 
                
                self.nubmer_index = self.nubmer_index + 1
                poe2_api.dbgp("当前尝试次数:", self.nubmer_index)
                
                api_Sleep(500)
                poe2_api.time_p("打开仓库（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
        end
    },

    -- 仓库取物品
    Warehouse_pickup_items = {
        run = function(self, env)
            poe2_api.print_log("仓库取物品...")
            local text = ""
            if env.warehouse_type == game_str.Warehouse then
                text = game_str.Warehouse
            else
                text = game_str.Guild_Warehouse
            end
            -- 确认打开仓库
            if not (poe2_api.find_text({UI_info = env.UI_info, text = game_str.Emphasize_the_item,min_x = 250,min_y = 700}) and poe2_api.find_text({UI_info = env.UI_info, text = text,min_x=0,min_y=32,max_x=381,max_y=78})) then
                return bret.SUCCESS
            end
            
            local all_refinement_list = {}
            local refinement_pos = {
                ["濃縮液態恐懼"] = {274, 331},
                ["液態厭惡"] = {160, 330},
                ["液態絕望"] = {218, 329},
                ["液態偏執"] = {331, 269},
                ["稀釋的液態憤怒"] = {161, 271},
                ["稀釋的液態罪惡"] = {218, 272},
                ["濃縮液態苦難"] = {335, 333},
                ["液態忌妒"] = {392, 272},
                ["稀釋的液態貪婪"] = {275, 275},
                ["濃縮液態孤立"] = {390, 330}
            }
            
            local missing_refinement = env.missing_refinement or {}
            local refining_list = env.refining_list or {}
            local bag_info = env.bag_info or {}
            
            poe2_api.dbgp(table.concat({
                "开始取精炼: 缺失", tostring(#missing_refinement), 
                "个, 列表: ", table.concat(missing_refinement, ", ")
            }))

            local config = env.user_config
            local check_res = false
            
            -- # 重置 背包 精煉
            local function reset_backpack_refinement(bag_info)
                for _, item in ipairs(bag_info) do
                    if string.find(item.baseType_utf8, game_str.Refine) and not poe2_api.table_contains(refining_list, item.baseType_utf8) then
                        poe2_api.ctrl_left_click_bag_items(item.baseType_utf8, bag_info)
                    end
                end
            end
            
            -- 寻找背包中的精炼（改进版：找到所有缺失的精炼）
            local function look_for_refinement_in_backpack(bag_info, page_type, page_name)
                local found_any = false
                for _, item in ipairs(bag_info) do
                    -- 寻找指定的精炼
                    if poe2_api.table_contains(missing_refinement, item.baseType_utf8) then
                        local pos = poe2_api.get_center_position_store({item.start_x, item.start_y}, {item.end_x, item.end_y})
                        local all_refinement = {
                            ["仓库页"] = page_name,
                            [game_str.Refine] = item.baseType_utf8,
                            ["坐标"] = {pos[1], pos[2]}
                        }
                        if page_type == 15 then
                            all_refinement["坐标"] = refinement_pos[item.baseType_utf8]
                        elseif page_type == 7 then
                            local point = poe2_api.get_center_position_store_max({item.start_x,item.start_y},{item.end_x,item.end_y})
                            all_refinement["坐标"] = point
                        end
                        table.insert(all_refinement_list, all_refinement)
                        found_any = true
                        poe2_api.dbgp("在仓库页 '" .. page_name .. "' 中找到精炼: " .. item.baseType_utf8)
                    end
                end
                return found_any
            end

            -- 从背包中拿出精炼（改进版：取出所有找到的精炼）
            local function out_of_refinement_in_backpack()
                local taken_count = 0
                for _, aj in ipairs(all_refinement_list) do
                    if poe2_api.table_contains(missing_refinement, aj[game_str.Refine]) then
                        if not aj["坐标"] then
                            poe2_api.dbgp("坐标未找到: " .. aj[game_str.Refine])
                            goto continue_item
                        end
                        
                        -- 查找仓库页文本并点击
                        local page_found = false
                        if poe2_api.find_text({UI_info = env.UI_info, text = aj["仓库页"], max_y = 90, min_x = 10, max_x = 500, min_y = 0, click = 2}) then
                            page_found = true
                            api_Sleep(200)
                        elseif poe2_api.find_text({UI_info = env.UI_info, text = aj["仓库页"], max_y = 800, min_x = 556, min_y = 20, max_x = 851, click = 2}) then
                            page_found = true
                            api_Sleep(200)
                        end
                        
                        if not page_found then
                            poe2_api.dbgp("未找到仓库页: " .. aj["仓库页"])
                            goto continue_item
                        end
                        
                        -- 点击精炼物品
                        poe2_api.ctrl_left_click(aj["坐标"][1], aj["坐标"][2])
                        api_Sleep(500)
                        
                        -- 从缺失列表中移除已取出的精炼
                        local filtered = {}
                        for _, x in ipairs(missing_refinement) do
                            if x ~= aj[game_str.Refine] then
                                table.insert(filtered, x)
                            else
                                poe2_api.dbgp("成功取出精炼: " .. x)
                                taken_count = taken_count + 1
                            end
                        end
                        env.missing_refinement = filtered
                        missing_refinement = filtered  -- 更新本地变量
                        
                        -- 如果所有精炼都已取出，提前结束
                        if #missing_refinement == 0 then
                            break
                        end
                    end
                    ::continue_item::
                end
                poe2_api.dbgp("本轮取出 " .. tostring(taken_count) .. " 个精炼，剩余缺失: " .. tostring(#missing_refinement))
                return taken_count > 0
            end

            reset_backpack_refinement(bag_info)
            
            -- # 仓库类型
            local pages = {}
            if env.warehouse_type == game_str.Warehouse then
                local items_info = poe2_api.get_items_config_info(config)
                local unique_storage_pages = {}
                for _, item in ipairs(items_info) do
                    if item["類型"] == game_str.Refine and item['存倉頁名'] and not item["不撿"] and item["基礎類型名"] == "全部物品" and not item["工會倉庫"] then
                        unique_storage_pages[item['存倉頁名']] = true
                    end
                end
                if next(unique_storage_pages) ~= nil then
                    local pages_list = api_GetRepositoryPages(0)
                    for _, i in ipairs(pages_list) do
                        if unique_storage_pages[i.name_utf8] then
                            table.insert(pages, i)
                        end
                    end
                else
                    pages = api_GetRepositoryPages(0)
                end
            elseif env.warehouse_type == "工會倉庫" then
                local items_info = poe2_api.get_items_config_info(config)
                local unique_storage_pages = {}
                for _, item in ipairs(items_info) do
                    if item["類型"] == game_str.Refine and item['存倉頁名'] and not item["不撿"] and item["基礎類型名"] == "全部物品" and item["工會倉庫"] then
                        unique_storage_pages[item['存倉頁名']] = true
                    end
                end
                if next(unique_storage_pages) ~= nil then
                    local pages_list = api_GetRepositoryPages(1)
                    for _, i in ipairs(pages_list) do
                        if unique_storage_pages[i.name_utf8] then
                            table.insert(pages, i)
                        end
                    end
                else
                    pages = api_GetRepositoryPages(1)
                end
            else
                return bret.FAIL
            end
            
            -- 獲取列表按鈕
            local tab_list_button = poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.tab_list_button,ret_data = true})

            -- 獲取鎖定按鈕
            local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
            local lock_button = {}
            for _,v in ipairs(lock) do
                if v.name_utf8 == "" and v.text_utf8 == "" then
                    table.insert(lock_button,v)
                end
            end
            
            if next(missing_refinement) ~= nil then
                local old_page = {}
                local warehouse_text = nil
                if env.warehouse_type == game_str.Warehouse then
                    warehouse_text = game_str.Warehouse
                else
                    warehouse_text = game_str.Guild_Warehouse
                end

                for _, page in ipairs(pages) do
                    -- 缺少的精炼已全部取出
                    if not next(missing_refinement) then
                        poe2_api.dbgp("所有缺失精炼已取出")
                        break
                    end
            
                    -- 仓库页去重
                    if old_page[page.name_utf8] then
                        goto continue
                    else
                        old_page[page.name_utf8] = true
                    end
            
                    -- 跳過地图页
                    local skip_types = {3, 4, 5, 8, 17, 18}
                    if poe2_api.table_contains(skip_types, page.type) then
                        goto continue
                    end
                    
                    if not tab_list_button then
                        if page.manage_index == 0 then
                            if poe2_api.find_text({UI_info = env.UI_info, text=page.name_utf8, max_y=90, min_x=10, max_x=500, min_y=0, click=2}) then
                                api_Sleep(500)
                            end
                            return bret.RUNNING
                        end
                    else
                        if not lock_button or not next(lock_button) then
                            api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                            api_Sleep(2000)
                            api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2 + 30),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2 - 30),1)
                            api_Sleep(5000)
                            return bret.RUNNING
                        end
                        if page.manage_index == 0 then
                            if poe2_api.find_text({UI_info = env.UI_info, text=page.name_utf8, max_y=800, min_x=556, min_y=20, max_x=851, click=2}) then
                                api_Sleep(500)
                            end
                            return bret.RUNNING
                        end
                    end

                    -- 检查仓库类型
                    if not poe2_api.find_text({UI_info = env.UI_info, text = warehouse_text, min_x = 0, min_y = 32, max_x = 381, max_y=78}) then
                        api_ClickScreen(523, 57,1)
                        return bret.RUNNING
                    end
                    
                    -- 检查仓库页
                    local bag_ls = {}
                    if warehouse_text == game_str.Warehouse then
                        bag_ls = api_Getinventorys(page.manage_index,0)
                    else
                        bag_ls = api_Getinventorys(page.manage_index,2)
                    end
                    
                    if next(bag_ls) == nil then
                        goto continue
                    end

                    -- 清空前一个页面的结果
                    all_refinement_list = {}
                    check_res = look_for_refinement_in_backpack(bag_ls, page.type, page.name_utf8)
        
                    if not check_res then
                        -- 该仓库没有精炼
                        goto continue
                    end

                    local click = nil
                    if not tab_list_button then
                        click = poe2_api.find_text({UI_info = env.UI_info, text=page.name_utf8, max_y=90, min_x=10, max_x=500, min_y=0, click=2})
                    else
                        click = poe2_api.find_text({UI_info = env.UI_info, text=page.name_utf8, max_y=800, min_x=556, min_y=20, max_x=851, click=2})
                    end
                    
                    if not click then
                        goto continue
                    end

                    if check_res then
                        -- 有指定精炼，尝试取出
                        out_of_refinement_in_backpack()
                    end

                    ::continue::
                end
            end
            
            poe2_api.dbgp("【倉庫類型】 已经處理完畢----------------")
            poe2_api.dbgp(table.concat({
                "最终结果: 剩余缺失精炼", tostring(#missing_refinement), 
                "个", #missing_refinement > 0 and (" (" .. table.concat(missing_refinement, ", ") .. ")") or ""
            }))

            -- 更新精炼列表
            if env.missing_refinement then
                local new_refining_list = {}
                for _, refining in ipairs(refining_list) do
                    local found = false
                    for _, not_refining in ipairs(missing_refinement) do
                        if refining == not_refining then
                            found = true
                            break
                        end
                    end
                    if not found then
                        table.insert(new_refining_list, refining)
                    end
                end
                env.refining_list = new_refining_list
            end
            
            -- 检查精炼列表是否为空
            if not env.refining_list or #env.refining_list == 0 then
                env.dizhu_end = true
                poe2_api.dbgp("所有精炼都已处理完成，结束流程")
                return bret.RUNNING
            end
            
            -- 如果还有缺失的精炼，需要继续处理
            if #missing_refinement > 0 then
                poe2_api.dbgp("仍有缺失精炼，需要继续处理")
                if (env.take_still_times or 0) > 5 then
                    poe2_api.dbgp("仓库缺少精炼")
                    env.not_need_take = (env.not_need_take or 0) + 1
                else
                    env.not_need_take = 0
                end
            else
                poe2_api.dbgp("所有精炼都已取出")
                env.not_need_take = (env.not_need_take or 0) + 1
            end
            env.take_still_times = (env.take_still_times or 0) + 1
            return bret.RUNNING
        end
    },

    -- 检查滴注页面
    Check_the_drip_page = {
        run = function(self, env)
            poe2_api.print_log("检查滴注页面")

            if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.backpack , min_x = 1020, min_y = 46, max_x = 1090, max_y = 70}) then
                poe2_api.click_keyboard("i",0)
                api_Sleep(500)
                return bret.RUNNING
            end
            if poe2_api.find_text({UI_info = env.UI_info, text =game_str.Emphasize_the_item , min_x = 280,min_y = 730, max_x = 342, max_y = 758}) and poe2_api.find_text({UI_info = env.UI_info, text = {game_str.Warehouse, game_str.Guild_Warehouse},min_x=0,min_y=32,max_x=381,max_y=78}) then
                poe2_api.find_text({UI_info = env.UI_info, text = {game_str.Warehouse, game_str.Guild_Warehouse},min_x=0,min_y=32,max_x=381,max_y=78, add_x = 247,add_y = -5, click = 2})
                return bret.RUNNING
            end

            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in, min_x = 200, refresh = true}) then
                poe2_api.dbgp("在滴注页面")
                local function check_refinement()
                    for _, item in ipairs(env.bag_info) do
                        if string.find(item.baseType_utf8, game_str.Refine) then
                            return item
                        end
                    end
                    return false
                end
                local it = check_refinement()
                -- poe2_api.printTable(it)
                -- api_Sleep(50000)
                if it then
                    
                    -- 清除多余页面
                    if poe2_api.find_text({UI_info = env.UI_info, text =game_str.Emphasize_the_item , min_x = 280,min_y = 730, max_x = 342, max_y = 758}) then
                        poe2_api.ctrl_left_click_bag_items(it.obj, env.bag_info, 1)
                        api_Sleep(500)
                    end
                    poe2_api.ctrl_left_click_bag_items(it.obj,env.bag_info,1)
                    api_Sleep(500)
    
                    -- 取出地图
                    if next(api_Getinventorys(0x26,0)) then
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_y = 134,min_x = 0,click = 4, refresh = true})
                        api_Sleep(300)
                        return bret.RUNNING
                    end
                
                    -- 取出精煉
                    local re_refining = api_Getinventorys(0x25, 0)
                    if next(re_refining) then
                        for _,k in ipairs(re_refining) do
                            if k.start_x == 0 then
                                poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_x=-73,add_y=246,min_x=0,click=4})
                            end
                            if k.start_x == 1 then
                                poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_y=246,min_x=0,click=4})
                            end
                            if k.start_x == 2 then
                                poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_x=73,add_y=246,min_x=0,click=4})
                            end
                        end
                        api_Sleep(300)
                        return bret.RUNNING
                    end
                    env.is_refinement = it.baseType_utf8
                else
                    env.is_dizhu_times = (env.is_dizhu_times or 0) + 1
                    if (env.is_dizhu_times or 0) > 5 then
                        env.dizhu_end = true
                    end
                end
                return bret.FAIL
            else
                poe2_api.print_log("打开滴注")
                if env.is_refinement then
                    poe2_api.ctrl_left_click_bag_items(env.is_refinement,env.bag_info,1)
                    api_Sleep(800)
                end
                return bret.RUNNING
            end
        end
    },

    -- 放置钥匙
    Place_And_Instill = {
        run = function(self, env)
            poe2_api.print_log("放置地图钥匙")
            local bag_info = env.bag_info
            local key = env.map_key
            local key_ok = env.key_ok
            local user_map = env.user_map

            local not_use_map = poe2_api.deepCopy(env.not_use_map)
            table.insert(not_use_map, game_str.The_delirium_of_players)
            -- poe2_api.printTable(not_use_map)  -- 新表
            -- poe2_api.printTable(env.not_use_map)  -- 原表不变

            -- 選擇最佳地圖
            local map_level = poe2_api.select_best_map_key(
                {
                    inventory  = bag_info,
                    key_level_threshold = user_map,
                    not_use_map = not_use_map,
                    vall = true
                }
            )

            if map_level then
                -- 點擊地圖物品
                poe2_api.ctrl_left_click_bag_items(
                    map_level.obj,
                    bag_info,
                    2
                )
                api_Sleep(200)
            end
            env.key_ok = key_ok
            api_Sleep(500)
            env.check_map_key = true
            poe2_api.print_log("放置精炼")
            local refining_list = env.refining_list
            local re_refining = api_Getinventorys(0x25, 0)
            if next(re_refining) then
                for _,k in ipairs(re_refining) do
                    if k.start_x == 0 then
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_x=-73,add_y=246,min_x=0,click=4})
                    end
                    if k.start_x == 1 then
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_y=246,min_x=0,click=4})
                    end
                    if k.start_x == 2 then
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_x=73,add_y=246,min_x=0,click=4})
                    end
                end
                api_Sleep(300)
                return bret.RUNNING
            end
            local in_refining = {}
            for _,i in ipairs(refining_list) do
                for _,bag in ipairs(api_Getinventorys(1,0)) do
                    if bag.baseType_utf8 == i then
                        table.insert(in_refining,i)
                        break
                    end
                end
            end
            for k , in_refining in ipairs(in_refining) do
                poe2_api.ctrl_left_click_bag_items(in_refining,api_Getinventorys(1,0))
                api_Sleep(300)
            end

            -- 检查
            if next(re_refining) then
                for k,instill in ipairs(re_refining) do
                    if instill.baseType_utf8 ~= in_refining[k] then
                        -- 放回背包
                        if instill.start_x == 0 then
                            poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_x=-73,add_y=246,min_x=0,click=4})
                        end
                        if instill.start_x == 1 then
                            poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_y=246,min_x=0,click=4})
                        end
                        if instill.start_x == 2 then
                            poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_x=73,add_y=246,min_x=0,click=4})
                        end
                        api_Sleep(300)
                        poe2_api.ctrl_left_click_bag_items(instill,api_Getinventorys(1,0))
                        api_Sleep(300)
                    end
                end
            end
            poe2_api.ctrl_left_click(525,701)
            api_Sleep(300)
            
            -- 取出地图
            if next(api_Getinventorys(0x26,0))then
                poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_y = 134,min_x = 0,click = 4, refresh = true})
                api_Sleep(300)
                return bret.RUNNING
            end
        
            -- 取出精煉
            if next(re_refining) then
                for _,k in ipairs(re_refining) do
                    if k.start_x == 0 then
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_x=-73,add_y=246,min_x=0,click=4})
                    end
                    if k.start_x == 1 then
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_y=246,min_x=0,click=4})
                    end
                    if k.start_x == 2 then
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Dripping_in,add_x=73,add_y=246,min_x=0,click=4})
                    end
                end
                api_Sleep(300)
                return bret.RUNNING
            end

            local ui_esc = {game_str.The_delirium_of_players,game_str.backpack}
            for _,ui in ipairs(ui_esc) do
                if poe2_api.find_text({UI_info = env.UI_info, text = ui}) then
                    poe2_api.dbgp1("bhjftjrftjuertdhesdghsdg")
                    poe2_api.click_keyboard("space")
                    api_Sleep(300)
                end
            end

            -- 结束
            env.is_over = true
            return bret.RUNNING
        end
    },

    -- 是否存储物品
    Is_Store_Items = {
        run = function(self, env)
            poe2_api.print_log("是否存储...")
            local start_time = api_GetTickCount64()
            local config = env.user_config
            local map_config = config['刷圖設置'][game_str.Map_Key_CH]
            local altar_shop_config = config['刷圖設置']["祭祀購買"]
            -- local dist_ls = config['刷圖設置']['異界地圖']['涂油设置']
            local not_use_map = env.not_use_map
            local user_map = env.user_map
            local priority_map = env.priority_map
            local items_info = poe2_api.get_items_config_info(config)
            env.tower_do = false
            
            -- 判断两个键值对表是否相等
            local function deep_equal_unordered_full(a, b)
                if type(a) ~= type(b) then return false end
                if type(a) ~= "table" then return a == b end
            
                -- 检查所有键值对（包括非数字键）
                local visited = {}
                for k, v in pairs(a) do
                    if not deep_equal_unordered_full(v, b[k]) then
                        return false
                    end
                    visited[k] = true
                end
            
                -- 检查 b 中有没有 a 没有的键
                for k, _ in pairs(b) do
                    if not visited[k] then
                        return false
                    end
                end
            
                return true
            end
            
            -- 词条过滤
            local function match_item_suffixes(item_suffixes, config_suffixes)
                if not item_suffixes or not next(item_suffixes) then
                    return false
                end
                if not config_suffixes or not next(config_suffixes) then
                    return false
                end
                for _, v in ipairs(item_suffixes) do
                    for _, v1 in ipairs(config_suffixes) do
                        if v.name_utf8 == v1 then
                            return true
                        end
                    end
                end
                return false
            end
            -- 祭祀购买是否配置了存储页
            local function is_not_altar_shop(item)
                local text = poe2_api.get_item_type(item)
                poe2_api.print_log("祭祀购买物品类型:"..text)
                local item_key = ""
                if text ~= "" then
                    item_key = text
                else
                    poe2_api.dbgp("999999999999999999")
                    poe2_api.dbgp("item.category_utf8:"..item.category_utf8)
                    for k, v in pairs(my_game_info.type_conversion) do
                        -- poe2_api.dbgp("k:"..k.." v:"..v)
                        if item.category_utf8 == v then
                            item_key = k
                            break
                        end
                    end
                end
                poe2_api.dbgp("item_key:"..type(item_key))
                if item_key and item_key ~= "" then
                    local item_type_list = {}
                    for _, v in ipairs(items_info) do
                        poe2_api.dbgp("type(v):"..v['類型'])
                        
                        if v['類型'] == item_key then
                            poe2_api.dbgp("10101010101")
                            table.insert(item_type_list,v)
                        end
                    end
                    
                    if item_type_list and next(item_type_list) then
                        
                        for _, v in ipairs(item_type_list) do
                            if not v["不撿"] then
                                if v['基礎類型名'] == "全部物品" or string.find(v['基礎類型名'],item.baseType_utf8) then
                                    return true
                                end
                            end
                        end
                    end
                else
                    error("物品名称:"..item.name_utf8.."新物品类型:"..item.category_utf8.."请联系我们添加，感谢您的支持")
                end
                return false

            end
            -- 背包排序
            local function get_store_bag_info(bag)
                local function item_save_as1(goods,cfg_object)
                    local satisfy = {}
                    for _, v in ipairs(items_info) do
                        if not v["不撿"] and v["存倉頁名"] and v["存倉頁名"] ~= "" and string.find(v["基礎類型名"],goods.baseType_utf8) then
                            table.insert(satisfy,v)
                        end
                    end
                    if next(satisfy) then
                        for _, v in ipairs(satisfy) do
                            if not deep_equal_unordered_full(v,cfg_object) then
                                if v["工會倉庫"] then
                                    return 1
                                else
                                    return 2
                                end
                            end
                        end
                    
                    end
                    return false
                end
                local store_bag = {}
                local store_bag1 = {}
                local store_bag2 = {}
                for _,v in ipairs(bag) do
                    
                    for _, item in ipairs(items_info) do
                        if poe2_api.match_item(v,item) and not item["工會倉庫"] and not item["不撿"] then
                            local a = item_save_as1(v,item)
                            if a then
                                if a == 1 then
                                    table.insert(store_bag2,v)
                                    break
                                end
                            end
                            table.insert(store_bag1,v)
                        elseif poe2_api.match_item(v,item) and item["工會倉庫"] and not item["不撿"] then
                            local a = item_save_as1(v,item)
                            if a then
                                if a == 2 then
                                    table.insert(store_bag1,v)
                                    break
                                end
                            end
                            table.insert(store_bag2,v)
                        end
                    end
                end
                poe2_api.dbgp("store_bag1:"..#store_bag1)
                poe2_api.dbgp("store_bag2:"..#store_bag2)
                for _, v in ipairs(store_bag1) do
                    table.insert(store_bag, v)
                end
                
                for _, v in ipairs(store_bag2) do
                    table.insert(store_bag, v)
                end
               
                return store_bag
                
            end
            -- 判断是否需要存储
            local function get_store_item(bag,unique_storage_pages,public_warehouse_pages,map_ys_level_min)
                 
                -- 获取背包中的地图钥匙
                local function get_map_number()
                    local items = {}
                    for _, item in ipairs(bag) do
                        if item.category_utf8 == game_str.Map_EN then
                            table.insert(items,item)
                        end
                    end
                    if items and next(items) then
                        return items
                    end
                    return false
                end
                -- 获取背包地图数量
                local function map_index()
                    local number = get_map_number()
                    if number and #number >= 4 then
                        return true
                    end
                    return false
                    
                end
                
                -- 获取背包中不打等级的地图钥匙
                local function get_map_not_level()
                    local map = get_map_number()
                    if map then
                        local tiers = {}
                        for _, v in ipairs(map_config) do
                            table.insert(tiers,tonumber(v["階級"]))
                        end
                        if tiers and next(tiers) then
                            for _, v1 in ipairs(map) do
                                if not poe2_api.table_contains(poe2_api.extract_level(v1.baseType_utf8),tiers) then
                                    return v1
                                end
                                for _, v in ipairs(map_config) do
                                    if poe2_api.extract_level(v1.baseType_utf8) == v["階級"]  then
                                        if v1.color == 2 and not v["黃"] then
                                            return v1
                                        end
                                        if v1.contaminated and not v["已污染"] then
                                            return v1
                                        end
                                    end
                                end
                            end
                        end 
                    end
                    return false
                end
                -- 获取背包中不打词条的地图钥匙
                local function get_map_not_entry()
                    local map = get_map_number()
                    if map then
                        for _,item in ipairs(map) do
                            if item.color > 0 and not item.not_identified and match_item_suffixes(api_GetObjectSuffix(item.mods_obj),not_use_map) then
                                return item
                            end
                        end
                    end
                    return false
                end
                -- 找不是疯癫的地图
                local function get_map_not_crazy()
                    local map = get_map_number()
                    local max_map = poe2_api.select_best_map_key({inventory=bag,key_level_threshold=user_map,not_use_map = not_use_map,priority_map = priority_map})
                    if max_map then
                        local max_map_level = poe2_api.extract_level(max_map.baseType_utf8)
                        local is_oiled = nil
                        for _,v in ipairs(map_config) do
                            if v["階級"] == max_map_level then
                                if v["塗油設置"]  then
                                    is_oiled = v["塗油設置"]["是否塗油"]
                                end
                            end
                        end
                        if is_oiled then
                            local function is_crazy(item)
                                local item_entry = api_GetObjectSuffix(item.mods_obj)
                                if item_entry and next(item_entry) then
                                    for _, entry in ipairs(item_entry) do
                                        if string.find(entry.name_utf8,game_str.Delirium) then
                                            -- table.insert()
                                            return true
                                        end
                                    end
                                end
                            end
                            for _, v in ipairs(map) do
                                if not is_crazy(v) then
                                    if v.obj ~= max_map.obj then
                                        return v
                                    end
                                end
                            end
                        end
                    end
                    return false
                end
                
                -- 是否另存为
                local function item_save_as(goods,cfg_object)
                    local satisfy = {}
                    for _, v in ipairs(items_info) do
                        if not v["不撿"] and v["存倉頁名"] and v["存倉頁名"] ~= "" and string.find(v["基礎類型名"],goods.baseType_utf8) then
                            local color = goods.color or -1
                            if  v['颜色'] and next(v['颜色']) and poe2_api.table_contains(color,v['颜色']) then
                                table.insert(satisfy,v)
                            end
                            
                        end
                    end
                    if satisfy and next(satisfy) then
                        for _, v in ipairs(satisfy) do
                            if not deep_equal_unordered_full(v,cfg_object) then
                                if v["工會倉庫"] then
                                    
                                    if poe2_api.table_contains(game_str.Enhancement_Item_List_TWCH,goods.baseType_utf8) then
                                        local mininumber = nil
                                        local miniobj = nil
                                        for _, v in ipairs(bag) do
                                            if v.baseType_utf8 == goods.baseType_utf8 and poe2_api.table_contains(game_str.Enhancement_Item_List_TWCH,goods.baseType_utf8) then
                                                if not mininumber or mininumber > v.stackCount then
                                                    miniobj = v
                                                    mininumber = v.stackCount
                                                end
                                            end
                                        end
                                        return {miniobj,v["存倉頁名"],1}
                                    else
                                        return {goods,v["存倉頁名"],1}
                                    end
                                else
                                    if poe2_api.table_contains(game_str.Enhancement_Item_List_TWCH,goods.baseType_utf8) then
                                        local mininumber = nil
                                        local miniobj = nil
                                        for _, v in ipairs(bag) do
                                            if v.baseType_utf8 == goods.baseType_utf8 and poe2_api.table_contains(game_str.Enhancement_Item_List_TWCH,goods.baseType_utf8) then
                                                if not mininumber or mininumber > v.stackCount then
                                                    miniobj = v
                                                    mininumber = v.stackCount
                                                end
                                            end
                                        end
                                        return {miniobj,v["存倉頁名"],0}
                                    else
                                        return {goods,v["存倉頁名"],0}
                                    end
                                end
                            end
                        end
                    end  
                    return false
                end
                -- 判断是否设置了词缀
                local function is_valid_affix(affix)
                    return affix and (affix["name"] and affix.name ~= "")         
                end
                local function get_ct_config(object_cfg)
                    local affixes = object_cfg["物品詞綴"] or {}
                    for _, affix_group in pairs(affixes) do
                        if affix_group and type(affix_group) == "table" then
                            local affix_list = affix_group["詞綴"]
                            if affix_list then
                                for _, affix in ipairs(affix_list) do
                                    if is_valid_affix(affix) then
                                        -- poe2_api.dbgp("找到有效詞綴："..affix.name)
                                        return true
                                    end
                                end
                            end
                        end
                    end
                    return false
                end
                local function plaque_optimal(item)
                    if next(env.settings_cfg_plaque) then
                        for _, v in ipairs(env.settings_cfg_plaque) do
                            if string.find(item.baseType_utf8,v["基礎類型名"]) then
                                poe2_api.dbgp("fffffffffffffffffffffffffffffffffffff")
                                if next(v["物品詞綴"]) then
                                    return true
                                end
                            end
                        end
                    end 
                    return false
                end
                local min_map = poe2_api.select_best_map_key({inventory=bag,index = 1,no_categorize_suffixes = 1,min_level=map_ys_level_min,trashest=true})
                
                if unique_storage_pages and next(unique_storage_pages) then
                    for _, i in ipairs(unique_storage_pages) do
                        for _, b in ipairs(bag) do
                            -- poe2_api.dbgp("b.baseType_utf8:"..b.baseType_utf8)
                            for _, item in ipairs(items_info) do
                                if poe2_api.match_item(b,item) and item["存倉頁名"] == i and not item["工會倉庫"] and not item["不撿"] then
                                    if ((item["名稱"] and item["名稱"] ~= "" and item["名稱"] ~= "全部物品") or get_ct_config(item)) and b.not_identified then
                                        poe2_api.dbgp("1")
                                        break
                                    end
                                    if b.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                        break
                                    end
                                    if b.category_utf8 ~= game_str.StackableCurrency and poe2_api.is_do_without_pick_up(b,items_info) then
                                        poe2_api.dbgp("2")
                                        break
                                    end
                                    if b.category_utf8 == game_str.QuestItem then
                                        poe2_api.dbgp("3")
                                        break
                                    end
                                    if poe2_api.table_contains(game_str.Enhancement_Item_List_TWCH,b.baseType_utf8) then
                                        local number = 0
                                        for _, v in ipairs(bag) do
                                            if v.baseType_utf8 == b.baseType_utf8 and poe2_api.table_contains(game_str.Enhancement_Item_List_TWCH,v.baseType_utf8) then
                                                number = number + v.stackCount
                                            end
                                        end
                                        -- poe2_api.dbgp("number:"..number)
                                        -- api_Sleep(3000)
                                        if number <= 20 then
                                            break
                                        end
                                    end
                                    if env.special_mode_enabled then
                                        if b.baseType_utf8 == env.special_map_type then
                                            break
                                        end
                                    end
                                    if b.category_utf8 == game_str.Map_EN then
                                        local map_not_level = get_map_not_level()
                                        if map_not_level then
                                            env.store_item = {map_not_level,i,0}
                                            poe2_api.dbgp("4")
                                            return true
                                        end
                                        if b.color > 0 then
                                            if not_use_map then
                                                local not_entry = get_map_not_entry()
                                                if not_entry then
                                                    env.store_item = {not_entry,i,0}
                                                    poe2_api.dbgp("5")
                                                    return true
                                                end    
                                            end   
                                        end
                                        if not map_index() then
                                            poe2_api.dbgp("6")
                                            break
                                        end
                                        local crazy = get_map_not_crazy()
                                        if crazy then
                                            env.store_item = {crazy,i,0}
                                            poe2_api.dbgp("7")
                                            return true
                                        end
                                        if min_map and b.obj ~= min_map.obj then
                                            poe2_api.dbgp("8")
                                            break
                                        end 
                                    end
                                    -- if is_insert_stone then
                                    if b.category_utf8 == game_str.TowerAugmentation and env.is_get_plaque then
                                        poe2_api.dbgp("9")
                                        break
                                    end
                                    -- end
                                    local item_entry = item["物品詞綴"] or {}
                                    if item_entry and next(item_entry) then
                                        local function get_cfg_entry(entry_list)
                                            for k, v in pairs(entry_list) do
                                                if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                                    if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                        return true
                                                    end
                                                end
                                            end
                                            return false
                                        end
                                        local function get_cfg_entry_tower()
                                            for k, v in pairs(item_entry) do
                                                if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                                    if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                        for i, v1 in ipairs(v["詞綴"]) do
                                                            if not string.find(v1["name"],"範圍內") then
                                                                return true
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                            return false
                                        end
                                        
                                        if get_cfg_entry(item_entry) then
                                            local a = false
                                            if b.category_utf8 == game_str.TowerAugmentation then
                                                if get_cfg_entry_tower() then
                                                    if env.plaque_upgrade then
                                                        if b.color == 0 or (b.color == 1 and b.fixedSuffixCount<2) or b.not_identified then
                                                            env.tower_do = true
                                                            break
                                                        end
                                                    -- else
                                                    --     a = true
                                                    end
                                                end
                                            else
                                                a = false
                                            end
                                            if not a then
                                                if poe2_api.table_contains(b.category_utf8,my_game_info.equip_type) and not b.not_identified then
                                                    local suffixes = api_GetObjectSuffix(b.mods_obj)
                                                    if suffixes and next(suffixes) and not poe2_api.filter_item(b,suffixes,config["物品過濾"]) then
                                                        break
                                                    end
                                                end
                                            end
                                            
                                        end
                                        
                                    end
                                    if b.category_utf8 == game_str.TowerAugmentation then
                                        if plaque_optimal(b) and env.plaque_upgrade then
                                            if b.color == 0 or (b.color == 1 and b.fixedSuffixCount<2) or b.not_identified then
                                                -- poe2_api.dbgp("qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq")
                                                env.tower_do = true
                                                break
                                            end
                                        end
                                    end
                                    -- if poe2_api.table_contains(b.category_utf8,my_game_info.equip_type) and not b.not_identified then
                                    --     local suffixes = api_GetObjectSuffix(b.mods_obj)
                                    --     if suffixes and next(suffixes) and not poe2_api.filter_item(b,suffixes,config["物品過濾"]) then
                                    --         poe2_api.dbgp("10")
                                    --         break
                                    --     end
                                    -- end
                                    local save_as = item_save_as(b,item)
                                    if save_as and next(save_as) then
                                        env.store_item  = save_as
                                        poe2_api.dbgp("11")
                                        return true
                                    end
                                    if poe2_api.table_contains(game_str.Enhancement_Item_List_TWCH,b.baseType_utf8) then
                                        local mininumber = nil
                                        local miniobj = nil
                                        for _, v in ipairs(bag) do
                                            if v.baseType_utf8 == b.baseType_utf8 and poe2_api.table_contains(game_str.Enhancement_Item_List_TWCH,v.baseType_utf8) then
                                                if not mininumber or mininumber > v.stackCount then
                                                    miniobj = v
                                                    mininumber = v.stackCount
                                                end
                                            end
                                        end
                                        env.store_item = {miniobj,i,0}
                                        -- return {miniobj,v["存倉頁名"],0}
                                    else
                                        env.store_item = {b,i,0}
                                        -- return {goods,v["存倉頁名"],0}
                                    end
                                    return true
                                end
                            end
                        end
                    end
                end
                if public_warehouse_pages and next(public_warehouse_pages) then
                    for _, i in ipairs(public_warehouse_pages) do
                        for _, b in ipairs(bag) do
                            for _, item in ipairs(items_info) do
                                if poe2_api.match_item(b,item) and item["存倉頁名"] == i and item["工會倉庫"] and not item["不撿"] then
                                    if ((item["名稱"] and item["名稱"] ~= "" and item["名稱"] ~= "全部物品") or get_ct_config(item)) and b.not_identified then
                                        break
                                    end
                                    if b.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                        break
                                    end
                                    if b.category_utf8 ~= game_str.StackableCurrency and poe2_api.is_do_without_pick_up(b,items_info) then
                                        break
                                    end
                                    if b.category_utf8 == game_str.QuestItem then
                                        break
                                    end
                                    if poe2_api.table_contains(game_str.Enhancement_Item_List_TWCH,b.baseType_utf8) then
                                        local number = 0
                                        for _, v in ipairs(bag) do
                                            if v.baseType_utf8 == b.baseType_utf8 and poe2_api.table_contains(game_str.Enhancement_Item_List_TWCH,v.baseType_utf8) then
                                                number = number + v.stackCount
                                            end
                                        end
                                        if number <= 20 then
                                            break
                                        end
                                    end
                                    if env.special_mode_enabled then
                                        if b.baseType_utf8 == env.special_map_type then
                                            break
                                        end
                                    end
                                    if b.category_utf8 == game_str.Map_EN then
                                        local map_not_level = get_map_not_level()
                                        if map_not_level then
                                            env.store_item = {map_not_level,i,1}
                                            return true
                                        end
                                        if b.color > 0 then
                                            if not_use_map then
                                                local not_entry = get_map_not_entry()
                                                if not_entry then
                                                    env.store_item = {not_entry,i,1}
                                                    return true
                                                end    
                                            end   
                                        end
                                        if not map_index() then
                                            break
                                        end
                                        local crazy = get_map_not_crazy()
                                        if crazy then
                                            env.store_item = {crazy,i,1}
                                            return true
                                        end
                                        if min_map and b.obj ~= min_map.obj then
                                            break
                                        end 
                                    end
                                    -- if is_insert_stone then
                                    if b.category_utf8 == game_str.TowerAugmentation and env.is_get_plaque then
                                        break
                                    end
                                    -- end
                                    local item_entry = item["物品詞綴"] or {}
                                    if item_entry and next(item_entry) then
                                        local function get_cfg_entry(entry_list)
                                            for k, v in pairs(entry_list) do
                                                if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                                    if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                        return true
                                                    end
                                                end
                                            end
                                            return false
                                        end
                                        local function get_cfg_entry_tower()
                                            for k, v in pairs(item_entry) do
                                                if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                                    if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                        for i, v1 in ipairs(v["詞綴"]) do
                                                            if not string.find(v1["name"],"範圍內") then
                                                                return true
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                            return false
                                        end
                                        
                                        if get_cfg_entry(item_entry) then
                                            local a = false
                                            if b.category_utf8 == game_str.TowerAugmentation then
                                                if get_cfg_entry_tower() then
                                                    if env.plaque_upgrade then
                                                        if b.color == 0 or (b.color == 1 and b.fixedSuffixCount<2) or b.not_identified then
                                                            env.tower_do = true
                                                            break
                                                        end
                                                    -- else
                                                    --     a = true
                                                    end
                                                end
                                            else
                                                a = false
                                            end
                                            if not a then
                                                if poe2_api.table_contains(b.category_utf8,my_game_info.equip_type) and not b.not_identified then
                                                    local suffixes = api_GetObjectSuffix(b.mods_obj)
                                                    if suffixes and next(suffixes) and not poe2_api.filter_item(b,suffixes,config["物品過濾"]) then
                                                        break
                                                    end
                                                end
                                            end
                                            
                                        end
                                        
                                        
                                    end
                                    -- poe2_api.dbgp("qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq")
                                    if b.category_utf8 == game_str.TowerAugmentation then
                                        -- poe2_api.dbgp("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
                                        if plaque_optimal(b)  and env.plaque_upgrade then
                                            -- poe2_api.dbgp("bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb")
                                            if b.color == 0 or (b.color == 1 and b.fixedSuffixCount<2) or b.not_identified then
                                                -- poe2_api.dbgp("cccccccccccccccccccccccccccc")
                                                env.tower_do = true
                                                break
                                            end
                                        end
                                    end
                                    -- if poe2_api.table_contains(b.category_utf8,my_game_info.equip_type) and not b.not_identified then
                                    --     local suffixes = api_GetObjectSuffix(b.mods_obj)
                                    --     if suffixes and next(suffixes) and not poe2_api.filter_item(b,suffixes,config["物品過濾"]) then
                                    --         break
                                    --     end
                                    -- end
                                    local save_as = item_save_as(b,item)
                                    if save_as and next(save_as) then
                                        env.store_item  = save_as
                                        return true
                                    end
                                    if poe2_api.table_contains(game_str.Enhancement_Item_List_TWCH,b.baseType_utf8) then
                                        local mininumber = nil
                                        local miniobj = nil
                                        for _, v in ipairs(bag) do
                                            if v.baseType_utf8 == b.baseType_utf8 and poe2_api.table_contains(game_str.Enhancement_Item_List_TWCH,v.baseType_utf8) then
                                                if not mininumber or mininumber > v.stackCount then
                                                    miniobj = v
                                                    mininumber = v.stackCount
                                                end
                                            end
                                        end
                                        env.store_item = {miniobj,i,1}
                                        -- return {miniobj,v["存倉頁名"],0}
                                    else
                                        env.store_item = {b,i,1}
                                        -- return {goods,v["存倉頁名"],0}
                                    end
                                    return true
                                end
                            end
                        end
                    end
                end
                return false
            end
            local player_info = env.player_info
            local bag_info = env.bag_info
            -- local current_map_info = env.current_map_info
            -- 没有人物信息
            if not next(player_info) then
                poe2_api.time_p("是否存储物品（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            
            -- 是否需要合成
            if env.is_need_strengthen then
                poe2_api.time_p("是否存储物品（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            -- 背包为空
            if not bag_info or not next(bag_info) then
                poe2_api.time_p("是否存储物品（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local point = poe2_api.get_space_point({width=1,height=1,info=env.bag_info})
            if not point then
                env.is_public_warehouse = true
                env.is_public_warehouse_plaque = true
                -- poe2_api.time_p("是否存储物品（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                -- return bret.RUNNING
            end
            -- 是否需要点金
            if not env.is_public_warehouse then
                poe2_api.time_p("是否存储物品（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            -- 碑牌是否需要点金
            if not env.is_public_warehouse_plaque then
                poe2_api.time_p("是否存储物品（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local items_info = poe2_api.get_items_config_info(config)
            local unique_storage_pages = {}
            for _, v in ipairs(items_info) do
                if v['存倉頁名'] and v['存倉頁名'] ~= "" and not v['工會倉庫'] and not v["不撿"] then
                    table.insert(unique_storage_pages,v['存倉頁名'])
                end
            end
            
            local public_warehouse_pages = {}
            for _, v in ipairs(items_info) do
                if v['存倉頁名'] and v['存倉頁名'] ~= "" and v['工會倉庫'] and not v["不撿"] then
                    table.insert(public_warehouse_pages,v['存倉頁名'])
                end
            end
            -- 未配置物品过滤
            if (not unique_storage_pages or not next(unique_storage_pages)) and (not public_warehouse_pages or not next(public_warehouse_pages)) then
                poe2_api.time_p("是否存储物品（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local map_level_type = {}
            local map_ys_level_min = 0
            for _, v in ipairs(items_info) do
                if string.find(v["類型"],game_str.Map_Key_CH) and not v["不撿"] then
                    table.insert(map_level_type,v['等級'])
                end
            end
            if next(map_level_type) then
                local map_type = map_level_type[1]["type"]
                if map_type == "exact" then
                    local item_level = map_level_type[1]["value"]
                    map_ys_level_min = item_level-3
                else
                    local min_level = map_level_type[1]["min"]
                    map_ys_level_min = min_level
                end
            end
            -- 是否需要插入碑牌
            -- local is_insert_stone = env.is_insert_stone
            local bag_store_info = get_store_bag_info(bag_info)
            -- poe2_api.dbgp("bag_store_info",type(bag_store_info),#bag_store_info)
            local store = get_store_item(bag_store_info,unique_storage_pages,public_warehouse_pages,map_ys_level_min)
            
            if not store then
                -- poe2_api.dbgp("ooooooooooooooo")
                local not_config_altar_item = nil
                for _, v in ipairs(bag_info) do
                    if poe2_api.table_contains(altar_shop_config,v.baseType_utf8) then
                        not_config_altar_item = v
                    end
                end
                if not_config_altar_item then
                    if not is_not_altar_shop(not_config_altar_item) then
                        local text = poe2_api.get_item_type(not_config_altar_item)
                        local item_key = ""
                        if text ~= "" then
                            item_key = text
                        else
                            for k, v in ipairs(my_game_info.type_conversion) do
                                if not_config_altar_item.category_utf8 == v then
                                    item_key = k
                                    break
                                end
                            end
                        end
                        error("未配置购物祭祀物品：->"..not_config_altar_item.name_utf8 .."<-,物品类型为:->".. item_key .."<-,相关存储页请在物品配置中添加")
                    end
                end
                if env.tower_do then
                    env.store = true
                    -- api_Sleep(10000)
                    poe2_api.time_p("是否存储物品（RUNNING333）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                
                env.exchange_status = false
                env.storage_complete = true
                poe2_api.time_p("是否存储物品（SUCCESS8）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            env.store = false
            env.tower_do = false
            env.storage_complete = false
            local store_item = env.store_item
            poe2_api.dbgp("store_item",store_item[1].baseType_utf8,store_item[3])
            -- api_Sleep(5000)
            if store_item[3] == 0 then
                if poe2_api.find_text({UI_info=env.UI_info,text=game_str.Emphasize_the_item,min_y=700,min_x=250}) and poe2_api.find_text({UI_info=env.UI_info,text=game_str.Guild_Warehouse,min_x=0,min_y=32,max_x=381,max_y=78}) then
                    -- poe2_api.click_keyboard('space')
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Guild_Warehouse, min_x=0,min_y=32,max_x=381,max_y=78, click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("是否存储物品（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            elseif store_item[3] == 1 then
                poe2_api.dbgp(game_str.Guild_Warehouse_text)
                if poe2_api.find_text({UI_info=env.UI_info,text=game_str.Emphasize_the_item,min_y=700,min_x=250}) and poe2_api.find_text({UI_info=env.UI_info,text=game_str.Warehouse,min_x=0,min_y=32,max_x=381,max_y=78}) then
                    -- poe2_api.click_keyboard('space')
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Warehouse, min_x=0,min_y=32,max_x=381,max_y=78, click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("是否存储物品（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            if env.store_item[3] == 0 then
                env.warehouse_type_interactive = game_str.Warehouse_text
            else
                env.warehouse_type_interactive = game_str.Guild_Warehouse_text
            end
            poe2_api.dbgp("存仓-----------------------------------------------1010101")
            poe2_api.time_p("是否存储物品（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
            
        end
    },

    -- 存储动作
    Store_Items = {
        run = function(self, env)
            poe2_api.print_log("存储行为...")
            local start_time = api_GetTickCount64()
            poe2_api.dbgp("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
            local text = ""
            if env.warehouse_type_interactive == game_str.Warehouse_text then
                text = game_str.Warehouse
                if poe2_api.find_text({text = game_str.Emphasize_the_item,UI_info = env.UI_info,min_x = 250,min_y = 700}) 
                and poe2_api.find_text({text = game_str.Guild_Warehouse,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=78}) then
                    -- poe2_api.click_keyboard("space")
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Guild_Warehouse, min_x=0,min_y=32,max_x=381,max_y=78, click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("存储动作（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            elseif env.warehouse_type_interactive == game_str.Guild_Warehouse_text then
                text = game_str.Guild_Warehouse
                if poe2_api.find_text({text = game_str.Emphasize_the_item,UI_info = env.UI_info,min_x = 250,min_y = 700}) 
                and poe2_api.find_text({text = game_str.Warehouse,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=78}) then
                    poe2_api.find_text({text = game_str.Warehouse,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=78,click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("存储动作（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            else
                error("未知的仓库类型")
            end
            if not poe2_api.find_text({text = game_str.Emphasize_the_item,UI_info = env.UI_info,min_x = 250,min_y = 700}) then
            -- and poe2_api.find_text({text = text,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=78}) then
                poe2_api.dbgp("存仓11111-----------------------------------------------1010101")
                poe2_api.time_p("存储动作（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            
            if not self.bool then
                self.type = 0
                self.timeout = 0
                self.is_wait = false
                self.wait_item = nil
                self.current = nil
                self.obj = nil
                self.num = 0
                self.bool = true
                self.page = nil
                poe2_api.time_p("存储动作（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local store_item = env.store_item
            local bag_info = env.bag_info
            local current_map_info = env.current_map_info
            local config = env.user_config
            local map_config = config['刷圖設置'][game_str.Map_Key_CH]
            local currency_exchange_is_opens = config['刷圖設置']["通貨交換設置"]
            local godown_info = api_GetRepositoryPages(store_item[3])
            if self.page then
                if store_item[2] ~= self.page then
                    env.page_full_list = {}
                    self.page = store_item[2]
                end
            end
            if not self.page then
                self.page = store_item[2]
            end
            if next(env.page_full_list) and poe2_api.table_contains(env.page_full_list,tostring(store_item[2])) then
                for _, v in ipairs(godown_info) do
                    -- poe2_api.dbgp(v.name_utf8)
                    if v.name_utf8 ~= "" and v.name_utf8 ~= tostring(store_item[2]) and not poe2_api.table_contains(env.page_full_list,v.name_utf8) then
                        if poe2_api.table_contains(v.type,{0,1,7}) then
                            store_item[2] = v.name_utf8
                            break
                        end
                        
                        
                    end
                end
            end
            local function is_everything_liquidated()
                if not next(env.page_full_list) then
                    return true
                end
                for _, v in pairs(godown_info) do
                    if v.name_utf8 ~= "" and not poe2_api.table_contains(env.page_full_list,v.name_utf8) then
                        if poe2_api.table_contains(v.type,{0,1,7}) then
                            return true
                            -- return false
                        end
                        
                    end
                end
                return false
            end
            local a = is_everything_liquidated()
            poe2_api.dbgp("is_everything_liquidated:",a)
            poe2_api.dbgp("store_item[2]:",store_item[2])
            -- return bret.SUCCESS
            local function map_color()
                local color_map = {}
                if not map_config or not next(map_config) then
                    return false
                end
                for _, i in ipairs(map_config) do
                    local color = {}
                    if i["白"] then table.insert(color, 0) end
                    if i["藍"] then table.insert(color, 1) end
                    if i["黃"] then table.insert(color, 2) end
                    color_map[i["階級"]] = color
                end
                return color_map
            end
            local function is_get_map_color(map_info,map)
                if not map_info or not next(map_info) then
                    return false
                end
                for k, v in ipairs(map_info) do
                    if poe2_api.extract_level(map.baseType_utf8) == k then
                        if v then
                            if poe2_api.table_contains(map.color,v) then
                                return true
                            end
                        end
                    end
                end
                return false
            end
            local map_color_info = map_color()
            -- 检测某物品是否超过三
            local function has_three_duplicates(lst)
                local counter = {}
                for _, v in ipairs(lst) do
                    counter[v] = (counter[v] or 0) + 1
                end
                for _, count in pairs(counter) do
                    if count >= 3 then
                        return true
                    end
                end
                return false
            end
            local items_info = poe2_api.get_items_config_info(config)
            
            local page = {}
            local index = 0
            if store_item[3] == 0 then
                for _, item in ipairs(items_info) do
                    if not item["不撿"] and string.find(item["類型"],game_str.Map_Key_CH) and not item["工會倉庫"] then
                        table.insert(page,item["存倉頁名"])
                        index = 0
                    end  
                end
            else
                for _, item in ipairs(items_info) do
                    if not item["不撿"] and string.find(item["類型"],game_str.Map_Key_CH) and item["工會倉庫"] then
                        table.insert(page,item["存倉頁名"])
                        index = 2
                    end  
                end
            end
            if self.timeout == 0 then
                self.timeout = api_GetTickCount64()
            end
            if api_GetTickCount64() - self.timeout > 5000 then
                self.type = 0
                self.timeout = 0
            end
            if next(env.page_full_list) and not is_everything_liquidated() then
                if store_item[3] == 1 then
                    error("仓库已满，手动清理1111")
                else
                    currency_exchange_is_opens = currency_exchange_is_opens["是否自動對換"] or false
                    if currency_exchange_is_opens then
                        if env.exchange_status then
                            error("仓库已满，手动清理1111")
                        end
                        if env.warehouse_full and not poe2_api.get_space_point({width=2,height=4,info=bag_info}) then
                            error("仓库已满，手动清理1111")
                        end
                        env.warehouse_full = store_item[2]
                        self.num = 0
                        poe2_api.time_p("存储动作（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    else
                        error("仓库已满，手动清理1111")
                    end
                end
            end
            if store_item[3] == 1 then
                if self.num > 16 and is_everything_liquidated() then
                    table.insert(env.page_full_list,tostring(store_item[2]))
                    self.num = 0
                    poe2_api.time_p("存储动作（RUNNING17）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                    -- error("仓库已满，手动清理1111")
                end
            else
                if self.num > 8 and is_everything_liquidated() then
                    table.insert(env.page_full_list,tostring(store_item[2]))
                    self.num = 0
                    poe2_api.time_p("存储动作（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                    -- currency_exchange_is_opens = currency_exchange_is_opens["是否自動對換"] or false
                    -- if currency_exchange_is_opens then
                    --     if env.exchange_status then
                    --         error("仓库已满，手动清理1111")
                    --     end
                    --     if env.warehouse_full and not poe2_api.get_space_point({width=2,height=4,info=bag_info}) then
                    --         error("仓库已满，手动清理1111")
                    --     end
                    --     env.warehouse_full = store_item[2]
                    --     self.num = 0
                    --     poe2_api.time_p("存储动作（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    --     return bret.RUNNING
                    -- else
                    --     error("仓库已满，手动清理1111")
                    -- end
                end
            end
            if self.is_wait then
                if api_GetTickCount64() - self.current < self.wait_item then
                    poe2_api.print_log("等待间隔时间到达")
                    poe2_api.time_p("存储动作（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            if not poe2_api.find_text({text=game_str.backpack,UI_info=env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                poe2_api.click_keyboard("i")
                api_Sleep(500)
                poe2_api.dbgp("开背包5")
                self.is_wait = true
                self.current = api_GetTickCount64()
                self.wait_item = 1000
                poe2_api.time_p("存储动作（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            self.is_wait = false
            local tab_list_button = poe2_api.click_text_UI({text = game_str.tab_list_button, UI_info = env.UI_info,ret_data = true})
            
            local precut_page = nil
            -- poe2_api.dbgp(store_item[1].name_utf8)
            for _, v in ipairs(godown_info) do
                -- poe2_api.dbgp(v.name_utf8)
                if v.name_utf8 ~= "" then
                    if v.name_utf8 == tostring(store_item[2]) then
                        precut_page = v
                        break
                    end
                end
            end
            if not precut_page then
                poe2_api.print_log("找不到仓库页2222 ->"..store_item[2].."<-")
                api_Sleep(1000)
                poe2_api.time_p("存储动作（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if not tab_list_button then
                
                if self.type ~= store_item[2] or precut_page.manage_index == 0 then
                    if poe2_api.find_text({text=store_item[2],UI_info=env.UI_info,max_y=90,min_x=10,max_x=500,click = 2}) then
                        poe2_api.find_text({text=store_item[2],UI_info=env.UI_info,max_y=90,min_x=10,max_x=500,click = 2})
                        self.is_wait = true
                        self.current = api_GetTickCount64()
                        self.wait_item = 500
                        self.type = store_item[2]
                        poe2_api.time_p("存储动作（RUNNING8）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    
                    else
                        poe2_api.print_log("找不到仓库页333 ->"..store_item[2].."<-")
                        api_Sleep(1000)
                        poe2_api.time_p("存储动作（RUNNING9）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                end
            else
                local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
                local lock_button = {}
                for _,v in ipairs(lock) do
                    if v.name_utf8 == "" and v.text_utf8 == "" then
                        table.insert(lock_button,v)
                    end
                end
                if not lock_button or not next(lock_button) then
                    api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                    api_Sleep(2000)
                    api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),1)
                    api_Sleep(1000)
                    poe2_api.time_p("存储动作（RUNNING10）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                -- poe2_api.dbgp("self.type1111:",self.type)
                -- poe2_api.dbgp("store_item:",store_item[2])
                -- poe2_api.dbgp("precut_page:",precut_page)
                -- poe2_api.dbgp("precut_pagemanage_index:",precut_page.manage_index)
                -- -- poe2_api.printTable(godown_info)
                -- for _, v in ipairs(godown_info) do
                --     if v.name_utf8 == tostring(store_item[2]) then
                --     -- self.manage_index,     # 管理器索引
                --     -- self.page_index,       # 頁的索引，例如在第幾頁
                --     -- self.type,             # 页的类型
                --     -- self.name_utf8,        # 页名
                --         poe2_api.dbgp("name_utf8",v.name_utf8)
                --         poe2_api.dbgp("manage_index",v.manage_index)
                --         poe2_api.dbgp("page_index",v.name_utf8)
                --         poe2_api.dbgp("type",v.manage_index)

                --         -- poe2_api.dbgp(v.name)
                --         poe2_api.dbgp("--------")
                --     end
                -- end
                -- poe2_api.dbgp("=================================")
                if self.type ~= store_item[2] or precut_page.manage_index == 0 then
                    if poe2_api.find_text({text=store_item[2],UI_info=env.UI_info,max_y=800,min_x=556,min_y=20,max_x=851,click = 2}) then
                        poe2_api.find_text({text=store_item[2],UI_info=env.UI_info,max_y=800,min_x=556,min_y=20,max_x=851,click = 2})
                        self.is_wait = true
                        self.current = api_GetTickCount64()
                        self.wait_item = 500
                        self.type = store_item[2]
                        poe2_api.time_p("存储动作（RUNNING11）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    else
                        poe2_api.print_log("找不到仓库页1111 ->"..store_item[2].."<-")
                        api_Sleep(1000)
                        poe2_api.time_p("存储动作（RUNNING12）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                end
            end
            local need_synthesis = config["全局設置"]["刷图通用設置"]["自動合成地圖"]
            if need_synthesis then
                local is_czt = nil
                for _, v in ipairs(current_map_info) do
                    if v.name_utf8 == game_str.TreasureVaultHammerActive and v.flagStatus1 == 1 then
                        is_czt = v
                        break
                    end
                end
                if is_czt and page and next(page) and self.type == page[1] then
                    local warehouse = api_Getinventorys(precut_page.manage_index,index)
                    if warehouse and next(warehouse) then
                        local a = {}
                        for _, v in ipairs(warehouse) do
                            if v.category_utf8 == game_str.Map_EN and not v.contaminated and poe2_api.extract_level(v.baseType_utf8)<15 and is_get_map_color(map_color_info,v) then
                                table.insert(a,v.baseType_utf8)
                            end
                        end
                        if a and next(a) then
                            if has_three_duplicates(a) then 
                                env.is_need_strengthen = true
                                poe2_api.time_p("存储动作（RUNNING13）... 耗时 --> ", api_GetTickCount64() - start_time)
                                return bret.RUNNING
                            else
                                env.is_need_strengthen = false
                            end
                        else
                            env.is_need_strengthen = false
                        end
                    end
                end
            end
            if poe2_api.table_contains(precut_page.type,{0,1}) then
                local warehouse = api_Getinventorys(precut_page.manage_index,index)
                if warehouse and next(warehouse) then
                    if env.need_sale_map and store_item[1].category_utf8 == game_str.Map_EN then
                        local count = poe2_api.get_space_point({width=1,height=1,w=12,h=12,gox=14,goy=99,info=warehouse,ret_number = true})
                        if count == 0 then
                            env.map_page_full = store_item[1].category_utf8
                            poe2_api.time_p("存储动作（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        end
                        local bag_map_count = 0
                        for _, v in ipairs(bag_info) do
                            if v.category_utf8 == game_str.Map_EN then
                                bag_map_count = bag_map_count + 1
                            end
                        end
                        poe2_api.dbgp("bag_map_count:",bag_map_count)
                        poe2_api.dbgp("count:",count)
                        -- api_Sleep(100000)
                        if count <= bag_map_count - 3 then
                            env.map_page_full = store_item[1].category_utf8
                            poe2_api.dbgp("map_page_full:",env.map_page_full)
                            -- api_Sleep(3000)
                            poe2_api.time_p("存储动作（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        end
                    end
                    local w = store_item[1].end_x - store_item[1].start_x
                    local h = store_item[1].end_y - store_item[1].start_y
                    local point = poe2_api.get_space_point({width=w,height=h,w=12,h=12,gox=14,goy=99,info=warehouse})
                    if not point and is_everything_liquidated() then 
                        table.insert(env.page_full_list,tostring(store_item[2]))
                        self.num = 0
                        poe2_api.time_p("存储动作（RUNNING18）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                        -- currency_exchange_is_opens = currency_exchange_is_opens["是否自動對換"] or false
                        -- if currency_exchange_is_opens then
                        --     if env.exchange_status then
                        --         error("仓库已满，手动清理2222")
                        --     end
                        --     if env.warehouse_full and not poe2_api.get_space_point({width=2,height=4,info=bag_info}) then
                        --         error("仓库已满，手动清理2222")
                        --     end
                        --     if store_item[3] == 0 then
                        --         env.warehouse_full = store_item[2]
                        --         poe2_api.time_p("存储动作（RUNNING14）... 耗时 --> ", api_GetTickCount64() - start_time)
                        --         return bret.RUNNING
                        --     else
                        --         error("仓库已满，手动清理2222")
                        --     end
                        -- else
                        --     error("仓库已满，手动清理2222")
                        -- end
                    end
                end
            elseif precut_page.type == 7 then
                local warehouse = api_Getinventorys(precut_page.manage_index,index)
                if warehouse and next(warehouse) then
                    if env.need_sale_map and store_item[1].category_utf8 == game_str.Map_EN then
                        local count = poe2_api.get_space_point({width=1,height=1,w=24,h=24,gox=14,goy=99,grid_x=22,grid_y=22,info=warehouse,ret_number = true})
                        if count == 0 then
                            env.map_page_full = store_item[1].category_utf8
                            poe2_api.time_p("存储动作（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        end
                        local bag_map_count = 0
                        for _, v in ipairs(bag_info) do
                            if v.category_utf8 == game_str.Map_EN then
                                bag_map_count = bag_map_count + 1
                            end
                        end
                        poe2_api.dbgp("bag_map_count:",bag_map_count)
                        poe2_api.dbgp("count:",count)
                        -- api_Sleep(100000)
                        if count <= bag_map_count - 3 then
                            env.map_page_full = store_item[1].category_utf8
                            poe2_api.dbgp("map_page_full:",env.map_page_full)
                            -- api_Sleep(3000)
                            poe2_api.time_p("存储动作（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        end
                    end
                    local w = store_item[1].end_x - store_item[1].start_x
                    local h = store_item[1].end_y - store_item[1].start_y
                    local point = poe2_api.get_space_point({width=w,height=h,w=24,h=24,gox=15,goy=100,grid_x=22,grid_y=22,info=warehouse})
                    if not point and is_everything_liquidated() then 
                        table.insert(env.page_full_list,tostring(store_item[2]))
                        self.num = 0
                        poe2_api.time_p("存储动作（RUNNING17）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                        -- currency_exchange_is_opens = currency_exchange_is_opens["是否自動對換"] or false
                        -- if currency_exchange_is_opens then
                        --     if env.exchange_status then
                        --         error("仓库已满，手动清理3333")
                        --     end
                        --     if env.warehouse_full and not poe2_api.get_space_point({width=2,height=4,info=bag_info}) then
                        --         error("仓库已满，手动清理3333")
                        --     end
                        --     if store_item[3] == 0 then
                        --         env.warehouse_full = store_item[2]
                        --         poe2_api.time_p("存储动作（RUNNING15）... 耗时 --> ", api_GetTickCount64() - start_time)
                        --         return bret.RUNNING
                        --     else
                        --         error("仓库已满，手动清理3333")
                        --     end
                            
                        -- else
                        --     error("仓库已满，手动清理3333")
                        -- end
                    end
                end
            end
            if self.obj and self.obj == store_item[1].obj then
                self.num = self.num + 1
            end
            if not self.obj then
                self.obj = store_item[1].obj
            end
            if self.obj ~= store_item[1].obj then
                self.obj = store_item[1].obj
                self.num = 0
            end
            if self.num and self.num ~= 0 and self.num % 3 == 0 then
                local x = math.random(100, 1500)
                local y = math.random(50, 100)
                api_ClickScreen(poe2_api.toInt(x),poe2_api.toInt(y),0)
                api_Sleep(300)
                poe2_api.click_keyboard('alt')
                api_Sleep(300)
                if poe2_api.find_text({text=game_str.Private_message,UI_info=env.UI_info,min_x=0,min_y=0,max_x=1000}) then
                    poe2_api.click_keyboard("enter")
                    api_Sleep(300)
                end
            end
            -- if store_item[2] ~= self.page then
            --     local point = poe2_api.get_center_position({store_item[1].start_x,store_item[1].start_y},{store_item[1].end_x,store_item[1].end_y})
            --     api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1,100,150)
            --     api_Sleep(500)
            --     local point1 = nil
            --     local w = store_item[1].end_x - store_item[1].start_x
            --     local h = store_item[1].end_y - store_item[1].start_y
            --     if precut_page.type == 7 then
                    
            --         local warehouse = api_Getinventorys(precut_page.manage_index,index)
            --     -- if warehouse and next(warehouse) then
            --         point1 = poe2_api.get_space_point({width=w,height=h,w=24,h=24,gox=15,goy=100,grid_x=22,grid_y=22,info=warehouse})
            --     else
            --         local warehouse = api_Getinventorys(precut_page.manage_index,index)
            --     -- if warehouse and next(warehouse) then
            --         point1 = poe2_api.get_space_point({width=w,height=h,w=12,h=12,gox=14,goy=99,info=warehouse})
            --     end
            --     api_ClickScreen(poe2_api.toInt(point1[1]),poe2_api.toInt(point1[2]),1,100,150)
            --     -- api_Sleep(500)
            -- else
            --     poe2_api.ctrl_left_click_bag_items(store_item[1].obj,bag_info,3)
            -- end
            if poe2_api.table_contains(store_item[1].baseType_utf8,game_str.Enhancement_Item_List_TWCH) then
                poe2_api.ctrl_left_click_bag_items(store_item[1].obj,bag_info)
            else
                poe2_api.ctrl_left_click_bag_items(store_item[1].obj,bag_info,3)
            end
            
            api_Sleep(300)
            poe2_api.time_p("存储动作（RUNNING16）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.RUNNING
        end
    },

    -- 是否购买地图
    Is_Shopping_Map = {
        run = function(self, env)
            poe2_api.print_log("是否购买地图...")
            local start_time = api_GetTickCount64()
            if not env.is_shop then
                poe2_api.time_p("是否购买地图（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local player_info = env.player_info
            local bag_info = env.bag_info
            poe2_api.printTable(bag_info)
            if not next(player_info) then
                poe2_api.time_p("是否购买地图（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local config = env.user_config
            local map_config = config['刷圖設置'][game_str.Map_Key_CH]
            local not_use_map = env.not_use_map
            -- 词条过滤
            local function match_item_suffixes(item_suffixes, config_suffixes)
                if not item_suffixes or not next(item_suffixes) then
                    return false
                end
                if not config_suffixes or not next(config_suffixes) then
                    return false
                end
                for _, v in ipairs(item_suffixes) do
                    for _, v1 in ipairs(config_suffixes) do
                        if v.name_utf8 == v1 then
                            return true
                        end
                    end
                end
                return false
            end
            local function get_map_len(bag_info)
                local tiers = {}
                for _, v in ipairs(map_config) do
                    table.insert(tiers,v["階級"])
                end
                local function number_map()
                    if not tiers or not next(tiers) then
                        return false
                    end
                    local map_count = 0
                    poe2_api.printTable(tiers)
                    for _, v in ipairs(bag_info) do
                        if v.category_utf8 == game_str.Map_EN and poe2_api.table_contains(poe2_api.extract_level(v.baseType_utf8),tiers) and not match_item_suffixes(api_GetObjectSuffix(v.mods_obj),not_use_map) then
                            map_count = map_count + 1
                        end
                    end
                    if map_count < 1 then
                        return true
                    end
                    return false
                end
                if not bag_info or not next(bag_info) or number_map() then
                    return true
                end
                return false
            end
            local a = get_map_len(bag_info)
            poe2_api.dbgp("a------------------------------------------------------------------------:",tostring(a))
            if not  a then
                env.is_shop = false
                poe2_api.time_p("是否购买地图（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            poe2_api.time_p("是否购买地图（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end
    },

    -- 打开商店
    Open_Shop = {
        run = function(self, env)
            poe2_api.print_log("打开商店...")
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.index = 0
                self.bool = true
            end
            local player_info = env.player_info
            local current_map_info = env.current_map_info
            -- local range_info = env.range_info
            local warehouse = nil
            if (not current_map_info or not next(current_map_info)) and (not env.range_info or not next(env.range_info)) then
                poe2_api.dbgp("小地图信息和周围对象信息都为空")
                api_Sleep(1000)
                poe2_api.time_p("打开商店（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local warehouse1 = nil
            local warehouse2 = nil
            for _, v in ipairs(current_map_info) do
                if v.name_utf8 == game_str.Appraisal_NPC and v.flagStatus == 0 and v.flagStatus1 == 1 then
                    warehouse1 = v
                end
            end
            if not warehouse1 then
                for _, v in ipairs(env.range_info) do
                    if v.name_utf8 == game_str.Appraisal_NPC and v.is_selectable then
                        warehouse2 = v
                    end
                end
                if warehouse2 then
                    warehouse = warehouse2
                end
            else
                warehouse = warehouse1
            end

            if warehouse then
                local distance = poe2_api.point_distance(warehouse.grid_x,warehouse.grid_y,player_info)
                if poe2_api.find_text({text=game_str.Purchase_or_sell,UI_info=env.UI_info,min_x=0,max_x=800}) and distance <=25 then
                    self.index = 0
                    poe2_api.time_p("打开商店（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
                if poe2_api.find_text({text=game_str.Buy_or_Sell_items_EN,UI_info=env.UI_info,min_x=0,max_x=1600,click=2}) and distance <=25 then
                    api_Sleep(500)
                    poe2_api.time_p("打开商店（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if poe2_api.find_text({text=game_str.Buy_or_Sell_items_CH,UI_info=env.UI_info,min_x=0,max_x=1600,click=2}) and distance <=25 then
                    api_Sleep(500)
                    poe2_api.time_p("打开商店（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if distance and distance > 25 then
                    env.interactive = game_str.Appraisal_NPC
                    poe2_api.time_p("打开商店（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                else
                    api_ClickMove(poe2_api.toInt(warehouse.grid_x),poe2_api.toInt(warehouse.grid_y),1)
                    api_Sleep(500)
                    if self.index >= 10 then
                        poe2_api.dbgp1("111111111111111111111111111111111")
                        poe2_api.click_keyboard("space")
                        api_Sleep(200)
                        self.index = 0
                    end
                    self.index = self.index + 1
                    api_Sleep(200)
                    poe2_api.time_p("打开商店（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            else
                poe2_api.dbgp("找不到多里亞尼")
                poe2_api.time_p("打开商店（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            poe2_api.time_p("打开商店（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 购买地图动作
    Shopping_Map = {
        run = function(self, env)
            poe2_api.print_log("购买地图动作...")
            local start_time = api_GetTickCount64()
            local player_info = env.player_info
            local current_map_info = env.current_map_info
            -- local range_info = env.range_info
            local warehouse = nil
            if (not current_map_info or not next(current_map_info)) and (not env.range_info or not next(env.range_info)) then
                poe2_api.dbgp("小地图信息和周围对象信息都为空")
                api_Sleep(1000)
                poe2_api.time_p("购买地图动作（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local warehouse1 = nil
            local warehouse2 = nil
            for _, v in ipairs(current_map_info) do
                if v.name_utf8 == game_str.Appraisal_NPC and v.flagStatus == 0 and v.flagStatus1 == 1 then
                    warehouse1 = v
                end
            end
            if not warehouse1 then
                for _, v in ipairs(env.range_info) do
                    if v.name_utf8 == game_str.Appraisal_NPC and v.is_selectable then
                        warehouse2 = v
                    end
                end
                if warehouse2 then
                    warehouse = warehouse2
                end
            else
                warehouse = warehouse1
            end
            if warehouse then
                local distance = poe2_api.point_distance(warehouse.grid_x,warehouse.grid_y,player_info)
                poe2_api.print_log("多里亞尼距离: "..distance)
                if distance and distance > 25 then
                    poe2_api.time_p("购买地图动作（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                end
                if not poe2_api.find_text({text=game_str.Purchase_or_sell,UI_info=env.UI_info,min_x=0,max_x=800}) then
                    -- self.index = 0
                    poe2_api.time_p("购买地图动作（FAIL2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                end
            else
                poe2_api.dbgp("小地图和周围对象找不到多里亞尼")
                poe2_api.time_p("购买地图动作（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local config = env.user_config
            local map_config = config['刷圖設置'][game_str.Map_Key_CH]
            local tiers = {}
            for _, v in ipairs(map_config) do
                table.insert(tiers,v["階級"])
            end
            local map = api_GetInventoryItemsInRect(238,215,563,508)
            poe2_api.printTable(map)
            -- api_Sleep(1000000)
            if map and next(map) then
                local function get_max_level(map_shop)
                    local index = nil
                    for _, v in ipairs(map_shop) do
                        if v.category_utf8 == game_str.Map_EN and poe2_api.table_contains(v.mapLevel,tiers) then
                            index = v
                            break
                        end
                    end
                    if index then
                        return index
                    end
                    return false
                end
                local max_map = get_max_level(map)
                if max_map then
                    -- local function get_point(start_cell,end_cell)
                    --     local center_x = 259 + (((start_cell[1] + start_cell[2]) / 2) * 43.81)
                    --     local center_y = 230 + (((end_cell[1] + end_cell[2]) / 2) * 43.81)
                    --     return {center_x,center_y}
                    -- end
                    -- local point = get_point({max_map.RectSart_x, max_map.RectSart_y},{max_map.start_y,max_map.end_y})
                    poe2_api.ctrl_left_click(((max_map.RectSart_x + max_map.RectEnd_x) / 2), ((max_map.RectSart_y + max_map.RectEnd_y) / 2))
                    return bret.RUNNING
                end
            end
            error("商城已无地图或者没有你想要打的等级地图，请手动购买")
            -- return bret.SUCCESS
        end
    },

    -- 更新地图石
    Update_Map_Stone = {
        run = function(self, env)
            poe2_api.print_log("更新地图石...")
            return bret.SUCCESS
        end
    },

    -- 售卖地图
    Selling_Map = {
        run = function(self, env)
            poe2_api.print_log("售卖地图动作...")
            poe2_api.dbgp("售卖地图动作...")
            local player_info = env.player_info
            local current_map_info = env.current_map_info
            local bag_info = env.bag_info
            local warehouse = nil

            if not env.full_map then
                return bret.SUCCESS
            end

            if (not current_map_info or not next(current_map_info)) and (not env.range_info or not next(env.range_info)) then
                poe2_api.dbgp("小地图信息和周围对象信息都为空")
                api_Sleep(1000)
                return bret.RUNNING
            end
            local function get_bag_map(items)
                for _,v in ipairs(items) do
                    if v.category_utf8 == game_str.Map_EN then
                        return v
                    end
                end
                return false
            end
            local function count_bag_map(items)
                local count = 0
                for _,v in ipairs(items) do
                    if v.category_utf8 == game_str.Map_EN then
                        count = count + 1
                    end
                end
                return count
            end
            if count_bag_map(bag_info) <= 2 then
                env.full_map = false
                env.map_page_full = nil
                return bret.RUNNING
            end 
            local warehouse1 = nil
            local warehouse2 = nil
            for _, v in ipairs(current_map_info) do
                if v.name_utf8 == game_str.Appraisal_NPC and v.flagStatus == 0 and v.flagStatus1 == 1 then
                    warehouse1 = v
                end
            end
            if not warehouse1 then
                for _, v in ipairs(env.range_info) do
                    if v.name_utf8 == game_str.Appraisal_NPC and v.is_selectable then
                        warehouse2 = v
                    end
                end
                if warehouse2 then
                    warehouse = warehouse2
                end
            else
                warehouse = warehouse1
            end
            if warehouse then
                local distance = poe2_api.point_distance(warehouse.grid_x,warehouse.grid_y,player_info)
                poe2_api.print_log("多里亞尼距离: "..distance)
                if distance and distance > 25 then
                    return bret.FAIL
                end
                if not poe2_api.find_text({text=game_str.Purchase_or_sell,UI_info=env.UI_info,min_x=0,max_x=800}) then
                    -- self.index = 0
                    poe2_api.dbgp("没有检测到购买和出售按钮")
                    return bret.FAIL
                end
            else
                poe2_api.dbgp("小地图和周围对象找不到多里亞尼")
                return bret.RUNNING
            end
            local selling_map = get_bag_map(bag_info)
            if type(selling_map) == "table" then
                local point = poe2_api.get_center_position({selling_map.start_x,selling_map.start_y},{selling_map.end_x,selling_map.end_y})
                poe2_api.ctrl_left_click(point[1],point[2])
                api_Sleep(100)
                return bret.RUNNING
            end
            return bret.RUNNING
        end
    },

    -- 检查是否需要拿地图(特殊)
    Is_Need_Take_Map_Sp = {
        run = function(self, env)
            poe2_api.dbgp("检查是否需要拿地图(特殊)...")

            if env.special_map_tier > 1 then
                -- 获取异界之门的物品信息
                local door_item_data = api_Getinventorys(0x55, 0)
                local bags = poe2_api.check_item_in_inventory(env.special_map_type, env.bag_info, env.special_map_tier, true)
                poe2_api.dbgp("检查背包是否有 "..env.special_map_type.." 数量: "..bags.." 需求: "..env.special_map_tier)

                poe2_api.dbgp("异界之门物品数据:", door_item_data)
                poe2_api.dbgp("异界之门物品数量:", #door_item_data)

                -- 首先检查表是否为空
                if not door_item_data or #door_item_data < 1 or door_item_data[1].stackCount < env.special_map_tier then
                    poe2_api.dbgp("异界之门没有物品")
                    -- 检查背包和异界之门的总数量是否足够
                    if env.special_map_tier > bags then
                        poe2_api.dbgp("总数量不足,需要拿图")
                        return bret.FAIL
                    else
                        poe2_api.dbgp("背包数量足够,不需要拿图")
                        return bret.SUCCESS
                    end
                end

                -- 检查第一个物品的类型
                local first_item = door_item_data[1]
                if not first_item or first_item.baseType_utf8 ~= env.special_map_type then
                    poe2_api.dbgp("异界之门的物品类型不匹配")
                    -- 检查背包数量是否足够
                    if env.special_map_tier > bags then
                        poe2_api.dbgp("总数量不足,需要拿图")
                        return bret.FAIL
                    else
                        poe2_api.dbgp("背包数量足够,不需要拿图")
                        return bret.SUCCESS
                    end
                end

                -- 检查物品数量（现在first_item肯定存在且类型正确）
                local total_count = bags + first_item.stackCount
                if total_count < env.special_map_tier then
                    poe2_api.dbgp("异界之门和背包的总数量不足,需要拿图")
                    poe2_api.dbgp("异界之门数量: "..first_item.stackCount..", 背包数量: "..bags..", 总数量: "..total_count..", 需求: "..env.special_map_tier)
                    return bret.FAIL
                end

                poe2_api.dbgp("异界之门物品检查通过,不需要拿图")
                return bret.SUCCESS
            else
                local bags = poe2_api.check_item_in_inventory(env.special_map_type, env.bag_info, env.special_map_tier)
                if not bags then
                    poe2_api.dbgp("背包没有 "..env.special_map_type..",需要拿图")
                    return bret.FAIL
                end
                poe2_api.dbgp("背包已有 "..env.special_map_type..",不需要拿图")
                return bret.SUCCESS
            end
        end
    },
    
    -- 取地图(特殊)
    Take_Map_Sp = {
        run = function(self, env)
            poe2_api.print_log("从仓库拿地图...")
            poe2_api.dbgp("开始执行取地图 - 环境变量:", env)
            
            local current_time = api_GetTickCount64()
            local bag_info = env.bag_info
            local user_map = env.user_map
            local current_map_info = env.current_map_info
            local not_use_map = env.not_use_map
            -- poe2_api.printTable(env.user_map)
            local config = env.user_config
            local player_info = env.player_info
            
            local is_guid = false
            if env.special_storage_type == game_str.Guild_Warehouse_text then
                is_guid = true
            end

            -- 检查仓库是否打开
            local function check_warehouse_opened(warehouse_type)
                local emphasize_text = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Emphasize_the_item, min_x = 250, min_y = 700})
                local warehouse_text = poe2_api.find_text({UI_info = env.UI_info, text = warehouse_type, min_x=0, min_y=32, max_x=381, max_y=78})
                return emphasize_text and warehouse_text
            end

            -- 打开指定类型的仓库
            local function open_warehouse(refreshs)
                local warehouse_type = env.special_storage_type
                if env.special_storage_type == game_str.Warehouse_text then
                    warehouse_type = game_str.Warehouse
                elseif env.special_storage_type == game_str.Guild_Warehouse_text then
                    warehouse_type = game_str.Guild_Warehouse
                end
                -- poe2_api.dbgp("尝试打开仓库:", warehouse_type)

                if refreshs then
                    env.UI_info = UiElements:Update()
                end
                
                -- 先确保仓库界面已打开
                if not check_warehouse_opened(warehouse_type) then
                    env.warehouse_type_interactive = env.special_storage_type
                    poe2_api.dbgp("仓库界面未打开，返回FAIL进入其他节点")
                    return bret.FAIL  -- 返回FAIL让主逻辑可以进入其他节点处理
                end
                
                -- 检查当前仓库类型
                local current_type_text = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Warehouse, min_x=0, min_y=32, max_x=381, max_y=78}) and game_str.Warehouse or
                                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Guild_Warehouse, min_x=0, min_y=32, max_x=381, max_y=78}) and game_str.Guild_Warehouse or nil
                
                -- 如果需要切换仓库类型
                if current_type_text ~= warehouse_type then
                    local switch_button = poe2_api.find_text({UI_info = env.UI_info, 
                        text = warehouse_type, 
                        min_x=0, min_y=32, max_x=381, max_y=78,
                        add_x = 250, 
                        click = 2
                    })
                    
                    if switch_button then
                        api_Sleep(1500)
                        return true
                    end
                    return false
                end
                return true
            end

            -- 检查背包中的地图
            local function check_sp_map_in_bag(bag_info)
                local total_count = 0  -- 改为total_count以记录总和
                
                poe2_api.dbgp("检查背包中的地图 - 背包信息:", bag_info)
                
                -- 检查背包中的地图
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        -- 查找包含game_str.Map_Key_CH的物品
                        if item.baseType_utf8 == env.special_map_type then
                            total_count = total_count + item.stackCount  -- 累加数量
                            poe2_api.dbgp("找到匹配物品:", item.baseType_utf8, "数量:", item.stackCount, "当前总计:", total_count)
                        end
                    end
                end

                -- 获取异界之门的物品信息
                local door_item_data = api_Getinventorys(0x55, 0)
                
                if door_item_data and #door_item_data > 0 then
                    -- 检查异界之门中的地图
                    for _, door_item in ipairs(door_item_data) do
                        if door_item.baseType_utf8 == env.special_map_type then
                            total_count = total_count + door_item.stackCount  -- 累加到总数量
                            poe2_api.dbgp("异界之门中找到匹配物品:", door_item.baseType_utf8, "数量:", door_item.stackCount, "当前总计:", total_count)
                        end
                    end
                    
                    -- 检查异界之门是否满足条件
                    local door_has_valid_item = false
                    if door_item_data and door_item_data[1].baseType_utf8 == env.special_map_type then
                        door_has_valid_item = true
                        if total_count < env.special_map_tier then
                            poe2_api.dbgp("异界之门的物品数量不足,需要拿图")
                            return fasle
                        end
                    end
                    
                    if not door_has_valid_item then
                        poe2_api.dbgp("异界之门的物品类型不匹配,需要拿图")
                        return fasle
                    end
                else
                    poe2_api.dbgp("异界之门没有物品,需要拿图")
                    return fasle
                end
                
                poe2_api.dbgp("检查完成 - 地图总数量:", total_count)
                return true
            end

            local function check_map_test(max_y, min_x, max_x, min_y)
                -- 初始化变量
                local map_page = false
                local page_index = 0
                local user_map = env.user_map
                local not_use_map = env.not_use_map
                local map_update_to = env.map_update_to
                local need_synthesis = env.need_synthesis
                local bag_info = env.bag_info
                
                -- 调试输出初始参数
                poe2_api.dbgp("开始执行check_map_test - 参数:", 
                    "max_y" , max_y,
                    "min_x" , min_x,
                    "max_x" , max_x,
                    "min_y" , min_y,
                    "is_guid", is_guid
                )
                
                -- 获取仓库页面
                local repositoryPages
                if is_guid then
                    repositoryPages = api_GetRepositoryPages(1)
                    poe2_api.dbgp("获取公会仓库页面 - 结果:", repositoryPages and #repositoryPages or 0)
                else
                    repositoryPages = api_GetRepositoryPages(0)
                    poe2_api.dbgp("获取普通仓库页面 - 结果:", repositoryPages and #repositoryPages or 0)
                end
                
                -- 非地图页处理
                poe2_api.dbgp("开始处理非地图页 - 页面名称:", page)
                
                -- 获取页面索引
                local page_index = 0
                local page_type = 0 
                -- for _, page_info in ipairs(repositoryPages) do
                    
                --     if not poe2_api.table_contains(page_info.type, {4, 5, 8, 17, 18}) then
                --         poe2_api.find_text({UI_info = env.UI_info, refresh = true, text = page_info.name_utf8, max_y = max_y, min_x = min_x, max_x = max_x, min_y = min_y, click = 2, delay = 100}) 
                --         api_Sleep(1000)
                --         -- 获取仓库物品
                --         local items = api_GetInventoryItemsInRect(5, 95, 545, 640)
                --         if poe2_api.ctrl_left_click_interface_items(env.special_map_type, items) then
                --             return true
                --         end
                --     end
                -- end
                -- 先寻找 type == 15 的页面
                local found_in_type_15 = false
                if env.special_map_type == game_str.Fantom_Fragment then
                    -- 第一轮遍历：只找 type == 15 的页面
                    for _, page_info in ipairs(repositoryPages) do
                        local warehouse_result = open_warehouse(true)

                        if warehouse_result == bret.FAIL then
                            -- 仓库未打开，设置标志并返回，保存当前索引
                            env.need_open_warehouse = true
                            env.target_warehouse_type = is_guid and game_str.Guild_CH or game_str.Self_CH
                            return bret.FAIL
                        end

                        if page_info.type == 15 then
                            poe2_api.dbgp("在类型15的页面中搜索: " .. page_info.name_utf8)
                            poe2_api.find_text({
                                UI_info = env.UI_info, 
                                refresh = true, 
                                text = page_info.name_utf8, 
                                max_y = max_y, 
                                min_x = min_x, 
                                max_x = max_x, 
                                min_y = min_y, 
                                click = 2, 
                                delay = 100
                            }) 
                            api_Sleep(1000)
                            -- 获取仓库物品
                            local items = api_GetInventoryItemsInRect(5, 95, 545, 640)
                            if poe2_api.ctrl_left_click_interface_items(env.special_map_type, items) then
                                if is_guid then
                                    api_Sleep(1000)
                                end
                                found_in_type_15 = true
                                return true
                            end
                        end
                    end
                end

                -- 如果在 type == 15 的页面中没有找到，再搜索其他符合条件的页面
                if not found_in_type_15 then
                    for _, page_info in ipairs(repositoryPages) do
                        local warehouse_result = open_warehouse(true)

                        if warehouse_result == bret.FAIL then
                            -- 仓库未打开，设置标志并返回，保存当前索引
                            env.need_open_warehouse = true
                            env.target_warehouse_type = is_guid and game_str.Guild_CH or game_str.Self_CH
                            return bret.FAIL
                        end

                        if not poe2_api.table_contains(page_info.type, {4, 5, 8, 17, 18, 15}) then
                            poe2_api.dbgp("在其他页面中搜索: " .. page_info.name_utf8)
                            poe2_api.find_text({
                                UI_info = env.UI_info, 
                                refresh = true, 
                                text = page_info.name_utf8, 
                                max_y = max_y, 
                                min_x = min_x, 
                                max_x = max_x, 
                                min_y = min_y, 
                                click = 2, 
                                delay = 100
                            }) 
                            api_Sleep(1000)
                            -- 获取仓库物品
                            local items = api_GetInventoryItemsInRect(5, 95, 545, 640)
                            if poe2_api.ctrl_left_click_interface_items(env.special_map_type, items) then
                                if is_guid then
                                    api_Sleep(1000)
                                end
                                return true
                            end
                        end
                    end
                end
                return false
            end

            -- 切换到指定仓库页
            local function switch_to_storage_page()
                poe2_api.dbgp("类型:", is_guid and game_str.Guild_CH or game_str.Self_CH)
                
                -- 先确保打开正确的仓库类型
                if not open_warehouse() then
                    return false
                end
                
                -- 检查标签列表是否展开
                local tab_list_button = poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.tab_list_button, ret_data = true})
                
                if tab_list_button then
                    local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
                    -- poe2_api.printTable(lock)
                    -- api_Sleep()
                    local lock_button = {}
                    for _,v in ipairs(lock) do
                        if v.name_utf8 == "" and v.text_utf8 == "" then
                            table.insert(lock_button,v)
                        end
                    end
                    if not lock_button or not next(lock_button) then
                        api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                        api_Sleep(2000)
                        api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),1)
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    -- 已展开标签列表的情况
                    return true
                else
                    -- 未展开标签列表的情况
                    return true
                end
            end

            -- 主逻辑
            if not current_map_info or not player_info then
                poe2_api.dbgp("缺失必要数据 - 当前地图信息副本:", current_map_info, "玩家信息:", player_info)
                return bret.RUNNING
            end

            poe2_api.dbgp("类型:", is_guid and game_str.Guild_CH or game_str.Self_CH)
            
            -- 切换到目标仓库页
            local warehouse_result = open_warehouse()
            poe2_api.dbgp("warehouse_result: ----===>>>>", warehouse_result)

            if warehouse_result == bret.FAIL then
                -- 仓库未打开，设置标志并返回，保存当前索引
                env.need_open_warehouse = true
                env.target_warehouse_type = is_guid and game_str.Guild_CH or game_str.Self_CH
                return bret.FAIL

            elseif warehouse_result then
                -- 尝试从仓库取地图
                local SUCCESS = false
                if switch_to_storage_page() then
                    -- 获取仓库标签按钮
                    local tab_list_button = poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.tab_list_button,ret_data = true})

                    poe2_api.dbgp("tab_list_button:", tostring(tab_list_button))

                    if tab_list_button then
                        SUCCESS = check_map_test(800, 556, 851, 20)
                    else
                        poe2_api.dbgp("未展开标签列表的情况")
                        SUCCESS = check_map_test(90, 0, 500, 0)
                    end

                    if SUCCESS then
                        return bret.RUNNING
                    end
                end
            end

            -- 所有仓库页尝试失败
            poe2_api.dbgp("所有仓库页尝试失败")
            env.take_map_times = (env.take_map_times or 0) + 1
            if env.take_map_times > 3 then
                error("所有仓库页未找到匹配的物品")
            end
            return bret.RUNNING
        end
    },

    -- 检查是否需要拿地图
    Is_Need_Take_Map = {
        run = function(self, env)
            poe2_api.print_log("检查是否需要拿地图...")
            poe2_api.dbgp("开始执行 Is_Need_Take_Map 检查")
            
            local current_time = api_GetTickCount64()
            local bag_info = env.bag_info
            local player_info = env.player_info
            
            local is_map_complete = env.is_map_complete
            local user_map = env.user_map
            local not_use_map = env.not_use_map
            local is_have_map = env.is_have_map
            local current_map_info = env.current_map_info
            local one_other_map = env.one_other_map
            local config = env.user_config
            local entry_length_take_map = env.entry_length_take_map

            -- poe2_api.dbgp("环境变量检查:", {
            --     bag_info = bag_info and #bag_info or "nil",
            --     player_info = player_info and "exists" or "nil",
            --     range_info = range_info and #range_info or "nil",
            --     is_map_complete = is_map_complete,
            --     user_map = user_map,
            --     not_use_map = not_use_map,
            --     is_have_map = is_have_map,
            --     config = config and "exists" or "nil"
            -- })

            if not player_info then
                return bret.RUNNING
            end
        
            -- 检查背包中是否有地图
            local function check_map_in_bag(bag_info, return_count)
                return_count = return_count or true
                local matches = {}
                
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        if item.baseType_utf8 and string.find(item.baseType_utf8, game_str.Map_Key_CH) then
                            table.insert(matches, item)
                        end
                    end
                end
                
                if return_count then
                    return #matches > 0 and #matches or false
                else
                    return #matches > 0 and matches or false
                end
            end
        
            -- 检查当前是否在城镇或藏身处
            local function is_in_town_or_hideout()
                local result = false
                if string.find(player_info.current_map_name_utf8 or "", game_str.town) then
                    result = true
                end
                
                if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                    result = true
                end
                
                -- poe2_api.dbgp("is_in_town_or_hideout 检查:", {
                --     current_map = player_info.current_map_name_utf8,
                --     result = result
                -- })
                return result
            end
        
            -- 获取非地图物品（传送点/异界之门除外）
            local function get_not_map()
                local result = false
                for _, item in ipairs(env.range_info) do
                    if item.type == 5 and item.name_utf8 ~= '' and 
                    item.name_utf8 ~= game_str.Transfer_point_CH and item.name_utf8 ~= game_str.The_Gate_of_the_Outland_CH then
                        result = item
                        break
                    end
                end
                
                -- poe2_api.dbgp("get_not_map 结果:", result)
                return result
            end
        
            -- 主逻辑
            if not is_in_town_or_hideout() then
                poe2_api.dbgp("不在城镇或藏身处，直接返回SUCCESS")
                poe2_api.time_p("Is_Need_Take_Map... 耗时 --> ", api_GetTickCount64() - current_time)
                env.is_shop = false
                env.take_map_times = 0
                return bret.SUCCESS
            end

            -- 如果在藏身处且有可交互的非地图物品
            if is_in_town_or_hideout() then
                local not_map = get_not_map()
                poe2_api.dbgp("藏身处非地图物品检查:", not_map)
                
                if not_map and not is_map_complete then
                    -- if poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0}) then
                        -- poe2_api.dbgp("发现世界地图文本，执行ESC")
                        -- poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0})
                    --     poe2_api.click_keyboard('esc')
                    -- end
                    env.is_shop = false
                    env.take_map_times = 0
                    return bret.SUCCESS
                end
            end

            if poe2_api.find_text({text = game_str.Purchase_or_sell, UI_info = env.UI_info,min_x=0}) then
                -- poe2_api.dbgp("999999999999999999999999999999999999999999")
                poe2_api.click_keyboard('space')
                api_Sleep(500)
                poe2_api.time_p("是否存储物品（RUNNING3）... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.RUNNING
            end
        
            -- 如果已经在世界地图界面，直接返回成功
            local world_map_text = poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, max_y = 100, min_x = 250})
            if world_map_text then
                poe2_api.dbgp("已在世界地图界面，返回SUCCESS")
                env.is_shop = false
                env.take_map_times = 0
                return bret.SUCCESS
            end
        
            -- 检查是否需要合成地图
            local need_synthesis = config["全局設置"]["刷图通用設置"]["自動合成地圖"]
            poe2_api.dbgp("自动合成地图设置:", need_synthesis)
            poe2_api.dbgp("env.is_need_strengthen:", env.is_need_strengthen)
            
            if env.is_need_strengthen and need_synthesis then
                poe2_api.dbgp("需要强化地图，返回FAIL")
                return bret.FAIL
            end
        
            -- 检查背包中的地图
            local map_count = check_map_in_bag(bag_info)
            local best_map = poe2_api.select_best_map_key({
                inventory = bag_info, 
                key_level_threshold = user_map,
                not_use_map = not_use_map
            })

            poe2_api.dbgp("背包地图检查结果:", {
                map_count = map_count,
                best_map = best_map and "exists" or "nil"
            })
        
            poe2_api.dbgp("背包地图数量: ", (map_count or 0))

            if env.need_sale_map and env.map_page_full == game_str.Map_EN then
                poe2_api.dbgp("------------------>仓库地图已满，需要出售地图",env.need_sale_map,env.map_page_full)
                env.full_map = true
                return bret.FAIL
            else
                env.full_map = false
            end
        
            if (not map_count or map_count < 1 or not best_map) or env.full_map then
                -- poe2_api.dbgp("背包没有符合条件的地图")
                return bret.FAIL
            end
        
            -- poe2_api.dbgp("Is_Need_Take_Map 检查完成，返回SUCCESS")
            env.is_shop = false
            env.take_map_times = 0
            return bret.SUCCESS
        end
    },

    -- 取地图
    Take_Map = {
        run = function(self, env)
            poe2_api.print_log("从仓库拿地图...")
            poe2_api.dbgp("开始执行取地图 - 环境变量:", env)
            
            local current_time = api_GetTickCount64()
            local bag_info = env.bag_info
            local user_map = env.user_map
            local current_map_info = env.current_map_info
            local not_use_map = env.not_use_map
            -- poe2_api.printTable(env.user_map)
            local config = env.user_config
            local need_synthesis = config["全局設置"]["刷图通用設置"]["自動合成地圖"]
            local player_info = env.player_info
            local entry_length_take_map = env.entry_length_take_map
            local map_update_to = env.map_update_to
            
            local full_map = (env.need_sale_map and env.map_page_full == game_str.Map_EN) or false

            -- 获取所有地图仓库页配置
            local storage_pages = {}
            for _, item in ipairs(poe2_api.get_items_config_info(config)) do
                if item["類型"] and item["類型"] == game_str.Map_Key_CH and item["存倉頁名"] then
                    table.insert(storage_pages, {
                        name = item["存倉頁名"],
                        is_guild = item["工會倉庫"] or false,
                        priority = item["優先級"] or 1  -- 默认优先级为1
                    })
                end
            end

            -- 按优先级排序仓库页
            table.sort(storage_pages, function(a, b) return a.priority > b.priority end)

            -- 检查仓库是否打开
            local function check_warehouse_opened(warehouse_type)
                local emphasize_text = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Emphasize_the_item, min_x = 250, min_y = 700})
                local warehouse_text = poe2_api.find_text({UI_info = env.UI_info, text = warehouse_type, min_x=0, min_y=32, max_x=381, max_y=78})
                return emphasize_text and warehouse_text
            end

            -- 打开指定类型的仓库
            local function open_warehouse(is_guild)
                local warehouse_type = is_guild and game_str.Guild_Warehouse or game_str.Warehouse
                poe2_api.dbgp("尝试打开仓库:", warehouse_type)
                
                -- 先确保仓库界面已打开
                if not check_warehouse_opened(warehouse_type) then
                    if warehouse_type == game_str.Guild_Warehouse then
                        env.warehouse_type_interactive = game_str.Guild_Warehouse_text
                    else
                        env.warehouse_type_interactive = game_str.Warehouse_text
                    end
                    poe2_api.dbgp("仓库界面未打开，返回FAIL进入其他节点")
                    return bret.FAIL  -- 返回FAIL让主逻辑可以进入其他节点处理
                end
                
                -- 检查当前仓库类型
                local current_type_text = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Warehouse, min_x=0, min_y=32, max_x=381, max_y=78}) and game_str.Warehouse or
                                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Guild_Warehouse, min_x=0, min_y=32, max_x=381, max_y=78}) and game_str.Guild_Warehouse or nil
                
                -- 如果需要切换仓库类型
                if current_type_text ~= warehouse_type then
                    local switch_button = poe2_api.find_text({UI_info = env.UI_info, 
                        text = warehouse_type, 
                        min_x=0, min_y=32, max_x=381, max_y=78,
                        add_x = 250, 
                        click = 2
                    })
                    
                    if switch_button then
                        api_Sleep(1500)
                        return true
                    end
                    return false
                end
                return true
            end

            -- 切换到指定仓库页
            local function switch_to_storage_page(page_name, is_guild)
                poe2_api.dbgp("尝试切换到仓库页:", page_name, "类型:", is_guild and game_str.Guild_CH or game_str.Self_CH)
                
                -- 先确保打开正确的仓库类型
                if not open_warehouse(is_guild) then
                    return false
                end
                
                -- 检查标签列表是否展开
                local tab_list_button = poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.tab_list_button, ret_data = true})
                
                if tab_list_button then
                    local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
                    -- poe2_api.printTable(lock)
                    -- api_Sleep()
                    local lock_button = {}
                    for _,v in ipairs(lock) do
                        if v.name_utf8 == "" and v.text_utf8 == "" then
                            table.insert(lock_button,v)
                        end
                    end
                    if not lock_button or not next(lock_button) then
                        api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                        api_Sleep(2000)
                        api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),1)
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    -- 已展开标签列表的情况
                    return poe2_api.find_text({UI_info = env.UI_info, 
                        text = page_name, 
                        max_y = 800, min_x = 556, min_y = 20, max_x = 851, 
                        click = 2
                    })
                else
                    -- 未展开标签列表的情况
                    return poe2_api.find_text({UI_info = env.UI_info, 
                        text = page_name, 
                        max_y = 90, min_x = 10, max_x = 500, min_y = 0, 
                        click = 2
                    })
                end
            end

            -- 检查背包中的地图
            local function check_map_in_bag(bag_info)
                local count = 0  -- 初始化计数器为0
                
                poe2_api.dbgp("检查背包中的地图 - 背包信息:", bag_info)
                
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        -- 查找包含“地圖鑰匙”的物品
                        if item.baseType_utf8 and string.find(item.baseType_utf8, game_str.Map_Key_CH) then
                            count = count + 1  -- 找到则计数+1
                        end
                    end
                end
                
                poe2_api.dbgp("检查背包地图结果（数量）:", count)
                return count or 0  -- 直接返回数量，无匹配时自然为0
            end
            
            -- 检查相同地图是否超过3个
            local function check_same_map_over_3(bag_info)
                poe2_api.dbgp("检查相同地图是否超过3个 - 背包信息:", bag_info)
                
                local item_counts = {}
                if bag_info then
                    for _, actor in ipairs(bag_info) do
                        if actor.baseType_utf8 and string.find(actor.baseType_utf8, game_str.Map_Key_CH) and not actor.contaminated and not actor.not_identified and actor.baseType_utf8 ~= game_str.Map_Key_Class_15 and actor.baseType_utf8 ~= game_str.Map_Key_Class_16 then
                            item_counts[actor.baseType_utf8] = (item_counts[actor.baseType_utf8] or 0) + 1
                        end
                    end
                else
                    poe2_api.dbgp("背包没有地图")
                    poe2_api.dbgp("检查相同地图结果:", false)
                    return false
                end
                
                -- 检查是否有至少3个相同的物品
                local synthesis_possible = false
                for _, count in pairs(item_counts) do
                    if count >= 3 then
                        synthesis_possible = true
                        break
                    end
                end
                
                poe2_api.dbgp("检查相同地图结果 - 物品计数:", item_counts, "是否可以合成:", synthesis_possible)
                return synthesis_possible
            end

            -- 统计所有名称包含game_str.Map_Key_CH的物品数量
            local function count_all_maps(bag_info)
                poe2_api.dbgp("开始统计所有地图钥匙数量 - 背包信息:", bag_info)
                
                local total_count = 0
                
                if bag_info then
                    for _, actor in ipairs(bag_info) do
                        if actor.baseType_utf8 and string.find(actor.baseType_utf8, game_str.Map_Key_CH) then
                            total_count = total_count + 1
                        end
                    end
                end
                
                poe2_api.dbgp("地图钥匙总数:", total_count)
                return total_count
            end

            local function check_map_test(max_y, min_x, max_x, min_y, map_num, page, is_guild)
                -- 初始化变量
                local map_page = false
                local page_index = 0
                local user_map = env.user_map
                local not_use_map = env.not_use_map
                local map_update_to = env.map_update_to
                local need_synthesis = env.need_synthesis
                local bag_info = env.bag_info
                
                -- 调试输出初始参数
                poe2_api.dbgp("开始执行check_map_test - 参数:", 
                    "max_y" , max_y,
                    "min_x" , min_x,
                    "max_x" , max_x,
                    "min_y" , min_y,
                    "map_num" , map_num,
                    "page", page,
                    "is_guild", is_guild
                )
                
                -- 获取仓库页面
                local repositoryPages
                if is_guild then
                    repositoryPages = api_GetRepositoryPages(1)
                    poe2_api.dbgp("获取公会仓库页面 - 结果:", repositoryPages and #repositoryPages or 0)
                else
                    repositoryPages = api_GetRepositoryPages(0)
                    poe2_api.dbgp("获取普通仓库页面 - 结果:", repositoryPages and #repositoryPages or 0)
                end
                
                -- 检查是否为地图页
                if repositoryPages then
                    poe2_api.dbgp("开始检查仓库页面 - 总页数:", #repositoryPages)
                    for i, page_info in ipairs(repositoryPages) do
                        poe2_api.dbgp("检查页面#"..i.." - 名称:", page_info.name_utf8, "类型:", page_info.type)
                        if page_info.name_utf8 == page and page_info.type == 5 then
                            map_page = true
                            poe2_api.dbgp("找到匹配的地图页 - 索引:", i)
                            break
                        end
                    end
                end
                
                -- 选择最佳地图
                local best_map = poe2_api.select_best_map_key({
                    inventory = bag_info,
                    key_level_threshold = user_map,
                    not_use_map = not_use_map,
                    entry_length = map_update_to
                })
                poe2_api.dbgp("选择最佳地图 - 结果:", best_map ~= nil)
                
                -- 处理地图页
                if map_page then
                    poe2_api.dbgp("开始处理地图页 - 页面名称:", page)

                    if poe2_api.find_text({UI_info = env.UI_info, 
                        text = page,
                        max_y = max_y,
                        min_x = min_x,
                        max_x = max_x,
                        min_y = min_y,
                        click = 2
                    }) then
                        api_Sleep(500)
                    end
                    
                    -- 初始化颜色和等级列表
                    local white, blue, gold, valls, level = {}, {}, {}, {}, {}
                    if user_map then
                        poe2_api.dbgp("开始解析用户地图配置 - 配置数量:", #user_map)
                        for _, config in ipairs(user_map) do
                            local levels = tonumber(config["階級"]) or 0
                            table.insert(level, levels)
                        end
                    end
                    
                    -- 罗马数字映射
                    local ROMAN_NUMERALS = {
                        [1] = "I", [2] = "II", [3] = "III", [4] = "IV", [5] = "V",
                        [6] = "VI", [7] = "VII", [8] = "VIII", [9] = "IX", [10] = "X",
                        [11] = "XI", [12] = "XII", [13] = "XIII", [14] = "XIV", [15] = "XV", [16] = "XVI"
                    }
                    
                    local the_maps_num = 0
                    local click_positions = {152, 202, 252, 302, 352, 402}
                    
                    -- 按等级降序查找
                    table.sort(level, function(a, b) return a > b end)
                    poe2_api.dbgp("排序后的等级列表 - 内容:", table.concat(level, ","))
                    
                    for _, num in ipairs(level) do
                        poe2_api.dbgp("处理等级 - 当前等级:", num)
                        if num >= 1 and num <= 16 then
                            local roman_num = ROMAN_NUMERALS[num]
                            poe2_api.dbgp("转换罗马数字 - 数字:", num, "罗马数字:", roman_num)
                            
                            local a = poe2_api.find_text({UI_info = env.UI_info, 
                                refresh = true,
                                text = roman_num,
                                max_y = 242,
                                min_x = 0,
                                max_x = 544,
                                min_y = 0,
                                position = 1
                            })
                            
                            if a then
                                poe2_api.dbgp("找到罗马数字 - 位置X:", a[1], "位置Y:", a[2])
                                
                                local min_x = a[1] - 48
                                local min_y = a[2] - 48
                                local max_x = a[1] + 48
                                local max_y = a[2] + 48
                                
                                the_maps_num = poe2_api.find_text_position({UI_info = env.UI_info, 
                                    refresh = true,
                                    min_x = min_x,
                                    min_y = min_y,
                                    max_x = max_x,
                                    max_y = max_y,
                                    lens = 0
                                })
                                -- api_Sleep(100000)
                                -- poe2_api.dbgp("the_maps_num: ",the_maps_num)
                                the_maps_num = tonumber(the_maps_num) or 0
                                poe2_api.dbgp("地图数量检测 - 数量:", the_maps_num)
                                
                                if the_maps_num == 0 then
                                    poe2_api.dbgp("跳过空地图 - 罗马数字:", roman_num)
                                    goto continue
                                end
                                
                                if poe2_api.find_text({UI_info = env.UI_info, 
                                    refresh = true,
                                    text = roman_num,
                                    max_y = 242,
                                    min_x = 0,
                                    max_x = 544,
                                    min_y = 0,
                                    click = 2
                                }) then
                                    api_Sleep(1000)
                                    -- poe2_api.dbgp("==================================")
                                    
                                    map_table = api_GetInventoryItemsInRect(15,268,545,640)
                                    -- poe2_api.printTable(map_table)
                                    -- poe2_api.dbgp("==================================")
                                    
                                    local c = poe2_api.select_best_map_key({
                                        inventory = map_table,
                                        key_level_threshold = user_map,
                                        not_use_map = not_use_map,
                                        entry_length = map_update_to
                                    })

                                    -- poe2_api.printTable(c)

                                    if c then
                                        local map_x = (c.RectSart_x + c.RectEnd_x) / 2
                                        local map_y = (c.RectSart_y + c.RectEnd_y) / 2
                                        -- poe2_api.dbgp("准备点击地图 - X坐标:", map_x, "Y坐标:", map_y)
                                        -- poe2_api.dbgp("准备点击地图 - X坐标:", poe2_api.toInt(map_x), "Y坐标:", poe2_api.toInt(map_y))
                                        poe2_api.click_position(map_x, map_y, 1)
                                        -- poe2_api.dbgp("找到匹配的地图 - 数量:", c)
                                    end

                                    -- api_Sleep(5000)

                                    local b = poe2_api.select_best_map_key({
                                        inventory = api_Getinventorys(1, 0),
                                        key_level_threshold = user_map,
                                        not_use_map = not_use_map,
                                        entry_length = map_update_to
                                    })
                                    poe2_api.dbgp("背包地图检查 - 最佳地图:", b ~= nil)

                                    if full_map then
                                        if not poe2_api.get_space_point({width = 1, height = 1}) then
                                            poe2_api.dbgp("满地图 - 返回成功")
                                            return true
                                        end
                                    else
                                        if map_num then
                                            local current_map_count = check_map_in_bag(api_Getinventorys(1, 0))
                                            poe2_api.dbgp("地图数量验证 - 当前:", current_map_count, "需要:", map_num + 3)
                                            
                                            if current_map_count >= map_num + 3 and b then
                                                poe2_api.dbgp("满足地图数量要求 - 返回成功")
                                                return true
                                            end
                                        end
                                    end
                                    
                                    if c == 0 or not c then
                                        poe2_api.dbgp("开始尝试点击不同位置 - 位置列表:", table.concat(click_positions, ","))
                                        
                                        for _, k in ipairs(click_positions) do
                                            poe2_api.dbgp("尝试位置 - X坐标:", k)
                                            local b = poe2_api.select_best_map_key({
                                                inventory = api_Getinventorys(1, 0),
                                                key_level_threshold = user_map,
                                                not_use_map = not_use_map,
                                                entry_length = map_update_to
                                            })
                                            
                                            if map_num then
                                                local map_num1 = check_map_in_bag(api_Getinventorys(1, 0))
                                                poe2_api.dbgp("地图数量检查 - 当前:", map_num1, "需要:", map_num)
                                                
                                                if map_num1 >= map_num and b then
                                                    poe2_api.dbgp("满足最低数量要求 - 返回成功")
                                                    return true
                                                end
                                            end
                                            
                                            api_ClickScreen(k, 269, 1)
                                            api_Sleep(1000)
    
                                            map_table = api_GetInventoryItemsInRect(15,268,545,640)
                                            -- poe2_api.printTable(map_table)
                                            -- poe2_api.dbgp("==================================")
                                            
                                            local c = poe2_api.select_best_map_key({
                                                inventory = map_table,
                                                key_level_threshold = user_map,
                                                not_use_map = not_use_map,
                                                entry_length = map_update_to
                                            })

                                            -- poe2_api.printTable(c)

                                            if c then
                                                local map_x = (c.RectSart_x + c.RectEnd_x) / 2
                                                local map_y = (c.RectSart_y + c.RectEnd_y) / 2
                                                -- poe2_api.dbgp("准备点击地图 - X坐标:", map_x, "Y坐标:", map_y)
                                                -- poe2_api.dbgp("准备点击地图 - X坐标:", poe2_api.toInt(map_x), "Y坐标:", poe2_api.toInt(map_y))
                                                poe2_api.click_position(map_x, map_y, 1)
                                                -- poe2_api.dbgp("找到匹配的地图 - 数量:", c)
                                            end

                                            -- poe2_api.dbgp("点击后查找结果 - 找到数量:", c)
                                            
                                            if c then
                                                poe2_api.dbgp("位置点击成功 - 返回成功")
                                                return true
                                            end

                                        end
                                        goto continue
                                    end
                                    
                                    poe2_api.dbgp("成功点击罗马数字 ", roman_num, " (对应等级 ", num, ")")
                                    return true
                                end
                            else
                                poe2_api.dbgp("未找到罗马数字 - 跳过")
                            end
                        else
                            poe2_api.dbgp("无效等级 - 跳过")
                        end
                        ::continue::
                    end
                    return false
                end
                
                -- 非地图页处理
                poe2_api.dbgp("开始处理非地图页 - 页面名称:", page)
                
                if poe2_api.find_text({UI_info = env.UI_info, 
                    refresh = true,
                    text = page,
                    max_y = max_y,
                    min_x = min_x,
                    max_x = max_x,
                    min_y = min_y,
                    click = 2
                }) then
                    api_Sleep(1000)
                    
                    -- 获取页面索引
                    local page_index = 0
                    local page_type = 0
                    for _, page_info in ipairs(repositoryPages) do
                        if page_info.name_utf8 == page and page_info.type ~= 5 then
                            page_index = page_info.manage_index
                            page_type = page_info.type
                            break
                        end
                    end
                    poe2_api.dbgp("获取页面索引 - 结果:", page_index)
                    poe2_api.dbgp("获取页面索引 is_guild:", is_guild)
                    -- 获取仓库物品
                    local items
                    if is_guild then
                        items = api_Getinventorys(page_index, 2)
                        poe2_api.dbgp("获取公会仓库物品 - 数量:", items and #items or 0)
                    else
                        items = api_Getinventorys(page_index, 0)
                        poe2_api.dbgp("获取普通仓库物品 - 数量:", items and #items or 0)
                    end
                    
                    -- 检查是否可以合成
                    local can_synthesize = check_same_map_over_3(items)
                    poe2_api.dbgp("合成检查 - 是否可以合成:", can_synthesize, "需要合成:", need_synthesis)
                 
                    -- 如果不需要合成或地图数量足够
                    if full_map then
                        poe2_api.dbgp("满地图处理 - 开始处理")
                        local all_map_nums = count_all_maps(items)

                        if not poe2_api.get_space_point({width = 1, height = 1}) then
                            poe2_api.dbgp("满地图 - 返回成功")
                            return true
                        end
                        -- 从仓库取地图
                        poe2_api.dbgp("开始从仓库取地图")
                        for i = 1, math.floor(all_map_nums * 0.6) do
                            -- print("循环执行第 ", i, " 次")
                            -- 获取仓库物品
                            local items
                            if text == game_str.Guild_Warehouse then
                                items = api_Getinventorys(page_index, 2)
                                poe2_api.dbgp("获取公会仓库物品 - 数量:", items and #items or 0)
                            else
                                items = api_Getinventorys(page_index, 0)
                                poe2_api.dbgp("获取普通仓库物品 - 数量:", items and #items or 0)
                            end

                            local select_result = poe2_api.select_best_map_key({
                                inventory = items,
                                click = 1,
                                type = 1,
                                not_use_map = not_use_map,
                                entry_length = map_update_to,
                                trash_map = full_map
                            })
                            poe2_api.dbgp("选择地图结果:", select_result ~= nil)
                            
                            if not poe2_api.get_space_point({width = 1, height = 1}) or not select_result then
                                poe2_api.dbgp("满地图 - 返回成功")
                                return true
                            end
                            api_Sleep(100)
                        end
                    else
                        if not (need_synthesis and can_synthesize) then
                            if map_num then
                                local bag_count = check_map_in_bag(api_Getinventorys(1, 0))
                                poe2_api.dbgp("背包地图检查 - 当前数量:", bag_count, "需要数量:", map_num)
                                
                                if bag_count and bag_count > map_num and best_map then
                                    env.entry_length_take_map = false
                                    poe2_api.dbgp("满足数量要求 - 返回成功")
                                    return true
                                end
                            end
                        end
                        -- 从仓库取地图
                        poe2_api.dbgp("开始从仓库取地图")
                        local select_result = poe2_api.select_best_map_key({
                            inventory = items,
                            click = 1,
                            key_level_threshold = user_map,
                            type = 1,
                            not_use_map = not_use_map,
                            entry_length = map_update_to,
                            page_type = page_type
                        })
                        poe2_api.dbgp("选择地图结果:", select_result ~= nil)
                        
                        if map_num then
                            local bag_count = check_map_in_bag(api_Getinventorys(1, 0))
                            poe2_api.dbgp("最终检查 - 当前数量:", bag_count, "需要数量:", map_num)
                            if bag_count > map_num and best_map then
                                poe2_api.dbgp("满足最终数量要求 - 返回成功")
                                return true
                            end
                        end
                    end
                end
                
                env.is_need_strengthen = false
                poe2_api.dbgp("所有检查未通过 - 返回失败")
                return false
            end

            -- 主逻辑
            if not current_map_info or not player_info then
                poe2_api.dbgp("缺失必要数据 - 当前地图信息副本:", current_map_info, "玩家信息:", player_info)
                return bret.RUNNING
            end

            -- 检查背包地图数量
            local bag_map_count = 0
            if bag_info then
                for _, item in ipairs(bag_info) do
                    if item.baseType_utf8 and string.find(item.baseType_utf8, game_str.Map_Key_CH) then
                        bag_map_count = bag_map_count + 1
                    end
                end
            end

            -- 选择最佳地图
            local best_map = poe2_api.select_best_map_key({
                inventory = bag_info,
                key_level_threshold = user_map,
                not_use_map = not_use_map,
                entry_length = map_update_to
            })

            -- 如果背包已有足够地图且不需要强化
            if bag_map_count >= 2 and best_map and not env.is_need_strengthen and not full_map then
                env.is_have_map = true
                return bret.RUNNING
            end

            -- 在env中初始化或获取当前检查的仓库页索引
            env.current_storage_page_index = env.current_storage_page_index or 1

            -- 获取仓库标签按钮
            local tab_list_button = poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.tab_list_button,ret_data = true})

            poe2_api.dbgp("tab_list_button:", tostring(tab_list_button))

            -- 按优先级尝试各个仓库页
            for i = env.current_storage_page_index, #storage_pages do
                local page_info = storage_pages[i]
                poe2_api.dbgp("尝试从仓库页获取地图:", page_info.name, "类型:", page_info.is_guild and game_str.Guild_CH or game_str.Self_CH, "当前索引:", i)
                
                -- 切换到目标仓库页
                local warehouse_result = open_warehouse(page_info.is_guild)
                poe2_api.dbgp("warehouse_result: ----===>>>>", warehouse_result)

                if warehouse_result == bret.FAIL then
                    -- 仓库未打开，设置标志并返回，保存当前索引
                    env.need_open_warehouse = true
                    env.target_warehouse_type = page_info.is_guild and game_str.Guild_CH or game_str.Self_CH
                    env.current_storage_page_index = i  -- 保存当前索引以便下次继续
                    return bret.FAIL

                elseif warehouse_result then
                    -- 仓库已打开，继续切换到具体页面
                    if switch_to_storage_page(page_info.name, page_info.is_guild) then
                        api_Sleep(1500)
                        
                        -- 获取仓库物品
                        local repositoryPages = api_GetRepositoryPages(page_info.is_guild and 1 or 0)
                        local page_index = 0
                        for _, page in ipairs(repositoryPages) do
                            if page.name_utf8 == page_info.name then
                                page_index = page.manage_index
                                break
                            end
                        end
                        
                        local items = api_Getinventorys(page_index, page_info.is_guild and 2 or 0)
                        
                        -- 尝试从仓库取地图
                        if tab_list_button then
                            local SUCCESS = check_map_test(800, 556, 851, 20, 2, page_info.name, page_info.is_guild)
                        else
                            poe2_api.dbgp("未展开标签列表的情况")
                            local SUCCESS = check_map_test(90, 0, 500, 0, 2, page_info.name, page_info.is_guild)
                        end

                        -- local SUCCESS = check_map_test(
                        --     page_info.is_guild and 800 or 90, 
                        --     page_info.is_guild and 556 or 0, 
                        --     page_info.is_guild and 851 or 500, 
                        --     page_info.is_guild and 20 or 0, 
                        --     3, 
                        --     page_info.name
                        -- )
                        
                        if SUCCESS then
                            -- 检查是否成功获取地图
                            local new_bag_info = api_Getinventorys(1, 0)
                            local new_count = 0
                            for _, item in ipairs(new_bag_info) do
                                if item.baseType_utf8 and string.find(item.baseType_utf8, game_str.Map_Key_CH) then
                                    new_count = new_count + 1
                                end
                            end
                            
                            if new_count > bag_map_count then
                                env.is_have_map = true
                                env.current_storage_page_index = 1  -- 成功获取后重置索引
                                return bret.RUNNING
                            end
                        end
                    end
                end
                
                -- 当前页面检查完成，递增索引
                env.current_storage_page_index = i + 1
            end

            -- 所有仓库页尝试完成，重置索引
            env.current_storage_page_index = 1

            -- 所有仓库页尝试失败
            poe2_api.dbgp("所有仓库页尝试失败")
            env.take_map_times = (env.take_map_times or 0) + 1
            poe2_api.dbgp("entry_length_take_map-->", entry_length_take_map)
            poe2_api.dbgp("self.times-->", self.times)
            if env.take_map_times > 3 then
                env.take_map_times = 0
                if entry_length_take_map then
                    env.map_up = true
                else
                    poe2_api.dbgp("111111111")
                    env.map_up = false
                    env.is_shop = true
                end
            end
            poe2_api.dbgp("22222")
            env.is_have_map = false
            return bret.RUNNING

        end
    },

    -- 物品丢弃
    StackableCurrency_Discard = {
        run = function(self, env)
            poe2_api.print_log("物品丢弃...")
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.item_name = nil
                self.index = 0
                self.bool = true
            end
            local config = env.user_config
            local is_decompose = config['全局設置']["刷图通用設置"]["是否分解暗金"] or false
            local altar_shop_config = config['刷圖設置']["祭祀購買"]
            -- local range_info = env.range_info
            local player_info = env.player_info
            local bag_info = env.bag_info
           
            local processed_configs = poe2_api.get_items_config_info(config)
            local Attachments = api_Getinventorys(0xd,0)
            -- 背包和附着物为空
            if (not bag_info or not next(bag_info)) and (not Attachments or not next(Attachments)) then
                poe2_api.dbgp("背包和附着物为空,不丢弃")
                poe2_api.time_p("物品丢弃（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS 
            end
            -- 是否需要丢弃
            local function get_not_item(items)
                local function is_props(bag)
                    local text_list = {game_str.The_Book_of_Knowledge,game_str.The_crystallization_core_of_knowledge_CH}
                    -- for _, i in ipairs(bag) do
                        -- poe2_api.dbgp("i.baseType_utf8:",i.baseType_utf8)
                        -- poe2_api.dbgp("i.category_utf8:",i.category_utf8)
                        -- poe2_api.dbgp("i.color:","----------------------------------")
                        if bag.category_utf8 == game_str.QuestItem then
                            for _, v in ipairs(text_list) do
                                if string.find(bag.baseType_utf8,v) then
                                    return true
                                end
                                
                            end
                        end
                    -- end
                    return false
                end
                local function get_not(item,index)
                    local props = is_props(item)
                    if props then
                        return false
                    end
                    if item.baseType_utf8 == game_str.Decayed_backpack_charging_CH then
                        return false
                    end
                    if poe2_api.is_do_without_pick_up(item,processed_configs) then
                        if is_decompose and type(is_decompose)~="table" then
                            if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                return false
                                
                            end
                        end
                        return true
                    end
                    for _, cfg in ipairs(processed_configs) do
                        if poe2_api.match_item(item,cfg) then
                            if cfg["不撿"] then
                                if poe2_api.table_contains(item.baseType_utf8,altar_shop_config) then
                                    return false
                                end
                                if is_decompose and type(is_decompose)~="table" then
                                    if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                        return false
                                        
                                    end
                                end
                                return true
                            end
                            if item.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                local number = 0
                                for _, v in ipairs(items) do
                                    if v.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                        number = number + v.stackCount
                                    end
                                end
                                if number > 80 then
                                    return true
                                end
                            end
                            local item_entry = cfg["物品詞綴"] or {}
                            if item_entry and next(item_entry) then
                                local function get_cfg_entry(entry_list)
                                    for k, v in pairs(entry_list) do
                                        if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                            if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                return true
                                            end
                                        end
                                    end
                                    return false
                                end
                                local function get_cfg_entry_tower()
                                    for k, v in pairs(item_entry) do
                                        if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                            if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                for i, v1 in ipairs(v["詞綴"]) do
                                                    if not string.find(v1["name"],game_str.within_the_scope_CH) then
                                                        return true
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    return false
                                end
                                if get_cfg_entry(item_entry) then
                                    if item.category_utf8 == game_str.TowerAugmentation then
                                        if get_cfg_entry_tower() then
                                            if item.color ~= 1 or (item.color == 1 and item.fixedSuffixCount<2) then
                                                return false    
                                            end
                                        end
                                    end
                                    if poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) and not item.not_identified then
                                        local suffixes = api_GetObjectSuffix(item.mods_obj)
                                        if not suffixes or #suffixes == 0 then
                                            return {item}
                                        end
                                        if not poe2_api.filter_item(item,suffixes,config["物品過濾"]) then
                                            if is_decompose and type(is_decompose)~="table" then
                                                if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                                    return false
                                                end
                                            end
                                            return true
                                        end
                                    end
                                end
                            end
                            return false
                        end
                        if is_decompose and type(is_decompose)~="table" then
                            if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                return false
                            end
                        end
                    end
                    if poe2_api.table_contains(item.baseType_utf8,altar_shop_config) and index == 0 then
                        return false
                    end
                    return true
                end
                if not items or not next(items) then
                    return false
                end
                for _, item in ipairs(items) do
                    local is_dis = get_not(item,0)
                    if is_dis then
                        if type(is_dis) == "table" then
                            return is_dis
                        end
                        if item.baseType_utf8 == game_str.The_Knowledge_Scroll then
                            local mininumber = nil
                            local miniobj = nil
                            for _, v in ipairs(items) do
                                if v.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                    if not mininumber or mininumber > v.stackCount then
                                        miniobj = v
                                        mininumber = v.stackCount
                                    end
                                end
                            end
                            env.discard_item = miniobj
                            return true
                        end
                        env.discard_item = item
                        return true
                    else
                        if poe2_api.table_contains(item.baseType_utf8,altar_shop_config) and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                            local is_dis = get_not(item,1)
                            if is_dis then
                                env.discard_item = item
                                return true
                            end
                            -- return false
                        end
                    end
                end
                return false
            end
            -- 找黑雾祭坛
            local function get_altar(range_info)
                if not range_info or not next(range_info) then
                    return false
                end
                for _, i in ipairs(range_info) do
                    if i.path_name_utf8 and i.path_name_utf8 ~= "" and string.find(game_str.Ritual_PATH,i.path_name_utf8) then
                        -- local stateMachineList = i:GetStateMachineList()
                        if i.stateMachineList and next(i.stateMachineList) then
                            local current_state = (i.stateMachineList or {}).current_state or 5
                            local interaction_enabled = (i.stateMachineList or {}).interaction_enabled or 5
                            if current_state == 2 and interaction_enabled == 0 then
                                return i
                            end
                        end
                        
                    end
                end
                return false
            end
            -- 判断自身一定范围内是否有激活怪
            local function get_monster(range_info,mate,distance)
                if not range_info or not next(range_info) then
                    return false
                end
                for _, v in ipairs(range_info) do
                    if v.type == 1 and not v.is_friendly and v.life > 0
                     and not poe2_api.table_contains(v.name_utf8,my_game_info.not_attact_mons_CN_name)
                     and v.isActive and not string.find(v.name_utf8,game_str.temple) and v.is_selectable then
                        local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                        if dis and dis < distance then
                            return true
                        end
                    end
                end
                return false
            end
            local is_not_item = get_not_item(bag_info)
            -- 没有要丢弃物品和附着物为空
            if not is_not_item and (not Attachments or not next(Attachments)) then
                poe2_api.dbgp("没有要丢弃物品和附着物为空,不丢弃")
                poe2_api.time_p("物品丢弃（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local is_altar = get_altar(env.range_info)
            if is_altar then
                local dis = poe2_api.point_distance(is_altar.grid_x, is_altar.grid_y,player_info)
                if dis and dis < 105 then
                    poe2_api.dbgp("在黑屋祭坛,不丢弃")
                    poe2_api.time_p("物品丢弃（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
            end
            local mon = get_monster(env.range_info,player_info,100)
            if mon then
                poe2_api.dbgp("在怪附近,不丢弃")
                poe2_api.time_p("物品丢弃（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if player_info.isInDangerArea then
                poe2_api.dbgp("玩家是否在危险区域:", player_info.isInDangerArea)
                local point = api_GetSafeAreaLocation(player_info.grid_x, player_info.grid_y, 60, 10, 0, 0.5)
                if point then
                    api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),7)
                    api_Sleep(100)
                    poe2_api.dbgp1("+++++++++++++++++++++++++++++++++++++++++++++++")
                    poe2_api.click_keyboard("space")
                    poe2_api.time_p("物品丢弃（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            if type(is_not_item) == "table" then
                if not poe2_api.find_text({text = game_str.backpack,UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                    poe2_api.click_keyboard("i")
                    api_Sleep(300)
                    poe2_api.dbgp("开背包,刷新词条")
                    poe2_api.time_p("物品丢弃（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local point = poe2_api.get_center_position({is_not_item[1].start_x,is_not_item[1].start_y},{is_not_item[1].end_x,is_not_item[1].end_y})
                if point and next(point) then
                    api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                    poe2_api.time_p("物品丢弃（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            if not Attachments or not next(Attachments) then
                if not bag_info or not next(bag_info) then
                    env.discard_item = nil
                    poe2_api.time_p("物品丢弃（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local obj = nil
                for _, v in ipairs(bag_info) do
                    if v.obj == env.discard_item.obj then
                        obj = v
                    end
                end
                if not obj then
                    env.discard_item = nil
                    poe2_api.time_p("物品丢弃（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if not poe2_api.find_text({text = game_str.backpack,UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                    poe2_api.click_keyboard("i")
                    api_Sleep(300)
                    poe2_api.dbgp("开背包,丢弃1")
                    poe2_api.time_p("物品丢弃（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local point = poe2_api.get_center_position({env.discard_item.start_x,env.discard_item.start_y},{env.discard_item.end_x,env.discard_item.end_y})
                api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                api_Sleep(500)
                poe2_api.time_p("物品丢弃（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            else
                local index_list ={2,3,4,5,6,7,8,9,0xa,0xb}
                local point_list = {
                    [2] = {1320,250},
                    [3] = {1151,191},
                    [4] = {1493,191},
                    [5] = {1322,133},
                    [6] = {1410,201},
                    [7] = {1237,255},
                    [8] = {1410,255},
                    [9] = {1213,330},
                    [0xa] = {1431,330},
                    [0xb] = {1322,353},
                }
                local point = nil
                for _, v in ipairs(index_list) do
                    if poe2_api.table_contains(v,{10,11}) then
                        v = string.format("0x%x", v)
                    end
                    local item = env["item"..v]
                    if item and next(item) then
                        if Attachments[1].baseType_utf8 == item[1].baseType_utf8 
                        and Attachments[1].DemandStrength == item[1].DemandStrength
                        and Attachments[1].DemandAgility == item[1].DemandAgility
                        and Attachments[1].DemandWisdom == item[1].DemandWisdom
                        and Attachments[1].DemandLevel == item[1].DemandLevel
                        and Attachments[1].not_identified == item[1].not_identified
                        and Attachments[1].category_utf8 == item[1].category_utf8
                        and Attachments[1].quality == item[1].quality
                        and Attachments[1].sockets == item[1].sockets
                        and Attachments[1].color == item[1].color then
                            local current_item = api_Getinventorys(v,0)
                            if current_item and next(current_item) then
                                if current_item[1].baseType_utf8 == item[1].baseType_utf8 
                                and current_item[1].DemandStrength == item[1].DemandStrength
                                and current_item[1].DemandAgility == item[1].DemandAgility
                                and current_item[1].DemandWisdom == item[1].DemandWisdom
                                and current_item[1].DemandLevel == item[1].DemandLevel
                                and current_item[1].not_identified == item[1].not_identified
                                and current_item[1].category_utf8 == item[1].category_utf8
                                and current_item[1].quality == item[1].quality
                                and current_item[1].sockets == item[1].sockets
                                and current_item[1].color == item[1].color then
                                else
                                    point = point_list[v]
                                    break
                                end
                            else
                                point = point_list[v]
                                break
                            end
                        end
                    end
                end
                if point then
                    if poe2_api.find_text({text = game_str.backpack,UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                        api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                        api_Sleep(100)
                        poe2_api.time_p("物品丢弃（RUNNING8）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    else
                        poe2_api.dbgp("开背包,丢弃2")
                        poe2_api.click_keyboard("i")
                        api_Sleep(300)
                        poe2_api.time_p("物品丢弃（RUNNING9）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                else     
                    -- 先设置随机种子（只需执行一次）
                    math.randomseed(os.time())
                    -- 生成 [20, 450) 范围内的随机浮点数
                    local x = 20 + (450 - 20) * math.random()
                    -- 生成 [50, 500) 范围内的随机浮点数
                    local y = 50 + (500 - 50) * math.random()
                    api_ClickScreen(poe2_api.toInt(x),poe2_api.toInt(y),1)
                    api_Sleep(200)
                    if not self.item_name then
                        self.item_name = Attachments[1].baseType_utf8
                    end
                    if self.item_name ~= Attachments[1].baseType_utf8 then
                        self.item_name = Attachments[1].baseType_utf8
                    else
                        self.index = self.index + 1
                    end
                    if self.index > 8 then
                        if poe2_api.find_text({text = game_str.backpack,UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                            poe2_api.click_keyboard("i")
                            poe2_api.dbgp("关背包6")
                            api_Sleep(300)
                        end
                        local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),50)
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),1)
                            api_Sleep(200)
                            poe2_api.dbgp1("rsdgjtgjasdvzxbfdhfsdh")
                            poe2_api.click_keyboard("space")
                            self.index = 0
                        end
                    end
                    poe2_api.time_p("物品丢弃（RUNNING10）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            poe2_api.time_p("物品丢弃（RUNNING11）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.RUNNING
        end
    },

    -- 鉴定指定装备
    Identify_designated_equipment = {
        run = function(self, env)
            poe2_api.print_log("鉴定指定装备...") 
            local player_info = env.player_info
            local attack_dis_map = env.map_level_dis
            local stuck_monsters = env.stuck_monsters
            local not_attack_mos = env.not_attack_mos
            local config = env.user_config

            if self.need_identify_in_map == nil then
                self.need_identify_in_map = config["全局設置"]["刷图通用設置"]["是否图内鉴定"]
                return bret.RUNNING
            end

            if not self.need_identify_in_map then
                return bret.SUCCESS
            end

            local config_name = env.item_config_name
            local config_type = env.item_config_type

            poe2_api.dbgp(string.format("当前地图: %s, 危险区域: %s", 
                player_info.current_map_name_utf8 or "未知", 
                tostring(player_info.isInDangerArea)))
            
            if poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout) then
                return bret.SUCCESS
            end

            -- poe2_api.dbgp("====== 开始装备鉴定流程 ======")

            -- 创建反向字典
            local reverse_type_conversion = {}
            for k, v in pairs(my_game_info.type_conversion) do
                reverse_type_conversion[v] = k
                -- poe2_api.dbgp(string.format("类型转换表: %s -> %s", k, v))
            end

            local function convert_key(key)
                local converted = my_game_info.type_conversion[key] or reverse_type_conversion[key]
                -- poe2_api.dbgp(string.format("类型转换: %s -> %s", key, converted or "无对应转换"))
                return converted
            end

            local function convert_config_type(config_type_dict)
                if not config_type_dict then
                    poe2_api.dbgp("警告: 配置类型字典为空")
                    return {}
                end
                
                local converted_dict = {}
                poe2_api.dbgp("开始转换配置类型...")
                
                for chinese_type, info_list in pairs(config_type_dict) do
                    local english_type = my_game_info.type_conversion[chinese_type]
                    -- poe2_api.dbgp(string.format("处理类型: %s -> %s", chinese_type, english_type or "无对应英文"))
                    
                    if english_type then
                        -- 处理内嵌'類型'字段
                        if type(info_list) == "table" and info_list["類型"] then
                            poe2_api.dbgp("发现嵌套类型字段，开始处理...")
                            if type(info_list["類型"]) == "table" then
                                local converted_types = {}
                                for _, t in ipairs(info_list["類型"]) do
                                    local converted = my_game_info.type_conversion[t] or t
                                    table.insert(converted_types, converted)
                                    -- poe2_api.dbgp(string.format("转换嵌套类型: %s -> %s", t, converted))
                                end
                                info_list["類型"] = converted_types
                            else
                                local converted = my_game_info.type_conversion[info_list["類型"]] or info_list["類型"]
                                info_list["類型"] = {converted}
                                -- poe2_api.dbgp(string.format("转换单类型: %s -> %s", info_list["類型"], converted))
                            end
                        end
                        converted_dict[english_type] = info_list
                    else
                        poe2_api.dbgp(string.format("严重警告: 未找到类型 '%s' 的英文转换", chinese_type))
                    end
                end
                
                poe2_api.dbgp("配置类型转换完成")
                return converted_dict
            end

            -- 转换配置类型
            poe2_api.dbgp("开始转换主配置类型...")
            config_type = convert_config_type(config_type)
            -- poe2_api.dbgp(string.format("转换后配置类型条目数: %d", table.count(config_type)))

            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Continue_Game, click = 2}) then
                poe2_api.dbgp("城外鉴定: 发现'繼續遊戲'文本，点击处理中...")
                return bret.RUNNING
            end

            local appraisal_item_list = {}

            local function need_appraisal(bag_info)
                if not bag_info then
                    poe2_api.dbgp("城外鉴定: 背包信息为空")
                    return false
                end
                
                -- poe2_api.dbgp(string.format("开始检查背包物品，总数: %d", #bag_info))
                
                local function get_matched_config(bag)
                    -- 初始物品信息检查
                    -- poe2_api.dbgp("\n========== 开始物品匹配流程 ==========")
                    -- poe2_api.dbgp(string.format("[物品基本信息] 名称: %s | 类型: %s | 基础类型: %s | 颜色: %d", 
                    --     bag.name_utf8 or "nil", 
                    --     bag.category_utf8 or "nil", 
                    --     bag.baseType_utf8 or "nil", 
                    --     bag.color or -1))
                    
                    -- 检查config_type是否存在
                    if not config_type then
                        -- poe2_api.dbgp("[错误] config_type 配置表不存在！")
                        return nil
                    end
                
                    -- 1. 首先检查类型匹配
                    -- poe2_api.dbgp("\n=== 开始类型配置匹配 ===")
                    for config_name, item_config in pairs(config_type) do
                        -- poe2_api.dbgp(string.format("\n[检查配置组] 配置组名称: %s", config_name))
                        -- poe2_api.dbgp("[配置内容] %s", poe2_api.printTable(item_config))

                        for idx, item in ipairs(item_config) do
                            -- poe2_api.dbgp("\n[检查配置项] 序号: %d", idx)
                            -- poe2_api.dbgp("------------------------------------------------------------------------")
                            if type(item) ~= "table" then
                                -- poe2_api.dbgp("[警告] 配置项不是table类型，跳过")
                                goto continue
                            end
                
                            -- 类型检查
                            local item_type = item["類型"]
                            -- poe2_api.dbgp(string.format("[类型检查] 配置类型: %s | 物品类型: %s", 
                            --     poe2_api.printTable(item_type), 
                            --     bag.category_utf8 or "nil"))
                
                            -- 处理类型匹配
                            local type_match = false
                            if type(item_type) == "table" and #item_type > 0 then
                                type_match = (item_type[1] == convert_key(bag.category_utf8))
                            elseif type(item_type) == "string" then
                                type_match = (item_type == convert_key(bag.category_utf8))
                            else
                                -- poe2_api.dbgp("[警告] 配置类型格式无效")
                            end
                
                            if not type_match then
                                -- poe2_api.dbgp("-> 类型不匹配，跳过")
                                goto continue
                            end
                            -- poe2_api.dbgp("-> 类型匹配通过")
                
                            -- 基础类型检查
                            local base_type = item["基礎類型名"] or "nil"
                            -- poe2_api.dbgp(string.format("[基础类型检查] 配置基础类型: %s | 物品基础类型: %s", 
                            --     base_type, bag.baseType_utf8 or "nil"))
                
                            if bag.baseType_utf8 ~= base_type and base_type ~= "全部物品" and not string.find(base_type, bag.baseType_utf8) then
                                -- poe2_api.dbgp("-> 基础类型不匹配，跳过")
                                goto continue
                            end
                            poe2_api.dbgp("-> 基础类型匹配通过")
                
                            -- 品质检查
                            local quality_check = {
                                white = item["白裝"],
                                blue = item["藍裝"],
                                yellow = item["黃裝"],
                                unique = item["暗金"]
                            }
                            -- poe2_api.dbgp(string.format("[品质检查] 配置要求: 白=%s 蓝=%s 黄=%s 暗金=%s | 物品颜色: %d",
                            --     tostring(quality_check.white),
                            --     tostring(quality_check.blue),
                            --     tostring(quality_check.yellow),
                            --     tostring(quality_check.unique),
                            --     bag.color or -1))
                
                            local quality_ok = false
                            if bag.color == 0 and quality_check.white then
                                quality_ok = true
                            elseif bag.color == 1 and quality_check.blue then
                                quality_ok = true
                            elseif bag.color == 2 and quality_check.yellow then
                                quality_ok = true
                            -- elseif bag.color == 3 and quality_check.unique then
                            elseif bag.color == 3 then
                                quality_ok = true
                            end
                
                            if not quality_ok then
                                poe2_api.dbgp("-> 品质不匹配，跳过")
                                goto continue
                            end
                            poe2_api.dbgp("-> 品质检查通过")
                
                            -- 名称检查
                            if item["名稱"] then
                                -- poe2_api.dbgp(string.format("[名称检查] 配置名称: %s | 物品名称: %s",
                                --     item["名稱"], bag.name_utf8 or "nil"))
                                
                                if item["名稱"] == bag.name_utf8 then
                                    -- poe2_api.dbgp("-> 名称完全匹配，返回配置")
                                    -- poe2_api.dbgp("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item))
                                    return item
                                else
                                    -- poe2_api.dbgp("-> 名称不匹配，继续检查")
                                end
                            else
                                -- poe2_api.dbgp("[名称检查] 配置无名称要求，检查词缀")
                                
                                -- 词缀检查
                                if item["物品詞綴"] then
                                    poe2_api.dbgp("[词缀检查] 发现词缀配置")
                                    local affix_dict = item["物品詞綴"]
                                    
                                    if affix_dict and type(affix_dict) == "table" then
                                        for affix_name, v in pairs(affix_dict) do
                                            if type(v) == "table" and v["詞綴"] then
                                                -- poe2_api.dbgp(string.format("-> 发现有效词缀: %s", affix_name))
                                                -- poe2_api.dbgp(string.format("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item)))
                                                return item
                                            end
                                        end
                                    end
                                end
                            end
                
                            -- 如果前面都通过但没返回，检查基础类型名
                            -- poe2_api.dbgp("[最终检查] 基础类型名匹配检查")
                            if base_type == bag.baseType_utf8 or base_type == "全部物品" or string.find(item["基礎類型名"] , bag.baseType_utf8) then
                                -- poe2_api.dbgp("-> 基础类型名匹配，返回配置")
                                -- poe2_api.dbgp(string.format("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item)))
                                return item
                            end
                
                            ::continue::
                        end
                    end
                    
                    -- 2. 检查名称匹配
                    poe2_api.dbgp("\n=== 开始名称配置匹配 ===")
                    if not config_name then
                        poe2_api.dbgp("[警告] config_name 配置表不存在")
                    else
                        for config_name, item_config in pairs(config_name) do
                            -- poe2_api.dbgp(string.format("\n[检查名称配置组] %s", config_name))
                            
                            for idx, item in ipairs(item_config) do
                                -- poe2_api.dbgp(string.format("[检查配置项] 序号: %d", idx))
                                
                                if type(item) == "table" then
                                    -- poe2_api.dbgp(string.format("[基础类型比较] 配置: %s | 物品: %s",
                                    --     item["基礎類型名"] or "nil", bag.baseType_utf8 or "nil"))
                                    
                                    if item["基礎類型名"] == bag.baseType_utf8 or string.find(item["基礎類型名"] , bag.baseType_utf8) or item["名稱"] ~= "" or item["名稱"] ~= nil then
                                        poe2_api.dbgp("-> 基础类型匹配")
                                        
                                        local type_ok = true
                                        if item["類型"] and item["類型"][1] then
                                            type_ok = (item["類型"][1] == bag.category_utf8)
                                            -- poe2_api.dbgp(string.format("[类型比较] 配置: %s | 物品: %s | 结果: %s",
                                            --     item["類型"][1], bag.category_utf8 or "nil",
                                            --     type_ok and "匹配" or "不匹配"))
                                        end
                                        
                                        if type_ok then
                                            -- poe2_api.dbgp("-> 所有条件匹配，返回配置")
                                            return item
                                        end
                                    end
                                end
                            end
                        end
                    end
                
                    poe2_api.dbgp("\n[匹配结果] 未找到匹配配置")
                    return nil
                end

                local items_to_identify = {}
                poe2_api.dbgp("开始扫描背包物品...")
                
                for i, bag in ipairs(bag_info) do
                    -- poe2_api.dbgp(string.format("\n物品 %d/%d: %s (类型: %s, 基础类型: %s, 颜色: %d, 已鉴定: %s)", 
                    --     i, #bag_info, bag.name_utf8 or "无名", bag.category_utf8 or "无类型", 
                    --     bag.baseType_utf8 or "无基础类型", bag.color or -1, 
                    --     tostring(not bag.not_identified)))
                    
                    -- 基础条件：未鉴定、未污染、不在排除列表
                    if not (bag.not_identified and
                            not poe2_api.table_contains(my_game_info.not_need_identify, bag.category_utf8)) then
                        -- poe2_api.dbgp("物品已鉴定或在不需鉴定列表中，跳过")
                        goto continue_item
                    end
                    
                    -- 特殊类别直接加入鉴定列表
                    if poe2_api.table_contains({game_str.Map_EN, game_str.TowerAugmentation}, bag.category_utf8) then
                        poe2_api.dbgp("特殊类别物品，直接加入鉴定列表")
                        table.insert(items_to_identify, bag)
                        goto continue_item
                    end

                    -- 获取匹配的配置
                    poe2_api.dbgp("开始匹配配置...")
                    local matched_config = get_matched_config(bag)
                    
                    -- 检查物品詞綴配置
                    if matched_config and matched_config["物品詞綴"] or matched_config["名稱"] then
                        poe2_api.dbgp("找到匹配配置，检查词缀...")
                        local affix_dict = matched_config["物品詞綴"]
                        if matched_config["名稱"] ~= nil then
                            table.insert(items_to_identify, bag)
                            poe2_api.dbgp(string.format("发现有效名稱内容: %s", matched_config["名稱"]))
                        end
                        if affix_dict and type(affix_dict) == "table" then
                            local has_valid_affix = false
                            for affix_name, v in pairs(affix_dict) do
                                if type(v) == "table" and v["詞綴"] then
                                    poe2_api.dbgp(string.format("发现有效词缀: %s", affix_name))
                                    has_valid_affix = true
                                    break
                                end
                            end
                            
                            if has_valid_affix then
                                poe2_api.dbgp("物品有有效词缀或者名稱，加入鉴定列表")
                                table.insert(items_to_identify, bag)
                            else
                                poe2_api.dbgp("配置中无有效词缀，跳过")
                            end
                        end
                    else
                        poe2_api.dbgp("未找到匹配配置或配置无词缀要求")
                    end
                    ::continue_item::
                end

                if #items_to_identify > 0 then
                    poe2_api.dbgp(string.format("找到 %d 件需要鉴定的物品", #items_to_identify))
                    appraisal_item_list = items_to_identify
                    return items_to_identify
                end
                poe2_api.dbgp("未找到需要鉴定的物品")
                return false
            end

            poe2_api.dbgp("开始检查是否需要鉴定...")
            local bag_info = api_Getinventorys(1, 0)
            if not bag_info then
                poe2_api.dbgp("错误: 无法获取背包信息")
                return bret.SUCCESS
            end

            local items_to_identify = need_appraisal(bag_info)
            if not items_to_identify then
                poe2_api.dbgp("当前没有需要鉴定的物品")
                return bret.SUCCESS
            end

            poe2_api.dbgp(string.format("需要鉴定的物品数量: %d", #items_to_identify))
            
            if player_info.isInDangerArea then
                poe2_api.dbgp("警告: 玩家处于危险区域，暂停鉴定")
                return bret.SUCCESS
            end

            local has_monsters = poe2_api.is_have_mos({range_info = env.range_info, 
                player_info = player_info, 
                attack_dis_map = attack_dis_map, 
                stuck_monsters = stuck_monsters, 
                not_attack_mos = not_attack_mos,
                not_sight = true
            })
            
            if has_monsters then
                poe2_api.dbgp("警告: 周围有怪物，暂停鉴定")
                return bret.SUCCESS
            end

            local function use_items(bag_info, click)
                if not bag_info then 
                    poe2_api.dbgp("错误: use_items 传入的背包信息为空")
                    return false 
                end
                
                poe2_api.dbgp("开始查找知识卷轴...")
                for _, actor in ipairs(bag_info) do
                    if actor.baseType_utf8 == game_str.The_Knowledge_Scroll then
                        poe2_api.dbgp(string.format("找到知识卷轴，位置: %d,%d - %d,%d", 
                            actor.start_x, actor.start_y, actor.end_x, actor.end_y))
                        
                        if click == 1 then
                            -- 计算中心坐标
                            local start_cell = {actor.start_x, actor.start_y}
                            local end_cell = {actor.end_x, actor.end_y}
                            local center_position = poe2_api.get_center_position(start_cell, end_cell)
                            
                            poe2_api.dbgp(string.format("卷轴中心位置: %d, %d", center_position[1], center_position[2]))
                            
                            poe2_api.dbgp("点击卷轴...")
                            api_ClickScreen(center_position[1], center_position[2],0)
                            api_Sleep(200)
                            api_ClickScreen(center_position[1], center_position[2],2)
                            api_Sleep(500)
                        end
                        return true
                    end
                end
                poe2_api.dbgp("警告: 背包中没有找到知识卷轴")
                return false
            end

            poe2_api.dbgp("准备使用卷轴...")
            if not use_items(bag_info) then
                poe2_api.dbgp("错误: 无法使用知识卷轴")
                return bret.SUCCESS
            end

            -- 重新获取背包信息
            poe2_api.dbgp("重新获取背包信息...")
            bag_info = api_Getinventorys(1, 0)
            if not bag_info then
                poe2_api.dbgp("错误: 重新获取背包信息失败")
                return bret.SUCCESS
            end

            items_to_identify = need_appraisal(bag_info)
            if not items_to_identify then
                poe2_api.dbgp("重新检查后没有需要鉴定的物品")
                return bret.SUCCESS
            end

            if (poe2_api.is_have_mos({range_info = env.range_info, player_info = player_info}) and 
                (poe2_api.table_contains(my_game_info.hideout_CH, player_info.current_map_name_utf8) or 
                string.find(player_info.current_map_name_utf8, game_str.town))) then
                poe2_api.dbgp("警告: 安全区域发现怪物，暂停鉴定")
                return bret.SUCCESS
            end
            
            poe2_api.dbgp("开始鉴定物品...")
            for _, items in ipairs(bag_info) do
                for _, k in ipairs(items_to_identify) do
                    if items.obj == k.obj then
                        poe2_api.dbgp(string.format("鉴定物品: %s (类型: %s)", 
                            items.name_utf8 or "无名", items.category_utf8 or "无类型"))
                        
                        if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.backpack, min_x = 1020, min_y = 32, max_x = 1600, max_y=78}) then
                            poe2_api.dbgp("未检测到背包UI，尝试打开背包...")
                            poe2_api.click_keyboard("i")
                            api_Sleep(500)
                        end

                        use_items(bag_info, 1)
                        api_Sleep(500)
                        
                        -- 计算中心坐标
                        local start_cell = {items.start_x, items.start_y}
                        local end_cell = {items.end_x, items.end_y}
                        local center_position = poe2_api.get_center_position(start_cell, end_cell)
                        poe2_api.dbgp(string.format("物品中心位置: %d, %d", center_position[1], center_position[2]))

                        poe2_api.dbgp("左键点击物品...")
                        api_ClickScreen(center_position[1], center_position[2],0)
                        api_Sleep(200)
                        poe2_api.dbgp("右键点击物品...")
                        api_ClickScreen(center_position[1], center_position[2],1)
                        api_Sleep(200)
                        
                        poe2_api.dbgp("物品鉴定完成")
                        return bret.RUNNING
                    end
                end
            end

            poe2_api.dbgp("错误: 未找到匹配的需要鉴定的物品")
            return bret.SUCCESS
        end
    },

    -- 检查是否拾取
    Is_Pick_UP = {
        run = function(self, env)
            poe2_api.print_log("检查是否需要拾取...")
            local start_time = api_GetTickCount64()
            local current_time = api_GetTickCount64()
            if not self.bool then
                self.id1 = nil
                self.number = 0
                self.bool = true
                self.wait = false
                self.wait_time = 0
                self.currte_time = 0
                self.path_time = 0
            end
            local config = env.user_config
            local need_item = env.need_item
            local is_decompose = config["全局設置"]["刷图通用設置"]["是否分解暗金"] or false
            local altar_shop_config = config['刷圖設置']["祭祀購買"]
            local stuck_monsters = env.stuck_monsters
            -- local item_list = env.range_items
            local player_info = env.player_info
            -- local range_info = env.range_info
            local bag_info = env.bag_info
            -- local current_map_info = env.current_map_info
            if not next(player_info) then
                poe2_api.dbgp("人物信息为空")
                poe2_api.time_p("检查是否拾取（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local function is_props(bag)
                local text_list = {game_str.The_Book_of_Knowledge,game_str.The_crystallization_core_of_knowledge_CH}
                for _, i in ipairs(bag) do
                    if i.category_utf8 == game_str.QuestItem then
                        for _, v in ipairs(text_list) do
                            if string.match(i.baseType_utf8,v) then
                                return i
                            end
                            
                        end
                    end
                end
                return false
            end
            local function get_item(items,processed_configs)
                
                local sorted_items = poe2_api.get_sorted_list(items,player_info)
                if not sorted_items or not next(sorted_items) then
                    poe2_api.dbgp("数据有问题2222")
                    return false
                end
                -- for _, v in ipairs(sorted_items) do
                --     poe2_api.dbgp(v.name_utf8)
                --     poe2_api.dbgp(v.baseType_utf8)
                --     poe2_api.dbgp(v.category_utf8)
                --     poe2_api.dbgp(tostring(v.grid_x))
                --     poe2_api.dbgp(tostring(v.grid_y))
                --     poe2_api.dbgp(tostring("========================================"))
                -- end
                poe2_api.dbgp(tostring(#sorted_items))
                for _, item in ipairs(sorted_items) do
                    -- api_Sleep(5000)
                    -- poe2_api.dbgp(item.name_utf8)
                    -- poe2_api.dbgp(item.baseType_utf8)
                    -- poe2_api.dbgp(item.category_utf8)
                    -- poe2_api.dbgp(tostring(item.grid_x))
                    -- poe2_api.dbgp(tostring(item.grid_y))
                    -- poe2_api.dbgp(tostring("========================================"))
                    if item.grid_x ~= 0 and item.grid_y ~= 0 then
                        -- poe2_api.dbgp("cccccccccccccccccccccccccccccccccc")
                        if item.category_utf8 == game_str.QuestItem then
                            if is_props(items) then
                                env.interactive = item
                                env.need_item = item
                                return true
                            end
                        end
                        if item.baseType_utf8 == game_str.Decayed_backpack_charging_CH then
                            env.interactive = item
                            env.need_item = item
                            return true
                        end
                        for _, cfg in ipairs(processed_configs) do
                            
                            if poe2_api.match_item(item,cfg) then
                                -- poe2_api.dbgp("999================================================")
                                if env.pick_up_timeout and next(env.pick_up_timeout) and poe2_api.table_contains(item.id,env.pick_up_timeout) then
                                    break
                                end
                                if not cfg['不撿'] then
                                    if poe2_api.is_do_without_pick_up(item,processed_configs) then
                                        break
                                    end
                                    local item_entry = cfg["物品詞綴"] or {}
                                    if item_entry and next(item_entry) then
                                        local function get_cfg_entry(entry_list)
                                            for k, v in pairs(entry_list) do
                                                if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                                    if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                        return true
                                                    end
                                                end
                                            end
                                            return false
                                        end
                                        local function get_cfg_entry_tower()
                                            for k, v in pairs(item_entry) do
                                                if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                                    if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                        for i, v1 in ipairs(v["詞綴"]) do
                                                            if not string.find(v1["name"],game_str.within_the_scope_CH) then
                                                                return true
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                            return false
                                        end
                                        if get_cfg_entry(item_entry) then
                                            if item.category_utf8 == game_str.TowerAugmentation then
                                                if get_cfg_entry_tower() then
                                                    if item.color ~= 1 or (item.color == 1 and item.fixedSuffixCount<2) then
                                                        env.interactive = item
                                                        env.need_item = item
                                                        return true
                                                    end
                                                end
                                            end
                                            if poe2_api.table_contains(item.category_utf8,my_game_info.equip_type)
                                             and not item.not_identified then
                                                local suffixes = api_GetObjectSuffix(item.mods_obj)
                                                if suffixes and next(suffixes) then
                                                    if not poe2_api.filter_item(item,suffixes,config["物品過濾"]) then
                                                        poe2_api.dbgp("词缀不符合*******************************************")
                                                        break
                                                    end
                                                else
                                                    poe2_api.dbgp("未找到物品词缀——————————————————————————————————————————————")
                                                    break
                                                end
                                                
                                            end
                                        end
                                    end
                                    if bag_info and next(bag_info) then
                                        if item.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                            local number = 0
                                            for _, v in ipairs(bag_info) do
                                                if v.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                                    number = number + v.stackCount
                                                end
                                            end
                                            if number >= 80 then
                                                break
                                            end
                                        end
                                    end
                                    local distance = poe2_api.point_distance(item.grid_x,item.grid_y,player_info)
                                    local function is_point(grid_x,grid_y)
                                        local point = api_FindNearestReachableInRange(math.floor(grid_x),math.floor(grid_y),15,0)
                                        local ralet = api_FindPath(player_info.grid_x,player_info.grid_y,math.floor(point.x),math.floor(point.y))
                                        return ralet
                                    end
                                    if distance and distance > 15 then
                                        local ralet = is_point(item.grid_x,item.grid_y)
                                        if not ralet or not next(ralet) then
                                            poe2_api.dbgp("无路径")
                                            api_UpdateMapObstacles(100)
                                            break
                                        end
                                    end
                                    env.interactive = item
                                    env.need_item = item
                                    return true
                                end
                                break
                            end

                        end
                        if poe2_api.table_contains(item.baseType_utf8,altar_shop_config) then
                            -- poe2_api.dbgp("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk")
                            if env.pick_up_timeout and next(env.pick_up_timeout) and poe2_api.table_contains(item.id,env.pick_up_timeout) then
                                break
                            end
                            if poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                for _, cfg in ipairs(processed_configs) do
                            
                                    if poe2_api.match_item(item,cfg) then
                                        -- poe2_api.dbgp("999================================================")
                                        if env.pick_up_timeout and next(env.pick_up_timeout) and poe2_api.table_contains(item.id,env.pick_up_timeout) then
                                            break
                                        end
                                        if not cfg['不撿'] then
                                            if poe2_api.is_do_without_pick_up(item,processed_configs) then
                                                break
                                            end
                                            local item_entry = cfg["物品詞綴"] or {}
                                            if item_entry and next(item_entry) then
                                                local function get_cfg_entry(entry_list)
                                                    for k, v in pairs(entry_list) do
                                                        if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                                            if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                                return true
                                                            end
                                                        end
                                                    end
                                                    return false
                                                end
                                                local function get_cfg_entry_tower()
                                                    for k, v in pairs(item_entry) do
                                                        if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                                            if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                                for i, v1 in ipairs(v["詞綴"]) do
                                                                    if not string.find(v1["name"],game_str.within_the_scope_CH) then
                                                                        return true
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                    return false
                                                end
                                                if get_cfg_entry(item_entry) then
                                                    if item.category_utf8 == game_str.TowerAugmentation then
                                                        if get_cfg_entry_tower() then
                                                            if item.color ~= 1 or (item.color == 1 and item.fixedSuffixCount<2) then
                                                                env.interactive = item
                                                                env.need_item = item
                                                                return true
                                                            end
                                                        end
                                                    end
                                                    if poe2_api.table_contains(item.category_utf8,my_game_info.equip_type)
                                                     and not item.not_identified then
                                                        local suffixes = api_GetObjectSuffix(item.mods_obj)
                                                        if suffixes and next(suffixes) then
                                                            if not poe2_api.filter_item(item,suffixes,config["物品過濾"]) then
                                                                poe2_api.dbgp("词缀不符合*******************************************")
                                                                break
                                                            end
                                                        else
                                                            poe2_api.dbgp("未找到物品词缀——————————————————————————————————————————————")
                                                            break
                                                        end
                                                        
                                                    end
                                                end
                                            end
                                            if bag_info and next(bag_info) then
                                                if item.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                                    local number = 0
                                                    for _, v in ipairs(bag_info) do
                                                        if v.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                                            number = number + v.stackCount
                                                        end
                                                    end
                                                    if number >= 80 then
                                                        break
                                                    end
                                                end
                                            end
                                            local distance = poe2_api.point_distance(item.grid_x,item.grid_y,player_info)
                                            local function is_point(grid_x,grid_y)
                                                local point = api_FindNearestReachableInRange(math.floor(grid_x),math.floor(grid_y),15,0)
                                                local ralet = api_FindPath(player_info.grid_x,player_info.grid_y,math.floor(point.x),math.floor(point.y))
                                                return ralet
                                            end
                                            if distance and distance > 15 then
                                                local ralet = is_point(item.grid_x,item.grid_y)
                                                if not ralet or not next(ralet) then
                                                    poe2_api.dbgp("无路径")
                                                    api_UpdateMapObstacles(100)
                                                    break
                                                end
                                            end
                                            env.interactive = item
                                            env.need_item = item
                                            return true
                                        end
                                        break
                                    end
        
                                end
                                -- local is_dis = get_not(item,1)
                                -- if is_dis then
                                --     env.discard_item = item
                                --     return true
                                -- end
                                -- return false
                            else
                                env.interactive = item
                                env.need_item = item
                                return true
                            end
                            
                        end
                        if is_decompose then
                            -- poe2_api.dbgp("mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm")
                            if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                if env.pick_up_timeout and next(env.pick_up_timeout) and poe2_api.table_contains(item.id,env.pick_up_timeout) then
                                    -- poe2_api.dbgp("jjjjjjjjjjjjjjjjjjjjjjjjjjjjjj")
                                    break
                                end
                                env.interactive = item
                                env.need_item = item
                                -- poe2_api.dbgp("hhhhhhhhhhhhhhhhhhhhhh")
                                return true
                            end
                        end
                    end
                end
                return false
            end
            if self.wait then
                if api_GetTickCount64() - self.current_time < self.wait_time then
                    poe2_api.dbgp("等待中")
                    poe2_api.time_p("检查是否拾取（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                self.wait = false
            end
            -- 判断自身一定范围内是否有激活怪
            local function is_monster(range_info,mate,distance)
                if not range_info or not next(range_info) then
                    return false
                end
                if distance > env.min_attack_dis then
                    distance = env.min_attack_dis  
                end
                local num = 0
                for _, v in ipairs(range_info) do
                    if v.type == 1 and not v.is_friendly and v.life > 0
                     and not poe2_api.table_contains(v.name_utf8,my_game_info.not_attact_mons_CN_name)
                     and v.isActive and not string.find(v.name_utf8,game_str.temple) and v.hasLineOfSight and v.is_selectable
                     and (not stuck_monsters or not next(stuck_monsters) or not poe2_api.table_contains(stuck_monsters,v.id)) then
                        local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                        if dis and dis < distance then
                            if v.rarity ~= 0 then
                                return true
                            end
                            num = num +1
                        end
                    end
                end
                if num >= 3 then
                    return true
                end
                return false
            end
            if env.bag_man and not is_monster(env.range_info, player_info,50) then
                if poe2_api.find_text({text = game_str.Are_you_sure_you_want_to_leave_CH,UI_info = env.UI_info,min_x=0}) then
                    poe2_api.find_text({text = game_str.Yes_CH,UI_info = env.UI_info,min_x=0,click=2})
                    api_Sleep(500)
                    env.bag_man = true
                    return bret.RUNNING
                end
                for _, i in ipairs(env.range_info) do
                    if i.name_utf8 ~= "" and i.type == 5 and ((not string.find(player_info.current_map_name_utf8,game_str.Abyss) and poe2_api.table_contains(i.name_utf8,my_game_info.hideout_CH)) or string.find(player_info.current_map_name_utf8,game_str.Abyss)) then
                        poe2_api.printTable(i)
                        local dis = poe2_api.point_distance(i.grid_x, i.grid_y, player_info)
                        if dis and dis < 25 then
                            if not string.find(player_info.current_map_name_utf8,game_str.Abyss) then
                                poe2_api.find_text({text = i.name_utf8,UI_info = env.UI_info,min_x=200,min_y=200,click=2})
                            else
                                poe2_api.find_text({text = i.name_utf8,UI_info = env.UI_info,min_x=200,click=2})
                            end
                            api_Sleep(200)
                            env.need_item = nil
                            poe2_api.time_p("检查是否拾取（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end
                end  
                api_ClickMove(poe2_api.toInt(player_info.grid_x),poe2_api.toInt(player_info.grid_y),7)
                api_Sleep(300) 
                -- 先设置随机种子（只需执行一次）
                math.randomseed(os.time())
                -- 生成 [0, 25) 范围内的随机浮点数
                local x = 0 + (5 - 0) * math.random()
                -- 生成 [0, 25) 范围内的随机浮点数
                local y = 0 + (5 - 0) * math.random()
                api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),0)
                api_Sleep(50)
                api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),1)
                self.wait = true
                self.current_time = api_GetTickCount64()
                self.wait_time = 2000
                poe2_api.dbgp("等待回城")
                poe2_api.time_p("检查是否拾取（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if (not env.range_items or not next(env.range_items)) and not env.need_item then
                poe2_api.dbgp("无物品可捡1")
                poe2_api.time_p("无物品可捡1(SUCCESS1)... 耗时 -->", api_GetTickCount64() - current_time )
                return bret.SUCCESS
            end
            local processed_configs = poe2_api.get_items_config_info(config)
            if not need_item then
                if not get_item(env.range_items,processed_configs) then
                    poe2_api.dbgp("无物品可捡2")
                    poe2_api.time_p("检查是否拾取（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
                self.path_time = api_GetTickCount64()
            end
            poe2_api.dbgp("1")
            
            local is_target = is_monster(env.range_info, player_info,50)
            if is_target then
                poe2_api.dbgp("附近有怪，不捡")
                poe2_api.time_p("检查是否拾取（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            
            
            poe2_api.dbgp("2")
            -- 找黑雾祭坛
            local function get_altar(range_info)
                if not range_info or not next(range_info) then
                    return false
                end
                for _, i in ipairs(range_info) do
                    if i.path_name_utf8 and i.path_name_utf8 ~= "" and string.find(game_str.Ritual_PATH,i.path_name_utf8) then
                        -- local stateMachineList = i:GetStateMachineList()
                        if i.stateMachineList and next(i.stateMachineList) then
                            local current_state = (i.stateMachineList or {}).current_state or 5
                            local interaction_enabled = (i.stateMachineList or {}).interaction_enabled or 5
                            if current_state == 2 and interaction_enabled == 0 then
                                return i
                            end
                        end
                        
                    end
                end
                return false
            end
            need_item = env.need_item
            local is_altar = get_altar(env.range_info)
            if is_altar then
                local dis1 = poe2_api.point_distance(is_altar.grid_x, is_altar.grid_y, player_info)
                if dis1 and dis1 < 100 then
                    local dis2 = poe2_api.point_distance(need_item.grid_x, need_item.grid_y, is_altar)
                    if dis2 and dis2 > 97 then
                        poe2_api.dbgp("黑雾祭坛附近，不捡")
                        poe2_api.time_p("检查是否拾取（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.SUCCESS
                    end
                end
            end
            poe2_api.dbgp("3")
            if player_info.current_map_name_utf8 == game_str.MapUniqueWildwood then
                poe2_api.dbgp("翠绿荒林时间：",self.path_time)
                if self.path_time ~= 0 and api_GetTickCount64() - self.path_time > 10000 then
                    local function is_point(grid_x,grid_y)
                        -- local point = api_FindNearestReachableInRange(math.floor(grid_x),math.floor(grid_y),15,0)
                        local ralet = api_FindPath(player_info.grid_x,player_info.grid_y,math.floor(grid_x),math.floor(grid_y))
                        return ralet
                    end
                    if distance and distance > 15 then
                        local ralet = is_point(need_item.grid_x,need_item.grid_y)
                        if not ralet or not next(ralet) then
                            poe2_api.dbgp("翠绿荒林，拾取无路径跳出")
                            return bret.SUCCESS
                        end
                        poe2_api.dbgp("翠绿荒林，拾取有路径")
                    elseif not distance then
                        poe2_api.dbgp("翠绿荒林，拾取无路径跳出11")
                        return bret.SUCCESS
                    end
                    self.path_time = api_GetTickCount64()
                end
                if self.path_time == 0 then
                    self.path_time = api_GetTickCount64()
                end
            end
            -- 判断特殊交互对象
            local function get_interactive(range_info)
                if not range_info or not next(range_info) then
                    return false
                end
                for _, v in ipairs(range_info) do
                    if v.name_utf8 ~= "" and poe2_api.table_contains(v.name_utf8,{game_str.Switch_CH,game_str.Door_CH,game_str.Handle_CH}) and v.isActive and v.is_selectable
                     and v.grid_x ~= 0 and v.grid_y ~= 0 then
                        if poe2_api.table_contains(v.name_utf8,{game_str.Switch_CH,game_str.Handle_CH}) then
                            local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                            if dis and dis <= 70 then
                                return v
                            end
                        end
                        if v.name_utf8 == game_str.Door_CH then
                            local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                            if dis and dis <= 25 then
                                return v
                            end
                        end
                        
                    end
                end
                return false
            end
            local is_interactive = get_interactive(env.range_info)
            if is_interactive then
                poe2_api.dbgp("特殊交互对象，不捡:  "..is_interactive.name_utf8)
                poe2_api.time_p("检查是否拾取（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            poe2_api.dbgp("4")
            env.interactive = need_item
            local distance = poe2_api.point_distance(need_item.grid_x, need_item.grid_y,player_info)
            poe2_api.dbgp("距离: "..distance)

            if distance then
                if distance < 25 then
                    local is_item = nil
                    poe2_api.dbgp("need_item.id: "..need_item.id)
                    for _, i in ipairs(env.range_items) do 
                        poe2_api.dbgp("i.id: "..i.id)
                        if i.id == need_item.id then 
                            is_item = i
                            break
                        end 
                    end
                    if not is_item then
                        env.need_item = nil
                        poe2_api.dbgp("物品已捡起1")
                        poe2_api.time_p("检查是否拾取（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    poe2_api.dbgp("111================")
                    local size = my_game_info.item_size[need_item.category_utf8]
                    poe2_api.dbgp("size:"..size[1],size[2])
                    local point = poe2_api.get_space_point({width=size[1],height=size[2],info=bag_info})
                    if not point and not player_info.isInBossBattle then
                        poe2_api.dbgp("背包空间不足，回城")
                        if poe2_api.find_text({text = game_str.Are_you_sure_you_want_to_leave_CH,UI_info = env.UI_info,min_x=0}) then
                            poe2_api.find_text({text = game_str.Yes_CH,UI_info = env.UI_info,min_x=0,click=2})
                            api_Sleep(500)
                            env.bag_man = true
                            return bret.RUNNING
                        end
                        for _, i in ipairs(env.range_info) do
                            if i.name_utf8 ~= "" and i.type == 5 and ((not string.find(player_info.current_map_name_utf8,game_str.Abyss) and poe2_api.table_contains(i.name_utf8,my_game_info.hideout_CH)) or string.find(player_info.current_map_name_utf8,game_str.Abyss)) then
                                poe2_api.printTable(i)
                                local dis = poe2_api.point_distance(i.grid_x, i.grid_y, player_info)
                                if dis and dis < 25 then
                                    if not string.find(player_info.current_map_name_utf8,game_str.Abyss) then
                                        poe2_api.find_text({text = i.name_utf8,UI_info = env.UI_info,min_x=200,min_y=200,click=2})
                                    else
                                        poe2_api.find_text({text = i.name_utf8,UI_info = env.UI_info,min_x=200,click=2})
                                        env.bag_man = true
                                    end
                                    api_Sleep(200)
                                    env.need_item = nil
                                    poe2_api.time_p("检查是否拾取（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                                    return bret.RUNNING
                                end
                            end
                        end  
                        api_ClickMove(poe2_api.toInt(player_info.grid_x),poe2_api.toInt(player_info.grid_y),7)
                        api_Sleep(300) 
                        -- 先设置随机种子（只需执行一次）
                        math.randomseed(os.time())
                        -- 生成 [0, 25) 范围内的随机浮点数
                        local x = 0 + (5 - 0) * math.random()
                        -- 生成 [0, 25) 范围内的随机浮点数
                        local y = 0 + (5 - 0) * math.random()
                        api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),0)
                        api_Sleep(50)
                        api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),1)
                        self.wait = true
                        self.current_time = api_GetTickCount64()
                        self.wait_time = 2000
                        poe2_api.dbgp("等待回城")
                        poe2_api.time_p("检查是否拾取（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    local bool = false
                    for _, i in ipairs(env.range_info) do
                        if i.name_utf8 ~= "" and i.type == 5 and poe2_api.table_contains(i.name_utf8,my_game_info.hideout_CH) then
                            local dis = poe2_api.point_distance(i.grid_x, i.grid_y, need_item)
                            if dis and dis < 25 then
                                bool = true
                                break
                            end
                        end
                    end
                    poe2_api.dbgp("是否在隐藏点: "..tostring(bool))
                    if bool then
                        for _, v in ipairs(env.range_info) do
                            if v.name_utf8 ~= "" and v.type == 5 and poe2_api.table_contains(v.name_utf8,my_game_info.hideout_CH) then
                                local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                                if dis and dis < 25 then
                                    local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                                    if point then
                                        api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),0)
                                        -- api_Sleep(200)
                                        poe2_api.dbgp1("fdgherhtfbfdbsrghdghjm")
                                        poe2_api.click_keyboard("space")
                                        api_Sleep(200)
                                        poe2_api.time_p("检查是否拾取（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                                        return bret.RUNNING
                                    end
                                end
                            end
                        end
                        local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),7)
                            api_Sleep(300)
                            -- 先设置随机种子（只需执行一次）
                            math.randomseed(os.time())
                            -- 生成 [0, 25) 范围内的随机浮点数
                            local x = 0 + (5 - 0) * math.random()
                            -- 生成 [0, 25) 范围内的随机浮点数
                            local y = 0 + (5 - 0) * math.random()
                            api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),0)
                            api_Sleep(50)
                            api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),1)
                            self.wait = true
                            self.current_time = api_GetTickCount64()
                            self.wait_time = 2000
                            -- -- api_Sleep(200)
                            -- poe2_api.click_keyboard("space")
                            poe2_api.time_p("检查是否拾取（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end   
                    -- if not player_info.isMoving then
                    --     if not self.id1 then
                    --         self.id1 = env.need_item.id
                    --     end
                    --     if self.id1 == env.need_item.id then
                    --         self.number = self.number + 1
                    --     else
                    --         self.number = 1
                    --         self.id1 = env.need_item.id
                    --         -- poe2_api.dbgp("物品已捡起,更新状态")
                    --         -- api_Sleep(1000)
                    --     end
                    --     if self.number % 10 == 0 then
                    --         local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                    --         if point then
                    --             api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),7)
                    --         end
                    --     end
                    --     poe2_api.dbgp("number: "..self.number)
                    --     if self.number >= 50 then
                    --         table.insert(env.pick_up_timeout,env.need_item.id)
                    --         env.need_item = nil
                    --         self.number = 0
                    --         poe2_api.time_p("检查是否拾取（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                    --         return bret.RUNNING
                    --     end
                    -- end
                    poe2_api.dbgp("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")   
                elseif distance < 50 then
                    local is_item = nil
                    for _, i in ipairs(env.range_items) do 
                        if i.id == need_item.id then 
                            is_item = i
                            break
                        end 
                    end
                    if not is_item then
                        env.need_item = nil
                        poe2_api.dbgp("物品已捡起2")
                        poe2_api.time_p("检查是否拾取（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    local bool = false
                    for _, i in ipairs(env.range_info) do
                        if i.name_utf8 ~= "" and i.type == 5 and poe2_api.table_contains(i.name_utf8,my_game_info.hideout_CH) then
                            local dis = poe2_api.point_distance(i.grid_x, i.grid_y, need_item)
                            if dis and dis < 25 then
                                bool = true
                                break
                            end
                        end
                    end
                    if bool then
                        for _, v in ipairs(env.range_info) do
                            if v.name_utf8 ~= "" and v.type == 5 and poe2_api.table_contains(v.name_utf8,my_game_info.hideout_CH) then
                                local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                                if dis and dis < 30 then
                                    local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                                    if point then
                                        api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),0)
                                        -- api_Sleep(200)
                                        poe2_api.dbgp1("fdsvsdvsdvdsfdrsfv")
                                        poe2_api.click_keyboard("space")
                                        poe2_api.time_p("检查是否拾取（RUNNING8）... 耗时 --> ", api_GetTickCount64() - start_time)
                                        return bret.RUNNING
                                    end
                                end
                            end
                        end
                        local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                        
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),7)
                            api_Sleep(300)
                            -- 先设置随机种子（只需执行一次）
                            math.randomseed(os.time())
                            -- 生成 [0, 25) 范围内的随机浮点数
                            local x = 0 + (5 - 0) * math.random()
                            -- 生成 [0, 25) 范围内的随机浮点数
                            local y = 0 + (5 - 0) * math.random()
                            api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),0)
                            api_Sleep(50)
                            api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),1)
                            self.wait = true
                            self.current_time = api_GetTickCount64()
                            self.wait_time = 2000                            -- -- api_Sleep(200)
                            -- poe2_api.click_keyboard("space")
                            poe2_api.time_p("检查是否拾取（RUNNING9）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end
                       
                end
                
            end
            if poe2_api.find_text({text = game_str.backpack ,UI_info = env.UI_info,min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                poe2_api.click_keyboard("i")
                poe2_api.dbgp("关背包7")
                api_Sleep(200)
                poe2_api.time_p("检查是否拾取（RUNNING10）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            poe2_api.dbgp("背包已關閉*********************************************************")
            poe2_api.time_p("检查是否拾取（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end
    },

    -- 祭祀购买
    Shop_Sacrifice_Items = {
        run = function(self, env)
            poe2_api.print_log("祭祀購買...")
            local current_time = api_GetTickCount64()
            -- if not self.init then
            --     self.init = true
            --     self.deferred_items = {}
            -- end
            local player_info = env.player_info
            local user_config = env.user_config
            -- if not env.not_more_ritual then
            --     if poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN  }) then
            --         -- local Attachments = api_Getinventorys(0xd,0)
            --         -- if Attachments and #Attachments > 0 then
            --         --     poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0 , add_x = 272, click = 2})
            --         --     return bret.RUNNING
            --         -- end
            --         poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0 , add_x = 272, click = 2})
            --         return bret.RUNNING
            --     end
            --     return bret.SUCCESS
            -- end
            local _get_valid_items = function(all_items, tribute,maxCount,finishedCount)
                -- self.deferred_items = {}
                if not all_items or #all_items == 0 then
                    return {}, {}, 0, {}, {}, {}
                end
            
                local ritual_config = user_config['刷圖設置']['祭祀購買']
                local inside_items = my_game_info.ritual_inside_item

                if not ritual_config then
                    return {}, {}, 0, {}, {}, {}
                end

                -- 以 inside_items 的顺序为准，合并 ritual_config 中剩下的物品
                local merged_order = {}
                local added_items = {}
                -- if env.is_sacrifice_shopping then
                    -- 首先添加 inside_items 中的所有项
                    -- for _, item in ipairs(inside_items) do
                    --     table.insert(merged_order, item)
                    --     added_items[item] = true
                    -- end
                -- end
                if not ritual_config or not next(ritual_config) then
                    -- poe2_api.dbgp("未配置相关祭祀购买物品，按内置物品购买")
                    for _, item in ipairs(inside_items) do
                        table.insert(merged_order, item)
                        added_items[item] = true
                    end
                else
                    -- poe2_api.dbgp("按用户配置")
                    for _, item in ipairs(ritual_config) do
                        table.insert(merged_order, item)
                        added_items[item] = true
                    end
                end
                -- while true do
                --     api_Sleep(1000)
                -- end
                
                -- 然后添加 ritual_config 中有但 inside_items 中没有的项
                -- for _, item in ipairs(ritual_config) do
                --     if not added_items[item] then
                --         table.insert(merged_order, item)
                --         added_items[item] = true
                --     end
                -- end

                -- 创建优先级字典，确保顺序与 merged_order 一致
                local priority_dict = {}
                for idx, item in ipairs(merged_order) do
                    priority_dict[item] = idx
                end

                -- 初始化物品分组
                local item_groups = {}
                for _, item_name in ipairs(merged_order) do
                    item_groups[item_name] = {}
                end

                -- -- 创建优先级字典，确保顺序与 ritual_config 一致
                -- local priority_dict = {}
                -- for idx, item in ipairs(ritual_config) do
                --     priority_dict[item] = idx
                -- end
            
                -- -- 初始化物品分组
                -- local item_groups = {}
                -- for _, item_name in ipairs(ritual_config) do
                --     item_groups[item_name] = {}
                -- end
            
                -- 分类物品：同时匹配 baseType_utf8 和 name_utf8
                local not_appeared_items = {}
                for _, item in ipairs(all_items) do
                    local matched = false
                    
                    -- 检查 baseType_utf8
                    if item.baseType_utf8 and item_groups[item.baseType_utf8] then
                        table.insert(item_groups[item.baseType_utf8], item)
                        matched = true
                    end
                    
                    -- 检查 name_utf8（如果 baseType_utf8 没有匹配）
                    if item.name_utf8 and item_groups[item.name_utf8] then
                        table.insert(item_groups[item.name_utf8], item)
                        matched = true
                    end
                    
                    -- 如果都没有匹配，且是隐藏道具
                    if not matched and item.baseType_utf8 == game_str.Hide_props_CH then
                        table.insert(not_appeared_items, item)
                    end
                end
            
                -- 按优先级排序物品
                local all_config_items_shopping = {}
                local all_config_items_cache = {}
                local all_config_items_with_caching= {}
                local all_config_items_no_price = {}
            
                -- 遍历 ritual_config merged_order 的顺序
                for _, item_name in ipairs(merged_order) do
                    if item_groups[item_name] and #item_groups[item_name] > 0 then
                        -- 按价格排序（优先选择价格低的）
                        table.sort(item_groups[item_name], function(a, b)
                            local a_cost = a.totalDeferredConsumption or math.huge
                            local b_cost = b.totalDeferredConsumption or math.huge
                            if a_cost == b_cost then
                                -- 价格相同，则按 tribute（贡品值）排序
                                return (b.tribute or math.huge) < (a.tribute or math.huge)
                            else
                                return a_cost < b_cost
                            end
                        end)
            
                        -- 添加到 all_config_items
                        for _, item in ipairs(item_groups[item_name]) do
                            --  local condition2 = (item.totalDeferredConsumption >= item.tribute or math.abs(item.totalDeferredConsumption - item.tribute) <= 50) and item.tribute <= tribute
                            if (item.totalDeferredConsumption >= item.tribute or math.abs(item.totalDeferredConsumption - item.tribute) <= 50) and item.tribute <= tribute then
                                table.insert(all_config_items_shopping, item)
                                -- break
                            -- end
                            -- local condition1 = not item.totalDeferredConsumption or item.totalDeferredConsumption <= tribute
                            elseif not item.totalDeferredConsumption or item.totalDeferredConsumption <= tribute then
                                -- table.insert(all_config_items_shopping, item)
                                table.insert(all_config_items_cache, item)
                            --     break
                            -- end
                            -- poe2_api.dbgp(item.tribute)
                            -- poe2_api.dbgp(tribute)
                            -- poe2_api.dbgp(maxRefreshCount)
                            -- poe2_api.dbgp(currentRefreshCount)
                            elseif not item.tribute or (60000 > item.tribute and item.tribute > tribute and maxCount ~= finishedCount) then
                                table.insert(all_config_items_no_price, item)
                            end
                            -- if condition1 or condition2 then
                            --     table.insert(all_config_items, item)
                            -- end
                        end
            
                        -- 添加到 all_config_items_no_price
                        -- for _, item in ipairs(item_groups[item_name]) do
                        --     if not item.tribute or (60000 > item.tribute and item.tribute > tribute and maxRefreshCount ~= currentRefreshCount) then
                        --         table.insert(all_config_items_no_price, item)
                        --     end
                        -- end
                    end
                end
            
                -- 打印所有存在的配置物品（按 ritual_config 顺序）
                local mapped_items = {}
                for _, item_name in ipairs(ritual_config) do
                    if item_groups[item_name] and #item_groups[item_name] > 0 then
                        table.insert(mapped_items, item_name)
                    end
                end
                poe2_api.dbgp("所有存在的配置物品: ",table.concat(mapped_items, ", "))
                -- 可以最低价购买的物品  需缓存的物品   ？    隐藏物品
                return all_config_items_shopping , all_config_items_cache, all_config_items_no_price, not_appeared_items
            end

            if poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout) then
                poe2_api.time_p("祭祀購買(SUCCESS)(不在异界)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
            -- poe2_api.printTable(env.team_info)
            -- if env.team_info then
            --     local nomarl_monster = poe2_api.is_have_mos({range_info = env.range_info, dis = env.min_attack_dis, player_info = env.player_info, stuck_monsters = env.stuck_monsters, not_sight = true})
            --     poe2_api.dbgp(nomarl_monster, env.min_attack_dis)
            --     if nomarl_monster then
            --         -- api_Sleep(10000)
            --         poe2_api.time_p("祭祀購買(SUCCESS)(组队且有怪)... 耗时 --> ", api_GetTickCount64() - current_time)
            --         return bret.SUCCESS
            --     end
            -- end
            local nomarl_monster = poe2_api.is_have_mos({range_info = env.range_info, dis = env.min_attack_dis, player_info = env.player_info, stuck_monsters = env.stuck_monsters, not_sight = true})
            poe2_api.dbgp(nomarl_monster, env.min_attack_dis)
            if nomarl_monster then
                -- api_Sleep(10000)
                poe2_api.time_p("祭祀購買(SUCCESS)(组队且有怪)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
            -- api_Sleep(10000)
            if env.afoot_altar and env.afoot_altar.stateMachineList[game_str.current_state_SML] == 2 and env.afoot_altar.stateMachineList[game_str.interaction_enabled_SML] == 0 then
                poe2_api.time_p("祭祀購買正在打祭祀(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
            --  找不到祭祀组件或者不需要祭祀购买，关闭文本
            if not poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.ritual_open_shop_button_CT  }) or env.not_items_buy then
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN  }) then
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0 , add_x = 272, click = 2})
                    return bret.RUNNING
                end
                poe2_api.time_p("祭祀購買(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
            
            local SacrificeItems = api_GetSacrificeItems()
            -- poe2_api.dbgp("祭坛总数:", SacrificeItems.maxCount, " 已完成数量:", SacrificeItems.finishedCount, " 当前贡礼:", SacrificeItems.leftGifts)
            -- poe2_api.dbgp("祭坛可刷新总数:", SacrificeItems.MaxRefreshCount, " 祭坛已刷新数:", SacrificeItems.CurrentRefreshCount)
            -- poe2_api.printTable(SacrificeItems.items)
            -- for k, v in pairs(SacrificeItems.items) do
            --     poe2_api.dbgp("物品:", v.baseType_utf8, "价格:", v.totalDeferredConsumption, "贡品值:", v.tribute)
            -- end

            --  第一次无数据，点击组件
            if not (0 < SacrificeItems.maxCount and SacrificeItems.maxCount < 10) or not (0 < SacrificeItems.finishedCount and SacrificeItems.finishedCount < 10) or #SacrificeItems.items == 0 then
                if poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.ritual_open_shop_button_CT  ,click = 1 }) then
                    api_Sleep(500)
                    return bret.RUNNING
                end
                return bret.SUCCESS
            end
            local Attachments = api_Getinventorys(0xd,0)
            if Attachments and #Attachments > 0 then
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN  }) then
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0 , add_x = 272, click = 2})
                    return bret.RUNNING
                    -- poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0 , add_x = 272, click = 2})
                    -- return bret.RUNNING
                end
                return bret.SUCCESS
            end
            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN  }) then
                local Attachments = api_Getinventorys(0xd,0)
                if Attachments and #Attachments > 0 then
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0 , add_x = 272, click = 2})
                    return bret.RUNNING
                end
                -- poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0 , add_x = 272, click = 2})
                -- return bret.RUNNING
            end
            -- 可购买          缓存物品      已缓存数        隐藏道具   
            local all_config_items_shopping , all_config_items_cache, all_items_no_price, not_appeared_items = _get_valid_items(SacrificeItems.items, SacrificeItems.leftGifts,SacrificeItems.maxCount, SacrificeItems.finishedCount)
            poe2_api.dbgp(#all_config_items_shopping)
            poe2_api.dbgp(#all_config_items_cache)
            poe2_api.dbgp(#all_items_no_price)
            -- poe2_api.printTable(all_items_no_price)
            poe2_api.dbgp(#not_appeared_items)
            if not next(all_config_items_shopping) and not next(all_config_items_cache) and not next(all_items_no_price) and not next(not_appeared_items) and ((SacrificeItems.MaxRefreshCount == SacrificeItems.CurrentRefreshCount) or (SacrificeItems.MaxRefreshCount ~= SacrificeItems.CurrentRefreshCount and SacrificeItems.leftGifts < SacrificeItems.refreshCost and SacrificeItems.maxCount == SacrificeItems.finishedCount)) then
                poe2_api.dbgp("qqqqqqqqqqqqqqqqqqqqqqqqqq")
                env.buy_items =  false
                env.have_ritual = false
                env.not_more_ritual = false
                env.not_items_buy = true
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN  }) then
                    -- local Attachments = api_Getinventorys(0xd,0)
                    -- if Attachments and #Attachments > 0 then
                    --     poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0 , add_x = 272, click = 2})
                    --     return bret.RUNNING
                    -- end
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0 , add_x = 272, click = 2})
                    return bret.RUNNING
                end
                return bret.SUCCESS

            end
            poe2_api.dbgp("wwwwwwwwwwwwwwwwwwwwwwwwwwwwwww")
            -- poe2_api.dbgp("所有可购买和缓存物品")
            -- poe2_api.printTable(all_items)
            -- poe2_api.dbgp("已缓存数")
            -- poe2_api.printTable(all_items_no_price)
            -- poe2_api.dbgp("隐藏道具")
            -- poe2_api.printTable(not_appeared_items)
            env.buy_items = true
            env.have_ritual = true
            env.not_more_ritual = true
            local life = player_info.remainingPortalCount
            poe2_api.dbgp("剩余重生机会:", life, "次")
            if life >= 2 then
                if not next(not_appeared_items) then
                    if next(all_config_items_shopping) then
                        if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0}) then
                            -- env.buy_items = true
                            poe2_api.click_text_UI({UI_info = env.UI_info, text =game_str.ritual_open_shop_button_CT, click = 1})
                            api_Sleep(1000)
                            return bret.RUNNING
                        end
                        if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.Temporary_prop_CN}) then
                            poe2_api.find_text({UI_info = env.UI_info, text =game_str.Cancel_TWCH, click = 2})
                            api_Sleep(1000)
                            return bret.RUNNING
                        end
                        env.buy_items = true
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN  ,click = 7 , min_x = 0})
                        api_Sleep(100)
                        for _, item in ipairs(all_config_items_shopping) do
                            poe2_api.dbgp("正在购买 ",item.baseType_utf8 or item.name_utf8)
                            poe2_api.dbgp("item.totalDeferredConsumption --> ", item.totalDeferredConsumption)
                            poe2_api.dbgp("item.tribute --> ", item.tribute)
                            if poe2_api.ctrl_left_click_altar_items(item.obj, all_config_items_shopping) then
                                api_Sleep(500)
                                return bret.RUNNING
                            end
                        end
                    end
                    if next(all_config_items_cache) then
                        env.buy_items = true
                        if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0}) then
                            -- env.buy_items = true
                            poe2_api.click_text_UI({UI_info = env.UI_info, text =game_str.ritual_open_shop_button_CT, click = 1})
                            api_Sleep(1000)
                            return bret.RUNNING
                        end
                        if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Temporary_prop_CN}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = game_str.Temporary_prop_CN, click = 2})
                            api_Sleep(1000)
                            return bret.RUNNING
                        end
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN  ,click = 7 , min_x = 0})
                        api_Sleep(100)
                        for _, item in ipairs(all_config_items_cache) do
                            poe2_api.dbgp("暫緩 ",item.baseType_utf8 or item.name_utf8, "贡礼: ", item.tribute)
                            poe2_api.dbgp("item.totalDeferredConsumption --> ", item.totalDeferredConsumption)
                            poe2_api.dbgp("item.tribute --> ", item.tribute)
                            if poe2_api.ctrl_left_click_altar_items(item.obj, all_config_items_cache,2) then
                                api_Sleep(500)
                                poe2_api.find_text({UI_info = env.UI_info, text = game_str.Confirm_TWCH, click = 1, refresh = true})
                                api_Sleep(100)
                                poe2_api.find_text({UI_info = env.UI_info, text = game_str.Confirm_TWCH, click = 2, refresh = true})
                                api_Sleep(500)
                                return bret.RUNNING
                            end
                        end
                    end
                    if SacrificeItems.MaxRefreshCount > SacrificeItems.CurrentRefreshCount and SacrificeItems.leftGifts > SacrificeItems.refreshCost then
                        env.buy_items = true
                        if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0}) then
                            -- env.buy_items = true
                            poe2_api.click_text_UI({UI_info = env.UI_info, text =game_str.ritual_open_shop_button_CT, click = 1})
                            api_Sleep(2000)
                            return bret.RUNNING
                        end
                        poe2_api.dbgp("第",SacrificeItems.CurrentRefreshCount,"次刷新贡礼")
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , click = 2 ,min_x = 0 , add_x = 203, add_y = 53})
                        api_Sleep(2000)
                        return bret.RUNNING
                    end
                -- else
                --     if poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN }) then
                --         -- local Attachments = api_Getinventorys(0xd,0)
                --         -- if Attachments and #Attachments > 0 then
                --         --     poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0 , add_x = 272, click = 2})
                --         --     return bret.RUNNING
                --         -- end
                --         poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0 , add_x = 272, click = 2})
                --         return bret.RUNNING
                --     end
                --     return bret.SUCCESS
                end
            else
                if next(all_config_items_shopping) then
                    env.buy_items = true
                    if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0}) then
                        -- env.buy_items = true
                        poe2_api.click_text_UI({UI_info = env.UI_info, text =game_str.ritual_open_shop_button_CT, click = 1})
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.Temporary_prop_CN}) then
                        poe2_api.find_text({UI_info = env.UI_info, text =game_str.Cancel_TWCH, click = 2})
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN  ,click = 7 , min_x = 0})
                    api_Sleep(100)
                    for _, item in ipairs(all_config_items_shopping) do
                        poe2_api.dbgp("正在购买 ",item.baseType_utf8 or item.name_utf8)
                        poe2_api.dbgp("item.totalDeferredConsumption --> ", item.totalDeferredConsumption)
                        poe2_api.dbgp("item.tribute --> ", item.tribute)
                        if poe2_api.ctrl_left_click_altar_items(item.obj, all_config_items_shopping) then
                            api_Sleep(500)
                            return bret.RUNNING
                        end
                    end
                end
                if next(all_config_items_cache) then
                    env.buy_items = true
                    if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0}) then
                        -- env.buy_items = true
                        poe2_api.click_text_UI({UI_info = env.UI_info, text =game_str.ritual_open_shop_button_CT, click = 1})
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Temporary_prop_CN}) then
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Temporary_prop_CN, click = 2})
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN  ,click = 7 , min_x = 0})
                    api_Sleep(100)
                    for _, item in ipairs(all_config_items_cache) do
                        poe2_api.dbgp("暫緩 ",item.baseType_utf8 or item.name_utf8, "贡礼: ", item.tribute)
                        poe2_api.dbgp("item.totalDeferredConsumption --> ", item.totalDeferredConsumption)
                        poe2_api.dbgp("item.tribute --> ", item.tribute)
                        if poe2_api.ctrl_left_click_altar_items(item.obj, all_config_items_cache,2) then
                            api_Sleep(500)
                            -- return bret.RUNNING
                            poe2_api.find_text({UI_info = env.UI_info, text = game_str.Confirm_TWCH, click = 1, refresh = true})
                            api_Sleep(100)
                            poe2_api.find_text({UI_info = env.UI_info, text = game_str.Confirm_TWCH, click = 2, refresh = true})
                            api_Sleep(500)
                            return bret.RUNNING
                        end

                    end
                end
                if SacrificeItems.MaxRefreshCount > SacrificeItems.CurrentRefreshCount and SacrificeItems.leftGifts > SacrificeItems.refreshCost then
                    env.buy_items = true
                    if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0}) then
                        -- env.buy_items = true
                        poe2_api.click_text_UI({UI_info = env.UI_info, text =game_str.ritual_open_shop_button_CT, click = 1})
                        api_Sleep(2000)
                        return bret.RUNNING
                    end
                    poe2_api.dbgp("第",SacrificeItems.CurrentRefreshCount,"次刷新贡礼")
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , click = 2 ,min_x = 0 , add_x = 203, add_y = 53})
                    api_Sleep(2000)
                    return bret.RUNNING
                end
            end
            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN}) then
                -- local Attachments = api_Getinventorys(0xd,0)
                -- if Attachments and #Attachments > 0 then
                --     poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0 , add_x = 272, click = 2})
                --     return bret.RUNNING
                -- end
                poe2_api.find_text({UI_info = env.UI_info, text = game_str.the_gift_CN , min_x = 0 , add_x = 272, click = 2})
                return bret.RUNNING
            end
            env.buy_items =  false
            -- env.have_ritual = true
            -- env.not_more_ritual = false
            -- env.not_items_buy = true
            return bret.SUCCESS
            
        end
    },

    -- 躲避技能
    DodgeAction_Inside = {
        name = "躲避",
        run = function(self, env)
            poe2_api.dbgp("DodgeAction_Inside")
            -- local is_initialized  = false
            if not env.is_initialized then
                poe2_api.dbgp("DodgeAction_Inside 初始化")
                self.last_space_time = 0.0 -- 上次按下空格的时间
                self.last_space_time_keep = 0.0 -- 上次按下空格的时间
                self.space_cooldown = 1500  -- 空格键冷却时间（秒）
                self.last_space_time1 = 0.0
                env.is_initialized = true
            end

            local is_bird = false
            for _,k in ipairs(env.player_info.buffs) do
                -- poe2_api.printTable(k)
                -- poe2_api.dbgp("k.name_en", k.name_en)
                if k.name_en == game_str.on_rhoa_mount_SKBUF then
                    is_bird = true
                    break
                end
            end

            if string.find(env.player_info.current_map_name_utf8 , game_str.Delirium_) then
                api_UpdateMapObstacles(240)
            end

            local _handle_space_action_path_name = function(player_info)
                local ret = nil
                local start_time = api_GetTickCount64()
                local danger = api_IsPointInAnyActive(player_info.grid_x , player_info.grid_y , 100)
                poe2_api.dbgp("耗时 === 》》》",api_GetTickCount64() - start_time)
                poe2_api.printTable(danger)
                if danger and danger.inside then
                    local safe_point = danger.safeTile
                    -- local safe_point = api_FindNearestSafeTile(player_info.grid_x , player_info.grid_y , 60 , 5)

                    if safe_point and safe_point.x ~= -1 and safe_point.y ~= -1 then
                        if not api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y), 7) or not api_HasObstacleBetween(safe_point.x, safe_point.y) then
                            poe2_api.dbgp("安全点过远或有障碍物")
                            env.end_point = {safe_point.x, safe_point.y}
                            return bret.FAIL
                        end
                        api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y), 7)
                        api_Sleep(200)
                        env.end_point = nil
                        env.path_list = nil
                        if not is_bird and danger.action == 2 then
                        -- if not is_bird then
                            poe2_api.dbgp("===========")
                            poe2_api.click_keyboard("space")
                        end
                        return true
                    end
                end
                return false
            end

            local is_space_open = env.space_config["是否開啟"] or false
            local space_check_dis = env.space_config["躲避距离"]
            local space_time = env.space_config["閾值"]
            local mons_num = env.space_config["触发躲避怪物数"]
            local is_space = env.space_config["是否翻滚"]

            -- 躲避技能
            _handle_space_action_path_name(env.player_info)
            
            -- local safe_point = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, env.space_config["躲避距离"], env.min_attack_dis, 2, 0.5)
            local safe_point = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 100, env.space_config["躲避距离"], 2, 0.5)
            local do_space_action = false
            local _handle_space_action = function(monster, space_flag, space_monsters, space_time, player_info)
                poe2_api.dbgp("space_time",space_time)
                if space_flag and poe2_api.table_contains(space_monsters,monster.rarity) and api_GetTickCount64() - self.last_space_time >= space_time then
                    local result = nil
                    result = api_GetNextCirclePosition(monster.grid_x, monster.grid_y, player_info.grid_x, player_info.grid_y, 50,20,0)

                    -- api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 0)
                    -- api_Sleep(200)
                    
                    if not is_bird then
                        poe2_api.dbgp("monster.rarity -->", monster.rarity)
                        poe2_api.dbgp("self.last_space_time -->", self.last_space_time)
                        poe2_api.dbgp("space_time -->", space_time)
                        poe2_api.dbgp("api_GetTickCount64() - self.last_space_time -->", (api_GetTickCount64() - self.last_space_time))
                        poe2_api.dbgp("_handle_space_action")
                        if poe2_api.table_contains(space_monsters,monster.rarity) and api_GetTickCount64() - self.last_space_time >= space_time then
                            api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), 7)
                            api_Sleep(200)
                            poe2_api.click_keyboard("space")
                        end
                        do_space_action = true
                    else
                        if not api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), 7) or api_HasObstacleBetween(result.x, result.y) then
                            poe2_api.dbgp("安全点过远或有障碍物")
                            env.end_point = {safe_point.x, safe_point.y}
                            do_space_action = true
                            self.last_space_time = api_GetTickCount64() + (math.random(-5, 5)* 0.01)
                            return bret.FAIL
                        end
                    end
                    self.last_space_time = api_GetTickCount64() + (math.random(-5, 5)* 0.01)
                    return false
                end
                return true
            end    

            local function keep_distancen(min_attack_range)
                if min_attack_range < 60 then
                    return false
                end
                local safe_point1 = api_GetSafeAreaLocationNoMonsters(40)
                local range_info1 = poe2_api.get_sorted_list(env.range_info, player_info)
                if api_GetTickCount64() - (self.last_space_time_keep or 0) >= 100 then
                    -- 怪物检查主逻辑
                    for _, monster in ipairs(range_info1) do
                        -- 快速跳过不符合基本条件的怪物
                        if monster.type ~= 1 or                  -- 类型检查
                        not monster.is_selectable or          -- 可选性检查
                        monster.is_friendly or                -- 友方检查
                        monster.life <= 0 or                  -- 生命值检查
                        monster.name_utf8 == "" or              -- 名称检查
                        poe2_api.table_contains(my_game_info.not_attact_mons_CN_name,monster.name_utf8) or
                        poe2_api.table_contains(my_game_info.not_attact_mons_path_name,monster.path_name_utf8)then  -- 路径名检查
                            goto continue_prop
                        end

                        if not monster.isActive then
                            goto continue_prop
                        end

                        -- 检查坐标有效性
                        if not monster.grid_x or not monster.grid_y then
                            goto continue_prop
                        end

                        -- 检查卡住状态
                        if env.stuck_monsters and next(env.stuck_monsters) and poe2_api.table_contains(env.stuck_monsters,monster.id) then
                            goto continue_prop
                        end

                        for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                            if poe2_api.table_contains(monster.magicProperties, prop) then
                                poe2_api.dbgp("特殊词缀怪物,不闪避")
                                return false
                            end
                        end

                        -- poe2_api.printTable(monster.magicProperties)

                        -- 计算距离
                        local distance = poe2_api.point_distance(monster.grid_x, monster.grid_y, env.player_info)
                        -- poe2_api.dbgp("计算距离：",distance,"==============================")
                        -- poe2_api.print_log("计算距离：",distance)
                        -- poe2_api.printTable(monster)
                        if distance and distance <= min_attack_range then
                            if monster.hasLineOfSight and api_HasObstacleBetween(monster.grid_x, monster.grid_y) then
                                poe2_api.dbgp("keep_distancen -- > ", safe_point.x, safe_point.y)
                                -- if not api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y), 7) or api_HasObstacleBetween(safe_point.x, safe_point.y) then
                                --     poe2_api.dbgp("安全点过远或有障碍物")
                                --     env.end_point = {safe_point.x, safe_point.y}
                                --     return bret.FAIL
                                -- end
                                if not api_ClickMove(poe2_api.toInt(safe_point1.x), poe2_api.toInt(safe_point1.y), 7) or api_HasObstacleBetween(safe_point1.x, safe_point1.y) then
                                    self.last_space_time_keep = api_GetTickCount64() + (math.random(-5, 5)* 0.01)
                                    poe2_api.dbgp("安全点过远或有障碍物11111")
                                    env.end_point = {safe_point1.x, safe_point1.y}
                                    return bret.FAIL
                                end
                                self.last_space_time_keep = api_GetTickCount64() + (math.random(-5, 5)* 0.01)
                                -- env.end_point = nil
                                -- env.path_list = nil
                                return true
                            end
                        end
                        ::continue_prop::
                    end
                end
                return false
            end

            -- 更新方法，执行躲避逻辑
            local monsters = env.range_info
            local player_info = env.player_info
            local space = env.space
            local space_time = env.space_time
            local space_monster = env.space_monster
            poe2_api.dbgp("space_monster")
            -- poe2_api.printTable(space_monster)

            if not monsters or not player_info or not is_space_open then
                return bret.SUCCESS
            end

            poe2_api.printTable(safe_point)

            -- if player_info.grid_x == safe_point.x and player_info.grid_y == safe_point.y then
            --     poe2_api.dbgp("无安全点可用")
            --     return bret.SUCCESS
            -- end
            
            local keep_distance = false

            
            local monster_count = poe2_api.count_mos_in_range({range_info = env.range_info, player_info = env.player_info, dis = space_check_dis, not_sight = false})
            poe2_api.dbgp("范围内怪物数量:", monster_count)
            

            poe2_api.dbgp("怪物躲避")
            monsters = poe2_api.get_sorted_list(monsters, player_info)
            for _, monster in ipairs(monsters) do
                -- poe2_api.printTable(monster)
                dis = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
                -- poe2_api.dbgp("dis-->", dis)
                if monster.life > 0 and monster.isActive and dis and dis < space_check_dis and 
                not monster.is_friendly and monster.hasLineOfSight then
                    -- poe2_api.printTable(monster)
                    poe2_api.dbgp("monster.rarity-->>", tostring(monster.rarity))
        
                    poe2_api.dbgp("怪物靠近。。。。。")

                    if (monster_count < mons_num or not is_space_open) and not poe2_api.table_contains(monster.rarity, {2, 3}) then
                        return bret.SUCCESS
                    end

                    
                    -- if not poe2_api.table_contains(monster.rarity, env.space_monster) and (not env.center_radius == nil or env.keep_distance) then
                    --     -- keep_distance = keep_distancen(space_check_dis, monster)
                    --     poe2_api.dbgp("怪物躲避1")
                    --     if not api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y), poe2_api.toInt(player_info.world_z), 7) or api_HasObstacleBetween(safe_point.x, safe_point.y) then
                    --         poe2_api.dbgp("安全点过远或有障碍物")
                    --         env.end_point = {safe_point.x, safe_point.y}
                    --         return bret.FAIL
                    --     end
                    --     env.end_point = nil
                    --     env.path_list = nil
                    --     return bret.RUNNING
                    -- end

                    if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                        -- poe2_api.dbgp("怪物躲避2")
                        goto continue
                    end

                    local function checks()
                        for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                            if poe2_api.table_contains(monster.magicProperties, prop) then
                                poe2_api.dbgp("特殊词缀怪物,不闪避")
                                return true
                            end
                        end
                        return false
                    end

                    -- if poe2_api.has_common_element(my_game_info.first_magicProperties, monster.magicProperties) then
                    --     poe2_api.dbgp("特殊词缀怪物,不闪避")
                    --     goto continue
                    -- end

                    if checks() then
                        poe2_api.dbgp("特殊词缀怪物,不闪避")
                        break
                    end

                    local function sp_boss(valid_monsters)
                        if valid_monsters.name_utf8 == "憎惡者．賈嫚拉" or valid_monsters.name_utf8 == "國王的侍從" then
                            for _,k in ipairs(env.range_info) do
                                if k.name_utf8 == "絲克瑪．阿薩拉" and k.stateMachineList and k.stateMachineList["sandstorm_defence"] == 1 then
                                    return true
                                end
                            end
                        end
                        return false
                    end

                    if sp_boss(monster) then
                        poe2_api.dbgp("特殊怪物,不闪避")
                        return bret.RUNNING
                    end

                    poe2_api.dbgp("躲避")
                    if poe2_api.table_contains(space_monsters,monster.rarity) then
                        _handle_space_action(monster, space, space_monster, space_time, player_info) 
                    else
                        if env.keep_distance then
                            poe2_api.dbgp("keep_distance")
                            keep_distancen(env.min_attack_dis)
                            poe2_api.dbgp("keep_distance(ret.keep_distance) --> ",env.keep_distance)
                            -- return bret.RUNNING
                            return bret.SUCCESS
                        end
                    end
                    break
                end
                ::continue::
            end

            

            poe2_api.printTable(env.select_skill)
            -- poe2_api.dbgp("env.select_skill.walk_attack -- >",env.select_skill.walk_attack)
            -- poe2_api.dbgp("env.select_skill and not env.select_skill.walk_attack --> ",(env.select_skill.walk_attack))
            poe2_api.dbgp("keep_distance --> ",keep_distance)
            poe2_api.dbgp("is_space --> ",is_space)
            poe2_api.dbgp("do_space_action --> ",do_space_action)
            -- if (env.select_skill and not env.select_skill.walk_attack) or keep_distance or is_space then
            -- if (env.select_skill and not env.select_skill.walk_attack) or keep_distance or do_space_action then
            if (env.select_skill and not env.select_skill.walk_attack) then
                poe2_api.dbgp("zouA NONONO")
                env.end_point = nil
                env.path_list = nil
                poe2_api.dbgp("is_space(ret.RUNNI) --> ",is_space)
                return bret.RUNNING
            else
                return bret.SUCCESS
            end
            env.end_point = nil
            env.path_list = nil
            return bret.RUNNING
        end
    },

    DodgeAction = {
        name = "躲避",
        run = function(self, env)
            poe2_api.dbgp("DodgeAction1111111111111")
            
            if not env.DodgeAction_is_initialized then
                poe2_api.dbgp("DodgeAction 初始化")
                self.last_space_time = 0.0 -- 上次按下空格的时间
                self.space_cooldown = 1500  -- 空格键冷却时间（秒）
                self.last_space_time1 = 0.0
                env.DodgeAction_is_initialized  = true
                -- is_initialized = true
            end

            if string.find(env.player_info.current_map_name_utf8 , game_str.Delirium_) then
                api_UpdateMapObstacles(240)
            end

            local is_bird = false
            for _,k in ipairs(env.player_info.buffs) do
                -- poe2_api.printTable(k)
                -- poe2_api.dbgp("k.name_en", k.name_en)
                if k.name_en == game_str.on_rhoa_mount_SKBUF then
                    is_bird = true
                    break
                end
            end

            local _handle_space_action_path_name = function(player_info)
                local ret = nil
                local start_time = api_GetTickCount64()
                local danger = api_IsPointInAnyActive(player_info.grid_x , player_info.grid_y , 100)
                poe2_api.dbgp("耗时 === 》》》",api_GetTickCount64() - start_time)
                poe2_api.printTable(danger)
                if danger and danger.inside then
                    local safe_point = danger.safeTile
                    -- local safe_point = api_FindNearestSafeTile(player_info.grid_x , player_info.grid_y , 60 , 5)

                    if safe_point and safe_point.x ~= -1 and safe_point.y ~= -1 then
                        if not api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y), 7) or not api_HasObstacleBetween(safe_point.x, safe_point.y) then
                            poe2_api.dbgp("安全点过远或有障碍物")
                            env.end_point = {safe_point.x, safe_point.y}
                            return bret.SUCCESS
                        end
                        api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y), 7)
                        api_Sleep(200)
                        env.end_point = nil
                        env.path_list = nil
                        poe2_api.dbgp("test11111111111111111111")
                        if danger.action == 2 and not is_bird then
                        -- if not is_bird then
                            poe2_api.click_keyboard("space")
                        end
                        return true
                    end
                end
                return false
            end

            local is_space_open = env.space_config["是否開啟"] or false
            local space_check_dis = env.space_config["躲避距离"]
            local space_time = env.space_config["閾值"]
            local mons_num = env.space_config["触发躲避怪物数"]
            local is_space = env.space_config["是否翻滚"]

            -- 躲避技能
            _handle_space_action_path_name(env.player_info)
            
            -- local safe_point = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, env.space_config["躲避距离"], env.min_attack_dis, 2, 0.5)
            local safe_point = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 100, env.space_config["躲避距离"], 2, 0.5)
            local do_space_action = false
            local _handle_space_action = function(monster, space_flag, space_monsters, space_time, player_info)
                poe2_api.dbgp("space_time",space_time)
                if space_flag and poe2_api.table_contains(space_monsters,monster.rarity) and api_GetTickCount64() - self.last_space_time >= space_time then
                    local result = nil
                    result = api_GetNextCirclePosition(monster.grid_x, monster.grid_y, player_info.grid_x, player_info.grid_y, 50,20,0)

                    -- api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), poe2_api.toInt(player_info.world_z), 0)
                    -- api_Sleep(200)
                    
                    if not is_bird then
                        poe2_api.dbgp("monster.rarity -->", monster.rarity)
                        poe2_api.dbgp("self.last_space_time -->", self.last_space_time)
                        poe2_api.dbgp("space_time -->", space_time)
                        poe2_api.dbgp("api_GetTickCount64() - self.last_space_time -->", (api_GetTickCount64() - self.last_space_time))
                        poe2_api.dbgp("_handle_space_action")
                        if poe2_api.table_contains(space_monsters,monster.rarity) and api_GetTickCount64() - self.last_space_time >= space_time then
                            api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), 7)
                            api_Sleep(200)
                            poe2_api.click_keyboard("space")
                        end
                        do_space_action = true
                    else
                        if not api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), 7) or api_HasObstacleBetween(result.x, result.y) then
                            poe2_api.dbgp("安全点过远或有障碍物")
                            env.end_point = {safe_point.x, safe_point.y}
                            do_space_action = true
                            self.last_space_time = api_GetTickCount64() + (math.random(-5, 5)* 0.01)
                            return bret.SUCCESS
                        end
                    end
                    self.last_space_time = api_GetTickCount64() + (math.random(-5, 5)* 0.01)
                    return false
                end
                return true
            end    

            local function keep_distancen(min_attack_range)
                if min_attack_range < 60 then
                    return false
                end
                local safe_point1 = api_GetSafeAreaLocationNoMonsters(40)
                local range_info1 = poe2_api.get_sorted_list(env.range_info, player_info)
                if api_GetTickCount64() - (self.last_space_time_keep or 0) >= 100 then
                    -- 怪物检查主逻辑
                    for _, monster in ipairs(range_info1) do
                        -- 快速跳过不符合基本条件的怪物
                        if monster.type ~= 1 or                  -- 类型检查
                        not monster.is_selectable or          -- 可选性检查
                        monster.is_friendly or                -- 友方检查
                        monster.life <= 0 or                  -- 生命值检查
                        monster.name_utf8 == "" or              -- 名称检查
                        poe2_api.table_contains(my_game_info.not_attact_mons_CN_name,monster.name_utf8) or
                        poe2_api.table_contains(my_game_info.not_attact_mons_path_name,monster.path_name_utf8)then  -- 路径名检查
                            goto continue_prop
                        end

                        if not monster.isActive then
                            goto continue_prop
                        end

                        -- 检查坐标有效性
                        if not monster.grid_x or not monster.grid_y then
                            goto continue_prop
                        end

                        -- 检查卡住状态
                        if env.stuck_monsters and next(env.stuck_monsters) and poe2_api.table_contains(env.stuck_monsters,monster.id) then
                            goto continue_prop
                        end

                        for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                            if poe2_api.table_contains(monster.magicProperties, prop) then
                                poe2_api.dbgp("特殊词缀怪物,不闪避")
                                return false
                            end
                        end

                        -- poe2_api.printTable(monster.magicProperties)

                        -- 计算距离
                        local distance = poe2_api.point_distance(monster.grid_x, monster.grid_y, env.player_info)
                        poe2_api.dbgp("计算距离：",distance,"==============================")
                        poe2_api.print_log("计算距离：",distance)
                        -- poe2_api.printTable(monster)
                        if distance and distance <= min_attack_range then
                            if monster.hasLineOfSight and api_HasObstacleBetween(monster.grid_x, monster.grid_y) then
                                poe2_api.dbgp("keep_distancen -- > ", safe_point.x, safe_point.y)
                                -- if not api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y), 7) or api_HasObstacleBetween(safe_point.x, safe_point.y) then
                                --     poe2_api.dbgp("安全点过远或有障碍物")
                                --     env.end_point = {safe_point.x, safe_point.y}
                                --     return bret.FAIL
                                -- end
                                if not api_ClickMove(poe2_api.toInt(safe_point1.x), poe2_api.toInt(safe_point1.y), 7) or api_HasObstacleBetween(safe_point1.x, safe_point1.y) then
                                    poe2_api.dbgp("安全点过远或有障碍物11111")
                                    self.last_space_time_keep = api_GetTickCount64() + (math.random(-5, 5)* 0.01)
                                    env.end_point = {safe_point1.x, safe_point1.y}
                                    return bret.SUCCESS
                                end
                                -- env.end_point = nil
                                -- env.path_list = nil
                                self.last_space_time_keep = api_GetTickCount64() + (math.random(-5, 5)* 0.01)
                                return true
                            end
                        end
                        ::continue_prop::
                    end
                end
                return false
            end

            -- 更新方法，执行躲避逻辑
            local monsters = env.range_info
            local player_info = env.player_info
            local space = env.space
            local space_time = env.space_time
            local space_monster = env.space_monster
            poe2_api.dbgp("space_monster")
            -- poe2_api.printTable(space_monster)

            if not monsters or not player_info or not is_space_open then
                return bret.FAIL
            end

            poe2_api.printTable(safe_point)

            -- if player_info.grid_x == safe_point.x and player_info.grid_y == safe_point.y then
            --     poe2_api.dbgp("无安全点可用")
            --     return bret.FAIL
            -- end
            
            local keep_distance = false

            
            local monster_count = poe2_api.count_mos_in_range({range_info = env.range_info, player_info = env.player_info, dis = space_check_dis, not_sight = false})
            poe2_api.dbgp("范围内怪物数量:", monster_count)
            

            poe2_api.dbgp("怪物躲避")
            monsters = poe2_api.get_sorted_list(monsters, player_info)
            for _, monster in ipairs(monsters) do
                -- poe2_api.printTable(monster)
                dis = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
                -- poe2_api.dbgp("dis-->", dis)
                if monster.life > 0 and monster.isActive and dis and dis < space_check_dis and 
                not monster.is_friendly and monster.hasLineOfSight then
                    -- poe2_api.printTable(monster)
                    poe2_api.dbgp("monster.rarity-->>", tostring(monster.rarity))
        
                    poe2_api.dbgp("怪物靠近。。。。。")

                    if (monster_count < mons_num or not is_space_open) and not poe2_api.table_contains(monster.rarity, {2, 3}) then
                        return bret.FAIL
                    end
                    
                    -- if not poe2_api.table_contains(monster.rarity, env.space_monster) and (not env.center_radius == nil or env.keep_distance) then
                    --     -- keep_distance = keep_distancen(space_check_dis, monster)
                    --     poe2_api.dbgp("怪物躲避1")
                    --     if not api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y), poe2_api.toInt(player_info.world_z), 7) or api_HasObstacleBetween(safe_point.x, safe_point.y) then
                    --         poe2_api.dbgp("安全点过远或有障碍物")
                    --         env.end_point = {safe_point.x, safe_point.y}
                    --         return bret.FAIL
                    --     end
                    --     env.end_point = nil
                    --     env.path_list = nil
                    --     return bret.RUNNING
                    -- end

                    if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                        -- poe2_api.dbgp("怪物躲避2")
                        goto continue
                    end
                    local function checks()
                        for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                            if poe2_api.table_contains(monster.magicProperties, prop) then
                                poe2_api.dbgp("特殊词缀怪物,不闪避")
                                return true
                            end
                        end
                        return false
                    end

                    -- if poe2_api.has_common_element(my_game_info.first_magicProperties, monster.magicProperties) then
                    --     poe2_api.dbgp("特殊词缀怪物,不闪避")
                    --     goto continue
                    -- end

                    if checks() then
                        poe2_api.dbgp("特殊词缀怪物,不闪避")
                        break
                    end

                    poe2_api.dbgp("躲避")
                    if poe2_api.table_contains(space_monsters,monster.rarity) then
                        _handle_space_action(monster, space, space_monster, space_time, player_info) 
                    else
                        if env.keep_distance then
                            poe2_api.dbgp("keep_distance")
                            keep_distancen(env.min_attack_dis)
                            poe2_api.dbgp("keep_distance(ret.keep_distance) --> ",env.keep_distance)
                            return bret.RUNNING
                        end
                    end
                    break
                end
                ::continue::
            end

            -- poe2_api.printTable(env.select_skill)
            -- poe2_api.dbgp("env.select_skill.walk_attack -- >",env.select_skill.walk_attack)
            -- poe2_api.dbgp("env.select_skill and not env.select_skill.walk_attack --> ",(env.select_skill.walk_attack))
            poe2_api.dbgp("keep_distance --> ",keep_distance)
            poe2_api.dbgp("is_space --> ",is_space)
            poe2_api.dbgp("do_space_action --> ",do_space_action)
            -- if (env.select_skill and not env.select_skill.walk_attack) or keep_distance or is_space then
            -- if (env.select_skill and not env.select_skill.walk_attack) or keep_distance or do_space_action then
            -- if (env.select_skill and not env.select_skill.walk_attack) then
            --     poe2_api.dbgp("zouA NONONO")
            --     env.end_point = nil
            --     env.path_list = nil
            --     poe2_api.dbgp("is_space(ret.RUNNI) --> ",is_space)
            --     return bret.RUNNING
            -- else
            --     return bret.FAIL
            -- end
            env.end_point = nil
            env.path_list = nil
            return bret.RUNNING
        end
    },

    -- 清理遮挡页面
    Game_Block = {
        run = function(self, env)
            -- poe2_api.print_log("游戏阻挡处理模块开始执行...")
            poe2_api.dbgp("=== 开始处理游戏阻挡 ===")
            
            local current_time = api_GetTickCount64()
            
            local player_info = env.player_info
            -- if player_info then
            --     return bret.SUCCESS
            -- end
            if not env.last_game_block_check_time then
                env.last_game_block_check_time = current_time
                return bret.RUNNING
            end
            
            -- poe2_api.dbgp(string.format("当前时间戳: %d", current_time))
            -- poe2_api.dbgp(string.format("当前地图: %s", player_info.current_map_name_utf8 or "未知"))

            if current_time - env.last_game_block_check_time > 200 then
                env.last_game_block_check_time = current_time
                -- 检查交易拒绝情况
                local refuse_click = {game_str.Waiting_for_the_player_to_accept_TWCH}
                if poe2_api.find_text({UI_info = env.UI_info, text = refuse_click, min_x = 0, add_x = 253, click = 2}) then
                    poe2_api.dbgp("检测到交易请求等待，将执行拒绝操作")
                    return bret.RUNNING
                end

                ---常驻
                local all_check = {
                    {UI_info = env.UI_info, text = game_str.Continue_Game, add_x = 0, add_y = 0, click = 2},
                    {UI_info = env.UI_info, text = game_str.Gemstone_cutting_TWCH, add_x = 280, add_y = 17, click = 2},
                    {UI_info = env.UI_info, text = game_str.Skill_CH, min_x = 0, add_x = 253, click = 2, max_y = 75, max_x = 550},
                }
                -- 检查单个按钮
                for _, check in ipairs(all_check) do
                    if poe2_api.find_text(check) then
                        poe2_api.dbgp(string.format("检测到按钮: %s，将执行点击操作", check.text))
                        return bret.RUNNING
                    end
                end

                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Private_message, add_x = 265, min_x = 0, max_x = 400, click = 2}) then
                    return bret.RUNNING
                end

                -- 检查顶部中间页面按钮
                local top_mid_page = {game_str.teleportation, game_str.Checkpoints_EN}
                if poe2_api.find_text({UI_info = env.UI_info, text = top_mid_page, min_x = 0, add_x = 215, click = 2}) then
                    return bret.RUNNING
                end

                -- 按键
                -- if not self.once_check then
                api_Log("检查是否在主页面11111")
                local once_check = {
                    {UI_info = env.UI_info, text = game_str.Selected_TWCH, add_x = 677, min_x = 0, add_y = 10, click = 2},
                    
                    {UI_info = env.UI_info, text = game_str.Social_TWCH, min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = game_str.Role_TWCH, min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = game_str.Activity_TWCH, min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = game_str.Options_TWCH, min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = game_str.Reset_talent_points, min_x = 0, add_x = 215, click = 2},
                    {UI_info = env.UI_info, text = game_str.Gifted_skills_TWCH, min_x = 0, add_x = 215, click = 2},
                    {UI_info = env.UI_info, text = game_str.Dark_Coin_TWCH,min_x = 0,min_y = 0,max_y=78,add_x = 673,add_y = 4,click = 2},
                    {UI_info = env.UI_info, text = game_str.Wish_list,min_x = 0,min_y = 0,max_y=78,add_x = 673,add_y = 4,click = 2},

                }
                -- 检查单个按钮
                for _, check in ipairs(once_check) do
                    if poe2_api.find_text(check) then
                        poe2_api.dbgp(string.format("检测到按钮: %s，将执行点击操作", check.text))
                        poe2_api.click_keyboard("space")
                        return bret.RUNNING
                    end
                end
                self.once_check = true
                -- end
                
                -- 藏身处特殊处理
                local current_map_info = env.current_map_info
                local function is_map_device(obj_list)
                    if not obj_list or #obj_list == 0 then
                        return false
                    end
                    for _, i in ipairs(obj_list) do
                        if i.name_utf8 == game_str.MapDevice then
                            return true
                        end
                    end
                    return false
                end
                local map = is_map_device(current_map_info)
                -- if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) and map then
                -- poe2_api.dbgp("当前位于藏身处")

                -- 检测地图启动失败情况
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Startup_failed_TWCH}) then
                    poe2_api.dbgp("检测到地图启动失败提示，设置need_SmallRetreat为true")
                    env.need_SmallRetreat = true
                    env.initiative_SmallRetreat = true
                    return bret.RUNNING
                end

                -- 检查背包保存提示
                local save_click = {game_str.You_can_t_throw_this_item}
                if poe2_api.find_text({UI_info = env.UI_info, text = save_click, min_x = 0}) then
                    poe2_api.dbgp("检测到背包保存提示，将执行保留操作")
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Reserved, min_x = 0, click = 2})
                    api_Sleep(500)
                    return bret.RUNNING
                end

                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Reset_talent_points, min_x = 0, max_y = 50}) then
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Reset_talent_points, min_x = 0, max_y = 50,add_x = 215, click = 2})
                    api_Sleep(500)
                    return bret.RUNNING
                end

                local reward_click = {game_str.Task_Reward_TWCH,game_str.Please_choose_a_reward_TWCH}
                if poe2_api.find_text({UI_info = env.UI_info, text = reward_click,min_x = 100}) then 
                    poe2_api.find_text({UI_info = env.UI_info, text = reward_click, min_x = 0 ,add_y = 50,click = 2})
                    if poe2_api.find_text({UI_info = env.UI_info, text =game_str.backpack, min_x = 1020} ) then
                        local point = poe2_api.get_space_point({width = 2,height = 2,index = 1})
                        if point then
                            api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                            return bret.RUNNING
                        else 
                            return bret.SUCCESS
                        end
                    else
                        poe2_api.click_keyboard("i")
                        api_Sleep(500)
                        return bret.RUNNING
                    end
                end
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Currency_exchange, add_x = 300}) then
                    poe2_api.click_keyboard("space")
                    return bret.RUNNING
                end

                --- 藏身处
                local in_safe = {
                    {UI_info = env.UI_info, text = game_str.Purchase_or_sell, add_x = 270, add_y = -9, click = 2},
                    {UI_info = env.UI_info, text = game_str.Choose_Hideout_TWCH, add_x = 516, click = 2, max_y = 130},
                    
                    {UI_info = env.UI_info, text = game_str.Restructuring, add_x = 235, add_y = -298, click = 2},
                    {UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, add_x = 240, min_x = 0, click = 2},
                    {UI_info = env.UI_info, text = game_str.Recycling_equipment, add_x = 160, add_y = -60, min_x = 0, click = 2},
                    {UI_info = env.UI_info, text = game_str.World_map, min_x = 0, add_x = 215, click = 2},
                }
                -- 检查单个按钮
                for _, check in ipairs(in_safe) do
                    if poe2_api.find_text(check) then
                        poe2_api.dbgp(string.format("检测到按钮: %s，将执行点击操作", check.text))
                        return bret.RUNNING
                    end
                end
                
                -- 检查仓库页面
                local warehouse_page = {game_str.Warehouse,game_str.Holy_Land_Lock_Cabinet_TWCH,game_str.Guild_Warehouse}
                if poe2_api.find_text({UI_info = env.UI_info, text = warehouse_page, min_x = 0, max_y = 78}) and 
                poe2_api.find_text({UI_info = env.UI_info, text = game_str.Emphasize_the_item, min_x = 0}) then
                    poe2_api.dbgp("检测到仓库页面，将执行点击操作")
                    poe2_api.find_text({UI_info = env.UI_info, text = warehouse_page, min_x = 0, max_y = 78, click = 2, add_x = 253})
                    return bret.RUNNING
                end
                
                local item = api_Getinventorys(0xd,0)
                if item and next(item) then
                    local width = item[1].end_x - item[1].start_x
                    local height = item[1].end_y - item[1].start_y
                    if poe2_api.table_contains(item[1].category_utf8,game_str.Item_category) then
                        poe2_api.dbgp("检测到物品，将执行点击操作111111")
                        local index_list ={2,3,4,5,6,7,8,9,0xa,0xb}
                        local point_list = {
                            [2] = {1320,250},
                            [3] = {1151,191},
                            [4] = {1493,191},
                            [5] = {1322,133},
                            [6] = {1410,201},
                            [7] = {1237,255},
                            [8] = {1410,255},
                            [9] = {1213,330},
                            [0xa] = {1431,330},
                            [0xb] = {1322,353},
                        }
                        local point = nil
                        for _, v in ipairs(index_list) do
                            if poe2_api.table_contains(v,{10,11}) then
                                v = string.format("0x%x", v)
                            end
                            local item_player = env["item"..v]
                            if item_player and next(item_player) then
                                if item[1].baseType_utf8 == item_player[1].baseType_utf8 
                                and item[1].DemandStrength == item_player[1].DemandStrength
                                and item[1].DemandAgility == item_player[1].DemandAgility
                                and item[1].DemandWisdom == item_player[1].DemandWisdom
                                and item[1].DemandLevel == item_player[1].DemandLevel
                                and item[1].not_identified == item_player[1].not_identified
                                and item[1].category_utf8 == item_player[1].category_utf8
                                and item[1].quality == item_player[1].quality
                                and item[1].sockets == item_player[1].sockets
                                and item[1].color == item_player[1].color then
                                    local current_item = api_Getinventorys(v,0)
                                    if current_item and next(current_item) then
                                        if current_item[1].baseType_utf8 == item_player[1].baseType_utf8 
                                        and current_item[1].DemandStrength == item_player[1].DemandStrength
                                        and current_item[1].DemandAgility == item_player[1].DemandAgility
                                        and current_item[1].DemandWisdom == item_player[1].DemandWisdom
                                        and current_item[1].DemandLevel == item_player[1].DemandLevel
                                        and current_item[1].not_identified == item_player[1].not_identified
                                        and current_item[1].category_utf8 == item_player[1].category_utf8
                                        and current_item[1].quality == item_player[1].quality
                                        and current_item[1].sockets == item_player[1].sockets
                                        and current_item[1].color == item_player[1].color then
                                        else
                                            point = point_list[v]
                                            break
                                        end
                                    else
                                        point = point_list[v]
                                        break
                                    end
                                end
                            else
                                point = point_list[v]
                                break
                            end
                        end
                        if point then
                            if poe2_api.find_text({text = game_str.backpack,UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                                api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                                api_Sleep(500)
                                poe2_api.time_p("开背包,城区附着... 耗时 --> ", api_GetTickCount64() - current_time)
                                return bret.RUNNING
                            else
                                poe2_api.dbgp("开背包,城区附着")
                                poe2_api.click_keyboard("i")
                                api_Sleep(300)
                                poe2_api.time_p("开背包,城区附着1... 耗时 --> ", api_GetTickCount64() - current_time)
                                return bret.RUNNING
                            end
                        end
                    end
                    local point = poe2_api.get_space_point({width = width, height = height, info = env.bag_info})
                    
                    poe2_api.dbgp(string.format("物品尺寸: 宽%d, 高%d", width, height))
                    poe2_api.dbgp(point[1],point[2])
                    if point then
                        poe2_api.dbgp(string.format("获取到空间点: (%d, %d)", poe2_api.toInt(point[1]), poe2_api.toInt(point[2])))
                        
                        if poe2_api.find_text({UI_info = env.UI_info, text = game_str.backpack,min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                            poe2_api.dbgp("检测到背包文字，将执行点击操作")
                            api_ClickScreen(point[1], point[2])
                            api_Sleep(100)
                            api_ClickScreen(point[1], point[2],1)
                            api_Sleep(500)
                        else
                            poe2_api.dbgp("未检测到背包文字，将按I键打开背包")
                            poe2_api.click_keyboard("i")
                            api_Sleep(500)
                        end
                        return bret.RUNNING
                    else
                        poe2_api.dbgp("警告: 无法获取物品空间点")
                    end
                else
                    poe2_api.dbgp("wufuzhuowu")
                end
                -- end
                
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.backpack, add_x = 250, min_x = 1020}) then
                    poe2_api.click_keyboard("i")
                    api_Sleep(500)
                    return bret.RUNNING
                end
            end
            
            poe2_api.dbgp("未检测到任何阻挡情况，模块返回SUCCESS状态")
            poe2_api.time_p("Game_Block 耗时 --> ", api_GetTickCount64() - current_time)
            return bret.SUCCESS
        end
    },

    -- 清理遮挡页面
    Game_Block_Inside = {
        run = function(self, env)
            poe2_api.print_log("游戏阻挡处理模块开始执行...")
            poe2_api.dbgp("=== 开始处理游戏阻挡 ===")
            
            local current_time = api_GetTickCount64()
            
            local player_info = env.player_info
            -- if player_info then
            --     return bret.SUCCESS
            -- end
            
            -- poe2_api.dbgp(string.format("当前时间戳: %d", current_time))
            -- poe2_api.dbgp(string.format("当前地图: %s", player_info.current_map_name_utf8 or "未知"))

            -- 检查交易拒绝情况
            local refuse_click = {game_str.Waiting_for_the_player_to_accept_TWCH}
            if poe2_api.find_text({UI_info = env.UI_info, text = refuse_click, min_x = 0, add_x = 253, click = 2}) then
                poe2_api.dbgp("检测到交易请求等待，将执行拒绝操作")
                return bret.RUNNING
            end

            ---常驻
            local all_check = {
                {UI_info = env.UI_info, text = game_str.Continue_Game, add_x = 0, add_y = 0, click = 2},
                {UI_info = env.UI_info, text = game_str.Gemstone_cutting_TWCH, add_x = 280, add_y = 17, click = 2},
                {UI_info = env.UI_info, text = game_str.Skill_CH, min_x = 0, add_x = 253, click = 2, max_y=78},
            }
            -- 检查单个按钮
            for _, check in ipairs(all_check) do
                if poe2_api.find_text(check) then
                    poe2_api.dbgp(string.format("检测到按钮: %s，将执行点击操作", check.text))
                    return bret.RUNNING
                end
            end

            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Private_message, add_x = 265, min_x = 0, max_x = 400, click = 2}) then
                return bret.RUNNING
            end

            -- 检查顶部中间页面按钮
            local top_mid_page = {game_str.teleportation, game_str.Checkpoints_EN}
            if poe2_api.find_text({UI_info = env.UI_info, text = top_mid_page, min_x = 0, add_x = 215, click = 2}) then
                return bret.RUNNING
            end

            -- 按键
            if not self.once_check then
                api_Log("检查是否在主页面11111")
                local once_check = {
                    {UI_info = env.UI_info, text = game_str.Selected_TWCH, add_x = 677, min_x = 0, add_y = 10, click = 2},
                    
                    {UI_info = env.UI_info, text = game_str.Social_TWCH, min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = game_str.Role_TWCH, min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = game_str.Activity_TWCH, min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = game_str.Options_TWCH, min_x = 0, add_x = 253, click = 2},
                    {UI_info = env.UI_info, text = game_str.Reset_talent_points, min_x = 0, add_x = 215, click = 2},
                    {UI_info = env.UI_info, text = game_str.Gifted_skills_TWCH, min_x = 0, add_x = 215, click = 2},
                    {UI_info = env.UI_info, text = game_str.Dark_Coin_TWCH,min_x = 0,min_y = 0,max_y=78,add_x = 673,add_y = 4,click = 2},
                    {UI_info = env.UI_info, text = game_str.Wish_list,min_x = 0,min_y = 0,max_y=78,add_x = 673,add_y = 4,click = 2},

                }
                -- 检查单个按钮
                for _, check in ipairs(once_check) do
                    if poe2_api.find_text(check) then
                        poe2_api.dbgp(string.format("检测到按钮: %s，将执行点击操作", check.text))
                        return bret.RUNNING
                    end
                end
                self.once_check = true
            end
            
            -- 藏身处特殊处理
            local current_map_info = env.current_map_info
            local function is_map_device(obj_list)
                if not obj_list or #obj_list == 0 then
                    return false
                end
                for _, i in ipairs(obj_list) do
                    if i.name_utf8 == game_str.MapDevice then
                        return true
                    end
                end
                return false
            end
            
            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.backpack, add_x = 250, min_x = 1020}) then
                poe2_api.click_keyboard("i")
                api_Sleep(500)
                return bret.RUNNING
            end
            
            poe2_api.dbgp("未检测到任何阻挡情况，模块返回SUCCESS状态")
            poe2_api.time_p("Game_Block 耗时 --> ", api_GetTickCount64() - current_time)
            return bret.FAIL
        end
    },

    -- 检查是否需要攻击
    Check_Is_Need_Attack = {
        run = function(self, env)
            poe2_api.print_log("检查是否需要攻击...")
            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            local stuck_monsters = poe2_api.deepCopy(env.stuck_monsters)
            local is_active = true
            local not_sight = false
            local search_dis = env.min_attack_dis

            if poe2_api.table_contains(env.player_info.current_map_name_utf8,my_game_info.hideout) then
                return bret.FAIL
			end
            
            if not player_info then
                poe2_api.dbgp("玩家信息不存在")
                return bret.RUNNING
            end
            
            if string.find(player_info.current_map_name_utf8, game_str.Claimable_EN) or string.find(player_info.current_map_name_utf8, game_str.Delirium_) then
                local range_sorted = poe2_api.get_sorted_list(env.range_info, env.player_info)
                for _, i in ipairs(range_sorted) do
                    if i.path_name_utf8 == game_str.Monolith_PATH then
                        is_active = true
                        not_sight = true
                        break
                    end
                end
                is_active = false
                not_sight = true
                search_dis = 1000
            end
            -- 特殊怪物檢查

            local function spcify_monsters()
                local spcify_monsters_name_list = {game_str.snake_king}
                for _, monster in ipairs(env.range_info) do
                    for _, name in ipairs(spcify_monsters_name_list) do
						if monster.name_utf8 == name and monster.life > 0 then

							return true
						end
					end
                end
                return false
            end

            poe2_api.dbgp("is_active:",is_active," ","not_sight:",not_sight)
            if #env.center_point > 0 and env.center_radius > 0 then
                stuck_monsters = {}
            end
            


            nomarl_monster = poe2_api.is_have_mos({range_info = env.range_info, dis = search_dis, player_info = player_info,is_active = is_active, not_sight = not_sight,stuck_monsters = stuck_monsters})
            poe2_api.dbgp("nomarl_monster -- > ", nomarl_monster)
            -- api_Log("nomarl_monster -- > ")
            -- api_Log(nomarl_monster)
            Boss_monster = poe2_api.is_have_mos_boss(env.range_info, my_game_info.boss_name)
            poe2_api.dbgp("Boss_monster --> ", Boss_monster)
            -- poe2_api.printTable(Boss_monster)
            local a = spcify_monsters()
            poe2_api.dbgp("spcify_monsters() --> ")
            if nomarl_monster or Boss_monster or spcify_monsters() then
                env.need_attack = true
                if env.player_info.current_map_name_utf8 == game_str.Abyss_Pinnacle_MDANA then
                    env.boss_id_list = {}
                end
                env.is_church_completed = false
                poe2_api.dbgp("需要攻击")
                poe2_api.time_p("Check_Is_Need_Attack(SUCCESS) 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            else
                poe2_api.dbgp("不需要攻击")
                env.need_attack = false
                if env.afoot_altar then
                    return bret.RUNNING
                end
                poe2_api.time_p("Check_Is_Need_Attack(FAIL) 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.FAIL
            end
        end
    },

    -- 检查是否需要攻击
    Check_Is_Need_Attack_Inside = {
        run = function(self, env)
            poe2_api.print_log("检查是否需要攻击...")
            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            local stuck_monsters = poe2_api.deepCopy(env.stuck_monsters)
            local is_active = true
            local not_sight = false
            local search_dis = env.min_attack_dis

            -- if poe2_api.table_contains(env.player_info.current_map_name_utf8,my_game_info.hideout) then
            --     return bret.SUCCESS
			-- end
            
            if not player_info then
                poe2_api.dbgp("玩家信息不存在")
                return bret.RUNNING
            end
            
            if string.find(player_info.current_map_name_utf8, game_str.Claimable_EN) or string.find(player_info.current_map_name_utf8, game_str.Delirium_) then
                local range_sorted = poe2_api.get_sorted_list(env.range_info, env.player_info)
                for _, i in ipairs(range_sorted) do
                    if i.path_name_utf8 == game_str.Monolith_PATH then
                        is_active = true
                        not_sight = true
                        -- search_dis = 1000
                        break
                    end
                end
                is_active = false
                not_sight = true
                search_dis = 1000
            end
            -- 特殊怪物檢查

            local function spcify_monsters()
                local spcify_monsters_name_list = {game_str.snake_king}
                for _, monster in ipairs(env.range_info) do
                    for _, name in ipairs(spcify_monsters_name_list) do
						if monster.name_utf8 == name and monster.life > 0 then
							return true
						end
					end
                end
                return false
            end
            poe2_api.dbgp("is_active:",is_active," ","not_sight:",not_sight)
            if #env.center_point > 0 and env.center_radius > 0 then
                stuck_monsters = {}
            end
            local stuck_monsters = poe2_api.deepCopy(env.stuck_monsters)
            nomarl_monster = poe2_api.is_have_mos({range_info = env.range_info, dis = search_dis, player_info = player_info,is_active = is_active, not_sight = not_sight,stuck_monsters = stuck_monsters})
            poe2_api.dbgp("nomarl_monster -- > ", nomarl_monster)
            Boss_monster = poe2_api.is_have_mos_boss(env.range_info, my_game_info.boss_name)
            poe2_api.dbgp("Boss_monster --> ", Boss_monster)
            if nomarl_monster or Boss_monster or spcify_monsters() then
                poe2_api.dbgp("需要攻击")
                env.need_attack = true
                if env.player_info.current_map_name_utf8 == game_str.Abyss_Pinnacle_MDANA then
                    env.boss_id_list = {}
                end
                env.is_church_completed = false
                poe2_api.time_p("Check_Is_Need_Attack(FAIL) 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.FAIL
            else
                poe2_api.dbgp("不需要攻击")
                env.need_attack = false
                -- if env.afoot_altar then
                --     return bret.RUNNING
                -- end
                poe2_api.time_p("Check_Is_Need_Attack(FAIL) 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
        end
    },

    -- 释放技能动作
    ReleaseSkillAction_Inside = {
        run = function(self, env)
            local current_time_ms = api_GetTickCount64()
            local player_info = env.player_info
            env.select_skill = nil
            --- 辅助函数
            -- 根据稀有度获取可释放的技能

            local available_skills = {}
            local function _get_available_skills(monster_rarity)
                -- 根据怪物稀有度获取可用技能
                local current_time = api_GetTickCount64()
                
                for _, skill in ipairs(env.skills_inside) do
                    
                    -- 检查冷却
                    poe2_api.dbgp("current_time --> ",current_time)
                    poe2_api.dbgp("skill.name --> ",skill.name)
                    poe2_api.dbgp("env.skill_cooldowns_inside[skill.name] --> ",env.skill_cooldowns_inside[skill.name])
                    if current_time < (env.skill_cooldowns_inside[skill.name] or 0) then
                        goto continue
                    end
                    
                    -- 检查技能是否适合攻击该稀有度怪物
                    if monster_rarity == 3 then  -- Boss
                        if not skill.target_targets[game_str.Boss_EN] then
                            goto continue
                        end
                    elseif monster_rarity == 2 then  -- 黄怪
                        if not skill.target_targets["黃怪"] then
                            goto continue
                        end
                    elseif monster_rarity == 1 then  -- 蓝怪
                        if not skill.target_targets["藍怪"] then
                            goto continue
                        end
                    elseif monster_rarity == 0 then  -- 白怪
                        if not skill.target_targets["白怪"] then
                            goto continue
                        end
                    end
                    
                    table.insert(available_skills, skill)
                    
                    ::continue::
                end
                return available_skills
            end

            -- 取可释放的单个技能
            local function _select_skill(available_skills)
                local current_time = api_GetTickCount64()

                local skill_setting = env.user_config["技能設置"]

                
                -- 参数检查
                if type(available_skills) ~= "table" or #available_skills == 0 then
                    error("Invalid skills list: " .. tostring(available_skills))
                end
                
                -- 筛选有效技能（有数字间隔的技能）
                local valid_skills = {}
                for _, skill in ipairs(available_skills) do
                    if type(skill.interval) == "number" then
                        table.insert(valid_skills, skill)
                    end
                end
                
                if #valid_skills == 0 then
                    error("No valid skills with numeric intervals")
                end
                
                -- 排序技能（先按interval降序，再按priority升序）
                table.sort(valid_skills, function(a, b)
                    if a.interval ~= b.interval then
                        return a.interval > b.interval  -- 降序
                    else
                        return (a.priority or 0) < (b.priority or 0)  -- 升序
                    end
                end)
                
                -- 获取最大间隔值
                local max_interval = valid_skills[1].interval
                local candidates = {}
                for _, skill in ipairs(valid_skills) do
                    if skill.interval == max_interval then
                        table.insert(candidates, skill)
                    else
                        break  -- 因为已排序，可以提前退出
                    end
                end
                
                -- 随机选择一个候选技能
                if #candidates > 0 then
                    return candidates[math.random(#candidates)]
                else
                    return nil
                end
            end

            -- 获取技能设置
            local function parse_skill_config()
                local skill_setting = env.user_config["技能設置"]
                local new_skills = {}
                local new_sup_skills = {}
                local preserved_cooldowns = {}
                local sup_preserved_cooldowns = {}
                local current_time = api_GetTickCount64()
                
                -- 确保skill_cooldowns表存在
                if not env.skill_cooldowns_inside then
                    env.skill_cooldowns_inside = {}
                end
                if not env.sup_skill_cooldowns_inside then
                    env.sup_skill_cooldowns_inside = {}
                end

                if not env.all_skill_infos_inside or env.all_skill_infos_inside == nil then
                    env.all_skill_infos_inside = api_GetSkillSlots()
                end

                if not env.all_skill_inside or env.all_skill_inside == nil then
                    env.all_skill_inside = api_GetSelectableSkillControls()
                end
                -- poe2_api.dbgp("22222222222222222222")
                -- poe2_api.printTable(api_GetSkillSlots())
                -- poe2_api.dbgp("111111111111111111111")
                -- poe2_api.printTable(api_GetSelectableSkillControls())
                -- poe2_api.dbgp("33333333333333333")
                -- api_Sleep(10000)
                local skill_pos = {
                    ["q"] = {1194, 1230},
                    ["w"] = {1236, 1272},
                    ["e"] = {1279, 1315},
                    ["r"] = {1322, 1358},
                    ["t"] = {1365, 1401},
                }

                -- 首先建立按键到控件的映射
                local key_to_control = {}
                if env.all_skill_inside and next(env.all_skill_inside) ~= nil then
                    for _, control in ipairs(env.all_skill_inside) do
                        if not control.text_utf8 or control.text_utf8 == "" then
                            goto continue
                        end
                        -- 跳过非主技能栏的技能
                        if control.top > 845 and control.left > 1190 then
                            for key, range in pairs(skill_pos) do
                                local pos = (control.left + control.right) / 2
                                if pos >= range[1] and pos <= range[2] then
                                    key_to_control[key] = control
                                    break
                                end
                            end
                        end
                        ::continue::
                    end
                end
                
                -- 创建按键到技能ID的映射
                local key_to_skill_id = {}
                for key, skill_data in pairs(skill_setting) do
                    if skill_data["启用"] then
                        local control = key_to_control[key]
                        if control then
                            for _, skill in ipairs(env.all_skill_infos_inside) do
                                if control.text_utf8 == skill.name_utf8 then
                                    key_to_skill_id[key] = skill.id
                                    break
                                end
                            end
                        end
                    end
                end
                
                -- 遍历技能设置
                for key, skill_data in pairs(skill_setting) do
                    -- 只处理启用技能
                    if skill_data["启用"] then
                        -- 处理攻击技能
                        if skill_data["技能屬性"] == "攻击技能" then
                            local skill = {
                                name = key,
                                key = key,
                                id = key_to_skill_id[key] or 0,
                                interval = (tonumber(skill_data["釋放間隔"]) or 0) / 1000,
                                priority = 1,
                                weight = 1.0,
                                attack = skill_data["釋放對象"],
                                walk_attack = skill_data["走A"],
                                attack_range = tonumber(skill_data["攻擊距離"]) or 100,
                                target_targets = {
                                    ["白怪"] = skill_data["白怪"] or false,
                                    ["藍怪"] = skill_data["藍怪"] or false,
                                    ["黃怪"] = skill_data["黃怪"] or false,
                                    [game_str.Boss_EN] = skill_data[game_str.Boss_EN] or false
                                }
                            }
                            
                            -- 保留原有冷却时间
                            if env.skill_cooldowns_inside[skill.name] then
                                preserved_cooldowns[skill.name] = env.skill_cooldowns_inside[skill.name]
                            else
                                preserved_cooldowns[skill.name] = 0
                            end
                            
                            table.insert(new_skills, skill)
                            
                        -- 处理辅助技能
                        elseif skill_data["技能屬性"] == "辅助技能" then
                            local sup_skill = {
                                name = key,
                                key = key,
                                id = key_to_skill_id[key] or 0,
                                interval = (tonumber(skill_data["釋放間隔"]) or 0) / 1000
                            }
                            
                            -- 保留原有冷却时间
                            if env.sup_skill_cooldowns_inside[sup_skill.name] then
                                sup_preserved_cooldowns[sup_skill.name] = env.sup_skill_cooldowns_inside[sup_skill.name]
                            else
                                sup_preserved_cooldowns[sup_skill.name] = 0
                            end
                            
                            table.insert(new_sup_skills, sup_skill)
                        end
                    end
                end
                
                env.skills_inside = new_skills
                env.sup_skills_inside = new_sup_skills
                -- poe2_api.printTable(env.skills_inside)
                env.skill_cooldowns_inside = preserved_cooldowns
                env.sup_skill_cooldowns_inside = sup_preserved_cooldowns

                -- 提取技能权重
                env._skill_weights_inside = {}
                for _, skill in ipairs(env.skills_inside) do
                    table.insert(env._skill_weights_inside, skill.weight)
                end
                
                return {
                    attack_skills = env.skills_inside,
                    support_skills = env.sup_skills_inside
                }
            end
            
            -- 计算释放距离
            local function _calculate_intermediate_position(start_x, start_y, end_x, end_y, ratio)
                local current_time = api_GetTickCount64()
                ratio = ratio or 0.8  -- 默认比例0.8
                
                -- 计算方向向量
                local dx = end_x - start_x
                local dy = end_y - start_y
                
                -- 添加随机扰动（避免完全直线移动）
                if ratio > 0.5 then  -- 靠近目标时增加随机性
                    dx = dx * (0.9 + math.random() * 0.2)  -- 0.9-1.1
                    dy = dy * (0.9 + math.random() * 0.2)
                end
                
                -- 计算中间点
                local mid_x = start_x + dx * ratio
                local mid_y = start_y + dy * ratio
                
                return mid_x, mid_y
            end

            -- 选择释放对象
            local function _calculate_movement(skill, monster, player_info)
                local current_time = api_GetTickCount64()
                local target_type = skill.target or "敵對"
                local move_x, move_y, move_z = nil, nil, nil
                
                -- 根据技能目标类型计算基础位置
                if target_type == "敵對" then
                    move_x = monster.grid_x
                    move_y = monster.grid_y
                    
                elseif target_type == "自身" then
                    -- 对自身释放：小范围随机移动
                    move_x = player_info.grid_x + (math.random() * 4 - 2)  -- -2到2
                    move_y = player_info.grid_y + (math.random() * 4 - 2)
                    move_z =poe2_api.toInt(player_info.world_z)
                    
                elseif target_type == "敵對尸體" then
                    -- 对尸体释放：查找最近的尸体
                    local death_em = poe2_api.enemy_death_target_object({env.range_info,env.player_info})
                    if death_em then
                        move_x = death_em.grid_x + (math.random() * 6 - 3)  -- -3到3
                        move_y = death_em.grid_y + (math.random() * 6 - 3)
                    end
                    
                elseif target_type == "友方召喚物" then
                    -- 对友方召唤物释放
                    local fr_ob = poe2_api.friendly_target_object({env.range_info,env.player_info})
                    if fr_ob then
                        move_x, move_y = api_FindNearestReachableInRange(
                            fr_ob.grid_x,
                            fr_ob.grid_y,
                            20,
                            0
                        )
                    end
                end
                
                -- 默认位置（如果前面未计算）
                if move_x == nil or move_y == nil then
                    move_x = monster.grid_x
                    move_y = monster.grid_y
                    move_z = monster.world_z
                end
                
                -- 特殊技能处理（如传送类技能）
                if skill.key == '`' then
                    -- 计算玩家到怪物的中间位置
                    move_x, move_y = _calculate_intermediate_position(
                        player_info.grid_x,
                        player_info.grid_y,
                        monster.grid_x,
                        monster.grid_y,
                        0.70  -- ratio
                    )
                end
                
                -- poe2_api.dbgp(777777777777777777)
                -- 
                return move_x, move_y, move_z
            end

            -- 释放技能
            local function _execute_skill(skill, monster, player_info)
                poe2_api.dbgp("释放技能=-=-=-->>>>")
                poe2_api.printTable(skill)
                local current_time = api_GetTickCount64()
                
                -- 计算移动位置
                local move_x, move_y, move_z =  _calculate_movement(skill, monster, player_info)

                if env.attack_last_time_inside == nil then
                    env.attack_last_time_inside = api_GetTickCount64()
                end
                
                -- api_ClickMove(math.floor(move_x), math.floor(move_y), poe2_api.toInt(move_z), 0)
                
                -- 设置冷却时间
                local skill_start = api_GetTickCount64()
                local base_cd = skill.interval
                poe2_api.dbgp("base_cd =-=-=-->>>>", base_cd)
                local actual_cd = (math.max(base_cd * (1 + math.random() * 0.2), 0.1)) * 1000
                env.skill_cooldowns_inside[skill.name] = skill_start + actual_cd
                
                -- 释放技能
                -- poe2_api.click_keyboard(skill.key)
                -- poe2_api.dbgp("id=-=-=-->>>>", skill.id)
                -- poe2_api.dbgp("env.player_info.grid_x=-=-=-->>>>", env.player_info.grid_x)
                -- poe2_api.dbgp("env.player_info.grid_y=-=-=-->>>>", env.player_info.grid_y)
                -- poe2_api.dbgp("move_x=-=-=-->>>>", move_x)
                -- poe2_api.dbgp("move_y=-=-=-->>>>", move_y)
                api_CastSkill(skill.id, 0, env.player_info.grid_x, env.player_info.grid_y, move_x, move_y)
                -- api_CastSkill(skill.id, 0, env.player_info.grid_x, env.player_info.grid_y, monster.grid_x, monster.grid_y)

                poe2_api.dbgp("释放技能=-=-=-->>>>", skill.key)
            end

            -- 释放辅助技能
            local function _execute_support_skill(skill, player_info)
                poe2_api.dbgp("释放辅助技能=-=-=-->>>>")
                poe2_api.printTable(skill)
                local current_time = api_GetTickCount64()
                
                -- 设置冷却时间
                local skill_start = api_GetTickCount64()
                local base_cd = skill.interval
                local actual_cd = (math.max(base_cd * (1 + math.random() * 0.2), 0.1)) * 1000
                env.sup_skill_cooldowns_inside[skill.name] = skill_start + actual_cd
                
                -- 释放辅助技能
                if skill.id and skill.id ~= 0 then
                    -- 辅助技能通常不需要目标位置，使用玩家当前位置
                    api_CastSkill(skill.id, 0, env.player_info.grid_x, env.player_info.grid_y, env.player_info.grid_x, env.player_info.grid_y)
                    poe2_api.dbgp("通过技能ID释放辅助技能:", skill.key, "技能ID:", skill.id)
                else
                    -- 备用方案：使用按键释放
                    poe2_api.click_keyboard(skill.key)
                    poe2_api.dbgp("通过按键释放辅助技能:", skill.key)
                end
            end

            -- 检查并释放辅助技能
            local function check_and_cast_support_skills()
                if not env.sup_skills_inside or #env.sup_skills_inside == 0 then
                    return
                end
                
                local current_time = api_GetTickCount64()
                
                -- 按优先级排序辅助技能
                table.sort(env.sup_skills_inside, function(a, b)
                    return a.priority > b.priority
                end)
                
                for _, skill in ipairs(env.sup_skills_inside) do
                    -- 检查冷却时间
                    local last_cast = env.sup_skill_cooldowns_inside[skill.name] or 0
                    if current_time - last_cast >= skill.interval * 1000 then
                        _execute_support_skill(skill, env.player_info)
                    end
                end
            end

            -- check_and_cast_support_skills()
            
            -- 特殊boss处理
            local function _handle_special_boss_movement(boss, player_info)
                local current_time = api_GetTickCount64()
                
                -- 使用pcall进行错误处理（替代try-catch）
                -- 计算安全距离（30单位）
                local safe_distance = 30
                local angle = math.atan2(
                    boss.grid_y - player_info.grid_y,
                    boss.grid_x - player_info.grid_x
                )
                
                -- 计算目标位置（保持安全距离）
                local target_x = boss.grid_x - safe_distance * math.cos(angle)
                local target_y = boss.grid_y - safe_distance * math.sin(angle)
                
                -- 寻找可达点
                local reachable_x, reachable_y = api_FindNearestReachableInRange(
                    target_x, 
                    target_y,
                    safe_distance * 0.7,  -- radius
                    0  -- z
                )
                
                -- 设置移动目标
                env.attack_move = true
                env.end_point = {reachable_x, reachable_y}
            
            end

            

            --- 主要动作
            poe2_api.dbgp("释放技能...")
            nearest_distance_sq = math.huge

            -- 加载技能设置
            if not env.is_have_skills then
                poe2_api.dbgp("加载技能设置...")
                env.stuck_monsters_inside = {}
                
                parse_skill_config()
                env.is_have_skills = true
                return bret.RUNNING
            end


            if not env.skills_inside or #env.skills_inside == 0 then
                poe2_api.dbgp("主动攻击无技能")
                return bret.FAIL
            end

            -- if (player_info.mana < (player_info.max_mana * 0.15)) then
            --     poe2_api.dbgp("蓝量小于15%")
            --     return bret.FAIL
            -- end

            -- 是否激活
            local is_active = true
            if string.find(env.player_info.current_map_name_utf8 or "", game_str.Claimable_EN) or string.find(env.player_info.current_map_name_utf8, game_str.Delirium_)then
                local range_sorted = poe2_api.get_sorted_list(env.range_info, env.player_info)
                for _, i in ipairs(range_sorted) do
                    if i.path_name_utf8 == game_str.Monolith_PATH then
                        is_active = true
                        break
                    end
                end
                is_active = false
            end

            local valid_monsters = nil
            
            -- 怪物筛选和处理逻辑
            for _, monster in ipairs(env.range_info) do
                if monster.name_utf8 == "" then
                    goto continue
                end
                -- poe2_api.dbgp("monster ------------------------------------------------------->")
                -- poe2_api.printTable(monster)
                -- poe2_api.dbgp("monster name -->" ,monster.name_utf8)
                -- poe2_api.dbgp("obj: ",tostring(string.format("%x",monster.obj)))
                -- poe2_api.dbgp("monster -->" ,monster.life)
                -- local a = monster
                -- poe2_api.print_log("a monster ------------------------------------------------------->")
                -- poe2_api.print_log("a monster name -->" ,a.name_utf8)
                -- poe2_api.print_log("a obj: ",tostring(string.format("%x",a.obj)))
                -- poe2_api.print_log("a monster -->" ,a.life)

                -- 快速失败条件检查（按计算成本从低到高排序）
                if not monster.is_selectable or          -- 可选性检查
                monster.is_friendly or                -- 友方检查
                monster.life <= 0 or                  -- 生命值检查
                monster.name_utf8 == "" or              -- 名称检查
                poe2_api.table_contains(my_game_info.not_attact_mons_CN_name, monster.name_utf8) or
                poe2_api.table_contains(my_game_info.not_attact_mons_path_name , monster.path_name_utf8) then  -- 路径名检查
                    goto continue
                end
                if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                    goto continue
                end    
                -- poe2_api.dbgp("monster ------------------------------------------------------->")
                -- poe2_api.dbgp("monster name -->" ,monster.name_utf8)
                -- poe2_api.dbgp("obj: ",tostring(string.format("%x",monster.obj)))
                -- poe2_api.dbgp("monster -->" ,monster.life)

                -- if string.find(monster.path_name_utf8,"Metadata/Monsters/TormentedSpirits/") then
                --     goto continue
                -- end

                -- 检查是否在中心点半径范围内
                if #env.center_point > 0 and env.center_radius > 0 then
                    local distance_to_center = math.sqrt(
                        (monster.grid_x - env.center_point[1])^2 + 
                        (monster.grid_y - env.center_point[2])^2
                    )
                    if distance_to_center > env.center_radius then
                        goto continue  -- 超出范围则跳过
                    end
                else
                    if env.stuck_monsters_inside and poe2_api.table_contains(env.stuck_monsters_inside, monster.id) then
                        goto continue
                    end
                end
                
                -- 是否激活  
                if (not monster.isActive) and is_active then
                    goto continue
                end

                -- 稀有度检查
                if env.not_attack_mos and env.not_attack_mos[monster.rarity] then
                    goto continue
                end

                -- 计算距离平方
                local distance_sq = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
                -- poe2_api.dbgp("当前怪物：",monster.name_utf8,"，距离：",distance_sq,"米")

                if not player_info.isInBossBattle and monster.rarity ~= 3 and not (string.find(player_info.current_map_name_utf8 or "", game_str.Claimable_EN) or string.find(player_info.current_map_name_utf8, game_str.Delirium_)) then
                    if monster.hasLineOfSight and distance_sq < nearest_distance_sq then
                        nearest_distance_sq = distance_sq
                        valid_monsters = monster
                    end
                else
                    if distance_sq < nearest_distance_sq then
                        nearest_distance_sq = distance_sq
                        valid_monsters = monster
                    end
                end
                ::continue::
            end

            if valid_monsters then
                -- 获取当前目标ID
                local current_target_id = valid_monsters and valid_monsters.id or nil
                -- poe2_api.dbgp("a valid_monsters ------------------------------------------------------->")
                -- poe2_api.dbgp("a valid_monsters name -->" ,valid_monsters.name_utf8)
                -- poe2_api.dbgp("a valid_monsters path_name -->" ,valid_monsters.path_name_utf8)
                -- poe2_api.dbgp("a valid_monsters: ",tostring(string.format("%x",valid_monsters.obj)))
                -- poe2_api.dbgp("a life -->" ,valid_monsters.life)
                -- poe2_api.dbgp("a grid_x -->" ,valid_monsters.grid_x)
                -- poe2_api.dbgp("a grid_y -->" ,valid_monsters.grid_y)


                if not (#env.center_point > 0 and env.center_radius > 0) then
                    -- 第二次遍历进行卡住检测和其他处理
                    for _, monster in ipairs(env.range_info) do
                        local current_time = api_GetTickCount64()

                        if string.find(player_info.current_map_name_utf8,game_str.Abyss_EN) then
                            break
                        end  
                        
                        -- 快速失败条件检查
                        if not monster.is_selectable or 
                        poe2_api.table_contains(env.stuck_monsters_inside,monster.id) or 
                        monster.is_friendly then
                            goto continue_second
                        end
                        if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                            goto continue_second
                        end   
                        -- Metadata/Monsters/TormentedSpirits/Cat/SpiritOfTheCat
                        -- if string.find(monster.path_name_utf8,"Metadata/Monsters/TormentedSpirits/") then
                        --     goto continue_second
                        -- end

                        if monster.name_utf8 == "" then
                            goto continue_second
                        end

                        -- 黑名单检查
                        if poe2_api.table_contains(my_game_info.not_attact_mons_CN_name, monster.name_utf8) or
                            poe2_api.table_contains(my_game_info.not_attact_mons_path_name, monster.path_name_utf8) or
                        string.find(monster.name_utf8 or "", game_str.temple) then
                            goto continue_second
                        end
                        
                        --- 基础状态检查       
                        if (not monster.isActive) and is_active then
                            goto continue_second
                        end

                        if not (monster.life > 0) then
                            goto continue_second
                        end
                        
                        -- 死亡怪物处理
                        if monster.life <= 0 then
                            env.monster_tracker_inside[monster.id] = nil
                            env.stuck_monsters_inside = {}
                            goto continue_second
                        end
                        
                        -- 卡住检测（仅对当前目标）
                        if monster.id == current_target_id then
                            -- 目标切换时重置所有数据
                            if current_target_id ~= env.last_target_id_inside then
                                env.current_target_data_inside = {
                                    first_seen = current_time,
                                    last_seen = current_time,
                                    initial_life = monster.life,
                                    grid_x = monster.grid_x,
                                    grid_y = monster.grid_y,
                                    rarity = monster.rarity
                                }
                                env.last_target_id_inside = current_target_id
                            else
                                -- 仅更新时间戳
                                env.current_target_data_inside.last_seen = current_time
                            end
                            
                            -- 计算存活时间和生命比例
                            local time_elapsed = current_time - env.current_target_data_inside.first_seen
                            local life_ratio = monster.life / math.max(env.current_target_data_inside.initial_life, 1)
                            
                            -- 获取稀有度对应的时间阈值
                            local rarity_index = math.min(monster.rarity, 3) + 1  -- Lua数组从1开始
                            local time_thresholds = {45, 60, 120, 180}
                            local time_threshold = (time_thresholds[rarity_index]) * 1000

                            -- 综合判断条件
                            if time_elapsed > time_threshold and life_ratio > 0.95 then
                                table.insert(env.stuck_monsters_inside, monster.id)
                                poe2_api.dbgp(string.format("%s 卡住（%.1f秒未击杀）", monster.name_utf8 or "未知怪物", time_elapsed / 1000))
                                valid_monsters = nil
                                goto continue_second
                            end
                        end
                        ::continue_second::
                    end
                end
            end

            -- 更新黑板数据
            if env.stuck_monsters_inside then
                env.stuck_monsters = env.stuck_monsters_inside
                -- poe2_api.printTable(env.stuck_monsters_inside)
            end

            env.valid_monsters = valid_monsters

            if valid_monsters then
                -- 计算距离
                local distance = math.sqrt((valid_monsters.grid_x - player_info.grid_x)^2 + 
                                        (valid_monsters.grid_y - player_info.grid_y)^2)

                poe2_api.dbgp("++++++++++++++++++++++++++++++++++")
                poe2_api.dbgp(string.format("攻击 %s(稀有度:%d) | 距离: %.1f",valid_monsters.name_utf8 or "未知怪物", valid_monsters.rarity or 0, distance))
                poe2_api.dbgp("is_friendly: ", tostring(valid_monsters.is_friendly))
                poe2_api.dbgp("hasLineOfSight: ", tostring(valid_monsters.hasLineOfSight))
                poe2_api.dbgp("isActive: ", tostring(valid_monsters.isActive))
                -- poe2_api.dbgp("isActive: ", tostring(valid_monsters.isActive))
                -- poe2_api.dbgp("rarity: ", tostring(valid_monsters.rarity))
                -- poe2_api.dbgp("path_name_utf8: ", tostring(valid_monsters.path_name_utf8))
                poe2_api.dbgp("obj: ", tostring(string.format("%x",valid_monsters.obj)))
                poe2_api.dbgp("grid_x: ", tostring(string.format("%x",valid_monsters.grid_x)))
                poe2_api.dbgp("grid_y: ", tostring(string.format("%x",valid_monsters.grid_y)))
                -- api_ClickMove(valid_monsters.grid_x, valid_monsters.grid_y, player_info.world_z, 0)
                poe2_api.dbgp("magicProperties: ", tostring(valid_monsters.magicProperties))
                poe2_api.printTable(valid_monsters.magicProperties)
                -- poe2_api.dbgp("stateMachineList: ", tostring(valid_monsters.stateMachineList))
                poe2_api.dbgp("血量：", valid_monsters.life )
                -- poe2_api.print_log("type --> ", type(valid_monsters))
                poe2_api.dbgp("++++++++++++++++++++++++++++++++++")
                
                -- 特殊Boss处理
                local special_bosses = {game_str.snake_king, game_str.The_Forgotten_Prisoner_NAME}
                if poe2_api.table_contains(valid_monsters.name_utf8, special_bosses) and distance > 50 and not valid_monsters.isActive then
                    poe2_api.dbgp("special_bosses,或者未激活")
                    _handle_special_boss_movement(valid_monsters, player_info)
                    poe2_api.dbgp("移动到目标附近444")
                    return bret.SUCCESS
                end

                if valid_monsters.name_utf8 == "憎惡者．賈嫚拉" or valid_monsters.name_utf8 == "國王的侍從" then
                    for _,k in ipairs(env.range_info) do
                        if k.name_utf8 == "絲克瑪．阿薩拉" and k.stateMachineList and k.stateMachineList["sandstorm_defence"] == 1 then
                            dis = poe2_api.point_distance(k.grid_x,k.grid_y,player_info)
                            if dis and dis > 25 then
                                env.end_point = {k.grid_x, k.grid_y}
                                return bret.SUCCESS
                            -- elseif poe2_api.point_distance(k.grid_x,k.grid_y,player_info) > 20 then
                            --     return bret.RUNNING
                            end
                        end
                    end
                end

                -- 构建可用技能池

                local available_skills = _get_available_skills(valid_monsters.rarity)

                local min_attack_range = 0
                if available_skills and #available_skills > 0 then
                    for _, skill in ipairs(available_skills) do
                        if skill.attack_range > min_attack_range then
                            min_attack_range = skill.attack_range
                        end
                    end
                end

                env.min_attack_range = min_attack_range
                
                if available_skills and #available_skills > 0 then
                    local selected_skill = _select_skill(available_skills)
                    if distance > 25 then
                        poe2_api.printTable(valid_monsters.magicProperties)
                        -- 检查特殊词缀
                        for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                            if poe2_api.table_contains(valid_monsters.magicProperties, prop) then
                                env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                poe2_api.dbgp("移动到目标附近111")
                                return bret.SUCCESS
                            end
                            ::continue_prop::
                        end
                    end

                    poe2_api.dbgp("selected_skill.attack_range", selected_skill.attack_range)
                    poe2_api.dbgp("min_attack_range", min_attack_range)
                    poe2_api.dbgp("distance", distance)

                    if valid_monsters.name_utf8 ~= game_str.The_Tyrant_of_Bones_NAME then
                        poe2_api.dbgp("11111111111111")
                        if distance > selected_skill.attack_range and distance > min_attack_range or not valid_monsters.isActive then
                            poe2_api.dbgp("移动到目标附近")
                            if string.find(player_info.current_map_name_utf8, game_str.Delirium_) and distance > selected_skill.attack_range then
                                env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                poe2_api.dbgp("移动到目标附近222")
                                return bret.SUCCESS
                            end
                            -- -- 拾取不移动
                            -- if need_item and not env.center_point and not center_radius then
                            --     return bret.FAIL
                            -- end

                            -- if env.is_map_complete then
                            --     -- 寻找传送门
                            --     if env.range_info then
                            --         for _, k in ipairs(env.range_info) do
                            --             if k.name_utf8 ~= '' and k.type == 5 and poe2_api.table_contains(k.name_utf8, my_game_info.hideout_CH) then
                            --                 dis = poe2_api.point_distance(k.grid_x, k.grid_y, player_info)
                            --                 if dis and dis < 25 then
                            --                     if not poe2_api.find_text({UI_info = env.UI_info, text = k.name_utf8, click = 2}) then
                            --                         api_ClickMove(poe2_api.toInt(k.grid_x), poe2_api.toInt(k.grid_y), poe2_api.toInt(k.world_z), 1)
                            --                     end
                            --                 end
                            --             end
                            --         end
                            --     end

                            --     env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                            --     poe2_api.dbgp("移动到目标附近555")
                            --     return bret.SUCCESS
                            -- end
                            
                            if env.afoot_altar then
                                local distance = poe2_api.point_distance(env.afoot_altar.grid_x, env.afoot_altar.grid_y, env.player_info)
                                if distance < 105 then
                                    env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                    poe2_api.dbgp("移动到目标附近222")
                                    return bret.SUCCESS
                                end
                            end

                            -- if env.afoot_box then
                            --     local distance = poe2_api.point_distance(env.afoot_box.grid_x, env.afoot_box.grid_y, env.player_info)
                            --     if distance < 120 then
                            --         env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                            --         poe2_api.dbgp("移动到目标附近333")
                            --         return bret.SUCCESS
                            --     end
                            -- end
                            
                            if poe2_api.table_contains(valid_monsters.rarity, {2, 3}) then
                                poe2_api.dbgp("精英怪移动到目标附近")
                                env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                return bret.SUCCESS
                            -- else
                            --     return bret.SUCCESS
                            end
                            return bret.FAIL
                        end
                    else
                        if distance > 80 then
                            env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                            poe2_api.dbgp("移动到目标附近333")
                            return bret.SUCCESS
                        end
                    end
                    
                    _execute_skill(selected_skill, valid_monsters, player_info)
                    poe2_api.dbgp("释放：")
                    poe2_api.printTable(selected_skill)
                    if select_skill then
                        env.select_skill = selected_skill
                    else
                        env.select_skill = nil
                    end
                    -- if valid_monsters.rarity > 1 then
                    --     poe2_api.time_p("ReleaseSkillAction(RUNNING) 耗时 --> ", api_GetTickCount64() - current_time_ms)
                    --     return bret.RUNNING
                    -- end
                    poe2_api.time_p("ReleaseSkillAction 耗时(123123123123) --> ", api_GetTickCount64() - current_time_ms)
                    return bret.FAIL
                    -- return bret.RUNNING
                end
                poe2_api.dbgp("ReleaseSkillAction bret.FAIL")
                -- return bret.RUNNING
                return bret.FAIL
            end

            poe2_api.time_p("ReleaseSkillAction 耗时(hcdhfhfhfhf) --> ", api_GetTickCount64() - current_time_ms)
            return bret.FAIL
            -- return bret.RUNNING
        end
    },

    -- 释放技能动作
    ReleaseSkillAction = {
        run = function(self, env)
            local current_time_ms = api_GetTickCount64()
            local player_info = env.player_info
            env.select_skill = nil
            --- 辅助函数
            -- 根据稀有度获取可释放的技能

            local available_skills = {}
            local function _get_available_skills(monster_rarity)
                -- 根据怪物稀有度获取可用技能
                local current_time = api_GetTickCount64()
                
                for _, skill in ipairs(env.skills_outside) do
                    
                    -- 检查冷却
                    poe2_api.dbgp("current_time --> ",current_time)
                    poe2_api.dbgp("skill.name --> ",skill.name)
                    poe2_api.dbgp("env.skill_cooldowns_outside[skill.name] --> ",env.skill_cooldowns_outside[skill.name])
                    if current_time < (env.skill_cooldowns_outside[skill.name] or 0) then
                        goto continue
                    end
                    
                    -- 检查技能是否适合攻击该稀有度怪物
                    if monster_rarity == 3 then  -- Boss
                        if not skill.target_targets[game_str.Boss_EN] then
                            goto continue
                        end
                    elseif monster_rarity == 2 then  -- 黄怪
                        if not skill.target_targets["黃怪"] then
                            goto continue
                        end
                    elseif monster_rarity == 1 then  -- 蓝怪
                        if not skill.target_targets["藍怪"] then
                            goto continue
                        end
                    elseif monster_rarity == 0 then  -- 白怪
                        if not skill.target_targets["白怪"] then
                            goto continue
                        end
                    end
                    
                    table.insert(available_skills, skill)
                    
                    ::continue::
                end
                return available_skills
            end

            -- 取可释放的单个技能
            local function _select_skill(available_skills)
                local current_time = api_GetTickCount64()

                local skill_setting = env.user_config["技能設置"]

                
                -- 参数检查
                if type(available_skills) ~= "table" or #available_skills == 0 then
                    error("Invalid skills list: " .. tostring(available_skills))
                end
                
                -- 筛选有效技能（有数字间隔的技能）
                local valid_skills = {}
                for _, skill in ipairs(available_skills) do
                    if type(skill.interval) == "number" then
                        table.insert(valid_skills, skill)
                    end
                end
                
                if #valid_skills == 0 then
                    error("No valid skills with numeric intervals")
                end
                
                -- 排序技能（先按interval降序，再按priority升序）
                table.sort(valid_skills, function(a, b)
                    if a.interval ~= b.interval then
                        return a.interval > b.interval  -- 降序
                    else
                        return (a.priority or 0) < (b.priority or 0)  -- 升序
                    end
                end)
                
                -- 获取最大间隔值
                local max_interval = valid_skills[1].interval
                local candidates = {}
                for _, skill in ipairs(valid_skills) do
                    if skill.interval == max_interval then
                        table.insert(candidates, skill)
                    else
                        break  -- 因为已排序，可以提前退出
                    end
                end
                
                -- 随机选择一个候选技能
                if #candidates > 0 then
                    return candidates[math.random(#candidates)]
                else
                    return nil
                end
            end

            -- 获取技能设置
            local function parse_skill_config()
                local skill_setting = env.user_config["技能設置"]
                local new_skills = {}
                local new_sup_skills = {}
                local preserved_cooldowns = {}
                local sup_preserved_cooldowns = {}
                local current_time = api_GetTickCount64()
                
                -- 确保skill_cooldowns表存在
                if not env.skill_cooldowns_outside then
                    env.skill_cooldowns_outside = {}
                end
                if not env.sup_skill_cooldowns_outside then
                    env.sup_skill_cooldowns_outside = {}
                end

                if not env.all_skill_infos_outside or env.all_skill_infos_outside == nil then
                    env.all_skill_infos_outside = api_GetSkillSlots()
                end

                if not env.all_skill_outside or env.all_skill_outside == nil then
                    env.all_skill_outside = api_GetSelectableSkillControls()
                end
                -- poe2_api.dbgp("22222222222222222222")
                -- poe2_api.printTable(api_GetSkillSlots())
                -- poe2_api.dbgp("111111111111111111111")
                -- poe2_api.printTable(api_GetSelectableSkillControls())
                -- poe2_api.dbgp("33333333333333333")
                -- api_Sleep(10000)
                local skill_pos = {
                    ["q"] = {1194, 1230},
                    ["w"] = {1236, 1272},
                    ["e"] = {1279, 1315},
                    ["r"] = {1322, 1358},
                    ["t"] = {1365, 1401},
                }

                -- 首先建立按键到控件的映射
                local key_to_control = {}
                if env.all_skill_outside and next(env.all_skill_outside) ~= nil then
                    for _, control in ipairs(env.all_skill_outside) do
                        if not control.text_utf8 or control.text_utf8 == "" then
                            goto continue
                        end
                        -- 跳过非主技能栏的技能
                        if control.top > 845 and control.left > 1190 then
                            for key, range in pairs(skill_pos) do
                                local pos = (control.left + control.right) / 2
                                if pos >= range[1] and pos <= range[2] then
                                    key_to_control[key] = control
                                    break
                                end
                            end
                        end
                        ::continue::
                    end
                end
                
                -- 创建按键到技能ID的映射
                local key_to_skill_id = {}
                for key, skill_data in pairs(skill_setting) do
                    if skill_data["启用"] then
                        local control = key_to_control[key]
                        if control then
                            for _, skill in ipairs(env.all_skill_infos_outside) do
                                if control.text_utf8 == skill.name_utf8 then
                                    key_to_skill_id[key] = skill.id
                                    break
                                end
                            end
                        end
                    end
                end
                
                -- 遍历技能设置
                for key, skill_data in pairs(skill_setting) do
                    -- 只处理启用技能
                    if skill_data["启用"] then
                        -- 处理攻击技能
                        if skill_data["技能屬性"] == "攻击技能" then
                            local skill = {
                                name = key,
                                key = key,
                                id = key_to_skill_id[key] or 0,
                                interval = (tonumber(skill_data["釋放間隔"]) or 0) / 1000,
                                priority = 1,
                                weight = 1.0,
                                attack = skill_data["釋放對象"],
                                walk_attack = skill_data["走A"],
                                attack_range = tonumber(skill_data["攻擊距離"]) or 100,
                                target_targets = {
                                    ["白怪"] = skill_data["白怪"] or false,
                                    ["藍怪"] = skill_data["藍怪"] or false,
                                    ["黃怪"] = skill_data["黃怪"] or false,
                                    [game_str.Boss_EN] = skill_data[game_str.Boss_EN] or false
                                }
                            }
                            
                            -- 保留原有冷却时间
                            if env.skill_cooldowns_outside[skill.name] then
                                preserved_cooldowns[skill.name] = env.skill_cooldowns_outside[skill.name]
                            else
                                preserved_cooldowns[skill.name] = 0
                            end
                            
                            table.insert(new_skills, skill)
                            
                        -- 处理辅助技能
                        elseif skill_data["技能屬性"] == "辅助技能" then
                            local sup_skill = {
                                name = key,
                                key = key,
                                id = key_to_skill_id[key] or 0,
                                interval = (tonumber(skill_data["釋放間隔"]) or 0) / 1000
                            }
                            
                            -- 保留原有冷却时间
                            if env.sup_skill_cooldowns_outside[sup_skill.name] then
                                sup_preserved_cooldowns[sup_skill.name] = env.sup_skill_cooldowns_outside[sup_skill.name]
                            else
                                sup_preserved_cooldowns[sup_skill.name] = 0
                            end
                            
                            table.insert(new_sup_skills, sup_skill)
                        end
                    end
                end
                
                env.skills_outside = new_skills
                env.sup_skills_outside = new_sup_skills
                -- poe2_api.printTable(env.skills_outside)
                env.skill_cooldowns_outside = preserved_cooldowns
                env.sup_skill_cooldowns_outside = sup_preserved_cooldowns

                -- 提取技能权重
                env._skill_weights_outside = {}
                for _, skill in ipairs(env.skills_outside) do
                    table.insert(env._skill_weights_outside, skill.weight)
                end
                
                return {
                    attack_skills = env.skills_outside,
                    support_skills = env.sup_skills_outside
                }
            end
            
            -- 计算释放距离
            local function _calculate_intermediate_position(start_x, start_y, end_x, end_y, ratio)
                local current_time = api_GetTickCount64()
                ratio = ratio or 0.8  -- 默认比例0.8
                
                -- 计算方向向量
                local dx = end_x - start_x
                local dy = end_y - start_y
                
                -- 添加随机扰动（避免完全直线移动）
                if ratio > 0.5 then  -- 靠近目标时增加随机性
                    dx = dx * (0.9 + math.random() * 0.2)  -- 0.9-1.1
                    dy = dy * (0.9 + math.random() * 0.2)
                end
                
                -- 计算中间点
                local mid_x = start_x + dx * ratio
                local mid_y = start_y + dy * ratio
                
                return mid_x, mid_y
            end

            -- 选择释放对象
            local function _calculate_movement(skill, monster, player_info)
                local current_time = api_GetTickCount64()
                local target_type = skill.target or "敵對"
                local move_x, move_y, move_z = nil, nil, nil
                
                -- 根据技能目标类型计算基础位置
                if target_type == "敵對" then
                    move_x = monster.grid_x
                    move_y = monster.grid_y
                    
                elseif target_type == "自身" then
                    -- 对自身释放：小范围随机移动
                    move_x = player_info.grid_x + (math.random() * 4 - 2)  -- -2到2
                    move_y = player_info.grid_y + (math.random() * 4 - 2)
                    move_z =poe2_api.toInt(player_info.world_z)
                    
                elseif target_type == "敵對尸體" then
                    -- 对尸体释放：查找最近的尸体
                    local death_em = poe2_api.enemy_death_target_object({env.range_info,env.player_info})
                    if death_em then
                        move_x = death_em.grid_x + (math.random() * 6 - 3)  -- -3到3
                        move_y = death_em.grid_y + (math.random() * 6 - 3)
                    end
                    
                elseif target_type == "友方召喚物" then
                    -- 对友方召唤物释放
                    local fr_ob = poe2_api.friendly_target_object({env.range_info,env.player_info})
                    if fr_ob then
                        move_x, move_y = api_FindNearestReachableInRange(
                            fr_ob.grid_x,
                            fr_ob.grid_y,
                            20,
                            0
                        )
                    end
                end
                
                -- 默认位置（如果前面未计算）
                if move_x == nil or move_y == nil then
                    move_x = monster.grid_x
                    move_y = monster.grid_y
                    move_z = monster.world_z
                end
                
                -- 特殊技能处理（如传送类技能）
                if skill.key == '`' then
                    -- 计算玩家到怪物的中间位置
                    move_x, move_y = _calculate_intermediate_position(
                        player_info.grid_x,
                        player_info.grid_y,
                        monster.grid_x,
                        monster.grid_y,
                        0.70  -- ratio
                    )
                end
                
                -- poe2_api.dbgp(777777777777777777)
                -- 
                return move_x, move_y, monster.world_z
            end

            -- 释放技能
            local function _execute_skill(skill, monster, player_info)
                poe2_api.dbgp("释放技能=-=-=-->>>>")
                poe2_api.printTable(skill)
                local current_time = api_GetTickCount64()
                
                -- 计算移动位置
                local move_x, move_y, move_z =  _calculate_movement(skill, monster, player_info)

                if env.attack_last_time_outside == nil then
                    env.attack_last_time_outside = api_GetTickCount64()
                end
                
                api_ClickMove(math.floor(move_x), math.floor(move_y), 0, poe2_api.toInt(move_z))
                
                -- 设置冷却时间
                local skill_start = api_GetTickCount64()
                local base_cd = skill.interval
                poe2_api.dbgp("base_cd =-=-=-->>>>", base_cd)
                local actual_cd = (math.max(base_cd * (1 + math.random() * 0.2), 0.1)) * 1000
                env.skill_cooldowns_outside[skill.name] = skill_start + actual_cd
                
                -- 释放技能
                poe2_api.click_keyboard(skill.key)
                -- poe2_api.dbgp("id=-=-=-->>>>", skill.id)
                -- poe2_api.dbgp("env.player_info.grid_x=-=-=-->>>>", env.player_info.grid_x)
                -- poe2_api.dbgp("env.player_info.grid_y=-=-=-->>>>", env.player_info.grid_y)
                -- poe2_api.dbgp("move_x=-=-=-->>>>", move_x)
                -- poe2_api.dbgp("move_y=-=-=-->>>>", move_y)
                -- api_CastSkill(skill.id, 0, env.player_info.grid_x, env.player_info.grid_y, move_x, move_y)
                -- api_CastSkill(skill.id, 0, env.player_info.grid_x, env.player_info.grid_y, monster.grid_x, monster.grid_y)

                poe2_api.dbgp("释放技能=-=-=-->>>>", skill.key)
            end

            -- 释放辅助技能
            local function _execute_support_skill(skill, player_info)
                poe2_api.dbgp("释放辅助技能=-=-=-->>>>")
                poe2_api.printTable(skill)
                local current_time = api_GetTickCount64()
                
                -- 设置冷却时间
                local skill_start = api_GetTickCount64()
                local base_cd = skill.interval
                local actual_cd = (math.max(base_cd * (1 + math.random() * 0.2), 0.1)) * 1000
                env.sup_skill_cooldowns_outside[skill.name] = skill_start + actual_cd
                
                -- 释放辅助技能
                if skill.id and skill.id ~= 0 then
                    -- 辅助技能通常不需要目标位置，使用玩家当前位置
                    api_CastSkill(skill.id, 0, env.player_info.grid_x, env.player_info.grid_y, env.player_info.grid_x, env.player_info.grid_y)
                    poe2_api.dbgp("通过技能ID释放辅助技能:", skill.key, "技能ID:", skill.id)
                else
                    -- 备用方案：使用按键释放
                    poe2_api.click_keyboard(skill.key)
                    poe2_api.dbgp("通过按键释放辅助技能:", skill.key)
                end
            end

            -- 检查并释放辅助技能
            local function check_and_cast_support_skills()
                if not env.sup_skills_outside or #env.sup_skills_outside == 0 then
                    return
                end
                
                local current_time = api_GetTickCount64()
                
                -- 按优先级排序辅助技能
                table.sort(env.sup_skills_outside, function(a, b)
                    return a.priority > b.priority
                end)
                
                for _, skill in ipairs(env.sup_skills_outside) do
                    -- 检查冷却时间
                    local last_cast = env.sup_skill_cooldowns_outside[skill.name] or 0
                    if current_time - last_cast >= skill.interval * 1000 then
                        _execute_support_skill(skill, env.player_info)
                    end
                end
            end

            -- check_and_cast_support_skills()
            
            -- 特殊boss处理
            local function _handle_special_boss_movement(boss, player_info)
                local current_time = api_GetTickCount64()
                
                -- 使用pcall进行错误处理（替代try-catch）
                -- 计算安全距离（30单位）
                local safe_distance = 30
                local angle = math.atan2(
                    boss.grid_y - player_info.grid_y,
                    boss.grid_x - player_info.grid_x
                )
                
                -- 计算目标位置（保持安全距离）
                local target_x = boss.grid_x - safe_distance * math.cos(angle)
                local target_y = boss.grid_y - safe_distance * math.sin(angle)
                
                -- 寻找可达点
                local reachable_x, reachable_y = api_FindNearestReachableInRange(
                    target_x, 
                    target_y,
                    safe_distance * 0.7,  -- radius
                    0  -- z
                )
                
                -- 设置移动目标
                env.attack_move = true
                env.end_point = {reachable_x, reachable_y}
            
            end

            

            --- 主要动作
            poe2_api.dbgp("释放技能...")
            nearest_distance_sq = math.huge

            -- 加载技能设置
            if not env.is_have_skills then
                poe2_api.dbgp("加载技能设置...")
                env.stuck_monsters_outside = {}
                
                parse_skill_config()
                env.is_have_skills = true
                return bret.RUNNING
            end


            if not env.skills_outside or #env.skills_outside == 0 then
                poe2_api.dbgp("主动攻击无技能")
                return bret.FAIL
            end

            -- if (player_info.mana < (player_info.max_mana * 0.15)) then
            --     poe2_api.dbgp("蓝量小于15%")
            --     return bret.FAIL
            -- end

            -- 是否激活
            local is_active = true
            if string.find(env.player_info.current_map_name_utf8 or "", game_str.Claimable_EN) then
                local range_sorted = poe2_api.get_sorted_list(env.range_info, env.player_info)
                for _, i in ipairs(range_sorted) do
                    if i.path_name_utf8 == game_str.Monolith_PATH then
                        is_active = true
                        break
                    end
                end
                is_active = false
            end

            local valid_monsters = nil
            
            -- 怪物筛选和处理逻辑
            for _, monster in ipairs(env.range_info) do
                if monster.name_utf8 == "" then
                    goto continue
                end
                -- poe2_api.dbgp("monster ------------------------------------------------------->")
                -- poe2_api.printTable(monster)
                -- poe2_api.dbgp("monster name -->" ,monster.name_utf8)
                -- poe2_api.dbgp("obj: ",tostring(string.format("%x",monster.obj)))
                -- poe2_api.dbgp("monster -->" ,monster.life)
                -- local a = monster
                -- poe2_api.print_log("a monster ------------------------------------------------------->")
                -- poe2_api.print_log("a monster name -->" ,a.name_utf8)
                -- poe2_api.print_log("a obj: ",tostring(string.format("%x",a.obj)))
                -- poe2_api.print_log("a monster -->" ,a.life)

                -- 快速失败条件检查（按计算成本从低到高排序）
                if not monster.is_selectable or          -- 可选性检查
                monster.is_friendly or                -- 友方检查
                monster.life <= 0 or                  -- 生命值检查
                monster.name_utf8 == "" or              -- 名称检查
                poe2_api.table_contains(my_game_info.not_attact_mons_CN_name, monster.name_utf8) or
                poe2_api.table_contains(my_game_info.not_attact_mons_path_name , monster.path_name_utf8) then  -- 路径名检查
                    goto continue
                end
                if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                    goto continue
                end    
                -- poe2_api.dbgp("monster ------------------------------------------------------->")
                -- poe2_api.dbgp("monster name -->" ,monster.name_utf8)
                -- poe2_api.dbgp("obj: ",tostring(string.format("%x",monster.obj)))
                -- poe2_api.dbgp("monster -->" ,monster.life)

                -- if string.find(monster.path_name_utf8,"Metadata/Monsters/TormentedSpirits/") then
                --     goto continue
                -- end

                -- 检查是否在中心点半径范围内
                if #env.center_point > 0 and env.center_radius > 0 then
                    local distance_to_center = math.sqrt(
                        (monster.grid_x - env.center_point[1])^2 + 
                        (monster.grid_y - env.center_point[2])^2
                    )
                    if distance_to_center > env.center_radius then
                        goto continue  -- 超出范围则跳过
                    end
                else
                    if env.stuck_monsters_outside and poe2_api.table_contains(env.stuck_monsters_outside, monster.id) then
                        goto continue
                    end
                end
                
                -- 是否激活  
                if (not monster.isActive) and is_active then
                    goto continue
                end

                -- 稀有度检查
                if env.not_attack_mos and env.not_attack_mos[monster.rarity] then
                    goto continue
                end

                -- 计算距离平方
                local distance_sq = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
                -- poe2_api.dbgp("当前怪物：",monster.name_utf8,"，距离：",distance_sq,"米")

                if not player_info.isInBossBattle and monster.rarity ~= 3 and not (string.find(player_info.current_map_name_utf8 or "", game_str.Claimable_EN) or string.find(player_info.current_map_name_utf8, game_str.Delirium_)) then
                    if monster.hasLineOfSight and distance_sq < nearest_distance_sq then
                        nearest_distance_sq = distance_sq
                        valid_monsters = monster

                    end
                else
                    if distance_sq < nearest_distance_sq then
                        nearest_distance_sq = distance_sq
                        valid_monsters = monster
                    end
                end
                ::continue::
            end

            if valid_monsters then
                -- 获取当前目标ID
                local current_target_id = valid_monsters and valid_monsters.id or nil
                -- poe2_api.dbgp("a valid_monsters ------------------------------------------------------->")
                -- poe2_api.dbgp("a valid_monsters name -->" ,valid_monsters.name_utf8)
                -- poe2_api.dbgp("a valid_monsters path_name -->" ,valid_monsters.path_name_utf8)
                -- poe2_api.dbgp("a valid_monsters: ",tostring(string.format("%x",valid_monsters.obj)))
                -- poe2_api.dbgp("a life -->" ,valid_monsters.life)
                -- poe2_api.dbgp("a grid_x -->" ,valid_monsters.grid_x)
                -- poe2_api.dbgp("a grid_y -->" ,valid_monsters.grid_y)


                if not (#env.center_point > 0 and env.center_radius > 0) then
                    -- 第二次遍历进行卡住检测和其他处理
                    for _, monster in ipairs(env.range_info) do
                        local current_time = api_GetTickCount64()

                        if string.find(player_info.current_map_name_utf8,game_str.Abyss_EN) then
                            break
                        end  
                        
                        -- 快速失败条件检查
                        if not monster.is_selectable or 
                        poe2_api.table_contains(env.stuck_monsters_outside,monster.id) or 
                        monster.is_friendly then
                            goto continue_second
                        end
                        if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                            goto continue_second
                        end   
                        -- Metadata/Monsters/TormentedSpirits/Cat/SpiritOfTheCat
                        -- if string.find(monster.path_name_utf8,"Metadata/Monsters/TormentedSpirits/") then
                        --     goto continue_second
                        -- end

                        if monster.name_utf8 == "" then
                            goto continue_second
                        end

                        -- 黑名单检查
                        if poe2_api.table_contains(my_game_info.not_attact_mons_CN_name, monster.name_utf8) or
                            poe2_api.table_contains(my_game_info.not_attact_mons_path_name, monster.path_name_utf8) or
                        string.find(monster.name_utf8 or "", game_str.temple) then
                            goto continue_second
                        end
                        
                        --- 基础状态检查       
                        if (not monster.isActive) and is_active then
                            goto continue_second
                        end

                        if not (monster.life > 0) then
                            goto continue_second
                        end
                        
                        -- 死亡怪物处理
                        if monster.life <= 0 then
                            env.monster_tracker_outside[monster.id] = nil
                            env.stuck_monsters_outside = {}
                            goto continue_second
                        end
                        
                        -- 卡住检测（仅对当前目标）
                        if monster.id == current_target_id then
                            -- 目标切换时重置所有数据
                            if current_target_id ~= env.last_target_id_outside then
                                env.current_target_data_outside = {
                                    first_seen = current_time,
                                    last_seen = current_time,
                                    initial_life = monster.life,
                                    grid_x = monster.grid_x,
                                    grid_y = monster.grid_y,
                                    rarity = monster.rarity
                                }
                                env.last_target_id_outside = current_target_id
                            else
                                -- 仅更新时间戳
                                env.current_target_data_outside.last_seen = current_time
                            end
                            
                            -- 计算存活时间和生命比例
                            local time_elapsed = current_time - env.current_target_data_outside.first_seen
                            local life_ratio = monster.life / math.max(env.current_target_data_outside.initial_life, 1)
                            
                            -- 获取稀有度对应的时间阈值
                            local rarity_index = math.min(monster.rarity, 3) + 1  -- Lua数组从1开始
                            local time_thresholds = {45, 60, 120, 180}
                            local time_threshold = (time_thresholds[rarity_index]) * 1000

                            -- 综合判断条件
                            if time_elapsed > time_threshold and life_ratio > 0.95 then
                                table.insert(env.stuck_monsters_outside, monster.id)
                                poe2_api.dbgp(string.format("%s 卡住（%.1f秒未击杀）", monster.name_utf8 or "未知怪物", time_elapsed / 1000))
                                valid_monsters = nil
                                goto continue_second
                            end
                        end
                        ::continue_second::
                    end
                end
            end

            -- 更新黑板数据
            if env.stuck_monsters_outside then
                env.stuck_monsters = env.stuck_monsters_outside
                -- poe2_api.printTable(env.stuck_monsters_outside)
            end

            env.valid_monsters = valid_monsters

            if valid_monsters then
                -- 计算距离
                local distance = math.sqrt((valid_monsters.grid_x - player_info.grid_x)^2 + 
                                        (valid_monsters.grid_y - player_info.grid_y)^2)

                poe2_api.dbgp("++++++++++++++++++++++++++++++++++")
                poe2_api.dbgp(string.format("攻击 %s(稀有度:%d) | 距离: %.1f",valid_monsters.name_utf8 or "未知怪物", valid_monsters.rarity or 0, distance))
                poe2_api.dbgp("is_friendly: ", tostring(valid_monsters.is_friendly))
                poe2_api.dbgp("hasLineOfSight: ", tostring(valid_monsters.hasLineOfSight))
                poe2_api.dbgp("isActive: ", tostring(valid_monsters.isActive))
                -- poe2_api.dbgp("isActive: ", tostring(valid_monsters.isActive))
                -- poe2_api.dbgp("rarity: ", tostring(valid_monsters.rarity))
                -- poe2_api.dbgp("path_name_utf8: ", tostring(valid_monsters.path_name_utf8))
                poe2_api.dbgp("obj: ", tostring(string.format("%x",valid_monsters.obj)))
                poe2_api.dbgp("grid_x: ", tostring(string.format("%x",valid_monsters.grid_x)))
                poe2_api.dbgp("grid_y: ", tostring(string.format("%x",valid_monsters.grid_y)))
                -- api_ClickMove(valid_monsters.grid_x, valid_monsters.grid_y, player_info.world_z, 0)
                poe2_api.dbgp("magicProperties: ", tostring(valid_monsters.magicProperties))
                poe2_api.printTable(valid_monsters.magicProperties)
                -- poe2_api.dbgp("stateMachineList: ", tostring(valid_monsters.stateMachineList))
                poe2_api.dbgp("血量：", valid_monsters.life )
                -- poe2_api.print_log("type --> ", type(valid_monsters))
                poe2_api.dbgp("++++++++++++++++++++++++++++++++++")
                
                -- 特殊Boss处理
                local special_bosses = {game_str.snake_king, game_str.The_Forgotten_Prisoner_NAME}
                if poe2_api.table_contains(valid_monsters.name_utf8, special_bosses) and distance > 50 and not valid_monsters.isActive then
                    poe2_api.dbgp("special_bosses,或者未激活")
                    _handle_special_boss_movement(valid_monsters, player_info)
                    poe2_api.dbgp("移动到目标附近444")
                    return bret.FAIL
                end
                -- 构建可用技能池

                local available_skills = _get_available_skills(valid_monsters.rarity)

                local min_attack_range = 0
                if available_skills and #available_skills > 0 then
                    for _, skill in ipairs(available_skills) do
                        if skill.attack_range > min_attack_range then
                            min_attack_range = skill.attack_range
                        end
                    end
                end

                env.min_attack_range = min_attack_range
                
                if available_skills and #available_skills > 0 then
                    local selected_skill = _select_skill(available_skills)
                    if distance > 25 then
                        poe2_api.printTable(valid_monsters.magicProperties)
                        -- 检查特殊词缀
                        for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                            if poe2_api.table_contains(valid_monsters.magicProperties, prop) then
                                env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                poe2_api.dbgp("移动到目标附近111")
                                return bret.FAIL
                            end
                            ::continue_prop::
                        end
                    end

                    poe2_api.dbgp("selected_skill.attack_range", selected_skill.attack_range)
                    poe2_api.dbgp("min_attack_range", min_attack_range)
                    poe2_api.dbgp("distance", distance)

                    if valid_monsters.name_utf8 ~= game_str.The_Tyrant_of_Bones_NAME then
                        poe2_api.dbgp("11111111111111")
                        if distance > selected_skill.attack_range and distance > min_attack_range or not valid_monsters.isActive then
                            poe2_api.dbgp("移动到目标附近")
                            if string.find(player_info.current_map_name_utf8, game_str.Delirium_) and distance > selected_skill.attack_range then
                                env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                poe2_api.dbgp("移动到目标附近222")
                                return bret.SUCCESS
                            end
                            -- -- 拾取不移动
                            -- if need_item and not env.center_point and not center_radius then
                            --     return bret.FAIL
                            -- end

                            -- if env.is_map_complete then
                            --     -- 寻找传送门
                            --     if env.range_info then
                            --         for _, k in ipairs(env.range_info) do
                            --             if k.name_utf8 ~= '' and k.type == 5 and poe2_api.table_contains(k.name_utf8, my_game_info.hideout_CH) then
                            --                 dis = poe2_api.point_distance(k.grid_x, k.grid_y, player_info)
                            --                 if dis and dis < 25 then
                            --                     if not poe2_api.find_text({UI_info = env.UI_info, text = k.name_utf8, click = 2}) then
                            --                         api_ClickMove(poe2_api.toInt(k.grid_x), poe2_api.toInt(k.grid_y), poe2_api.toInt(k.world_z), 1)
                            --                     end
                            --                 end
                            --             end
                            --         end
                            --     end

                            --     env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                            --     poe2_api.dbgp("移动到目标附近555")
                            --     return bret.SUCCESS
                            -- end
                            
                            if env.afoot_altar then
                                local distance = poe2_api.point_distance(env.afoot_altar.grid_x, env.afoot_altar.grid_y, env.player_info)
                                if distance < 105 then
                                    env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                    poe2_api.dbgp("移动到目标附近222")
                                    return bret.FAIL
                                end
                            end

                            -- if env.afoot_box then
                            --     local distance = poe2_api.point_distance(env.afoot_box.grid_x, env.afoot_box.grid_y, env.player_info)
                            --     if distance < 120 then
                            --         env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                            --         poe2_api.dbgp("移动到目标附近333")
                            --         return bret.FAIL
                            --     end
                            -- end
                            
                            if poe2_api.table_contains(valid_monsters.rarity, {2, 3}) then
                                poe2_api.dbgp("精英怪移动到目标附近")
                                env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                return bret.FAIL
                            -- else
                            --     return bret.SUCCESS
                            end
                            return bret.SUCCESS
                        end
                    else
                        if distance > 80 then
                            env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                            poe2_api.dbgp("移动到目标附近333")
                            return bret.FAIL
                        end
                    end
                    
                    _execute_skill(selected_skill, valid_monsters, player_info)
                    poe2_api.dbgp("释放：")
                    poe2_api.printTable(selected_skill)
                    if select_skill then
                        env.select_skill = selected_skill
                    else
                        env.select_skill = nil
                    end
                    -- if valid_monsters.rarity > 1 then
                    --     poe2_api.time_p("ReleaseSkillAction(RUNNING) 耗时 --> ", api_GetTickCount64() - current_time_ms)
                    --     return bret.RUNNING
                    -- end
                    poe2_api.time_p("ReleaseSkillAction 耗时(123123123123) --> ", api_GetTickCount64() - current_time_ms)
                    return bret.SUCCESS
                end
                poe2_api.dbgp("ReleaseSkillAction bret.FAIL")
                -- return bret.RUNNING
                return bret.SUCCESS
            end

            poe2_api.time_p("ReleaseSkillAction 耗时(hcdhfhfhfhf) --> ", api_GetTickCount64() - current_time_ms)
            return bret.SUCCESS
        end
    },

    -- 检查是否到达点
    Is_Arrive_Point = {
        run = function(self, env)
            poe2_api.print_log("检查是否到达目标点...")
            return bret.SUCCESS
        end
    },

    -- 进入异界地图节点
    Enter_Map = {
        name = "进入异界地图",
        run = function(self, env)
            local current_time = api_GetTickCount64()

            -- while true do
            --     return bret.FAIL
            -- end
            
            local player_info = env.player_info
            if not poe2_api.table_contains(env.player_info.current_map_name_utf8,my_game_info.hideout) then
                return bret.RUNNING
			end
            poe2_api.print_log("进入异界地图...")
            local is_map_complete = env.is_map_complete
            poe2_api.print_log("进入异界地图env.is_map_complete...", env.is_map_complete)
            local one_other_map = env.one_other_map
            local not_enter_map = env.not_enter_map
            local click_counter = env.enter_map_click_counter or 0
            local error_other_map = env.error_other_map or {}
            local click_grid_pos = env.click_grid_pos
            
            
            -- 检查加载中状态
            if poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.loading_screen_tip_label}) then
                return bret.RUNNING
            end

            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Restructuring, add_x = 240}) then
                poe2_api.click_keyboard("spcae")
                return bret.RUNNING
            end

            if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0}) then
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.backpack, add_x = 250, min_x = 1020}) then
                    poe2_api.click_keyboard("i")
                    api_Sleep(500)
                    return bret.RUNNING
                end

                -- 检查仓库页面
                local warehouse_page = {game_str.Warehouse,game_str.Holy_Land_Lock_Cabinet_TWCH,game_str.Guild_Warehouse}
                if poe2_api.find_text({UI_info = env.UI_info, text = warehouse_page, min_x = 0, max_y = 78,add_x = 253}) and
                poe2_api.find_text({UI_info = env.UI_info, text = game_str.Emphasize_the_item, min_x = 0}) then
                    poe2_api.dbgp("检测到仓库页面，将执行点击操作")
                    poe2_api.find_text({UI_info = env.UI_info, text = warehouse_page, min_x = 0, max_y = 78, click = 2, add_x = 253})
                    return bret.RUNNING
                end
            end
            
            -- 获取符合条件的非地图物品（传送点/异界之门除外）
            local function get_not_map(num)
                num = num or 1
                local valid_items = {}
                if env.special_mode_enabled then
                    for _, item in ipairs(env.range_info) do
                        if item.type == 5 and item.name_utf8 ~= '' and item.name_utf8 ~= game_str.Transfer_point_CH and item.name_utf8 == env.special_map_door_name then
                            table.insert(valid_items, item)
                        end
                    end
                else
                    for _, item in ipairs(env.range_info) do
                        if item.type == 5 and item.name_utf8 ~= '' and item.name_utf8 ~= game_str.Transfer_point_CH and item.name_utf8 ~= game_str.The_Gate_of_the_Outland_CH then
                            table.insert(valid_items, item)
                        end
                    end
                end
                
                
                -- 检查是否达到阈值数量
                if #valid_items < num then
                    return false
                end
                
                -- 按距离排序，返回最近的物品
                if #valid_items > 0 then
                    table.sort(valid_items, function(a, b)
                        a_dis = poe2_api.point_distance(a.grid_x, a.grid_y, player_info)
                        b_dis = poe2_api.point_distance(b.grid_x, b.grid_y, player_info)
                        if a_dis and b_dis then
                            return a_dis < b_dis
                        else
                            return false
                        end
                    end)
                    
                    -- -- 打印排序后的结果（调试用）
                    -- for i, item in ipairs(valid_items) do
                    --     local distance = poe2_api.point_distance(item.grid_x, item.grid_y, player_info)
                    --     poe2_api.dbgp(string.format("[dbgp] #%d: %s 距离=%.2f", i, item.name_utf8, distance))
                    -- end
                    
                    return valid_items[1]
                end
                
                return false
            end
            
            -- 点击计数器检查
            if click_counter >= 5 then
                env.is_map_complete = true
                env.one_other_map = nil
                env.enter_map_click_counter = 0
                
                return bret.FAIL
            end
            
            -- 错误文本检查
            local error_text = {game_str.Server_disconnected_TWCH, game_str.Error_Unable_to_enter_TWCH, game_str.Startup_failed_TWCH}
            for _, k in ipairs(error_text) do
                if poe2_api.find_text({UI_info = env.UI_info, text = k, min_x = 0}) then
                    if one_other_map then
                        table.insert(error_other_map, one_other_map)
                    end
                    env.one_other_map = nil
                    if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.clear, min_x = 0}) then
                        api_Sleep(1000)
                        poe2_api.click_keyboard("enter")
                        api_Sleep(500)
                        poe2_api.paste_text(game_str.clear)
                        api_Sleep(500)
                        poe2_api.click_keyboard("enter")
                        api_Sleep(500)
                        self.bool = true
                        
                        return bret.RUNNING
                    end
                end
            end
            -- env.click_grid_pos = true
            -- 检查是否在藏身处
            if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                -- poe2_api.dbgp("Enter_Map:is_map_complete ==> ", tostring(is_map_complete))
                -- poe2_api.dbgp("Enter_Map:one_other_map ==> ", (one_other_map and one_other_map.name_cn_utf8 or "nil"))
                
                if env.range_info then
                    local items = get_not_map()
                    if items and not one_other_map and not is_map_complete and not poe2_api.table_contains({items.name_utf8}, not_enter_map) then
                        poe2_api.dbgp("items: ", items.name_utf8)

                        
                        if poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0, refresh = true}) or 
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, min_x = 0, refresh = true}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0, click = 2, add_x = 216, refresh = true})
                            env.click_grid_pos = true
                            
                            return bret.RUNNING
                        end

                        dis = poe2_api.point_distance(items.grid_x, items.grid_y, player_info)
                        if dis and dis > 30 then
                            env.is_map_complete = false
                            env.end_point = {items.grid_x, items.grid_y}
                            return bret.SUCCESS
                        else
                            
                            env.enter_map_click_counter = click_counter + 1

                            if player_info.isMoving then
                                poe2_api.dbgp("等待静止")
                                api_Sleep(1000)
                                return bret.RUNNING
                            end

                            if env.click_grid_pos then
                                api_ClickMove(poe2_api.toInt(items.grid_x), poe2_api.toInt(items.grid_y), 1, items.world_z)
                                api_Sleep(1000)
                                return bret.RUNNING
                            end
                            
                            poe2_api.find_text({UI_info = env.UI_info, text = items.name_utf8, click = 2, sorted = true, min_x = 0})

                            api_Sleep(1000)
                            if not poe2_api.find_text({UI_info = env.UI_info, text = items.name_utf8, click = 2, sorted = true, min_x = 0}) then
                                api_ClickMove(poe2_api.toInt(items.grid_x), poe2_api.toInt(items.grid_y), 1, items.world_z)
                                api_Sleep(1000)
                            end
                            
                            return bret.RUNNING
                        end
                    end
                    
                    local not_map = get_not_map()
                    if one_other_map and not_map and not is_map_complete and not_map.name_utf8 == one_other_map.name_cn_utf8 and 
                    not poe2_api.table_contains({one_other_map.name_cn_utf8}, not_enter_map) then
                        poe2_api.dbgp("not_map: ", not_map.name_utf8)

                        if not poe2_api.find_text({UI_info = env.UI_info, text = one_other_map.name_cn_utf8, min_x = 0, refresh = true}) and 
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0, refresh = true}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0, click = 2, add_x = 216, refresh = true})
                            env.click_grid_pos = true
                            
                            return bret.RUNNING
                        end
                        
                        -- 记录地图开始时间和名称
                        env.map_start_time = api_GetTickCount64()
                        env.map_name = one_other_map.name_cn_utf8
                        env.map_recorded = false
                        
                        if poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0, refresh = true}) or 
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, min_x = 0}) then
                            poe2_api.click_position(1013, 25)
                            return bret.RUNNING
                        end
                        
                        dis = poe2_api.point_distance(not_map.grid_x, not_map.grid_y, player_info)
                        if dis and dis > 30 then
                            env.is_map_complete = false
                            env.end_point = {not_map.grid_x, not_map.grid_y}
                            return bret.SUCCESS
                        else
                            env.enter_map_click_counter = click_counter + 1
                            if player_info.isMoving then
                                poe2_api.dbgp("等待静止")
                                api_Sleep(1000)
                                return bret.RUNNING
                            end

                            if env.click_grid_pos then
                                api_ClickMove(poe2_api.toInt(not_map.grid_x), poe2_api.toInt(not_map.grid_y), 1, not_map.world_z)
                                api_Sleep(1000)
                                
                                return bret.RUNNING
                            end
                            
                            poe2_api.find_text({UI_info = env.UI_info, text = not_map.name_utf8, click = 2, sorted = true, min_x = 0})

                            api_Sleep(1000)
                            if not poe2_api.find_text({UI_info = env.UI_info, text = not_map.name_utf8, click = 2, sorted = true, min_x = 0}) then
                                api_ClickMove(poe2_api.toInt(not_map.grid_x), poe2_api.toInt(not_map.grid_y), 1, not_map.world_z)
                                api_Sleep(1000)
                            end
                            
                            return bret.RUNNING
                        end
                    end
                end
            end
            return bret.FAIL
        end
    },

    -- 放置异界地图节点
    Put_Map_In_Otherworld = {
        run = function(self, env)
            poe2_api.print_log("放置异界地图节点...")
            if not self.last_action_time then
                self.last_action_time = 0  -- 记录上次操作时间
                self.action_interval = 1  -- 操作间隔时间
                self.open_num = 0          -- 操作计数器
                self.add_num = 1           -- 方向计数器
                self.origin_point = {}    -- 原点坐标
                self.expansion_step = 1    -- 扩张步数
                self.spiral_round = 0      -- 螺线圈数
            end

            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            local one_other_map = env.one_other_map
            local bag_info = env.bag_info
            local user_map = env.user_map
            local not_use_map = env.not_use_map
            local sorted_map = env.sorted_map
            local not_enter_map = env.not_enter_map
            local error_other_map = env.error_other_map or {}
            local not_have_stackableCurrency = env.not_have_stackableCurrency
            local not_attack_mos = nil
            local entry_length = 0
            local color = 0
            
            -- 检查加载中状态
            if poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.loading_screen_tip_label}) then
                return bret.RUNNING
            end
            
            if not player_info then
                return bret.RUNNING
            end
            
            if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0}) then
                return bret.FAIL
            end

            local otherworld_info = nil
            if not otherworld_info then
                local otherworld_info1 = api_GetEndgameMapNodes()
                if not otherworld_info1 then
                    poe2_api.dbgp("未找到异界地图节点信息")
                    return bret.RUNNING
                end
                otherworld_info = otherworld_info1
            end
            
            -- 检查背包中的地图
            local function check_map_in_bag(bag_info, return_count)
                return_count = return_count or true
                local matches = {}
                
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        if item.baseType_utf8 and string.find(item.baseType_utf8, game_str.Map_Key_CH) then
                            table.insert(matches, item)
                        end
                    end
                end
                
                if return_count then
                    return #matches > 0 and #matches or false
                else
                    return #matches > 0 and matches or false
                end
            end
            
            if current_time - self.last_action_time >= self.action_interval then
                if otherworld_info == nil or #otherworld_info == 0 then
                    return bret.RUNNING
                end
                
                if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) and 
                poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0}) then

                    local point1, point2 = api_GetcurrentEndgameNodePoints()
                    
                    if not one_other_map or (not one_other_map.isMapAccessible and one_other_map.isCompleted) then
                        -- 获取地图信息
                        local map_info = nil
                        if env.first_map and env.first_map == game_str.Corruption_Sanctuary_TWCH then
                            poe2_api.dbgp("腐化聖域1")
                            map_info = poe2_api.get_map(
                            {otherworld_info = otherworld_info, sorted_map = sorted_map, not_enter_map = not_enter_map, bag_info = bag_info, 
                            key_level_threshold = user_map, not_use_map = not_use_map, 
                            error_other_map = error_other_map, 
                            not_have_stackableCurrency = not_have_stackableCurrency, currency_point = {x = point1, y = point2}, enter_city = env.enter_city}
                        )
                        else
                            poe2_api.dbgp("not腐化聖域2")
                            map_info = poe2_api.get_map_oringin(
                                {otherworld_info = otherworld_info, sorted_map = sorted_map, not_enter_map = not_enter_map, bag_info = bag_info, 
                                key_level_threshold = user_map, not_use_map = not_use_map, 
                                error_other_map = error_other_map, 
                                not_have_stackableCurrency = not_have_stackableCurrency, currency_point = {x = point1, y = point2}, enter_city = env.enter_city}
                            )
                        end

                        poe2_api.printTable(map_info)
                        
                        if map_info then
                            poe2_api.dbgp("map_info.name_utf8: ", map_info.name_cn_utf8)
                            -- poe2_api.dbgp("map_info.mapPlayModes: ")
                            -- poe2_api.printTable(map_info.mapPlayModes)
                            poe2_api.printTable(map_info)
                            -- api_EndgameNodeMove(map_info.position_x - 1900, map_info.position_y - 1900)
                            -- api_Sleep(10000)
                        end
                        if not map_info then
                            
                            -- poe2_api.dbgp("point: ", point)
                            if point1 ~= 0 and point2 ~= 0 then
                                if not env.origin_point then
                                    env.origin_point = {x = point1, y = point2}
                                    env.expansion_step = 1
                                    env.add_num = 1  -- 从1开始，对应四个方向
                                    env.spiral_round = 1
                                end
                                
                                -- poe2_api.dbgp("当前点: ", point1, point2)
                                -- poe2_api.dbgp("原点: ", env.origin_point.x, env.origin_point.y)
                                
                                -- 计算动态扩张因子（使扩张速度逐渐加快）
                                local dynamic_factor = 1 + (env.spiral_round * 0.2)  -- 每圈增加20%扩张速度
                                
                                -- 计算当前扩张距离（使用动态因子）
                                local base_offset = math.floor(4000 * env.expansion_step * dynamic_factor)
                                local diagonal_offset = math.floor(2000 * env.expansion_step * dynamic_factor)
                                
                                -- 定义四个方向的偏移（基于固定起点）
                                local move_directions = {
                                    [1] = {env.origin_point.x + base_offset, env.origin_point.y + base_offset},      -- 右上
                                    [2] = {env.origin_point.x - base_offset, env.origin_point.y + diagonal_offset},  -- 左上
                                    [3] = {env.origin_point.x - base_offset, env.origin_point.y - base_offset},      -- 左下
                                    [4] = {env.origin_point.x + base_offset, env.origin_point.y - diagonal_offset}   -- 右下
                                }
                                
                                -- 获取目标位置
                                local target_x, target_y = move_directions[env.add_num][1], move_directions[env.add_num][2]
                                
                                -- poe2_api.dbgp("移动方向: ", env.add_num)
                                -- poe2_api.dbgp("扩张步数: ", env.expansion_step)
                                -- poe2_api.dbgp("螺旋圈数: ", env.spiral_round)
                                -- poe2_api.dbgp("动态因子: ", dynamic_factor)
                                -- poe2_api.dbgp("目标位置: ", target_x, target_y)
                                
                                -- 执行移动
                                api_EndgameNodeMove(target_x, target_y)
                                
                                -- 更新方向和扩张参数
                                env.add_num = (env.add_num % 4) + 1
                                if env.add_num == 1 then  -- 完成一圈后
                                    env.expansion_step = env.expansion_step + 1
                                    env.spiral_round = env.spiral_round + 1  -- 增加螺线圈数
                                end
                                
                                poe2_api.dbgp("等待地图加载 (5s)")
                                api_Sleep(2000)
                            end
                            return bret.RUNNING
                        else
                            self.add_num = 1
                            self.expansion_step = 1
                            self.spiral_round = 0
                            self.origin_point = {}
                        end
                        
                        entry_length = 0
                        local vall = false
                        if map_info and map_info.mapPlayModes and poe2_api.table_contains(map_info.mapPlayModes, game_str.Corruption_Sanctuary_TWCH) then
                            entry_length = 4
                            color = 2
                            vall = true
                        end
                        
                        local map_level = poe2_api.select_best_map_key({inventory = bag_info,
                            key_level_threshold = user_map, not_use_map = not_use_map, color = color, entry_length = entry_length, vall = vall})
                        
                        if entry_length > 0 and map_level ~= nil then
                            if entry_length > map_level.fixedSuffixCount then
                                env.entry_length_take_map = true
                                env.the_update_map = map_level
                                env.map_update_to = entry_length
                                env.map_up = true
                                return bret.RUNNING
                            else
                                env.entry_length_take_map = false
                                env.the_update_map = nil
                                env.map_update_to = 0
                                env.map_up = false
                            end
                        end
                        
                        if map_info then
                            api_EndgameNodeMove(map_info.position_x - 1900, map_info.position_y - 1900)
                            env.one_other_map = map_info
                            api_Sleep(1000)
                            
                            return bret.RUNNING
                        else
                            
                            return bret.RUNNING
                        end
                    end
                    
                    if one_other_map then
                        if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Region_TWCH}) and 
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Private_message}) and 
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Power_TWCH}) and 
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Guild_TWCH}) then
                            poe2_api.click_keyboard('esc')
                        end
                        
                        if type(one_other_map) == "boolean" then
                            self.last_action_time = current_time
                            
                            return bret.RUNNING
                        end
                        
                        if one_other_map.name_utf8 and not poe2_api.table_contains(my_game_info.trash_map, one_other_map.name_utf8) and 
                        one_other_map.isMapAccessible and not one_other_map.isCompleted then
                            
                            if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.Crossing_TWCH, min_x = 0}) then
                                if self.open_num > 5 and poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, max_y = 100, min_x = 0}) then
                                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, max_y = 100, min_x = 0, click = 2, add_x = 212})
                                    table.insert(error_other_map, one_other_map)
                                    env.one_other_map = nil
                                    api_Sleep(1000)
                                    self.open_num = 0
                                    
                                    return bret.RUNNING
                                end
                                poe2_api.dbgp("更新前window_client_x, window_client_y --> ", one_other_map.window_client_x, ", ", one_other_map.window_client_y)
                                api_EndgameNodeMove(one_other_map.position_x - 1900, one_other_map.position_y - 1900)
                                api_Sleep(200)
                                
                                local one_other_map_refresh = api_GetEndgameMapNodes()
                                local window_client_x
                                local window_client_y
                                if one_other_map_refresh then
                                    for _, k1 in ipairs(one_other_map_refresh) do
                                        if k1.name_utf8 == one_other_map.name_utf8 and 
                                        k1.index_x == one_other_map.index_x and 
                                        k1.index_y == one_other_map.index_y then
                                            poe2_api.printTable(k1)
                                            if k1.window_client_x == 0 or k1.window_client_y == 0 then
                                                poe2_api.dbgp("更新后window_client_x, window_client_y --> ", k1.window_client_x, ", ", k1.window_client_y)
                                                -- env.need_SmallRetreat = true
                                                return bret.RUNNING
                                            end
                                            api_ClickScreen(k1.window_client_x, k1.window_client_y,0)
                                            window_client_x = k1.window_client_x
                                            window_client_y = k1.window_client_y
                                            api_Sleep(500)
                                        end
                                    end
                                end
                                
                                if poe2_api.find_text({UI_info = env.UI_info, text = one_other_map.name_cn_utf8, min_x = 0}) then
                                    api_ClickScreen(window_client_x, window_client_y,1)
                                    api_Sleep(500)
                                    api_EndgameNodeMove(one_other_map.position_x - 3900, one_other_map.position_y - 3900)
                                end
                                
                                self.last_action_time = current_time
                                self.open_num = self.open_num + 1
                                api_Sleep(100)
                                
                                return bret.RUNNING
                            end
                            
                            if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.backpack, min_x = 1020}) then
                                poe2_api.click_keyboard('i')
                                api_Sleep(1000)
                                self.last_action_time = current_time
                                return bret.RUNNING
                            end
                            
                            local k = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Crossing_TWCH, min_x = 0, position = 2})
                            local center_x = nil
                            local center_y = nil
                            if k.text_utf8 == game_str.Crossing_TWCH then
                                center_x = math.floor((k.left + k.right) / 2)
                                center_y = math.floor((k.top + k.bottom) / 2)
                            end
                            -- poe2_api.printTable(k)
                            -- poe2_api.dbgp("center_x -->", center_x)
                            -- poe2_api.dbgp("center_y -->", center_y)
                            
                            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.backpack, min_x = 1020}) and k then
                                if k.text_utf8 == game_str.Crossing_TWCH then
                                    local count = api_Getinventorys(0xe,0)
                                    poe2_api.dbgp("count -->", #count)
                                    -- api_Sleep(100000)
                                    if count then
                                        entry_length = 0
                                        local map_level = nil
                                        local vall = false
                                        
                                        if one_other_map and one_other_map.mapPlayModes and 
                                        poe2_api.table_contains(one_other_map.mapPlayModes, game_str.Corruption_Sanctuary_TWCH) then
                                            entry_length = 4
                                            vall = true
                                        end
                                    
                                        map_level = poe2_api.select_best_map_key(
                                            {inventory = count, 
                                            key_level_threshold = user_map, not_use_map = not_use_map, 
                                            color = color, vall = vall}
                                        )
                                        -- poe2_api.printTable(map_level)


                                        if map_level and (#count > 1 or (entry_length > 0 and entry_length > map_level.fixedSuffixCount)) then
                                            -- for _, k in ipairs(count) do
                                            --    poe2_api.dbgp("22222")
                                            --    poe2_api.select_best_map_key(
                                            --        {inventory = api_Getinventorys(0xe,0), index = 1, click = 1, 
                                            --        type = 3, START_X = center_x - 47, START_Y = center_y - 125}
                                            --    )
                                            --    api_Sleep(500)
                                            --end
                                            local items = api_GetInventoryItemsInRect(center_x - 210,center_y - 290,center_x + 160,center_y + 20)
                                            local map_item = nil
                                            for i,v in ipairs(items) do 
                                                if v.baseType_utf8 == map_level.baseType_utf8 and v.category_utf8 == map_level.category_utf8 and v.not_identified == map_level.not_identified and v.fixedSuffixCount == map_level.fixedSuffixCount and v.color == map_level.color then
                                                    map_item = v
                                                end
                                            end
                                            if map_item then
                                                poe2_api.ctrl_left_click(((map_item.RectSart_x + map_item.RectEnd_x) / 2), ((map_item.RectSart_y + map_item.RectEnd_y) / 2))
                                            end
                                            return bret.RUNNING
                                        elseif count and #count == 1 then
                                            need_put = false
                                        else
                                            need_put = true
                                        end
                                    end
                                end
                            end
                            
                            if need_put then
                                if not check_map_in_bag(bag_info) then
                                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, max_y = 100, min_x = 250}) then
                                        poe2_api.dbgp1("SDGBWSGDASGSDG")
                                        poe2_api.click_keyboard("space")
                                    end
                                    
                                    return bret.SUCCESS
                                end
                                
                                entry_length = 0
                                local vall = false
                                if one_other_map and one_other_map.mapPlayModes and 
                                poe2_api.table_contains(one_other_map.mapPlayModes, game_str.Corruption_Sanctuary_TWCH) then
                                    entry_length = 4
                                    color = 2
                                    vall = true
                                end
                                
                                local map_level = poe2_api.select_best_map_key(
                                    {inventory = bag_info, 
                                    key_level_threshold = user_map, not_use_map = not_use_map, 
                                    color = color, vall = vall}
                                )
                                
                                if entry_length > 0 and map_level then
                                    if entry_length > map_level.fixedSuffixCount then
                                        env.entry_length_take_map = true
                                        env.the_update_map = map_level
                                        env.map_update_to = entry_length
                                        env.map_up = true
                                        return bret.RUNNING
                                    else
                                        env.entry_length_take_map = false
                                        env.the_update_map = nil
                                        env.map_update_to = 0
                                        env.map_up = false
                                    end
                                end

                                map_level = poe2_api.select_best_map_key(
                                    {inventory = bag_info, 
                                    click = 1, key_level_threshold = user_map, not_use_map = not_use_map, 
                                    entry_length = entry_length}
                                )

                                poe2_api.dbgp("map_level",map_level)

                                if map_level then
                                    local attack_distance = nil
                                    not_attack_mos = {}
                                    for _, config in ipairs(user_map) do
                                        if config["階級"] == map_level then
                                            attack_distance = config["搜怪距離"] or 100
                                            
                                            if config["不打Boss"] then
                                                table.insert(not_attack_mos, 3)
                                            end
                                            if config["不打黃怪"] then
                                                table.insert(not_attack_mos, 2)
                                            end
                                            if config["不打藍怪"] then
                                                table.insert(not_attack_mos, 1)
                                            end
                                            if config["不打白怪"] then
                                                table.insert(not_attack_mos, 0)
                                            end
                                            
                                            break
                                        end
                                    end
                                    env.map_level_dis = attack_distance
                                    if #not_attack_mos > 0 then
                                        table.sort(not_attack_mos)
                                        env.not_attack_mos = not_attack_mos
                                    else
                                        env.not_attack_mos = not_attack_mos
                                    end
                                else
                                    poe2_api.dbgp("背包没有合适的地图钥匙")
                                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0}) then
                                        poe2_api.click_keyboard("space")
                                    end
                                    env.map_level_dis = nil
                                    env.is_have_map = false
                                end
                                poe2_api.dbgp("2222222")
                                api_Sleep(500)
                                
                                return bret.RUNNING
                            else
                                local maps = api_Getinventorys(0xe,0)
                                if maps and #maps > 0 then
                                    poe2_api.dbgp("len(maps): ", #maps)
                                    local map_level = poe2_api.extract_key_level(maps[1].baseType_utf8)
                                    
                                    local attack_distance = nil
                                    not_attack_mos = {}
                                    
                                    for _, config in ipairs(user_map) do
                                        if config["階級"] == map_level then
                                            attack_distance = config["搜怪距離"]
                                            
                                            if config["不打Boss"] then
                                                table.insert(not_attack_mos, 3)
                                            end
                                            if config["不打黃怪"] then
                                                table.insert(not_attack_mos, 2)
                                            end
                                            if config["不打藍怪"] then
                                                table.insert(not_attack_mos, 1)
                                            end
                                            if config["不打白怪"] then
                                                table.insert(not_attack_mos, 0)
                                            end
                                            
                                            break
                                        end
                                    end
                                    
                                    if attack_distance == nil then
                                        attack_distance = 100
                                    end
                                    
                                    env.map_level_dis = attack_distance
                                    env.not_attack_mos = not_attack_mos
                                    
                                    if maps and entry_length > 0 then
                                        local suffx = api_GetObjectSuffix(maps[1].mods_obj)
                                        -- poe2_api.dbgp("===========")
                                        -- poe2_api.printTable(maps[1])
                                        -- poe2_api.dbgp("----")
                                        -- poe2_api.printTable(suffx)
                                        -- api_Sleep(10000)
                                        if suffx and #suffx < entry_length then
                                            poe2_api.select_best_map_key({inventory = api_Getinventorys(0xe,0), index = 1, click = 1, type = 3, START_X = center_x - 47, START_Y = center_y - 125})
                                            env.one_other_map = nil
                                            env.map_level_dis = nil
                                            
                                            return bret.RUNNING
                                        end
                                    end

                                    local function check_plaque_position()
                                        local a = poe2_api.find_text({UI_info = env.UI_info, refresh = true, text = game_str.Crossing_TWCH, position = 1})
                                        if not a then
                                            poe2_api.dbgp("未找到game_str.Crossing_TWCH文字")
                                            return false, {}, 0, {}
                                        end
                                        
                                        poe2_api.printTable(a)
                                        local min_x = a[1] - 70
                                        local min_y = a[2] - 67
                                        local max_x = a[3] + 70
                                        local max_y = a[2] - 9
                                        
                                        local map = api_GetInventoryItemsInRect(min_x, min_y, max_x, max_y)
                                        
                                        -- 按照 x 坐标排序
                                        table.sort(map, function(a, b)
                                            return a.RectSart_x < b.RectSart_x
                                        end)
                                        
                                        poe2_api.printTable(map)
                                        poe2_api.dbgp("===========")
                                        poe2_api.printTable(env.stone_order)
                                        
                                        -- 检查整体顺序是否正确
                                        local need_rearrange = false
                                        local check_count = math.min(3, #map, #env.stone_order)
                                        
                                        if check_count == 0 then
                                            poe2_api.dbgp("没有需要检查的物品")
                                            return false, {}, check_count, {}
                                        end
                                        
                                        -- 找出需要取出的错误位置的物品
                                        local items_to_remove = {}
                                        local correct_positions = {} -- 记录每个正确物品应该在的位置
                                        
                                        -- 创建当前位置的物品名称列表
                                        local current_order = {}
                                        for i = 1, check_count do
                                            current_order[i] = map[i].baseType_utf8
                                            correct_positions[env.stone_order[i]] = i
                                        end
                                        
                                        poe2_api.dbgp("当前顺序: " .. table.concat(current_order, ", "))
                                        poe2_api.dbgp("正确顺序: " .. table.concat(env.stone_order, ", "))
                                        
                                        -- 检查整体顺序：提取当前存在的正确顺序物品，检查它们的相对顺序
                                        local current_correct_items = {}
                                        local current_correct_indices = {}
                                        
                                        for i = 1, check_count do
                                            local current_item = current_order[i]
                                            -- 检查这个物品是否在正确顺序中
                                            for j = 1, #env.stone_order do
                                                if current_item == env.stone_order[j] then
                                                    table.insert(current_correct_items, current_item)
                                                    table.insert(current_correct_indices, {current_index = i, correct_index = j})
                                                    break
                                                end
                                            end
                                        end
                                        
                                        poe2_api.dbgp("当前存在的正确物品: " .. table.concat(current_correct_items, ", "))
                                        
                                        -- 检查这些正确物品的相对顺序是否正确
                                        if #current_correct_items > 1 then
                                            for i = 1, #current_correct_items - 1 do
                                                local current_correct_index1 = current_correct_indices[i].correct_index
                                                local current_correct_index2 = current_correct_indices[i + 1].correct_index
                                                
                                                -- 如果后面的物品在正确顺序中应该出现在前面，说明顺序错误
                                                if current_correct_index1 > current_correct_index2 then
                                                    need_rearrange = true
                                                    poe2_api.dbgp(string.format("顺序错误: %s(%d) 不应该在 %s(%d) 前面", 
                                                        current_correct_items[i], current_correct_index1,
                                                        current_correct_items[i + 1], current_correct_index2))
                                                    break
                                                end
                                            end
                                        end
                                        
                                        -- 如果没有正确物品或者顺序正确，但位置不完整，也需要重新排列
                                        if #current_correct_items < check_count and not need_rearrange then
                                            need_rearrange = true
                                            poe2_api.dbgp("位置不完整，需要重新排列")
                                        end
                                        
                                        -- 如果需要重新排列，标记所有物品为需要取出
                                        if need_rearrange then
                                            for i = 1, check_count do
                                                table.insert(items_to_remove, {
                                                    index = i,
                                                    name = map[i].baseType_utf8,
                                                    x = (map[i].RectSart_x + map[i].RectEnd_x) / 2,
                                                    y = (map[i].RectSart_y + map[i].RectEnd_y) / 2
                                                })
                                            end
                                            poe2_api.dbgp("整体顺序不正确，需要重新排列")
                                            poe2_api.dbgp("需要取出的物品数量: " .. #items_to_remove)
                                            return true, items_to_remove, check_count, correct_positions
                                        else
                                            poe2_api.dbgp("整体顺序正确，无需重新排列")
                                            return false, {}, check_count, correct_positions
                                        end
                                    end
                                    
                                    local function remove_wrong_plaques(items_to_remove)
                                        if #items_to_remove == 0 then
                                            return true
                                        end
                                        
                                        poe2_api.dbgp("开始取出错误位置的物品...")
                                        for _, item in ipairs(items_to_remove) do
                                            poe2_api.dbgp("取出错误位置的物品: " .. item.name .. " 在位置 " .. item.index)
                                            poe2_api.click_position(item.x, item.y, 1)
                                            api_Sleep(150) -- 适当延迟确保操作完成
                                        end
                                        
                                        api_Sleep(300) -- 等待所有错误物品都被取出
                                        poe2_api.dbgp("错误物品取出完成")
                                        return false
                                    end
                                    
                                    -- 放置碑牌
                                    local function put_plaque_in_order()
                                        local map = api_Getinventorys(77, 0)
                                        if map and #map > 2 then
                                            return true
                                        end
                                        -- 如果没有设置顺序，则使用默认的任意放置
                                        if not env.stone_order or #env.stone_order == 0 then
                                            for _, item in ipairs(env.bag_info) do
                                                if item.category_utf8 == game_str.TowerAugmentation then
                                                    poe2_api.dbgp("找到碑牌物品: " .. (item.baseType_utf8 or "未知"))
                                                    poe2_api.ctrl_left_click_bag_items(item.obj, env.bag_info)
                                                    api_Sleep(400)
                                                    return false
                                                end
                                            end
                                            poe2_api.dbgp("背包中没有找到碑牌物品")
                                            return true
                                        end
                                        
                                        -- 按照指定顺序放置碑牌
                                        for _, stone_name in ipairs(env.stone_order) do
                                            for _, item in ipairs(env.bag_info) do
                                                if item.category_utf8 == game_str.TowerAugmentation and item.baseType_utf8 == stone_name then
                                                    poe2_api.dbgp("按顺序放置碑牌: " .. stone_name)
                                                    poe2_api.ctrl_left_click_bag_items(item.obj, env.bag_info)
                                                    api_Sleep(400)
                                                    return false
                                                end
                                            end
                                        end
                                        
                                        poe2_api.dbgp("没有找到指定顺序的碑牌物品")
                                        return true
                                    end
                                    
                                    -- 主执行逻辑
                                    local need_rearrange, items_to_remove, check_count, correct_positions = check_plaque_position()
                                    
                                    -- 取出错误位置的物品
                                    if not remove_wrong_plaques(items_to_remove) then
                                        return bret.RUNNING
                                    end
                                    
                                    -- 放置正确物品
                                    if not put_plaque_in_order() then
                                        return bret.RUNNING
                                    end                        
                                    
                                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Crossing_TWCH, click = 2, min_x = 0}) then
                                        api_Sleep(1000)
                                        if poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, max_y = 100, min_x = 250, refresh = true}) then
                                            return bret.RUNNING
                                        end
                                        env.click_traverse = true
                                        poe2_api.dbgp("点击穿越成功")
                                        env.is_map_complete = false
                                        self.open_num = 0
                                        env.enter_map_times = (env.enter_map_times or 0) + 1
                                        api_Sleep(3000)
                                        
                                        return bret.SUCCESS
                                    else
                                        env.one_other_map = nil
                                        env.map_level_dis = nil
                                        env.click_traverse = false
                                        
                                        return bret.RUNNING
                                    end
                                end
                            end
                        end
                    end
                    
                    
                    return bret.RUNNING
                end
            else
                
                return bret.RUNNING
            end
        end
    },

    -- 放置界域之门节点
    Put_Map_MapLeaguePortal = {
        run = function(self, env)
            poe2_api.print_log("放置界域之门节点...")
            if not self.last_action_time then
                self.last_action_time = 0  -- 记录上次操作时间
                self.action_interval = 1  -- 操作间隔时间
                self.open_num = 0          -- 操作计数器
                self.add_num = 1           -- 方向计数器
                self.origin_point = {}    -- 原点坐标
                self.expansion_step = 1    -- 扩张步数
                self.spiral_round = 0      -- 螺线圈数
            end

            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            local one_other_map = env.one_other_map
            local bag_info = env.bag_info
            local user_map = env.user_map
            local not_use_map = env.not_use_map
            local sorted_map = env.sorted_map
            local not_enter_map = env.not_enter_map
            local error_other_map = env.error_other_map or {}
            local not_have_stackableCurrency = env.not_have_stackableCurrency
            local not_attack_mos = nil
            local entry_length = 0
            local color = 0

            if not env.special_mode_enabled then
                return bret.FAIL
            end
            
            -- 检查加载中状态
            if poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.loading_screen_tip_label}) then
                return bret.RUNNING
            end
            
            if not player_info then
                return bret.RUNNING
            end
            
            if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0}) then
                return bret.FAIL
            end

            local otherworld_info = nil
            if not otherworld_info then
                local otherworld_info1 = api_GetEndgameMapNodes()
                if not otherworld_info1 then
                    poe2_api.dbgp("未找到异界地图节点信息")
                    return bret.RUNNING
                end
                otherworld_info = otherworld_info1
            end
            
            
            
            if current_time - self.last_action_time >= self.action_interval then
                if otherworld_info == nil or #otherworld_info == 0 then
                    return bret.RUNNING
                end

                
                if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) and 
                poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0}) then
                    -- 回到起点
                    local map_info = poe2_api.get_map3({otherworld_info = otherworld_info})

                    local door_item_data = api_Getinventorys(0x55, 0)

                    if not one_other_map then
                        if map_info and not env.one_other_map then
                            api_EndgameNodeMove(map_info.position_x, map_info.position_y)
                            env.one_other_map = map_info
                            -- 直接修改 name_utf8 的值
                            if env.one_other_map and env.one_other_map.name_utf8 then
                                env.one_other_map.name_cn_utf8 = env.special_map_door_name
                            end
                            return bret.RUNNING
                        else
                            -- api_EndgameNodeMove(1000,1000)
                            function dynamicSmoothEndgameMove(target_x, target_y, base_step_delay)
                                local current_x, current_y = api_GetcurrentEndgameNodePoints()
                                api_Sleep(1000)
                                
                                base_step_delay = base_step_delay or 100
                                
                                -- 计算两点之间的距离
                                local distance = math.sqrt((target_x - current_x)^2 + (target_y - current_y)^2)
                                
                                -- 根据距离动态计算步数（每单位距离0.5步）
                                local steps = math.max(100, math.min(20, math.floor(distance * 0.5)))
                                
                                local delta_x = (target_x - current_x) / steps
                                local delta_y = (target_y - current_y) / steps
                                
                                poe2_api.dbgp(string.format("动态平滑移动: 距离=%.2f, 步数=%d", distance, steps))
                                
                                for i = 1, steps do
                                    local move_x = current_x + delta_x * i
                                    local move_y = current_y + delta_y * i
                                    
                                    api_EndgameNodeMove(move_x, move_y)
                                    api_Sleep(base_step_delay)
                                end
                                
                                -- 最终精确定位
                                api_EndgameNodeMove(target_x, target_y)
                            end
                            
                            -- 使用示例
                            local point1, point2 = api_GetcurrentEndgameNodePoints()
                            -- dynamicSmoothEndgameMove(0, 0)
                            api_EndgameNodeMove(0, 0)
                            api_Sleep(1000)
                            api_ClickScreen(800, 450, 3)
                            api_Sleep(1000)
                            api_ClickScreen(400, 550, 0)
                            api_Sleep(1000)
                            api_ClickScreen(400, 550, 4)
                            -- api_ClickScreen(800, 450, 4)
                            api_Sleep(2000)
                            -- api_EndgameNodeMove(0, 0)
                            return bret.RUNNING
                        end
                    end
                    
                    if one_other_map then
                        if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Region_TWCH}) and 
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Private_message}) and 
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Power_TWCH}) and 
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Guild_TWCH}) then
                            poe2_api.click_keyboard('esc')
                        end
                        
                        if type(one_other_map) == "boolean" then
                            self.last_action_time = current_time
                            return bret.RUNNING
                        end
                        
                            
                        if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.Crossing_TWCH, min_x = 0}) then
                            if self.open_num > 5 and poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, max_y = 100, min_x = 0}) then
                                poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, max_y = 100, min_x = 0, click = 2, add_x = 212})
                                table.insert(error_other_map, one_other_map)
                                env.one_other_map = nil
                                api_Sleep(1000)
                                self.open_num = 0
                                
                                return bret.RUNNING
                            end
                            poe2_api.dbgp("更新前window_client_x, window_client_y --> ", one_other_map.window_client_x, ", ", one_other_map.window_client_y)
                            api_EndgameNodeMove(one_other_map.position_x, one_other_map.position_y)
                            api_Sleep(200)
                            
                            local one_other_map_refresh = api_GetEndgameMapNodes()
                            local window_client_x
                            local window_client_y
                            if one_other_map_refresh then
                                for _, k1 in ipairs(one_other_map_refresh) do
                                    if k1.name_utf8 == game_str.MapLeaguePortal_MDANA and 
                                    k1.index_x == one_other_map.index_x and 
                                    k1.index_y == one_other_map.index_y then
                                        poe2_api.printTable(k1)
                                        if k1.window_client_x == 0 or k1.window_client_y == 0 then
                                            poe2_api.dbgp("更新后window_client_x, window_client_y --> ", k1.window_client_x, ", ", k1.window_client_y)
                                            -- env.need_SmallRetreat = true
                                            return bret.RUNNING
                                        end
                                        api_ClickScreen(k1.window_client_x, k1.window_client_y,0)
                                        window_client_x = k1.window_client_x
                                        window_client_y = k1.window_client_y
                                        api_Sleep(500)
                                    end
                                end
                            end

                            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.MapLeaguePortal_TWCH, min_x = 0}) then
                                api_ClickScreen(window_client_x, window_client_y,1)
                                api_Sleep(500)
                                api_EndgameNodeMove(one_other_map.position_x - 3900, one_other_map.position_y - 3900)
                            end
                            
                            self.last_action_time = current_time
                            self.open_num = self.open_num + 1
                            api_Sleep(100)
                            return bret.RUNNING
                        end
                            
                        if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.backpack, min_x = 1020}) then
                            poe2_api.click_keyboard('i')
                            api_Sleep(1000)
                            self.last_action_time = current_time
                            return bret.RUNNING
                        end

                        -- env.special_mode_enabled
                        -- env.special_map_tier
                        -- env.special_map_type
                        -- env.special_storage_type
                        if not door_item_data or #door_item_data < 1 or door_item_data[1].stackCount < env.special_map_tier then
                            poe2_api.ctrl_left_click_bag_items(env.special_map_type, env.bag_info)
                            api_Sleep(1000)
                            return bret.RUNNING
                        else
                            if door_item_data[1].baseType_utf8 ~= env.special_map_type then
                                poe2_api.find_text({UI_info = env.UI_info, text = game_str.Crossing_TWCH, click = 4, min_x = 0, add_y = -65})
                            else
                                if not poe2_api.find_text({UI_info = env.UI_info, text = env.special_map_tier_text, click = 2, min_x = 0}) then
                                    api_Sleep(800)
                                    return bret.RUNNING
                                end
                                api_Sleep(1000)
                            end
                        end

                        if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Crossing_TWCH, click = 2, min_x = 0}) then
                            api_Sleep(1000)
                            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, max_y = 100, min_x = 250, refresh = true}) then
                                return bret.RUNNING
                            end
                            env.click_traverse = true
                            poe2_api.dbgp("点击穿越成功")
                            env.is_map_complete = false
                            self.open_num = 0
                            env.enter_map_times = (env.enter_map_times or 0) + 1
                            api_Sleep(3000)
                            
                            return bret.SUCCESS
                        else
                            env.one_other_map = nil
                            env.map_level_dis = nil
                            env.click_traverse = false
                            
                            return bret.RUNNING
                        end
                    end
                    return bret.RUNNING
                end
            else
                return bret.RUNNING
            end
        end
    },

    -- 清除所有遮挡物节点
    Clear_All_Page = {
        run = function(self, env)
            poe2_api.print_log('清除遮挡物...')
            if not self.last_action_time then
                self.last_action_time = 0  -- 记录上次操作时间
                self.action_interval = 1.5 -- 操作间隔时间
                self.wait_num = 0          -- 等待计数器
            end

            local current_time = api_GetTickCount64()
            
            local one_other_map = env.one_other_map
            
            local click_traverse = env.click_traverse
            local error_other_map = env.error_other_map or {}
            
            if not click_traverse then
                env.one_other_map = nil
                env.is_map_complete = true
                
                return bret.RUNNING
            end

            if not one_other_map then
                return bret.RUNNING
            end
            
            -- 获取非地图物品（传送点/异界之门除外）
            local function get_not_map()
                for _, item in ipairs(env.range_info) do
                    if item.type == 5 and item.name_utf8 ~= '' and 
                    item.name_utf8 ~= game_str.Transfer_point_CH and item.name_utf8 ~= game_str.The_Gate_of_the_Outland_CH then
                        return item
                    end
                end
                return false
            end
            
            local not_map = get_not_map()
            
            if one_other_map then
                local error_text = {
                    game_str.Server_disconnected_TWCH,
                    game_str.Error_Unable_to_enter_TWCH,
                    game_str.Startup_failed_TWCH
                }
                
                for _, k in ipairs(error_text) do
                    if poe2_api.find_text({UI_info = env.UI_info, text = k, min_x = 0}) then
                        table.insert(error_other_map, one_other_map)
                        env.one_other_map = nil
                        env.is_map_complete = true
                        
                        if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.clear, min_x = 0}) then
                            poe2_api.click_keyboard("enter")
                            api_Sleep(500)
                            poe2_api.paste_text(game_str.clear)
                            api_Sleep(500)
                            poe2_api.click_keyboard("enter")
                            api_Sleep(1000)
                            self.bool = true
                            
                            return bret.RUNNING
                        end
                    end
                end
                
                env.enter_map_click_counter = 0
                env.is_map_complete = false
                
                if self.wait_num > 3 then
                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, max_y = 100, min_x = 250, refresh = true}) then
                        poe2_api.click_position(1013, 25)
                    end
                    
                    return bret.RUNNING
                end
                
                if not_map and not_map.name_utf8 ~= one_other_map.name_cn_utf8 then
                    api_Sleep(3000)
                    
                    return bret.RUNNING
                end
                
                if not poe2_api.find_text({UI_info = env.UI_info, text = one_other_map.name_cn_utf8, min_x = 0, refresh = true}) then
                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, max_y = 100, min_x = 250, refresh = true}) then
                        poe2_api.click_position(1013, 25)
                        return bret.RUNNING
                    end
                end
                
                api_Sleep(3000)
                self.wait_num = self.wait_num + 1
                
                return bret.RUNNING
            end
            
            
            return bret.FAIL
        end
    },

    -- 打开异界地图页面节点
    Open_The_Otherworld_Page = {
        run = function(self, env)
            poe2_api.print_log('打开异界地图页面...')

            if not self.last_action_time then 
                self.last_action_time = 0  -- 记录上次操作时间
                self.action_interval = 1   -- 操作间隔时间
                self.wait_start = 0        -- 等待开始时间
            end

            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            
            if current_time - self.last_action_time >= self.action_interval then
                if player_info and 
                poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) and 
                not poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0}) then
                    poe2_api.dbgp("打开异界地图页面")
                    env.interactive = game_str.MapDevice
                    env.one_other_map = nil
                    
                    return bret.SUCCESS
                end
            end
            
            
            return bret.RUNNING
        end
    },

    -- 寻找精英怪怪物
    Find_Monster = {
        run = function(self, env)
            poe2_api.print_log("寻找怪物...")
            local current_time = api_GetTickCount64()
            local nearest_distance_sq = math.huge
            local stuck_monsters = env.stuck_monsters
            local player_info = env.player_info
            local valid_monsters = nil
            if env.range_info then
                -- 先确定当前目标
                for _, monster in ipairs(env.range_info) do
                    if poe2_api.table_contains(stuck_monsters, monster.id) then
                        goto continue
                    end
                    
                    -- 快速失败条件检查
                    if monster.type ~= 1 or not monster.is_selectable then
                        goto continue
                    end
                    
                    if monster.is_friendly then
                        goto continue
                    end
                    
                    if not monster.isActive then
                        goto continue
                    end
                    
                    if monster.life <= 0 or monster.name_utf8 == "" then
                        goto continue
                    end
                    
                    if poe2_api.table_contains(my_game_info.not_attact_mons_path_name, monster.path_name_utf8) then
                        goto continue
                    end
                    
                    if not_attack_mos and poe2_api.table_contains(not_attack_mos, monster.rarity) then
                        goto continue
                    end
                    
                    if monster.rarity == 0 or monster.rarity == 1 then
                        goto continue
                    end
                    
                    -- if monster.hasLineOfSight then
                    --     goto continue
                    -- end
                    
                    -- 计算距离平方
                    local distance_sq = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
                    
                    if distance_sq and distance_sq < nearest_distance_sq then
                        nearest_distance_sq = distance_sq
                        valid_monsters = monster
                    end
                    ::continue::
                end
            end
            
            if valid_monsters then
                -- if env.end_point and #env.path_list > 0 then
                    -- local dis = poe2_api.point_distance(valid_monsters.grid_x, valid_monsters.grid_y,{env.end_point[1], env.end_point[2]})
                    -- if dis and dis > 25 then
                poe2_api.dbgp("寻找怪物...", valid_monsters.grid_x, valid_monsters.grid_y)
                env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                    -- end
                -- end
                poe2_api.time_p("寻找怪物(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                return bret.FAIL
            else
                poe2_api.time_p("寻找怪物(FAIL) 耗时 -->", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
            -- return bret.SUCCESS
        end
    },

    -- 进图统计
    Open_Map_Count = {
        run = function(self, env)
            poe2_api.dbgp("进图统计...")
            -- while true do
            --     return bret.SUCCESS
            -- end
            local player_info = env.player_info
            -- poe2_api.printTable(player_info)
            if not player_info or not player_info.current_map_name_utf8 then
                return bret.RUNNING
            end
            -- 初始化
            if not self.map_stats then
                self.map_stats = {
                    state = "UNKNOWN",  -- HIDEOUT, MAP, TRANSITION
                    last_map = "",
                    transition_start = 0
                }
                env.open_map_count = 0
            end
            local current_map = player_info.current_map_name_utf8
            local is_hideout = poe2_api.table_contains(current_map, my_game_info.hideout)
            
            -- 状态机逻辑
            if self.map_stats.state == "HIDEOUT" and not is_hideout then
                -- 从藏身处进入地图
                self.map_stats.state = "MAP"
                env.open_map_count = (env.open_map_count or 0) + 1
                poe2_api.print_log(string.format("开图计数: 第%d次开图，进入地图: %s", env.open_map_count, current_map))
                
            elseif self.map_stats.state == "MAP" and is_hideout then
                -- 从地图回到藏身处
                self.map_stats.state = "HIDEOUT"
                poe2_api.dbgp("返回藏身处: " .. current_map)
                
            elseif self.map_stats.state == "UNKNOWN" then
                -- 初始状态判断
                self.map_stats.state = is_hideout and "HIDEOUT" or "MAP"
            end
            
            self.map_stats.last_map = current_map
            poe2_api.dbgp("进图统计...111111111111111111111111111")
            return bret.SUCCESS
        end
    },

    -- 检查是否在异界中
    Check_In_Otherworld_Map = {
        run = function(self, env)
            local current_time = api_GetTickCount64()
            poe2_api.dbgp("检查是否在异界中...")
            if poe2_api.table_contains(env.player_info.current_map_name_utf8,my_game_info.hideout) then
                env.boss_drop_time = 0
                env.boss_drop = false
                env.boss_id_list = {}
                env.drop_items = false
                env.need_item = nil
                env.not_more_ritual = true
                env.afoot_altar = nil
                env.afoot_box = nil
                env.interactive_timeout = nil
                env.not_match_id = nil
                env.interactive_id = nil
                env.interactive_id_list = {}
                env.interactive_replytime = 0
                env.interactive_permanent_id_list = {}
                env.obj_color = nil
                env.is_abyss_complete = false
                env.is_abyss_time = false
                env.abyss_point_list = {} -- 深渊坐标列表    城区刷新
                env.bag_man = false
                env.prestore_boss_list = {}
                env.not_box_list = {} -- 排除保险箱列表
                env.not_minimap_obj_list = {} -- 小地图排除对象列表
                
                
                -- for _,k in ipairs(env.player_info.buffs) do
                --     -- poe2_api.printTable(k)
                --     -- poe2_api.dbgp("k.name_en", k.name_en)
                --     if k.name_en == game_str.on_rhoa_mount_SKBUF then
                --         poe2_api.print_log("取消骑乘状态...")
                --         api_ClickMove(env.player_info.grid_x, env.player_info.grid_y, env.player_info.world_z, 0)
                --         poe2_api.click_keyboard("space")
                --         return true
                --     end
                -- end

                return bret.FAIL
			end
            poe2_api.dbgp("异界中...")
            env.clear_bool = false
            env.not_exist_stone = {}
            env.is_get_plaque = false
            env.is_get_plaque_node = true
            env.is_public_warehouse = true
            env.is_strengthened_map = true
            env.amplification_use_count = 0
            env.supreme_use_count = 0
            env.strengthened_map_obj = nil
            env.is_public_warehouse_plaque = true
            env.is_update_plaque = false
            env.entry_length_take_map = false
            env.not_have_stackableCurrency = false
            env.operated_plaque = false
            env.lack_of_currency = {} -- 缺少通货
            env.is_have_stone = true
            env.page_full_list = {} -- 页满列表
            env.stone_info = nil
            env.plaque_upgrade = true
            env.sale_completed = false  -- 未完成售卖
            env.one_not_plaque = false  -- 找碑牌顺序是否已执行一遍
            env.storage_complete = false  -- 是否存储完成
            -- env.drop_items = false
            -- env.not_exist_stone = {}
            -- env.is_get_plaque_node = true


            if not env.open_map_UI and not poe2_api.table_contains(env.player_info.current_map_name_utf8, my_game_info.hideout) then 
            -- if not poe2_api.table_contains(env.player_info.current_map_name_utf8, my_game_info.hideout) and not env.player_info.life > 0 then   
                if poe2_api.find_text({UI_info = env.UI_info, text = my_game_info.game_region, max_x=1800}) then
                    env.open_map_UI = true
                else
                    poe2_api.click_keyboard("tab")
                    api_Sleep(1000)
                    return bret.RUNNING
                end
            end

            -- 获取技能设置
            local function parse_skill_config()
                local skill_setting = env.user_config["技能設置"]
                local new_skills = {}
                local new_sup_skills = {}
                local preserved_cooldowns = {}
                local sup_preserved_cooldowns = {}
                local current_time = api_GetTickCount64()
                
                -- 确保skill_cooldowns表存在
                if not env.skill_cooldowns_sups then
                    env.skill_cooldowns_sups = {}
                end
                if not env.sup_skill_cooldowns_sups then
                    env.sup_skill_cooldowns_sups = {}
                end

                if not env.all_skill_infos_sups or env.all_skill_infos_sups == nil then
                    env.all_skill_infos_sups = api_GetSkillSlots()
                end

                if not env.all_skill_sups or env.all_skill_sups == nil then
                    env.all_skill_sups = api_GetSelectableSkillControls()
                end
                
                local skill_pos = {
                    ["q"] = {1194, 1230},
                    ["w"] = {1236, 1272},
                    ["e"] = {1279, 1315},
                    ["r"] = {1322, 1358},
                    ["t"] = {1365, 1401},
                }

                -- 首先建立按键到控件的映射
                local daimos_change = game_str.DemonFormPlayer_ENSK  -- 要匹配的技能名称
                local key_to_control = {}
                if env.all_skill_sups and next(env.all_skill_sups) ~= nil then
                    for _, control in ipairs(env.all_skill_sups) do
                        if not control.text_utf8 or control.text_utf8 == "" then
                            goto continue
                        end
                        if control.text_utf8 == daimos_change then
                            goto continue
                        end
                        -- 跳过非主技能栏的技能
                        if control.top > 845 and control.left > 1190 then
                            for key, range in pairs(skill_pos) do
                                local pos = (control.left + control.right) / 2
                                if pos >= range[1] and pos <= range[2] then
                                    key_to_control[key] = control
                                    break
                                end
                            end
                        end
                        ::continue::
                    end
                end
                
                -- 创建按键到技能ID的映射
                local key_to_skill_id = {}
                for key, skill_data in pairs(skill_setting) do
                    if skill_data["启用"] then
                        local control = key_to_control[key]
                        if control then
                            for _, skill in ipairs(env.all_skill_infos_sups) do
                                if control.text_utf8 == skill.name_utf8 then
                                    key_to_skill_id[key] = skill.id
                                    break
                                end
                            end
                        end
                    end
                end
                
                -- 遍历技能设置
                for key, skill_data in pairs(skill_setting) do
                    -- 只处理启用技能
                    if skill_data["启用"] then
                        if skill_data["技能屬性"] == "辅助技能" then
                            
                            local sup_skill = {
                                name = key,
                                key = key,
                                id = key_to_skill_id[key] or 0,
                                interval = (tonumber(skill_data["釋放間隔"]) or 0) / 1000,
                                target = skill_data["釋放對象"]
                            }
                            
                            -- 保留原有冷却时间
                            if env.sup_skill_cooldowns_sups[sup_skill.name] then
                                sup_preserved_cooldowns[sup_skill.name] = env.sup_skill_cooldowns_sups[sup_skill.name]
                            else
                                sup_preserved_cooldowns[sup_skill.name] = 0
                            end
                            
                            table.insert(new_sup_skills, sup_skill)
                        end
                    end
                end
                
                env.skills_sups = new_skills
                env.sup_skills_sups = new_sup_skills
                -- poe2_api.printTable(env.skills_sups)
                env.skill_cooldowns_sups = preserved_cooldowns
                env.sup_skill_cooldowns_sups = sup_preserved_cooldowns

                -- 提取技能权重
                env._skill_weights_sups = {}
                for _, skill in ipairs(env.skills_sups) do
                    table.insert(env._skill_weights_sups, skill.weight)
                end
                
                return {
                    attack_skills = env.skills_sups,
                    support_skills = env.sup_skills_sups
                }
            end

            -- 释放辅助技能
            local function _execute_support_skill(skill, player_info)
                poe2_api.dbgp("释放辅助技能=-=-=-->>>>")
                poe2_api.printTable(skill)
                local current_time = api_GetTickCount64()
                
                -- 设置冷却时间
                local skill_start = api_GetTickCount64()
                local base_cd = skill.interval
                local actual_cd = (math.max(base_cd * (1 + math.random() * 0.2), 0.1)) * 1000
                env.sup_skill_cooldowns_sups[skill.name] = skill_start + actual_cd
                if env.user_config["全局設置"]["内存模式"] then
                    -- 释放辅助技能
                    if skill.id and skill.id ~= 0 then
                        -- 辅助技能通常不需要目标位置，使用玩家当前位置
                        if env.target_point and next(env.target_point) then
                            api_CastSkill(skill.id, 0, env.player_info.grid_x, env.player_info.grid_y, env.target_point[1], env.target_point[2])
                        else
                            api_CastSkill(skill.id, 0, env.player_info.grid_x, env.player_info.grid_y, env.player_info.grid_x, env.player_info.grid_y)
                        end
                        
                        poe2_api.dbgp("通过技能ID释放辅助技能:", skill.key, "技能ID:", skill.id)
                    end
                else
                    -- 备用方案：使用按键释放
                    if env.valid_monsters and next(env.valid_monsters) and skill.target == "敵對" then
                        api_ClickMove(env.valid_monsters.grid_x, env.valid_monsters.grid_y, 0)
                    elseif env.target_point and next(env.target_point) then
                        api_ClickMove(env.target_point[1], env.target_point[2], 0)
                    elseif skill.target == "自身" then
                        api_ClickMove(env.player_info.grid_x, env.player_info.grid_y, 0)
                    end
                    poe2_api.click_keyboard(skill.key)
                    poe2_api.dbgp("通过按键释放辅助技能:", skill.key)
                end
            end

           -- 检查并释放辅助技能
            local function check_and_cast_support_skills()
                if not env.sup_skills_sups or #env.sup_skills_sups == 0 then
                    return
                end
                
                local current_time = api_GetTickCount64()
                
                for _, skill in ipairs(env.sup_skills_sups) do
                    -- 检查冷却时间
                    local last_cast = env.sup_skill_cooldowns_sups[skill.name] or 0
                    if current_time - last_cast >= skill.interval * 1000 then
                        _execute_support_skill(skill, env.player_info)
                    end
                end
            end

            -- if env.user_config["全局設置"]["内存模式"] then
                -- 加载技能设置
            if not env.skills_sups then
                poe2_api.dbgp("加载技能设置...")
                env.stuck_monsters_sups = {}
                
                parse_skill_config()
                return bret.RUNNING
            end
            
            check_and_cast_support_skills()
            -- end

            -- 获取技能设置
            local function parse_skill_config()
                poe2_api.dbgp("---恶魔变身---")
                for _,k in ipairs(env.player_info.buffs) do
                    -- poe2_api.printTable(k)
                    -- poe2_api.dbgp("k.name_en", k.name_en)
                    if k.name_en == game_str.demon_form_tick_prevention_buff_SKBUF then
                        return true
                    end
                end

                local skill_setting = env.user_config["技能設置"]

                local daimos_change = game_str.DemonFormPlayer_ENSK  -- 要匹配的技能名称

                -- local all_skill = api_GetSelectableSkillControls()
                if not self.all_skill or self.all_skill == nil then
                    self.all_skill = api_GetSelectableSkillControls()
                end
                
                -- poe2_api.printTable(self.all_skill)

                local skill_pos = {
                    ["q"] = {1194, 1230},
                    ["w"] = {1236, 1272},
                    ["e"] = {1279, 1315},
                    ["r"] = {1322, 1358},
                    ["t"] = {1365, 1401},
                }

                -- 首先建立按键到控件的映射
                local key_to_control = {}
                if self.all_skill and next(self.all_skill) ~= nil then
                    for _, control in ipairs(self.all_skill) do
                        if not control.text_utf8 or control.text_utf8 == "" then
                            goto continue
                        end
                        -- 跳过非主技能栏的技能
                        if control.top > 845 and control.left > 1190 then
                            
                            for key, range in pairs(skill_pos) do
                                pos = (control.left + control.right) / 2
                                if pos >= range[1] and pos <= range[2] then
                                    key_to_control[key] = control
                                    break
                                end
                            end
                        end
                        ::continue::
                    end
                end
                
                -- 遍历技能设置，查找匹配的技能
                for key, skill_data in pairs(skill_setting) do
                    -- 只处理启用的辅助技能
                    if skill_data["启用"] and skill_data["技能屬性"] == "辅助技能" then
                        local control = key_to_control[key]
                        -- poe2_api.printTable(control)
                        -- 使用control中的text_utf8进行比对
                        if control and control.text_utf8 == daimos_change then
                            -- 直接返回匹配的按键
                            poe2_api.click_keyboard(key)
                            api_Sleep(500)
                            return false
                        end
                    end
                end

                -- 如果没有找到匹配的技能，返回nil或默认值
                -- print("警告：未找到名称为 '" .. daimos_change .. "' 的辅助技能")
                return false
            end

            if env.player_info.life > 0 then
                parse_skill_config()
                -- api_Sleep(100000)
            end

            -- local skill_key = parse_skill_config()
            -- if skill_key then
            --     poe2_api.dbgp(skill_key)  -- 输出单个按键，如 "q", "w" 等
            -- else
            --     poe2_api.dbgp("未找到匹配的技能按键")
            -- end
            -- api_Sleep(10000)
            
            poe2_api.time_p("检查是否在异界中(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
            return bret.SUCCESS
        end
    },

    -- 骑鸟
    Take_Bird = {
        run = function(self, env)
            local player_info = env.player_info
            -- 骑鸟
            local function take_bird()
                for _,k in ipairs(env.player_info.buffs) do
                    -- poe2_api.printTable(k)
                    -- poe2_api.dbgp("k.name_en", k.name_en)
                    if k.name_en == game_str.on_rhoa_mount_SKBUF then
                        return true
                    end
                end
                -- if not bird then
                for _,i in ipairs(env.range_info) do
                    if i.name_utf8 == "恐喙鳥盟友" and i.life > 0 then
                        -- poe2_api.printTable(i)
                        local dis = poe2_api.point_distance(i.grid_x, i.grid_y, env.player_info)
                        poe2_api.dbgp("恐喙鳥盟友...", dis)
                        -- poe2_api.dbgp("恐喙鳥盟友i.grid_x", i.grid_x)
                        -- poe2_api.dbgp("恐喙鳥盟友i.grid_y", i.grid_y)
                        -- poe2_api.dbgp("player_info.grid_x", env.player_info.grid_x)
                        -- poe2_api.dbgp("player_info.grid_y", env.player_info.grid_y)
                        -- poe2_api.dbgp("============================================")
                        if dis and dis > 25 then
                            poe2_api.dbgp("恐喙鳥盟友 dis > 25")
                            
                            -- api_ClickMove(env.player_info.grid_x, env.player_info.grid_y, env.player_info.world_z, 0)
                            -- api_Sleep(200)
                            -- poe2_api.click_keyboard("`")
                            env.path_list = {}
                            env.end_point = {i.grid_x, i.grid_y}
                            return bret.FAIL
                            -- api_Sleep(500)
                            -- return false
                        end
                        api_ClickMove(i.grid_x, i.grid_y, 0)
                        api_Sleep(500)
                        api_ClickMove(i.grid_x, i.grid_y, 1)
                        api_Sleep(500)
                        return false
                    end
                end
                poe2_api.dbgp("没有恐喙鳥盟友...")
                return true
            end
            local stuck_monsters = poe2_api.deepCopy(env.stuck_monsters)
            nomarl_monster = poe2_api.is_have_mos({range_info = env.range_info, dis = env.min_attack_dis, player_info = player_info,is_active = is_active, not_sight = true,stuck_monsters = stuck_monsters})
            Boss_monster = poe2_api.is_have_mos_boss(env.range_info, my_game_info.boss_name)
            if env.is_bird and not env.is_map_complete and not nomarl_monster and not Boss_monster then
                poe2_api.dbgp("---上鸟---")
                local function is_door()
                    for _, v in ipairs(env.range_info) do
                        if v.name_utf8 ~= "" and v.type == 5 and poe2_api.table_contains(v.name_utf8,my_game_info.hideout_CH) then
                            local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                            if dis and dis < 50 then
                                return false
                            end
                        end
                        if v.MinimapIconActive == game_str.Entrance_EN then
                            local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                            if dis and dis < 50 then
                                return false
                            end
                        end
                        if v.path_name_utf8 == game_str.Ritual_PATH then
                            local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                            if dis and dis < 50 then
                                return false
                            end
                        end
                    end
                    return true
                end
                if is_door() then
                    if not take_bird() then
                        return bret.RUNNING
                    end
                end
            end
            return bret.SUCCESS
        end
    },

    -- 检查目标点
    Check_Target_Point = {
        run = function(self, env)
            poe2_api.print_log("检查目标点...")
            local current_time = api_GetTickCount64()
            -- 使用参数
            local no_mos_back = env.user_config["全局設置"]["刷图通用設置"]["是否全圖"] or false
            -- local no_mos_back = false
            local result = false
            env.radius = 120

            local player_info = env.player_info
            local path_list = env.path_list
            local current_map_info = env.current_map_info
            local have_ritual = env.have_ritual
            local afoot_altar = env.afoot_altar
            local is_perform_a_ritual_sacrifice = env.user_config["全局設置"]["刷图通用設置"]["是否打祭祀"] or false
            local is_into_the_abyss = env.user_config["全局設置"]["刷图通用設置"]["是否进深渊"] or false

            if self.last_action_time == nil then
                self.last_action_time = api_GetTickCount64()
                self.action_interval = 1000
                self.false_times = 0
                self.is_wait = false
                self.dq = 0
            end

            if env.boss_drop and not string.find(player_info.current_map_name_utf8,game_str.Delirium_) then
                if api_GetTickCount64() - env.boss_drop_time < 10000 then
                    poe2_api.dbgp("等待Boss掉落...")
                    return bret.RUNNING
                end
                env.boss_drop = false
            end
            if env.is_abyss_time then
                if api_GetTickCount64() - env.abyss_time < 5000 then
                    poe2_api.dbgp("等待深渊物品掉落...")
                    return bret.RUNNING
                end
            end
            -- 判断boss死亡
            local function is_not_boss(range_info)
                for _, monster in ipairs(range_info) do
                    if monster.rarity == 3 and monster.life == 0 and (monster.type == 1 or (player_info.current_map_name_utf8 == game_str.MapSinkhole_MDANA and monster.type == 3)) and (not env.boss_id_list or not next(env.boss_id_list) or not poe2_api.table_contains(monster.path_name_utf8, env.boss_id_list)) then
                        return monster
                    end
                end
                return false
            end

            if not string.find(player_info.current_map_name_utf8,game_str.MapUniqueMegalith_MDANA) then
                local bossname = is_not_boss(env.range_info)
                if not env.boss_drop and bossname then
                    env.boss_drop = true
                    env.boss_drop_time = api_GetTickCount64()
                    table.insert(env.boss_id_list,bossname.path_name_utf8)
                    poe2_api.dbgp("boss: "..bossname.name_utf8.." 死亡,添加到boss等待列表")
                    api_RestoreOriginalMap()
                    api_UpdateMapObstacles(300)
                    return bret.RUNNING
                end
            end

            -- 周围对象迷雾检查
            local function is_Delirium_completed(item)
                for _, item2 in ipairs(env.range_info) do
                    if item2.name_utf8 == item.name_utf8 and next(item2.stateMachineList) and item2.stateMachineList.goodbye == 1 then
                        return true
                    end
                end
                return false
            end

            -- 查找小地图对象
            local function get_target_minimap_object(current_map_info)
                if not current_map_info or not next(current_map_info) then
                    return false
                end
                local current_map_sorted_info = poe2_api.get_sorted_list(current_map_info, player_info)
                poe2_api.dbgp("current_map_sorted_info: ",current_map_sorted_info)
                if not env.minimap_info then
                    local black_mist_sacrifice = nil
                    local not_sacrifice = nil
                    local ultimately_boss = nil
                    local elite_boss = nil
                    local target = nil
                    poe2_api.dbgp("not_more_ritual: ",env.not_more_ritual)
                    if poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.Citadel_map) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH}) then
                        return false
                    end
                    if env.not_more_ritual and is_perform_a_ritual_sacrifice then
                        for _, item in ipairs(current_map_sorted_info) do
                            if item.name_utf8 == game_str.RitualRune_EN and item.flagStatus == 1 and item.flagStatus1 == 1 and afoot_altar and poe2_api.point_distance(item.grid_x,item.grid_y,afoot_altar)<20 then
                                env.minimap_info = item 
                                poe2_api.dbgp("小地图对象中黑雾祭坛----------------------------")
                                env.end_point = {item.grid_x, item.grid_y}
                                return true
                            end
                        end
                        local sacrifice_info = api_GetSacrificeItems()
                        if sacrifice_info and next(sacrifice_info) then
                            for _, item in ipairs(current_map_sorted_info) do
                                if item.name_utf8 == game_str.RitualRune_EN and item.flagStatus == 1 and item.flagStatus1 == 1 and ((0 < sacrifice_info.maxCount and sacrifice_info.maxCount < 10 and 0 < sacrifice_info.finishedCount and sacrifice_info.finishedCount < 10 and sacrifice_info.finishedCount  ~= sacrifice_info.maxCount) or (sacrifice_info.maxCount == 0 and sacrifice_info.finishedCount == 0)) then
                                    poe2_api.dbgp("小地图对象中普通祭坛----------------------------")
                                    env.minimap_info = item
                                    env.end_point = {item.grid_x, item.grid_y}
                                    return true
                                end
                            end
                        end
                    end
                    for _, item in ipairs(current_map_sorted_info) do
                        if item.name_utf8 == game_str.RareMonsterAlive_EN and item.flagStatus == 1 then
                            if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not poe2_api.find_text({text = game_str.Map_completed_TWCH})) then
                                poe2_api.dbgp("小地图对象中精英boss----------------------------")
                                env.minimap_info = item
                                env.end_point = {item.grid_x, item.grid_y}
                                return true
                            end
                        end
                    end
                    if env.is_click_essence then
                        for _, item in ipairs(current_map_sorted_info) do
                            if item.name_utf8 == game_str.Essence_EN and item.flagStatus == 1 and item.flagStatus1 == 1 then
                                if (not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and player_info.current_map_name_utf8 ~= game_str.MapUniqueSelenite_MDANA) or ((poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or player_info.current_map_name_utf8 == game_str.MapUniqueSelenite_MDANA) and not poe2_api.find_text({text = "地圖完成"})) then
                                    poe2_api.dbgp("小地图对象中精髓----------------------------")
                                    env.minimap_info = item
                                    env.end_point = {item.grid_x, item.grid_y}
                                    return true
                                end
                            end
                        end
                    end
                    
                    if string.find(player_info.current_map_name_utf8 , game_str.Delirium_) then
                        for _, item in ipairs(current_map_sorted_info) do
                            if item.name_utf8 == game_str.AfflictionInitiator_EN and item.flagStatus1 == 1 then
                                if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not poe2_api.find_text({text = game_str.Map_completed_TWCH})) then
                                    if not is_Delirium_completed(item) then
                                        poe2_api.dbgp("小地图对象中迷雾镜子----------------------------2")
                                        api_UpdateMapObstacles(env.radius * 2)
                                        env.minimap_info = item
                                        env.end_point = {item.grid_x, item.grid_y}
                                        return true
                                    end
                                end
                            end
                        end
                        -- for _, item in ipairs(current_map_sorted_info) do
                        --     if item.name_utf8 == game_str.StashPlayer and item.flagStatus1 == 1 then
                        --         if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not poe2_api.find_text({text = game_str.Map_completed_TWCH})) then
                        --             poe2_api.dbgp("小地图对象中迷雾仓库----------------------------")
                        --             env.minimap_info = item
                        --             env.end_point = {item.grid_x, item.grid_y}
                        --             return true
                        --         end
                        --     end
                        -- end
                    end
                    local function not_minimap(obj)
                        for i, item in ipairs(env.not_minimap_obj_list) do
                            if item.name_utf8 == obj.name_utf8 and item.flagStatus == obj.flagStatus and item.flagStatus1 == obj.flagStatus1 then
                                local dis = poe2_api.point_distance(item.grid_x,item.grid_y,obj)
                                if dis and dis < 10 then
                                    return true
                                end
                            end
                        end
                        return false
                    end
                    for _, item in ipairs(current_map_sorted_info) do
                        if item.name_utf8 == 'AbyssCrackActive' and item.flagStatus == 0 and item.flagStatus1 == 1 then
                            if not env.not_minimap_obj_list or not next(env.not_minimap_obj_list) or not not_minimap(item) then
                            -- if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not poe2_api.find_text({text = "地圖完成"})) then
                                poe2_api.dbgp("小地图对象中深渊绿点----------------------------")
                                env.minimap_info = item
                                env.end_point = {item.grid_x, item.grid_y}
                                return true
                            end
                        end
                    end
                    for _, item in ipairs(current_map_sorted_info) do
                        if item.name_utf8 == 'AbyssPitActive' and item.flagStatus == 1 and item.flagStatus1 == 1 then
                            if not env.not_minimap_obj_list or not next(env.not_minimap_obj_list) or not not_minimap(item) then
                            -- if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not poe2_api.find_text({text = "地圖完成"})) then
                                poe2_api.dbgp("小地图对象中深渊大坑----------------------------")
                                env.minimap_info = item
                                env.end_point = {item.grid_x, item.grid_y}
                                return true
                            end
                        end
                    end
                    for _, item in ipairs(current_map_sorted_info) do
                        if item.name_utf8 == game_str.AbyssChestActive_EN and item.flagStatus == 0 and item.flagStatus1 == 1 then
                            if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not poe2_api.find_text({text = game_str.Map_completed_TWCH})) then
                                poe2_api.dbgp("小地图对象中深渊宝箱----------------------------")
                                env.minimap_info = item
                                env.end_point = {item.grid_x, item.grid_y}
                                return true
                            end
                        end
                    end
                    for _, item in ipairs(current_map_sorted_info) do
                        if item.name_utf8 == 'RuneMarkersActive' and item.flagStatus1 == 1 and not string.find(player_info.current_map_name_utf8,"MapUniqueMegalith") then
                            if not env.not_minimap_obj_list or not next(env.not_minimap_obj_list) or not not_minimap(item) then
                            -- if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not poe2_api.find_text({text = "地圖完成"})) then
                                poe2_api.dbgp("小地图对象中巨石召唤----------------------------")
                                env.minimap_info = item
                                env.end_point = {item.grid_x, item.grid_y}
                                return true
                            end
                        end
                    end
                    for _, item in ipairs(current_map_sorted_info) do
                        if item.name_utf8 == 'RuneMarkersActive' and item.flagStatus1 == 0 and string.find(player_info.current_map_name_utf8,"MapUniqueMegalith") then
                            if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not poe2_api.find_text({text = "地圖完成"})) then
                                poe2_api.dbgp("小地图对象中传奇巨石召唤----------------------------")
                                env.minimap_info = item
                                env.end_point = {item.grid_x, item.grid_y}
                                return true
                            end
                        end
                    end
                    for _, item in ipairs(current_map_sorted_info) do
                        if item.name_utf8 == game_str.BossSummoningLocationActive_EN and item.flagStatus1 == 1 and string.find(player_info.current_map_name_utf8,game_str.MapUniqueMegalith_MDANA) then
                            if not poe2_api.find_text({text = game_str.Map_completed_TWCH}) then
                                poe2_api.dbgp("小地图对象中传奇地图Boss点----------------------------")
                                env.minimap_info = item
                                env.end_point = {item.grid_x, item.grid_y}
                                return true
                            end
                        end
                    end
                    if is_into_the_abyss then
                        for _, item in ipairs(current_map_sorted_info) do
                            if string.find(item.name_utf8,game_str.Abyss) and item.flagStatus1 == 1 and not env.is_abyss_complete then
                                if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not poe2_api.find_text({text = game_str.Map_completed_TWCH})) then
                                    poe2_api.dbgp("小地图对象中深渊入口----------------------------")
                                    env.minimap_info = item
                                    env.end_point = {item.grid_x, item.grid_y}
                                    return true
                                end
                            end
                        end
                    end

                    local function is_point1(grid_x,grid_y)
                        local player_position = api_FindNearestReachableInRange(grid_x,grid_y, 50, 0)
                        local resu = api_FindPath(player_info.grid_x,player_info.grid_y,player_position.x, player_position.y)
                        return resu
                    end
                        
                    for _, item in ipairs(current_map_sorted_info) do
                        if item.name_utf8 == game_str.UniqueMonsterAlive_EN and item.flagStatus == 1 and item.flagStatus1 == 1 then
                            local is_path = is_point1(item.grid_x,item.grid_y)
                            if is_path and next(is_path) then
                                poe2_api.dbgp("小地图对象中最终boss----------------------------")
                                env.minimap_info = item
                                local player_position = api_FindNearestReachableInRange(item.grid_x, item.grid_y, 50, 0)
                                env.end_point = {player_position.x, player_position.y}
                                return true
                            end
                            
                        end
                    end

                    if not env.minimap_info then
                        return false
                    end
                else
                    poe2_api.dbgp("小地图对象中已有目标--------------------------------------------------------------------------------------------")
                    local minimap_info = env.minimap_info
                    if poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.Citadel_map) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH}) then
                        env.minimap_info = nil
                        return "刷新"
                    end
                    if string.find(minimap_info.name_utf8,game_str.Abyss) then
                        if env.is_abyss_complete then
                            env.minimap_info = nil
                            return "刷新"
                        end
                        local distance = poe2_api.point_distance(minimap_info.grid_x, minimap_info.grid_y, env.player_info)
                        if distance < 50 then
                            local function get_abyss()
                                if not env.range_info or not next(env.range_info) then
                                    return false
                                end
                                for _, i in ipairs(env.range_info) do
                                    local condition25 = i.path_name_utf8 == game_str.AbyssSubAreaTransition_PATH
                                    if condition25 then
                                        return true
                                    end
                                end
                                return false
                            end
                            if not get_abyss() then
                                env.minimap_info = nil
                                env.is_abyss_complete = true
                                return "刷新"
                            end
                        end
                    end
                    if minimap_info.name_utf8 == game_str.BossSummoningLocationActive_EN then
                        if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH}) then
                            env.minimap_info = nil
                            return false
                        end
                    end
                    if string.find(env.player_info.current_map_name_utf8, game_str.MapUniqueWildwood) then
                        if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH}) then
                            env.minimap_info = nil
                            return false
                        end
                    end
                    if minimap_info.name_utf8 == game_str.RitualRune_EN then
                        if not env.not_more_ritual then
                            env.minimap_info = nil
                            -- env.is_abyss_complete = true
                            return "刷新"
                        end
                    end
                    for _, item in ipairs(current_map_sorted_info) do
                        local distance = poe2_api.point_distance(item.grid_x,item.grid_y,minimap_info)
                        if item.name_utf8 == minimap_info.name_utf8 and item.flagStatus == minimap_info.flagStatus and item.flagStatus1 == minimap_info.flagStatus1 and distance and distance < 20 then
                            if minimap_info.name_utf8 == game_str.UniqueMonsterAlive_EN then
                                local player_position = api_FindNearestReachableInRange(item.grid_x, item.grid_y, 50, 0)
                                if env.player_info.current_map_name_utf8 == game_str.MapSandspit_MDANA and env.player_info.isInBossBattle then
                                    if not env.prestore_boss_list or not next(env.prestore_boss_list) then
                                        local result_list = api_GetCalculateCircleGridPoints(poe2_api.toInt(player_position.x),poe2_api.toInt(player_position.y),100,math.floor(15))
                                        if result_list then
                                            poe2_api.dbgp("22222:",#result_list)
                                            env.prestore_boss_list = result_list
                                            poe2_api.dbgp("获取圆点列表")
                                            return "刷新"
                                        else
                                            local point = api_FindRandomWalkablePosition(math.floor(player_position.x),math.floor(player_position.y),80)
                                            if point then
                                                env.end_point = {point.x,point.y}
                                            else
                                                poe2_api.dbgp("获取圆形范围内均匀分布的网格点失败,随机移动")
                                                -- poe2_api.time_p("是否需要移动祭坛（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                                                return "刷新"
                                            end
                                            
                                        end
                                    else
                                        local distance = poe2_api.point_distance(env.prestore_boss_list[1].x,env.prestore_boss_list[1].y,player_info)
                                        if distance and distance < 15 then
                                            table.remove(env.prestore_boss_list,1)
                                            poe2_api.dbgp("移动到圆点列表第一个点完成")
                                            return "刷新"
                                        end
                                        -- if not path_list or not next(path_list) then
                                        --     local ralet = api_FindPath(player_info.grid_x,player_info.grid_y,env.prestore_list[1].x,env.prestore_list[1].y)
                                        --     if not ralet then
                                        --         table.remove(env.prestore_list,1)
                                        --         local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),80)
                                        --         api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), poe2_api.toInt(player_info.world_z), 7)
                                        --         poe2_api.click_keyboard("space")
                                        --         poe2_api.dbgp("人物在黑雾祭坛，计算到圆形范围内第一个点失败")
                                        --         return bret.RUNNING
                                        --     end
                                        -- end
                                        poe2_api.dbgp("移动到圆形范围内第一个点")
                                        env.end_point = {env.prestore_boss_list[1].x,env.prestore_boss_list[1].y}
                                        -- poe2_api.dbgp("人物在黑雾祭坛，移动到圆形范围内第一个点")
                                        -- poe2_api.time_p("是否需要移动祭坛（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
                                        -- return bret.SUCCESS
                                    end
                                else
                                    
                                    env.end_point = {item.grid_x, item.grid_y}
                                end
                                
                            else
                                if poe2_api.table_contains(minimap_info.name_utf8,{"AbyssCrackActive","AbyssPitActive","RuneMarkersActive"}) then
                                    local dis = poe2_api.point_distance(minimap_info.grid_x,minimap_info.grid_y,env.player_info)
                                    if dis and dis <= 25 then
                                        table.insert(env.not_minimap_obj_list,minimap_info)
                                        env.minimap_info = nil
                                        -- env.is_abyss_complete = true
                                        return "刷新"
                                    end
                                
                                end
                                env.end_point = {item.grid_x, item.grid_y}
                            end
                            
                            return true 
                        end
                    end
                    env.minimap_info = nil
                    return "刷新"
                end
            end

            poe2_api.dbgp("current_map_info: ",current_map_info)
            if path_list and next(path_list) and #path_list > 1 then  
                -- poe2_api.printTable(path_list)
                poe2_api.dbgp("next(path_list)(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end 

            if env.need_attack then
                poe2_api.dbgp("env.need_attack--------------------------")
                return bret.RUNNING
            end
            if env.user_config["全局設置"]["界域之门"] then
                if env.special_mode_enabled and env.special_map_type == game_str.The_Invitation_of_Skeleton_Mark_TWCH then
                    if not poe2_api.table_contains(player_info.current_map_name_utf8,{game_str.Abyss_Pinnacle_MDANA}) then
                        env.need_ReturnToTown = true
                        poe2_api.dbgp("开启特殊玩法骷髅马克，不在对应地图回城")
                        api_Sleep(3000)
                        return bret.RUNNING
                    end
                end
            end
            if not poe2_api.table_contains(player_info.current_map_name_utf8,{game_str.MapAugury_MDANA,game_str.MapAugury_NoBoss_MDANA,game_str.MapUniqueMegalith_MDANA}) then
                local state = get_target_minimap_object(current_map_info)
                if type(state) == "string" then
                    poe2_api.dbgp("刷新小地图对象--------------------------")
                    return bret.RUNNING
                elseif state then
                    poe2_api.dbgp("statestatestatestatestatestatestatestatestatestate(state)(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                    return bret.SUCCESS 
                end
            end

            -- 主要逻辑
            if no_mos_back then
                result = poe2_api.monster_monitor(45, env.UI_info)
            else
                result = true
            end

            if string.find(player_info.current_map_name_utf8,game_str.Claimable_EN) then
                result = poe2_api.monster_monitor(0, env.UI_info)
                env.radius = 30
            end
            poe2_api.dbgp("result -- > ", result)

            -- if current_time - self.last_action_time >= self.action_interval then
            if current_time - self.last_action_time >= 10 then
                point = api_GetUnexploredArea(env.radius)
                if player_info.current_map_name_utf8 == game_str.Abyss_Pinnacle_MDANA then
                    local function return_to_town_judgment()
                        local num = 0
                        -- local item = false
                        for _, v in ipairs(env.range_info) do
                            if v.name_utf8 == game_str.The_Container_of_Mark_the_Skeleton_TWCH then
                                if next(v.stateMachineList) and v.stateMachineList[game_str.dead_SML] == 1 then
                                    if v.stateMachineList[game_str.times_revived_SML] == 4 and not env.player_info.isInBossBattle and v.life == 0 then
                                        num = 1
                                        break
                                    end
                                    if v.stateMachineList[game_str.times_revived_SML] == 3 and not env.user_config["全局設置"]["骷髅马克玩法"]["骷髅马克是否打本体"] then
                                        num = 2
                                        break
                                    end
                                end
                            end
                        end
                        if num == 1 then
                            poe2_api.dbgp("111111111111")
                            return true
                        elseif num == 2 then
                            for _, v in ipairs(env.range_info) do
                                if v.name_utf8 == game_str.Obtain_the_ring_TWCH then
                                    if next(v.stateMachineList) and v.stateMachineList[game_str.active_SML] == 0 and not env.user_config["全局設置"]["骷髅马克玩法"]["骷髅马克是否打本体"] then
                                        poe2_api.dbgp("22222")
                                        return true
                                    end
                                end
                            end
                            
                        end
                        
                        return false
                        
                    end
                    if return_to_town_judgment() then
                        poe2_api.dbgp("地图完成回城")
                        api_Sleep(3000)
                        -- point.x, point.y = -1, -1
                        env.need_ReturnToTown = true
                        env.is_church_completed = true
                        return bret.RUNNING


                    else
                        env.is_church_completed = false
                        local dis = poe2_api.point_distance(404,779,env.player_info)
                        local dis1 = poe2_api.point_distance(435,754,env.player_info)
                        if dis1 < dis then
                            point.x, point.y = 435,754
                        else
                            point.x, point.y = 404,779
                        end
                    end
                end
                poe2_api.dbgp("radius -- > ", env.radius)
                poe2_api.dbgp("point -- > ", point.x, "--", point.y)
                poe2_api.dbgp("env.have_ritual -- > ", env.have_ritual)
                if point.x ~= -1 and point.y ~= -1 and env.have_ritual then
                    poe2_api.dbgp("貪圖========================================")
                    env.is_map_complete = false
                    env.end_point = {point.x, point.y}
                    env.is_arrive_end = false
                    self.last_action_time = current_time
                    poe2_api.time_p("检查目标点(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                end

                -- poe2_api.dbgp(poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH}))

                local function check_Delirium_object()
                    -- 基础空值检查
                    if not env or not env.range_info then
                        return false
                    end
                    
                    -- 遍历并检查条件
                    for _, item in ipairs(env.range_info) do
                        if item and 
                           item.MinimapIconActive == game_str.AfflictionInitiator_EN and
                           item.stateMachineList and
                           item.stateMachineList.goodbye == 1 then
                            return true
                        end
                    end
                    
                    return false
                end

                if (string.find(env.player_info.current_map_name_utf8, game_str.Delirium_) and check_Delirium_object()) or ((point.x == -1 and point.y == -1) and not string.find(env.player_info.current_map_name_utf8, game_str.Delirium_)) or (poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH}) and (result or poe2_api.find_text({UI_info = env.UI_info, text = game_str.The_arena_TWCH,min_x=0,max_x=1600}))) or (poe2_api.find_text({UI_info = env.UI_info, text =game_str.There_are_0_remaining_monsters_TWCH}) and not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not string.find(env.player_info.current_map_name_utf8, game_str.Delirium_)) or poe2_api.find_text({UI_info = env.UI_info, text = game_str.Return_to_the_surface_TWCH,min_x = 0,min_y = 0}) then
                    poe2_api.dbgp(game_str.Map_completed_TWCH)
                    
                    -- 提前结束迷雾状态
                    -- if poe2_api.click_text_UI({UI_info = env.UI_info, text = "delirium_skip_delay_button",click=2}) then
                    --     api_Sleep(1000)
                    --     return bret.RUNNING
                    -- end
                
                    -- Boss战Bug记录点回城
                    if player_info.isInBossBattle or (env.false_times or 0) > 5 then
                        poe2_api.dbgp("Boss战Bug记录点回城==>", env.false_times)
                        local list = poe2_api.get_sorted_list(env.range_info, env.player_info)
                        for _, item in ipairs(list) do
                            if item.name_utf8 == game_str.Check_point then
                                local distance = poe2_api.point_distance(item.grid_x, item.grid_y, player_info)
                                if distance and distance > 25 then
                                    env.end_point = {item.grid_x, item.grid_y}
                                    env.is_arrive_end = false
                                    poe2_api.time_p("检查目标点(Boss战小地图对象Bug记录点回城)(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                                    return bret.SUCCESS
                                else
                                    env.false_times = 0
                                end
                                -- env.end_point = {item.grid_x, item.grid_y}
                                -- env.is_arrive_end = false
                                -- poe2_api.time_p("检查目标点(Boss战Bug记录点回城)(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                                -- return bret.SUCCESS
                            end
                        end
                        local current_map_sorted_info = poe2_api.get_sorted_list(current_map_info, player_info)
                        for _, item in ipairs(current_map_sorted_info) do
                            if poe2_api.table_contains(item.name_utf8,{game_str.BossCheckpointActive_EN,game_str.Checkpoint_EN}) then
                                -- local is_path = is_point1(item.grid_x,item.grid_y)
                                -- if is_path and next(is_path) then
                                local distance = poe2_api.point_distance(item.grid_x, item.grid_y, player_info)
                                if distance and distance > 25 then
                                    env.end_point = {item.grid_x, item.grid_y}
                                    env.is_arrive_end = false
                                    poe2_api.time_p("检查目标点(Boss战小地图对象Bug记录点回城)(SUCCESS1) 耗时 -->", api_GetTickCount64() - current_time)
                                    return bret.SUCCESS
                                else
                                    env.false_times = 0
                                end
                                -- end
                            end
                        end
                        if string.find(player_info.current_map_name_utf8,game_str.MapUniqueMegalith_MDANA) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH}) then
                            local point = api_FindRandomWalkablePosition(player_info.grid_x,player_info.grid_y,100)
                            if point then
                                env.end_point = {point.x, point.y}
                                return bret.SUCCESS
                            end
                        end
                    end

                    if poe2_api.table_contains(player_info.current_map_name_utf8,{game_str.MapAugury_MDANA,game_str.MapAugury_NoBoss_MDANA,game_str.MapUniqueMegalith_MDANA}) then
                        if (point.x == -1 and point.y == -1) or poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH}) or result then
                            local state = get_target_minimap_object(current_map_info)
                            if type(state) == "string" then
                                poe2_api.dbgp("刷新小地图对象--------------------------")
                                return bret.RUNNING
                            elseif state then
                                poe2_api.time_p("检查目标点(state)(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                                return bret.SUCCESS 
                            end
                        end
                    end

                    if string.find(player_info.current_map_name_utf8,game_str.Abyss_EN) then
                        if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.Return_to_the_surface_TWCH,min_x = 0,min_y = 0}) then
                            api_InitExplorationArea()
                            poe2_api.time_p("深渊地图(RUNNING1) 耗时 -->", api_GetTickCount64() - current_time)
                            return bret.RUNNING
                        end
                        if not env.is_abyss_time then
                            env.is_abyss_time = true
                            env.abyss_time = api_GetTickCount64()
                            poe2_api.time_p("深渊地图(RUNNING2) 耗时 -->", api_GetTickCount64() - current_time)
                            return bret.RUNNING
                        end
                        env.is_abyss_complete = true
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Return_to_the_surface_TWCH,min_x = 0,min_y = 0,add_x = -50, click = 2})
                        api_Sleep(1000)
                        poe2_api.time_p("深渊地图(RUNNING) 耗时 -->", api_GetTickCount64() - current_time)
                        return bret.RUNNING
                    else
                        env.is_map_complete = true
                        env.one_other_map = nil
                    end

                    if not string.find(player_info.current_map_name_utf8 or "", game_str.town) and not poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout) or poe2_api.table_contains(player_info.current_map_name_utf8, PRIORITY_MAPS) then
                        no = poe2_api.is_have_mos({range_info = env.range_info, player_info = player_info,dis = 80, not_sight = 1})
                        if no then
                            point = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 60, 10, 0, 0.5)
                            if point then
                                env.end_point = {point.x, point.y}
                                env.is_arrive_end = false
                                poe2_api.time_p("检查目标点(api_GetSafeAreaLocationNoMonsters)(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                                return bret.SUCCESS
                            end
                            env.drop_items = true
                        end

                        -- 寻找传送门

                        if env.range_info then
                            for _, k in ipairs(env.range_info) do
                                if k.name_utf8 ~= '' and k.type == 5 and poe2_api.table_contains(k.name_utf8, my_game_info.hideout_CH) then
                                    dis = poe2_api.point_distance(k.grid_x, k.grid_y, player_info)
                                    if dis and dis < 50 then
                                        if not poe2_api.find_text({UI_info = env.UI_info, text = k.name_utf8, click = 2}) then
                                            api_ClickMove(poe2_api.toInt(k.grid_x), poe2_api.toInt(k.grid_y), 1)
                                        end
                                        api_Sleep(2000)
                                        -- env.false_times = 0
                                        return bret.RUNNING
                                    end
                                end
                            end
                        end

                        api_ClickMove(poe2_api.toInt(player_info.grid_x),poe2_api.toInt(player_info.grid_y),7)
                        api_Sleep(500)
                        api_ClickScreen(1230, 815, 0)
                        api_Sleep(500)
                        api_ClickScreen(1230, 815, 1)
                        -- api_Sleep(1500)
                        poe2_api.dbgp("重置地图信息")
                        api_RestoreOriginalMap()
                        api_UpdateMapObstacles(env.radius * 2)
                        self.false_times = self.false_times + 3000
                        env.false_times = (env.false_times or 0) + 1
                        self.last_action_time = current_time + 3000
                        return bret.RUNNING
                    else
                        env.return_town = false
                        point = api_FindRandomWalkablePosition(player_info.grid_x,player_info.grid_y,50)
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), 7)
                        end
                        self.last_action_time = current_time 
                        return bret.RUNNING
                    end
                else
                    env.is_map_complete = false
                    env.end_point = {point.x, point.y}
                    env.is_arrive_end = false
                    poe2_api.time_p("检查目标点(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                end
            end
            return bret.RUNNING
        end
    },


    -- 强化(通用)
    -- 核心参数 env.strengthened_map_obj(要强化的物品)
    --  env.warehouse_type_interactive(仓库类型)
    --  env.currency_name(使用通货物品名称)
    Strengthened = {
        run = function(self, env)
            poe2_api.print_log("执行强化操作...")
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.is_wait = false
                self.current = 0
                self.wait_item = nil  
                self.type = nil
                self.bool = true
            end

            if self.current == 0 then
                self.current = api_GetTickCount64()
            end
            if api_GetTickCount64() - self.current > 3000 then
                self.type = nil
                self.current = 0
            end
            poe2_api.dbgp("env.strengthened_map_obj" , env.strengthened_map_obj.category_utf8)
            poe2_api.dbgp("env.warehouse_type_interactive" , env.warehouse_type_interactive)
            poe2_api.dbgp("env.currency_name" , env.currency_name)
            -- api_Sleep(1000000)
            local config = env.user_config
            local item_config = poe2_api.get_items_config_info(config)
            local page = nil
            local type_ck = false -- false 为个仓  true 为公仓
            local map_object = env.strengthened_map_obj
            if env.warehouse_type_interactive == game_str.Warehouse_text then
                type_ck = false
            else
                type_ck = true
            end
            for _, v in ipairs(item_config) do
                if v["類型"] == "通貨" and not v["不撿"] and string.find(env.currency_name,v["基礎類型名"]) and v["工會倉庫"] == type_ck then
                    page = v["存倉頁名"]
                    break
                end
            end
            if not page then
                for _, v in ipairs(item_config) do
                    if v["類型"] == "通貨" and not v["不撿"] and v["基礎類型名"] == "全部物品" and v["工會倉庫"] == type_ck then
                        page = v["存倉頁名"]
                        break
                    end
                end
            end
            poe2_api.dbgp("page" , page)
            -- api_Sleep(1000000)
            local function bag_operate(godown_info,min_x,min_y,max_x,max_y)
                -- 判断背包物品
                local function get_items(bag_info,item)
                    if not bag_info or not next(bag_info) then
                        return false
                    end
                    -- poe2_api.printTable(bag_info)

                    -- api_Sleep()
                    for _, v in ipairs(bag_info) do
                        if v.baseType_utf8 == item then
                            return v
                        end
                    end
                    return false
                end
                -- 判断仓库有无通货页
                local function get_special_page(godown_info,page_type)
                    if not godown_info or not next(godown_info) then
                        return false
                    end
                    -- poe2_api.printTable(godown_info)
                    -- api_Sleep()
                    for _, v in ipairs(godown_info) do
                        if v.type == page_type then
                            if not v.name_utf8 or v.name_utf8 == "" then 
                                error("通货页未设置文本，请在游戏中设置！！！")
                            end
                            return v
                        end
                    end
                    return false
                end
                
                local bag_info = env.bag_info
                local item = get_items(bag_info,env.currency_name)
                if item then
                    local point = poe2_api.get_center_position({item.start_x,item.start_y},{item.end_x,item.end_y})
                    api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                    api_Sleep(300)
                    api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),2)
                    api_Sleep(300)
                    local point = poe2_api.get_center_position({map_object.start_x,map_object.start_y},{map_object.end_x,map_object.end_y})
                    api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                    api_Sleep(300)
                    api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                    api_Sleep(300)
                    if env.currency_name == game_str.Exalted_Orb_TWCH then
                        env.supreme_use_count = env.supreme_use_count + 1
                    end
                    env.streng_map_flushed_switch = true
                    return false
                end
                local precut_page = nil
                for _, v in ipairs(godown_info) do
                    if v.name_utf8 == page then
                        precut_page = v
                        break
                    end
                end
                if not precut_page then 
                    error("未找到预设存仓页 ->"..tostring(page).."<-,请检查预设存仓页与游戏仓库页是否一致")
                    
                elseif precut_page.manage_index == 0 then
                    if poe2_api.find_text({text = page,UI_info = env.UI_info,max_y=max_y,min_x=min_x,max_x=max_x,min_y=min_y,click = 2}) then 
                        self.is_wait = true
                        self.current = api_GetTickCount64()
                        self.wait_item = 500
                        self.type = page
                    end
                    return false
                end
                local index = nil
                if not type_ck then
                    index = 0
                else
                    index = 2
                end
                
                local currency = api_Getinventorys(precut_page.manage_index,index)
                if currency and next(currency) then
                    
                    local item = get_items(currency,env.currency_name)
                    if item then
                        -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk11111")
                        -- api_Sleep(10000000000000000)
                        if self.type ~= page then
                            if poe2_api.find_text({text = page,UI_info = env.UI_info,max_y=max_y,min_x=min_x,max_x=max_x,min_y=min_y,click = 2}) then 
                                self.is_wait = true
                                self.current = api_GetTickCount64()
                                self.wait_item = 500
                                self.type = page
                                return false
                            end
                        end
                        local point = nil
                        if poe2_api.table_contains(precut_page.type,{0,1}) then
                            point = poe2_api.get_center_position_store({item.start_x,item.start_y},{item.end_x,item.end_y})
                        elseif precut_page.type == 3 then
                            local item_list = api_GetInventoryItemsInRect(17,109,536,626)
                            local function get_item_point()
                                for _,v in ipairs(item_list) do
                                    if v.baseType_utf8 == item.baseType_utf8 then
                                        local point = {(v.RectSart_x + v.RectEnd_x) / 2, (v.RectSart_y + v.RectEnd_y) / 2}
                                        return point
                                    end
                                end
                            end
                            point = get_item_point()
                        elseif precut_page.type == 7 then
                            point = poe2_api.get_center_position_store_max({item.start_x,item.start_y},{item.end_x,item.end_y})
                        end
                        if not point then
                            env.streng_map_flushed_switch = true
                            return false    
                        end
                        api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                        api_Sleep(200)
                        if index == 0 then
                            api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),2)
                            api_Sleep(200)
                            local point = poe2_api.get_center_position({map_object.start_x,map_object.start_y},{map_object.end_x,map_object.end_y})
                            api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                            api_Sleep(200)
                            api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                            api_Sleep(200)
                            if env.currency_name == game_str.Exalted_Orb_TWCH then
                                env.supreme_use_count = env.supreme_use_count + 1
                            end
                        else
                            poe2_api.ctrl_left_click(point[1],point[2])
                            api_Sleep(800)
                        end
                        
                        env.streng_map_flushed_switch = true
                        return false
                    end
                end
                -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk222222")
                -- api_Sleep(10000000000000000)
                local page_type = get_special_page(godown_info,3)
                poe2_api.dbgp("precut_page.type",precut_page.type)
                poe2_api.dbgp("page_type",page_type)
                -- api_Sleep(10000000000)
                if precut_page.type == 3 or not page_type then
                    if string.find(map_object.baseType_utf8,game_str.Monument_plaque_TWCH) then
                        env.is_public_warehouse_plaque = true
                        env.is_update_plaque = false
                        table.insert(env.lack_of_currency,env.currency_name)
                    else
                        table.insert(env.lack_of_currency,env.currency_name)
                        -- env.is_strengthened_map = false
                        -- env.streng_map_flushed_switch = false
                        -- env.is_public_warehouse = true
                    end
                    -- env.item_state[env.currency_name] = false
                    return false
                end
                
                if page_type.manage_index == 0 then
                    if poe2_api.find_text({text = page_type.name_utf8,UI_info = env.UI_info,max_y=max_y,min_x=min_x,max_x=max_x,min_y=min_y,click = 2}) then 
                        self.is_wait = true
                        self.current = api_GetTickCount64()
                        self.wait_item = 500
                        self.type = page_type.name_utf8
                        return false
                    end
                end
                -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk44444")
                -- api_Sleep(10000000000000000)
                local currency = api_Getinventorys(page_type.manage_index,index)
                if currency and next(currency) then
                    -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk6666")
                    -- api_Sleep(10000000000000000)
                    poe2_api.dbgp("TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT")
                    local item = get_items(currency,env.currency_name)
                    poe2_api.dbgp(env.currency_name)
                    if item then
                        -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk")
                        -- api_Sleep(10000000000000000)
                        if self.type ~= page_type.name_utf8 then
                            if poe2_api.find_text({text = page_type.name_utf8,UI_info = env.UI_info,max_y=max_y,min_x=min_x,max_x=max_x,min_y=min_y,click = 2}) then 
                                self.is_wait = true
                                self.current = api_GetTickCount64()
                                self.wait_item = 500
                                self.type = page_type.name_utf8
                                return false
                            end
                        end
                        local item_list = api_GetInventoryItemsInRect(17,109,536,626)
                        local function get_item_point()
                            for _,v in ipairs(item_list) do
                                if v.baseType_utf8 == item.baseType_utf8 then
                                    local point = {(v.RectSart_x + v.RectEnd_x) / 2, (v.RectSart_y + v.RectEnd_y) / 2}
                                    return point
                                end
                            end
                        end
                        -- local point = my_game_info.currency_page[item.baseType_utf8]
                        local point = get_item_point()
                        if not point then
                            env.streng_map_flushed_switch = true
                            return false    
                        end
                        api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                        api_Sleep(200)
                        if index == 0 then
                            api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),2)
                            api_Sleep(200)
                            local point = poe2_api.get_center_position({map_object.start_x,map_object.start_y},{map_object.end_x,map_object.end_y})
                            api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                            api_Sleep(200)
                            api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                            api_Sleep(200)
                            if env.currency_name == game_str.Exalted_Orb_TWCH then
                                env.supreme_use_count = env.supreme_use_count + 1
                            end
                        else
                            poe2_api.ctrl_left_click(point[1],point[2])
                            api_Sleep(800)
                        end
                        env.streng_map_flushed_switch = true
                        return false
                    end
                end
                -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk555555")
                -- api_Sleep(10000000000000000)
                if string.find(map_object.baseType_utf8,game_str.Monument_plaque_TWCH) then
                    env.is_public_warehouse_plaque = true
                    env.is_update_plaque = false
                    table.insert(env.lack_of_currency,env.currency_name)
                else
                    table.insert(env.lack_of_currency,env.currency_name)
                    -- env.is_strengthened_map = false
                    -- env.streng_map_flushed_switch = false
                    -- env.is_public_warehouse = true
                end
                -- env.item_state[env.currency_name] = false
                return false
            end
            
            if self.is_wait then
                if api_GetTickCount64() - self.current > self.wait_item then 
                    poe2_api.dbgp("等待间隔时间到达")
                    poe2_api.time_p("强化(通用)（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                self.is_wait = false
            end
            if not poe2_api.find_text({UI_info=env.UI_info,text=game_str.backpack,min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                poe2_api.click_keyboard("i")
                api_Sleep(500)
                self.is_wait = true
                self.current = api_GetTickCount64()
                self.wait_item = 1000
                poe2_api.time_p("强化(通用)（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local tab_list_button = poe2_api.click_text_UI({text = game_str.tab_list_button, UI_info = env.UI_info,ret_data = true})
            if not tab_list_button then
                local godown_info
                if not type_ck then
                    godown_info = api_GetRepositoryPages(0)
                else
                    godown_info = api_GetRepositoryPages(1)
                end
                if not bag_operate(godown_info,10,0,500,90) then
                    poe2_api.time_p("强化(通用)（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            else
                
                local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
                local lock_button = {}
                for _,v in ipairs(lock) do
                    if v.name_utf8 == "" and v.text_utf8 == "" then
                        table.insert(lock_button,v)
                    end
                end
                if not lock_button or not next(lock_button) then
                    api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                    api_Sleep(2000)
                    api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),1)
                    api_Sleep(1000)
                    poe2_api.time_p("强化(通用)（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local godown_info
                if not type_ck then
                    godown_info = api_GetRepositoryPages(0)
                else
                    godown_info = api_GetRepositoryPages(1)
                end
                if not bag_operate(godown_info,556,20,851,800) then
                    poe2_api.time_p("强化(通用)（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            poe2_api.time_p("强化(通用)（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.RUNNING
        end
    },

    -- 地图强化是否到点
    Is_Arrive_Point_FUHUASHENGYV = {
        run = function(self, env)
            poe2_api.print_log("强化地图(腐化圣域)...")
            local start_time = api_GetTickCount64()
            local player_info = env.player_info
            local bag_info = env.bag_info
            local current_map_info = env.current_map_info
            -- local is_insert_stone = env.is_insert_stone
            local entry_length_take_map = env.entry_length_take_map
            local the_update_map = env.the_update_map
            local map_update_to = env.map_update_to
            local user_map = env.user_map
            local map_up = env.map_up
            local not_have_stackableCurrency = env.not_have_stackableCurrency
            
            -- 检查是否在城镇或藏身处
            if not string.find(player_info.current_map_name_utf8, game_str.town) and 
                not poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) or 
                not map then
                    poe2_api.dbgp("不在城镇或藏身处，或未找到地图装置")
                    env.entry_length_take_map = true
                    env.not_have_stackableCurrency = false
                    poe2_api.dbgp(string.format("节点执行耗时: %.2f 毫秒", (api_GetTickCount64() - start_time) * 1000))
                    return bret.SUCCESS
            end
            
            -- 检查地图强化条件
            if the_update_map then
                poe2_api.dbgp("检查地图强化条件...")
                local map_level = poe2_api.select_best_map_key({
                    inventory = bag_info,
                    key_level_threshold = user_map,
                    vall = true
                })
                
                if map_level then
                    poe2_api.dbgp(string.format("找到地图: %s (颜色: %d, 词缀数: %d)", 
                        map_level.baseType_utf8, map_level.color, map_level.fixedSuffixCount))
                    
                    if map_level.color > 0 and map_level.fixedSuffixCount >= map_update_to then
                        poe2_api.dbgp("地图已满足强化条件，重置状态")
                        env.map_up = false
                        env.entry_length_take_map = false
                        env.the_update_map = nil
                        poe2_api.dbgp(string.format("节点执行耗时: %.2f 毫秒", (api_GetTickCount64() - start_time) * 1000))
                        return bret.SUCCESS
                    end
                end
            end
            
            -- 检查是否需要强化
            if not map_up or not entry_length_take_map then
                poe2_api.dbgp("不需要强化地图或未设置entry_length_take_map")
                env.not_have_stackableCurrency = false
                poe2_api.dbgp(string.format("节点执行耗时: %.2f 毫秒", (api_GetTickCount64() - start_time) * 1000))
                return bret.SUCCESS
            end
            
            local map = nil
            for _, item in ipairs(current_map_info) do
                if item.name_utf8 == game_str.MapDevice then
                    map = item
                    break
                end
            end
            
            if not the_update_map then
                poe2_api.dbgp("未设置the_update_map")
                env.not_have_stackableCurrency = false
                env.entry_length_take_map = true
                poe2_api.dbgp(string.format("节点执行耗时: %.2f 毫秒", (api_GetTickCount64() - start_time) * 1000))
                return bret.SUCCESS
            end
            
            if not_have_stackableCurrency then
                poe2_api.dbgp("没有可堆叠货币")
                poe2_api.dbgp(string.format("节点执行耗时: %.2f 毫秒", (api_GetTickCount64() - start_time) * 1000))
                return bret.SUCCESS
            end
            
            -- 移动逻辑部分
            poe2_api.dbgp("开始处理移动逻辑...")
            local function get_items_config_info()
                local config = env.user_config
                local item_filters = config["物品過濾"] or {}
                local processed_configs = {}
                
                for _, cfg in ipairs(item_filters) do
                    local item_type = cfg["類型"]
                    if type(item_type) == "string" then
                        item_type = {item_type}
                    end
                    
                    local processed_cfg = {
                        ["類型"] = item_type,
                        ["名稱模式"] = cfg["基礎類型名"] == "全部物品" and "all" or "specific",
                        ["匹配名稱"] = cfg["基礎類型名"] ~= "全部物品" and {cfg["基礎類型名"]} or {},
                        ["颜色"] = {}
                    }
                    
                    if cfg["白裝"] then table.insert(processed_cfg["颜色"], 0) end
                    if cfg["藍裝"] then table.insert(processed_cfg["颜色"], 1) end
                    if cfg["黃裝"] then table.insert(processed_cfg["颜色"], 2) end
                    if cfg["暗金"] then table.insert(processed_cfg["颜色"], 3) end

                    processed["不撿"] = cfg["不撿"]
                    processed["等級"] = cfg["等級"]
                    processed["名稱"] = cfg["名稱"]
                    
                    table.insert(processed_configs, processed_cfg)
                end
                
                return processed_configs
            end
            
            local items_info = get_items_config_info()
            local unique_storage_pages = {}
            
            for _, item in ipairs(items_info) do
                if item["類型"] == "通貨" and item["存倉頁名"] and not item["工會倉庫"] then
                    unique_storage_pages[item["存倉頁名"]] = true
                end
            end
            
            local obj = nil
            local text = nil
            local warehouse = nil
            
            if next(unique_storage_pages) ~= nil then
                poe2_api.dbgp("使用个人仓库")
                for _, item in ipairs(current_map_info) do
                    if item.name_utf8 == game_str.StashPlayer then
                        warehouse = item
                        break
                    end
                end
                obj = game_str.StashPlayer
                text = game_str.Guild_Warehouse
            else
                poe2_api.dbgp("使用公会仓库")
                for _, item in ipairs(current_map_info) do
                    if item.name_utf8 == game_str.StashGuild_EN then
                        warehouse = item
                        break
                    end
                end
                obj = game_str.StashGuild_EN
                text = game_str.Warehouse
                env.is_public_warehouse_plaque = false
            end
            
            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Emphasize_the_item, min_y = 700, min_x = 250}) and 
            not poe2_api.find_text({UI_info = env.UI_info, text = text, min_x = 0, min_y = 32, max_x = 381, max_y=78}) then
                poe2_api.dbgp("已打开仓库界面")
                poe2_api.print_log("清路径444")
                env.path_list = nil
                env.end_point = nil
                return bret.SUCCESS
            end
            
            if not warehouse then
                poe2_api.dbgp("未找到仓库对象")
                return bret.FAIL
            end
            
            local distance = poe2_api.point_distance(warehouse.grid_x, warehouse.grid_y, player_info)
            poe2_api.dbgp(string.format("与仓库的距离: %.2f", distance))
            
            if distance and distance > 25 then
                poe2_api.dbgp("距离仓库太远，设置交互对象")
                env.interactive = obj
                poe2_api.dbgp(string.format("节点执行耗时: %.2f 毫秒", (api_GetTickCount64() - start_time) * 1000))
                return bret.FAIL
            else
                poe2_api.dbgp("正在移动到仓库位置...")
                api_ClickMove(poe2_api.toInt(warehouse.grid_x), poe2_api.toInt(warehouse.grid_y), 1)
                poe2_api.dbgp(string.format("节点执行耗时: %.2f 毫秒", (api_GetTickCount64() - start_time) * 1000))
                return bret.RUNNING
            end
        end
    },

    -- 是否需要插入碑牌
    Is_Insert_Plaque = {
        run = function(self, env)
            -- return bret.SUCCESS
            poe2_api.print_log("是否需要插入碑牌...")
            -- while true do
            --     return bret.SUCCESS
            -- end
            local start_time = api_GetTickCount64()
            local player_info = env.player_info
            local current_map_info = env.current_map_info
            if not next(player_info) then
                poe2_api.dbgp("未找到玩家信息,插碑")
                poe2_api.time_p("是否需要插入碑牌（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            
            -- local is_insert_stone = env.is_insert_stone
            -- if not is_insert_stone then
            --     poe2_api.dbgp("未开启插碑，不判断")
            --     poe2_api.time_p("是否需要插入碑牌（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
            --     return bret.SUCCESS
            -- end

            if env.one_other_map then
                poe2_api.dbgp("已开图，不插碑")
                env.is_public_warehouse = true
                env.strengthened_map_obj = nil
                poe2_api.time_p("是否需要插入碑牌（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            
            -- local is_have_stone = env.is_have_stone
            -- if not is_have_stone then
            --     poe2_api.dbgp("未找到可插入的塔")
            --     poe2_api.time_p("是否需要插入碑牌（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time) 
            --     return bret.SUCCESS
            -- end
            local not_exist_stone = env.not_exist_stone
            local stone_order = env.stone_order
            -- 判断两个数组是否相等
            local function deep_equal_unordered(a, b)
                if type(a) ~= type(b) then return false end
                if type(a) ~= "table" then return a == b end
                if #a ~= #b then return false end
            
                -- 统计 a 的元素（支持嵌套 table）
                local count = {}
                for _, v in ipairs(a) do
                    local key = type(v) == "table" and table.concat(v, ",") or tostring(v)
                    count[key] = (count[key] or 0) + 1
                end
            
                -- 检查 b 的元素
                for _, v in ipairs(b) do
                    local key = type(v) == "table" and table.concat(v, ",") or tostring(v)
                    if not count[key] then return false end
                    count[key] = count[key] - 1
                end
            
                return true
            end
            local function get_bag_plaque()
                if not env.bag_info or not next(env.bag_info) then return false end
                local num = 0
                for i, v in ipairs(env.bag_info) do
                    if v.category_utf8 == game_str.TowerAugmentation and poe2_api.table_contains(env.stone_order,v.baseType_utf8) then
                        num = num + 1
                    end
                end
                if num > 0 then
                    return true
                end
                return false
            end 
            if not_exist_stone and next(not_exist_stone) and stone_order and next(stone_order) then
                if not get_bag_plaque() and deep_equal_unordered(not_exist_stone, stone_order)  then
                    poe2_api.dbgp("没有可用碑牌")
                    poe2_api.time_p("是否需要插入碑牌（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
            end
            local max_map = poe2_api.select_best_map_key({inventory=env.bag_info,key_level_threshold=env.user_map,not_use_map = env.not_use_map})
            if not max_map then
                poe2_api.dbgp("未找到地图(max_map)")
                -- api_Sleep(10000)
                return bret.SUCCESS
            end
            local plaque_num = 3
            -- poe2_api.dbgp("max_map.fixedSuffixCount: " .. max_map.fixedSuffixCount)
            -- -- api_Sleep(10000)
            -- if max_map.fixedSuffixCount < 3 then
            --     plaque_num = 1
            -- elseif max_map.fixedSuffixCount < 6 then
            --     plaque_num = 2
            -- else
            --     plaque_num = 3
            -- end
            local get_plaque = api_Getinventorys(77,0)
            if plaque_num > #get_plaque and not get_bag_plaque() then
                env.is_get_plaque = true
                env.is_update_plaque = true
                env.pick_up_number = plaque_num - #get_plaque
                poe2_api.time_p("是否需要插入碑牌（RUNNING）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            else
                poe2_api.time_p("是否需要插入碑牌（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            
        end
    },

    -- 是否需要移动插碑
    Is_Move_Insert_Plaque = {
        run = function(self, env)
            poe2_api.dbgp("是否需要移动插碑...")
            local start_time = api_GetTickCount64()
            local current_map_info = env.current_map_info
            local player_info = env.player_info
            if not next(player_info) then
                poe2_api.dbgp("未找到玩家信息,插碑移动")
                poe2_api.time_p("是否需要移动插碑（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if not current_map_info then
                poe2_api.dbgp("未找到小地图信息,插碑移动")
                poe2_api.time_p("是否需要移动插碑（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local function is_map_device(obj_list)
                if not obj_list or #obj_list == 0 then
                    return false
                end
                for _, i in ipairs(obj_list) do
                    if i.name_utf8 == game_str.MapDevice then
                        return i
                    end
                end
                return false
            end
            local map = is_map_device(current_map_info)
            if map then
                local distance = poe2_api.point_distance(map.grid_x, map.grid_y, player_info)
                if poe2_api.find_text({text = game_str.World_map,UI_info = env.UI_info,min_x=0,min_y=0,max_y=78}) and distance <30 then
                    env.end_point = {}
                    api_Sleep(500)
                    poe2_api.time_p("是否需要移动插碑（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
            end
            env.interactive = game_str.MapDevice
            poe2_api.dbgp("正在移动到地图装置位置  ")
            poe2_api.time_p("是否需要移动插碑（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end
    },

    -- 插入牌匾(动作)
    Insert_Plaque = {
        run = function(self, env)
            poe2_api.print_log("执行插入牌匾动作...")
            local start_time = api_GetTickCount64()
            if not poe2_api.find_text({UI_info = env.UI_info,text = game_str.World_map,min_x=0,min_y=0,max_y=78}) then
                poe2_api.time_p("插入牌匾(动作)（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            else
                api_Sleep(1000)
            end

            local ret = api_GetEndgameMapNodes()
            local bag_info = env.bag_info
            local stone_info = env.stone_info
            local sorted_map = env.sorted_map
            local user_map = env.user_map
            local not_use_map = env.not_use_map
            local not_enter_map = env.not_enter_map
            local error_other_map = env.error_other_map
            local not_have_stackableCurrency = env.not_have_stackableCurrency
            local point1, point2 = api_GetcurrentEndgameNodePoints()
            local get_map = nil
            if env.first_map and env.first_map == game_str.Corruption_Sanctuary_TWCH then
                poe2_api.dbgp(game_str.Corruption_Sanctuary_TWCH)
                get_map = poe2_api.get_map(
                {otherworld_info = ret, sorted_map = sorted_map, not_enter_map = not_enter_map, bag_info = bag_info, 
                key_level_threshold = user_map, not_use_map = not_use_map, 
                error_other_map = error_other_map, 
                not_have_stackableCurrency = not_have_stackableCurrency, currency_point = {x = point1, y = point2}, enter_city = env.enter_city}
            )
            else
                poe2_api.dbgp("not腐化聖域")
                get_map = poe2_api.get_map_oringin(
                    {otherworld_info = ret, sorted_map = sorted_map, not_enter_map = not_enter_map, bag_info = bag_info, 
                    key_level_threshold = user_map, not_use_map = not_use_map, 
                    error_other_map = error_other_map, 
                    not_have_stackableCurrency = not_have_stackableCurrency, currency_point = {x = point1, y = point2}, enter_city = env.enter_city}
                )
            end
            poe2_api.printTable(get_map)
            if not get_map then
                poe2_api.dbgp("没有最优地图，不插碑")
                env.is_have_stone = false
                poe2_api.time_p("插入牌匾(动作)（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not stone_info then
                api_EndgameNodeMove(poe2_api.toInt(get_map.position_x -1900),poe2_api.toInt(get_map.position_y-1900))
                api_Sleep(500)
            end
            if get_map.window_client_x == 0 and get_map.window_client_y == 0 then
                -- env.need_SmallRetreat = true
                poe2_api.time_p("插入牌匾(动作)（FAIL2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local ret2 = api_GetEndgameMapNodes()
            local get_map1 = nil
            for _, i in ipairs(ret2) do
                if i.index_x == get_map.index_x and i.index_y == get_map.index_y then
                    get_map1 = i
                    break
                end
            end
            if stone_info then
                local tower2 = nil
                for _, i in ipairs(ret2) do
                    if poe2_api.table_contains(i.name_utf8,my_game_info.PRIORITY_MAPS) 
                     and i.isCompleted and i.index_x == stone_info.index_x and i.index_y == stone_info.index_y then
                        tower2 = i
                        break
                    end
                end
                if not tower2 then
                    env.stone_info = nil
                    env.is_get_plaque = false
                    env.pick_up_number = 0
                    poe2_api.time_p("插入牌匾(动作)（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            if not stone_info then
                local tower = nil
                for _, i in ipairs(ret2) do
                    if poe2_api.table_contains(i.name_utf8,my_game_info.PRIORITY_MAPS)
                     and i.isCompleted and get_map1 and poe2_api.get_point_distance(get_map1.window_client_x,get_map1.window_client_y,i.window_client_x,i.window_client_y) <= 1000 then
                        tower = i
                        break
                    end
                end
                if tower then
                    env.stone_info = tower
                    env.pick_up_number = tower.monumentUnlockCount
                    local get_plaque = api_Getinventorys(77,0)
                    -- local pick_up_number = env.pick_up_number
                    if get_plaque and next(get_plaque) and #get_plaque >= tower.monumentUnlockCount then

                    else
                        env.is_get_plaque = true
                        env.is_update_plaque = true
                    end
                    
                    poe2_api.time_p("插入牌匾(动作)（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                else
                    env.is_have_stone = false
                    env.is_get_plaque = false
                    env.pick_up_number = 0
                    poe2_api.time_p("插入牌匾(动作)（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end

            local stone_order = env.stone_order
            api_EndgameNodeMove(poe2_api.toInt(stone_info.position_x),poe2_api.toInt(stone_info.position_y))
            api_Sleep(500)
            local ret1 = api_GetEndgameMapNodes()
            local tower1 = nil 
            for _, i in ipairs(ret1) do
                if poe2_api.table_contains(i.name_utf8,my_game_info.PRIORITY_MAPS)
                 and i.isCompleted and i.index_x == stone_info.index_x and i.index_y == stone_info.index_y then
                    tower1 = i
                    break
                end
            end
            -- poe2_api.printTable(tower1)
            -- api_Sleep(5000)
            if not poe2_api.find_text({text = tower1.name_cn_utf8, UI_info = env.UI_info,max_y=500,min_x=750,max_x=1100,min_y=400}) then
                if tower1.window_client_x == 0 or tower1.window_client_y == 0 then
                    -- env.need_SmallRetreat = true
                    poe2_api.time_p("插入牌匾(动作)（FAIL3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if env.operated_plaque then
                    env.is_have_stone = false
                    poe2_api.time_p("插入牌匾(动作)（RUNNING11）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                math.randomseed(os.time())
                local x = math.random(tower1.window_client_x - 10, tower1.window_client_x + 10)
                local y = math.random(tower1.window_client_y - 10, tower1.window_client_y + 10)
                poe2_api.dbgp("x,y:",x,y)
                poe2_api.click_keyboard("ctrl")
                api_Sleep(200)
                api_ClickScreen(poe2_api.toInt(x),poe2_api.toInt(y),0)
                api_Sleep(200)
                api_ClickScreen(poe2_api.toInt(x),poe2_api.toInt(y),1)
                api_Sleep(500)
                poe2_api.time_p("插入牌匾(动作)（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            elseif poe2_api.find_text({text = "警告", UI_info = env.UI_info,min_x=0}) then
                poe2_api.find_text({text = game_str.Power_TWCH, UI_info = env.UI_info,min_x=0,click = 2,sorted=true})
                api_Sleep(500)
                poe2_api.find_text({text = game_str.confirm, UI_info = env.UI_info,min_x=0,click = 2})
                api_Sleep(500)
                poe2_api.time_p("插入牌匾(动作)（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            elseif poe2_api.find_text({text = tower1.name_cn_utf8, UI_info = env.UI_info,max_y=500,min_x=750,max_x=1100,min_y=400}) and poe2_api.find_text({text = game_str.Power_TWCH, UI_info = env.UI_info,max_y=880,min_x=750,max_x=1100}) then
                if not poe2_api.find_text({UI_info=env.UI_info,text=game_str.backpack,min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                    poe2_api.click_keyboard("i")
                    api_Sleep(200)
                    poe2_api.time_p("插入牌匾(动作)（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local get_plaque = api_Getinventorys(77,0)
                local pick_up_number = env.pick_up_number
                if get_plaque and next(get_plaque) and #get_plaque >= pick_up_number then
                    poe2_api.find_text({text = game_str.Power_TWCH, UI_info = env.UI_info,max_y=880,min_x=750,max_x=1100,click = 2})
                    api_Sleep(200)
                    env.operated_plaque = true
                    poe2_api.time_p("插入牌匾(动作)（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                else
                    if not stone_order then
                        poe2_api.time_p("插入牌匾(动作)（RUNNING8）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    local function store_plaque(bag_info,stone_order)
                        if not bag_info or not next(bag_info) then
                            return false
                        end
                        for _,v in ipairs(stone_order) do
                            for _,v2 in ipairs(bag_info) do
                                if v == v2.baseType_utf8 then
                                    return v2
                                end
                            end
                        end
                        return false
                    end
                    local one_plaque = store_plaque(bag_info,stone_order)
                    if one_plaque then
                        poe2_api.ctrl_left_click_bag_items(one_plaque.obj,bag_info)
                    else
                        env.is_have_stone = false
                    end
                    poe2_api.time_p("插入牌匾(动作)（RUNNING9）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            poe2_api.time_p("插入牌匾(动作)（RUNNING10）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.RUNNING
        end
    },

    -- 是否需要交换
    Is_Need_Exchange = {
        run = function(self, env)
            poe2_api.dbgp("开始执行通货交换检查...")
            local current_time = api_GetTickCount64()  -- 获取的是毫秒数
            local config = env.user_config
            local bag_info = env.bag_info
            local player_info = env.player_info

            -- env.in_exchange = false
            
            -- if not env.is_exchange then
            env.is_exchange = config["刷圖設置"]["通貨交換設置"]["是否自動對換"] or false
            -- end

            -- 基础条件检查
            if not env.is_exchange then
                poe2_api.dbgp("自动兑换未开启，跳过")
                env.exchange_status = true
                poe2_api.time_p("Is_Need_Exchange(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Currency_exchange, min_x = 0, max_y = 200}) then
                    poe2_api.click_keyboard("space")
                    return bret.RUNNING
                end
                return bret.SUCCESS
            end
            
            -- 初始化执行时间
            if env.last_execution_time == nil or env.last_execution_time == 0 then
                poe2_api.dbgp("初始化执行时间")
                env.last_execution_time = api_GetTickCount64()
                return bret.RUNNING
            end
            
            -- 检查是否在藏身处
            if not poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                poe2_api.dbgp("不在藏身处，跳过")
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Currency_exchange, min_x = 0, max_y = 200}) then
                    poe2_api.click_keyboard("space")
                    return bret.RUNNING
                end
                return bret.SUCCESS
            end
            
            -- 检查背包空间
            if bag_info then
                local point = poe2_api.get_space_point({width = 2, height = 4, info = bag_info})
                if not point then
                    poe2_api.dbgp("背包空间不足，跳过")
                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Currency_exchange, min_x = 0, max_y = 200}) then
                    poe2_api.click_keyboard("space")
                    return bret.RUNNING
                end
                    return bret.SUCCESS
                end
            end
            
            -- 检查仓库是否已满
            -- if not env.warehouse_full then
            --     poe2_api.dbgp("仓库已满，跳过")
            --     return bret.SUCCESS
            -- end
            
            -- 冷却时间检查
            local cooldown_hours = config["刷圖設置"]["通貨交換設置"]["兌換間隔時間"] or 1
            local cooldown_ms = cooldown_hours * 60 * 60 * 1000  -- 转换为毫秒
            local elapsed_time = current_time - env.last_execution_time  -- 毫秒数相减

            -- 毫秒转换为分钟和秒的字符串
            local function ms_to_min_sec(ms)
                local total_seconds = math.floor(ms / 1000)
                local minutes = math.floor(total_seconds / 60)
                local seconds = total_seconds % 60
                return string.format("%d分%d秒", minutes, seconds)
            end
            
            -- 使用转换函数显示更友好的时间格式
            poe2_api.dbgp(string.format("冷却时间检查: 已过 %s (需要 %s)", 
                ms_to_min_sec(elapsed_time), 
                ms_to_min_sec(cooldown_ms)))
            
            if elapsed_time < cooldown_ms and not env.warehouse_full then
                poe2_api.dbgp("冷却时间未到，跳过")
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Currency_exchange, min_x = 0, max_y = 200}) then
                    poe2_api.click_keyboard("space")
                    return bret.RUNNING
                end
                return bret.SUCCESS
            end
            
            -- 取消遮挡
            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.continue, click = 2}) then
                poe2_api.dbgp("发现遮挡，点击继续")
                return bret.RUNNING
            end

            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.The_recast_platform, min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, min_x = 0}) then
                poe2_api.dbgp("发现重铸台界面，按空格关闭")
                poe2_api.click_keyboard("space")
                self.last_action_time = current_time
                return bret.RUNNING
            end
            
            poe2_api.dbgp("满足所有条件，执行兑换")
            env.in_exchange = true
            return bret.FAIL
        end
    },

    -- 获取物品数量
    Obtain_The_Quantity_of_Items = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Obtain_The_Quantity_of_Items 节点")
            
            -- 检查仓库页面是否可用
            local function check_pages()
                poe2_api.dbgp("检查仓库页面是否可用...")
                local pages = api_GetRepositoryPages(0)
                if not pages then
                    poe2_api.dbgp("警告: 无法获取仓库页面信息")
                    return false
                end
                
                for _, page in ipairs(pages) do
                    if page.onlyWithdraw then
                        goto continue
                    end
                    if page.manage_index == 0 and page.type ~= 5 then
                        poe2_api.dbgp("发现无效仓库页面(manage_index=0且type≠5)")
                        return false
                    end
                    ::continue::
                end
                return true
            end
            
            -- 获取所有库存物品
            local function get_all_inventory_items()
                poe2_api.dbgp("开始获取所有库存物品...")
                local items = {}
                
                -- 获取常规背包物品
                local bag_items = api_Getinventorys(1, 0)
                if bag_items then
                    poe2_api.dbgp(string.format("获取到背包物品数量: %d", #bag_items))
                    for _, item in ipairs(bag_items) do
                        table.insert(items, item)
                    end
                else
                    poe2_api.dbgp("警告: 无法获取背包物品")
                end
                
                -- 检查特定槽位(0x7a 到 0x7a + 199)
                for offset = 0x7a, 0x7a + 199 do
                    local slot_data = api_Getinventorys(offset, 0)
                    if slot_data then
                        -- poe2_api.dbgp(string.format("槽位 0x%x 找到 %d 件物品", offset, #slot_data))
                        for _, item in ipairs(slot_data) do
                            table.insert(items, item)
                        end
                    end
                end
                
                poe2_api.dbgp(string.format("总共获取到 %d 件物品", #items))
                return items
            end
            
            -- 主逻辑开始
            if not check_pages() then
                poe2_api.dbgp("仓库页面不可用，返回FAIL")
                return bret.FAIL
            end
            
            local config = env.user_config
            if not config then
                poe2_api.dbgp("错误: 用户配置为空")
                return bret.FAIL
            end
            
            -- 获取通货交换设置
            local exchange_config = config["刷圖設置"] and config["刷圖設置"]["通貨交換設置"] or {}
            poe2_api.dbgp("获取通货交换配置:", #exchange_config)
            -- poe2_api.printTable(exchange_config)

            -- 初始化拥有和需要的通货列表
            local owned_currencies = {}
            local needed_currencies = {}

            -- 检查是否存在物品表
            if exchange_config["物品表"] then
                for _, item in ipairs(exchange_config["物品表"]) do
                    -- 添加拥有的通货
                    if item[game_str.I_Have] and item[game_str.I_Have] ~= "" then
                        table.insert(owned_currencies, item[game_str.I_Have])
                    end
                    
                    -- 添加需要的通货
                    if item[game_str.What_I_need_TWCH] and item[game_str.What_I_need_TWCH] ~= "" then
                        table.insert(needed_currencies, item[game_str.What_I_need_TWCH])
                    end
                end
            end

            poe2_api.dbgp("配置中的拥有通货:", #owned_currencies)
            poe2_api.printTable(owned_currencies)
            poe2_api.dbgp("配置中的需要通货:", #needed_currencies)
            poe2_api.printTable(needed_currencies)
            
            -- 初始化物品数量字典
            local item_nums_dict = {}
            local all_items = get_all_inventory_items()
            
            -- 检查是否存在"全部物品"需求
            local has_all_items = false
            for _, currency in ipairs(owned_currencies) do
                if currency == "全部物品" then
                    has_all_items = true
                    break
                end
            end
            
            poe2_api.dbgp("配置中包含'全部物品':", has_all_items)
            
            -- 通货类别列表
            local currency_categories = {}
            
            -- 合并所有通货类别
            local function merge_tables(...)
                local result = {}
                for _, tbl in ipairs({...}) do
                    for _, v in ipairs(tbl) do
                        table.insert(result, v)
                    end
                end
                return result
            end
            
            currency_categories = merge_tables(
                my_game_info.StackableCurrency_CN,
                my_game_info.Delirium_in_foreign_lands_CN,
                my_game_info.Crack_Alliance_CN,
                my_game_info.Fragment_CN,
                my_game_info.Dead_realm_exploration_CN,
                my_game_info.Essence_CN,
                my_game_info.Rune_CN,
                my_game_info.Sign_CN,
                my_game_info.SoulCore_CN,
                my_game_info.Sigil_CN,
                my_game_info.Abyss_CN,
                my_game_info.UncutGemstone_CN,
                my_game_info.Gemstone_CN
            )
            
            if has_all_items then
                poe2_api.dbgp("处理'全部物品'配置...")
                for _, currency in ipairs(currency_categories) do
                    if string.find(currency, "|") then
                        -- 处理分割的通货(如"混沌石|崇高石")
                        local currency_parts = {}
                        for part in string.gmatch(currency, "([^|]+)") do
                            table.insert(currency_parts, part)
                        end
                        
                        for _, part in ipairs(currency_parts) do
                            item_nums_dict[part] = 0
                            for _, item in ipairs(all_items) do
                                if item.baseType_utf8 == part then
                                    item_nums_dict[part] = (item_nums_dict[part] or 0) + (item.stackCount or 1)
                                end
                            end
                        end
                    else
                        item_nums_dict[currency] = 0
                        for _, item in ipairs(all_items) do
                            if item.baseType_utf8 == currency then
                                item_nums_dict[currency] = (item_nums_dict[currency] or 0) + (item.stackCount or 1)
                            end
                        end
                    end
                end
            else
                poe2_api.dbgp("处理特定通货配置...")
                for _, currency in ipairs(owned_currencies) do
                    if string.find(currency, "|") then
                        -- 处理分割的通货(如"混沌石|崇高石")
                        local currency_parts = {}
                        for part in string.gmatch(currency, "([^|]+)") do
                            table.insert(currency_parts, part)
                        end
                        
                        for _, part in ipairs(currency_parts) do
                            item_nums_dict[part] = 0
                            for _, item in ipairs(all_items) do
                                if item.baseType_utf8 == part then
                                    item_nums_dict[part] = (item_nums_dict[part] or 0) + (item.stackCount or 1)
                                end
                            end
                        end
                    else
                        item_nums_dict[currency] = 0
                        for _, item in ipairs(all_items) do
                            if item.baseType_utf8 == currency then
                                item_nums_dict[currency] = (item_nums_dict[currency] or 0) + (item.stackCount or 1)
                            end
                        end
                    end
                end
            end
            
            -- 过滤掉数量为0的通货
            local filtered_dict = {}
            for currency, count in pairs(item_nums_dict) do
                if count > 0 then
                    filtered_dict[currency] = count
                end
            end
            item_nums_dict = filtered_dict
            
            poe2_api.dbgp("过滤后的物品数量字典:", item_nums_dict)
            poe2_api.printTable(item_nums_dict)
            
            -- 检查兑换条件并过滤不满足的货币
            local valid_owned = {}
            local valid_needed = {}
            
            -- 用于存储"全部物品"的临时表
            local all_items_owned = {}
            local all_items_needed = {}

            -- 用于去重的临时表
            local added_pairs = {}

            local function add_unique_pair(owned, needed, target_owned, target_needed)
                local key = owned .. "|" .. needed
                if not added_pairs[key] then
                    table.insert(target_owned, owned)
                    table.insert(target_needed, needed)
                    added_pairs[key] = true
                end
            end

            -- 首先处理"全部物品"，但先存储到临时表中
            for i = 1, math.min(#owned_currencies, #needed_currencies) do
                local owned = owned_currencies[i]
                local needed = needed_currencies[i]
                
                if owned == "全部物品" then
                    if has_all_items then
                        -- 收集所有已经存在的货币（包括分割货币的部分）
                        local existing_currencies = {}
                        for j = 1, math.min(#owned_currencies, #needed_currencies) do
                            local other_owned = owned_currencies[j]
                            local other_needed = needed_currencies[j]
                            
                            if other_owned ~= "全部物品" then
                                -- 处理分割货币
                                if string.find(other_owned, "|") then
                                    for part in string.gmatch(other_owned, "([^|]+)") do
                                        existing_currencies[part] = true
                                    end
                                else
                                    existing_currencies[other_owned] = true
                                end
                            end
                        end
                        
                        for item, _ in pairs(item_nums_dict) do
                            -- 过滤条件：排除特定货币、已存在的货币和需要的货币
                            if not poe2_api.table_contains(item, {game_str.Div_Orb_TWCH, game_str.Mirror_TWCH}) and 
                            not existing_currencies[item] and  -- 排除已经存在的货币
                            item ~= needed then
                                add_unique_pair(item, needed, all_items_owned, all_items_needed)
                            end
                        end
                    end
                    break  -- 只需要处理一次"全部物品"
                end
            end

            -- 然后将"全部物品"的配置添加到结果表的前方
            for i = 1, #all_items_owned do
                table.insert(valid_owned, 1, all_items_owned[i])
                table.insert(valid_needed, 1, all_items_needed[i])
            end

            -- 最后处理其他非"全部物品"的配置
            for i = 1, math.min(#owned_currencies, #needed_currencies) do
                local owned = owned_currencies[i]
                local needed = needed_currencies[i]
                
                -- 跳过"全部物品"，已经处理过了
                if owned == "全部物品" then
                    goto continue
                end
                
                -- 处理包含"|"的分割货币
                if string.find(owned, "|") then
                    for part in string.gmatch(owned, "([^|]+)") do
                        if item_nums_dict[part] then
                            add_unique_pair(part, needed, valid_owned, valid_needed)
                        end
                    end
                    goto continue
                end
                
                if owned == needed then
                    goto continue
                end
                
                if not item_nums_dict[owned] then
                    goto continue
                end
                
                -- 添加一一对应的配置
                add_unique_pair(owned, needed, valid_owned, valid_needed)
                
                ::continue::
            end
            
            poe2_api.dbgp("有效的拥有通货:", #valid_owned)
            poe2_api.printTable(valid_owned)
            poe2_api.dbgp("有效的需要通货:", #valid_needed)
            poe2_api.printTable(valid_needed)
            -- while true do
            --     api_Sleep(1000)
            -- end
            
            -- 更新黑板参数
            if not next(env.owned_currencies) and not next(env.needed_currencies) then
                env.owned_currencies = valid_owned
                env.needed_currencies = valid_needed
                poe2_api.dbgp("首次设置黑板中的通货列表")
            end
            
            -- 转换为列表格式并更新黑板
            local item_nums_list = {}
            for _, currency in ipairs(valid_owned) do
                if item_nums_dict[currency] then
                    table.insert(item_nums_list, {currency, item_nums_dict[currency]})
                end
            end
            
            env.item_nums_list = item_nums_list
            poe2_api.dbgp("更新黑板中的物品数量列表:", item_nums_list)
            
            -- 检查是否有满足兑换条件的货币
            if #valid_owned > 0 then
                env.enough_currency = true
                poe2_api.dbgp("找到满足兑换条件的货币，返回FAIL")
                return bret.FAIL
            end
            
            env.enough_currency = false
            poe2_api.dbgp("未找到满足兑换条件的货币，返回SUCCESS")
            return bret.SUCCESS
        end
    },

    -- 点击所有仓库页
    Click_All_Pages = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Click_All_Pages 节点")
            
            local current_time = api_GetTickCount64()
            
            
            -- 检查仓库页面是否可用
            local function _check_pages()
                poe2_api.dbgp("检查仓库页面可用性...")
                local pages = api_GetRepositoryPages(0)  -- 0表示个人仓库
                if not pages then
                    poe2_api.dbgp("获取仓库页面失败")
                    return false
                end
                
                for _, page in ipairs(pages) do
                    if page.onlyWithdraw then
                        goto continue
                    end
                    if page.manage_index == 0 and page.type ~= 5 then
                        poe2_api.dbgp(string.format("发现无效页面: 索引=%d, 类型=%d, 名称=%s", 
                            page.manage_index, page.type, page.name_utf8 or "未知"))
                        return false
                    end
                    ::continue::
                end
                return true
            end

            -- 主逻辑
            if _check_pages() then
                poe2_api.dbgp("所有仓库页面均可用，返回FAIL")
                return bret.FAIL
            end
            
            -- 检查是否已打开仓库界面
            local emphasize_text = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Emphasize_the_item, min_x = 250, min_y = 700})
            local warehouse_text = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Warehouse, min_x = 0, min_y = 32, max_x = 381, max_y = 78})
            -- local warehouse_text = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Guild_Warehouse, min_x = 0, min_y = 32, max_x = 381, max_y=78})
            
            poe2_api.dbgp("仓库界面检查结果:", {
                emphasize_text = emphasize_text and "found" or "not found",
                warehouse_text = warehouse_text and "found" or "not found"
            })

            if not emphasize_text or not warehouse_text then
                poe2_api.dbgp("未打开仓库界面，返回SUCCESS")
                env.warehouse_type_interactive = game_str.Warehouse_text
                -- env.warehouse_type_interactive = game_str.Guild_Warehouse_text
                return bret.SUCCESS
            end

            api_Sleep(2000)  -- 等待2秒

            -- 获取仓库标签按钮
            local tab_list_button = poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.tab_list_button, ret_data = true})
            poe2_api.dbgp("标签按钮状态:", tab_list_button and "found" or "not found")

            -- 获取仓库页面
            local item_pages = {}
            local pages = api_GetRepositoryPages(0)
            if pages then
                for _, page in ipairs(pages) do
                    if page.onlyWithdraw then
                        goto continue
                    end
                    if page.type ~= 5 and page.manage_index == 0 then  -- 跳过地图页
                        table.insert(item_pages, page)
                        poe2_api.dbgp(string.format("添加仓库页: 名称=%s, 类型=%d, 索引=%d", page.name_utf8, page.type, page.manage_index))
                        poe2_api.dbgp("qvchu=%d", page.onlyWithdraw)
                    end
                    ::continue::
                end
            else
                poe2_api.dbgp("警告: 无法获取仓库页面列表")
                return bret.RUNNING
            end

            if not tab_list_button then
                poe2_api.dbgp("未展开标签列表的情况")
                -- 未展开标签列表的情况
                for _, page in ipairs(item_pages) do
                    poe2_api.dbgp(string.format("尝试点击页面: %s", page.name_utf8))
                    local text = nil
                    if page.onlyWithdraw then
                        text = page.name_utf8 .. "（只可取出）"
                    else
                        text = page.name_utf8
                    end
                    poe2_api.dbgp(string.format("点击页面: %s", text))
                    poe2_api.find_text({UI_info = env.UI_info, 
                        text = text,
                        max_y = 90,
                        min_x = 10,
                        max_x = 550,
                        min_y = 0,
                        click = 2
                    })
                    api_Sleep(200)
                end
                poe2_api.dbgp("完成未展开标签列表的页面点击")
                return bret.RUNNING
            else
                poe2_api.dbgp("已展开标签列表的情况")
                -- 已展开标签列表的情况
                local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
                -- poe2_api.printTable(lock)
                -- api_Sleep(10000)
                local lock_button = nil
                for _, v in ipairs(lock) do
                    if v.left >= 549 and v.top >= 34 and v.right <= 586 and v.bottom <= 76 and v.name_utf8 ~= game_str.bottom_icons_layout_CT then
                        lock_button = v
                        break
                    end
                end

                if not lock_button then
                    poe2_api.dbgp("未找到锁定按钮，尝试点击标签列表")
                    api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),0)
                    api_Sleep(500)
                    api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                    api_Sleep(2000)
                    api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),0)
                    api_Sleep(500)
                    api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),1)
                    api_Sleep(1000)
                    return bret.RUNNING
                end

                -- 点击所有页面
                for _, page in ipairs(item_pages) do
                    poe2_api.dbgp(string.format("尝试点击展开列表中的页面: %s", page.name_utf8))
                    local text = nil
                    if page.onlyWithdraw then
                        text = page.name_utf8 .. " （只可取出）"
                    else
                        text = page.name_utf8
                    end
                    poe2_api.dbgp(string.format("展开列表中的页面: %s", text))
                    poe2_api.find_text({UI_info = env.UI_info, 
                        text = text,
                        max_y = 750,
                        min_x = 556,
                        min_y = 20,
                        max_x = 851,
                        click = 2
                    })
                    api_Sleep(200)
                end
                poe2_api.dbgp("完成已展开标签列表的页面点击")
                return bret.RUNNING
            end
        end
    },

    -- 打开交换界面
    Open_The_Exchange_Interface = {
        run = function(self, env)
            poe2_api.dbgp("打开交换界面...")
            
            
            local player_info = env.player_info

            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Restructuring, min_x = 0, max_y = 200, add_x = 240}) then
                poe2_api.click_keyboard("spcae")
                return bret.RUNNING
            end

            local function check_in_range(object)
                for _, k in ipairs(env.range_info) do
                    if object then
                        if k.name_utf8 == object or k.path_name_utf8 == object then
                            return k
                        end
                    end
                    if (k.name_utf8 == interactive_object or k.path_name_utf8 == interactive_object) and k.grid_x ~= 0 and k.grid_y ~= 0 and k.is_selectable then
                        return k
                    end
                end
                return nil
            end

            if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.Currency_exchange, min_x = 0, max_y = 200}) then
                local target = nil
                local target_NPC = nil
                if env.player_info.current_map_name_utf8 == game_str.G_Endgame_Town_MDANA then
                    target = check_in_range(game_str.Exchange_NPC1)
                    target_NPC = game_str.Exchange_NPC1
                else
                    target = check_in_range(game_str.Exchange_NPC2)
                    target_NPC = game_str.Exchange_NPC2
                end
                local distance = poe2_api.point_distance(target.grid_x, target.grid_y, env.player_info)
                if distance and distance > 25 then 
                    env.interactive = target_NPC
                    return bret.FAIL
                else
                    if player_info.isMoving then
                        poe2_api.dbgp("等待静止")
                        api_Sleep(500)
                        return bret.RUNNING
                    end
                    api_Sleep(1000)
                    if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.Currency_exchange, min_x = 0}) then
                        api_Sleep(200)
                        poe2_api.find_text({UI_info = env.UI_info, text = target_NPC, min_x = 0, click = 2, max_x = 1200})
                        api_Sleep(1000)
                    else
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Currency_exchange, min_x = 0, click = 2, max_x = 1200})
                        api_Sleep(1000)
                        api_Sleep(500)
                    end
                    return bret.RUNNING
                end
            else
                return bret.SUCCESS
            end
        end
    },

    -- 领取通货
    Click_All_Exchange = {
        run = function(self, env)
            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Already_owned_TWCH, min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.ALL_text_TWCH, min_x = 0}) then
                return bret.SUCCESS
            end
            poe2_api.dbgp("开始执行 Click_All_Exchange 节点")
            
            -- 查找game_str.Completed_orders_TWCH文本
            local position = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Completed_orders_TWCH, max_y = 540, position = 3, min_x = 0})
            if position then
                poe2_api.dbgp(string.format("找到'完成的訂單'文本，位置: x=%d, y=%d", position[1], position[2]))
                
                -- 点击左侧领取按钮
                poe2_api.dbgp("点击左侧领取按钮")
                poe2_api.click_position(position[1]-108, position[2]-37, 2)
                api_Sleep(200)
                
                -- 再次检查game_str.Completed_orders_TWCH文本
                position = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Completed_orders_TWCH, max_y = 540, position = 3, min_x = 0})
                if position then
                    poe2_api.dbgp("找到第二个'完成的訂單'文本，点击右侧领取按钮")
                    poe2_api.click_position(position[1]+108, position[2]-37, 2)
                else
                    poe2_api.dbgp("未找到第二个'完成的訂單'文本")
                end
                
                poe2_api.dbgp("通货领取操作完成，返回RUNNING")
                return bret.RUNNING
            else
                poe2_api.dbgp("未找到'完成的訂單'文本")
            end
            
            poe2_api.dbgp("Click_All_Exchange 节点执行完成，返回SUCCESS")
            return bret.SUCCESS
        end
    },

    -- 訂單取消
    Click_All_Cancel = {
        run = function(self, env)
            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Already_owned_TWCH, min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.ALL_text_TWCH, min_x = 0}) then
                return bret.SUCCESS
            end
            poe2_api.dbgp("开始执行 Click_All_Cancel 节点")

            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Close_Order_TWCH, min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.confirm, min_x = 0, click = 2}) then
                return bret.RUNNING
            end
            
            -- 查找game_str.Order_cancellation_TWCH文本
            local position = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Order_cancellation_TWCH, max_y = 540, position = 3, min_x = 0})
            if position then
                poe2_api.dbgp(string.format("找到'訂單取消'文本，位置: x=%d, y=%d", position[1], position[2]))
                
                -- 点击左侧取消按钮
                poe2_api.dbgp("点击左侧取消按钮")
                poe2_api.click_position(position[1]-108, position[2]-37, 2)
                api_Sleep(200)
                
                -- 再次检查game_str.Order_cancellation_TWCH文本
                position = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Order_cancellation_TWCH, max_y = 540, position = 3, min_x = 0})
                if position then
                    poe2_api.dbgp("找到第二个'訂單取消'文本，点击右侧取消按钮")
                    poe2_api.click_position(position[1]+108, position[2]-37, 2)
                else
                    poe2_api.dbgp("未找到第二个'訂單取消'文本")
                end
                
                poe2_api.dbgp("订单取消操作完成，返回RUNNING")
                return bret.RUNNING
            else
                poe2_api.dbgp("未找到'訂單取消'文本")
            end
            
            poe2_api.dbgp("Click_All_Cancel 节点执行完成，返回SUCCESS")
            return bret.SUCCESS
        end
    },

    -- 清除旧的兑换
    Click_Old_Exchange = {
        run = function(self, env)
            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Already_owned_TWCH, min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.ALL_text_TWCH, min_x = 0}) then
                return bret.SUCCESS
            end
            poe2_api.dbgp("开始执行 Click_Old_Exchange 节点")
            poe2_api.dbgp(string.format("当前兑换索引: %d", env.current_pair_index or 0))
            
            -- 只在第一次执行时清除旧订单
            if (env.current_pair_index or 0) == 0 then
                poe2_api.dbgp("当前是第一次兑换，开始清除旧订单")
                
                -- 查找game_str.Order_cancellation_TWCH文本
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Order_cancellation_TWCH}) then
                    poe2_api.dbgp("找到'關閉訂單'文本，点击'確定'按钮")
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.confirm, click = 2})
                    api_Sleep(200)
                    return bret.RUNNING
                end
                
                -- 查找game_str.Listed_orders_TWCH文本
                local position = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Listed_orders_TWCH, max_y = 540, position = 3, min_x = 0})
                if position then
                    poe2_api.dbgp(string.format("找到'列出的訂單'文本，位置: x=%d, y=%d", position[1], position[2]))
                    poe2_api.dbgp("点击右侧关闭按钮")
                    poe2_api.click_position(position[1]+145, position[2]-33)
                    api_Sleep(200)
                    return bret.RUNNING
                else
                    poe2_api.dbgp("未找到'列出的訂單'文本")
                end
            else
                poe2_api.dbgp("非首次兑换，跳过清除旧订单步骤")
            end
            
            poe2_api.dbgp("Click_Old_Exchange 节点执行完成，返回SUCCESS")
            return bret.SUCCESS
        end
    },

    -- 点击无状态兑换
    Click_Stateless_Exchange = {
        run = function(self, env)
            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Already_owned_TWCH, min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.ALL_text_TWCH, min_x = 0}) then
                return bret.SUCCESS
            end
            poe2_api.dbgp("开始执行 Click_Stateless_Exchange 节点")
            
            -- 检查是否存在任何订单状态文本
            local position1 = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Listed_orders_TWCH, max_y = 540, min_x = 0})
            local position2 = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Order_cancellation_TWCH, max_y = 540, min_x = 0})
            local position3 = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Completed_orders_TWCH, max_y = 540, min_x = 0})
            
            poe2_api.dbgp(string.format("订单状态检查结果 - 列出的訂單: %s, 訂單取消: %s, 完成的訂單: %s", 
                tostring(position1), tostring(position2), tostring(position3)))
            
            if not position1 and not position2 and not position3 then
                poe2_api.dbgp("未找到任何订单状态文本，开始处理无状态订单")
                
                local stateless = api_GetCurrencyExchangeList()
                poe2_api.dbgp(string.format("获取无状态订单列表: %s", next(stateless) and "有数据" or "无数据"))
                
                if next(stateless) then
                    local position = poe2_api.find_text({UI_info = env.UI_info, text = game_str.What_I_need_TWCH, max_y = 540, position = 3})
                    if position then
                        poe2_api.dbgp(string.format("找到'我需要的'文本，位置: x=%d, y=%d", position[1], position[2]))
                        
                        -- 点击左侧取消按钮
                        poe2_api.dbgp("点击左侧取消按钮")
                        poe2_api.click_position(position[1] - 68, position[2] + 192, 2)
                        api_Sleep(200)
                        
                        -- 点击右侧取消按钮
                        poe2_api.dbgp("点击右侧取消按钮")
                        poe2_api.click_position(position[1] + 150, position[2] + 192, 2)
                        api_Sleep(200)
                        
                        poe2_api.dbgp("无状态订单清除操作完成，返回RUNNING")
                        return bret.RUNNING
                    else
                        poe2_api.dbgp("未找到'我需要的'文本")
                    end
                else
                    poe2_api.dbgp("无状态订单列表为空")
                end
            else
                poe2_api.dbgp("存在有效订单状态，无需处理无状态订单")
            end
            
            poe2_api.dbgp("Click_Stateless_Exchange 节点执行完成，返回SUCCESS")
            return bret.SUCCESS
        end
    },

    -- 选择和交换
    Select_AND_Exhange = {
        new = function(self, name)
            local o = {}
            setmetatable(o, self)
            self.__index = self
            o.name = name or self.name
            return o
        end,
    
        run = function(self, env)
            poe2_api.dbgp("开始执行 Select_AND_Exhange 节点")
            
            -- 检查是否有低比率提示
            if poe2_api.find_text({UI_info = env.UI_info, text=game_str.The_transaction_ratio_you_have_chosen_TWCH,refresh = true, min_x=0, match=2, delay = 50}) then
                poe2_api.dbgp("发现低比率提示，点击取消")
                poe2_api.find_text({UI_info = env.UI_info, text=game_str.Cancel_TWCH,refresh = true, click=2, delay = 50})
                return bret.RUNNING
            end

            local function _select_currency(currency, text)
                poe2_api.dbgp("选择通货:", currency)
                -- 判断类型并点击对应分类
                api_Sleep(1000)
                if poe2_api.find_text({UI_info = env.UI_info, text = text,refresh = true, min_x=0, max_y = 120}) then
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.ALL_text_TWCH,refresh = true, min_x=0, click=2, delay = 50})
                    api_Sleep(500)
                    if poe2_api.find_text({UI_info = env.UI_info, text = text,refresh = true, min_x=0, max_y = 120, add_X = 140, add_y = 690, click=2, delay = 50}) then
                        poe2_api.paste_text(currency)
                    end
                end

                api_Sleep(500)
                
                -- 尝试直接点击目标通货
                if poe2_api.find_text({UI_info = env.UI_info, text = currency,refresh = true, click=2, min_x=0, delay = 150}) then
                    api_Sleep(500)
                    return true, currency
                end
                
                return false, nil
            end

            local function _verify_left_currency(expected)
                poe2_api.dbgp("验证左边通货:", expected)

                local poesition_left = poe2_api.find_text({UI_info = env.UI_info, text=game_str.What_I_need_TWCH,refresh = true, min_x=0, position=1, delay = 50})
                if not poesition_left then
                    poe2_api.dbgp("未找到'我需要的'文本")
                    return false, nil
                end
                
                local ratio_area = {poesition_left[1] - 40, 174, poesition_left[3] + 40, 234}
                local current_left = poe2_api.find_text_position({UI_info = env.UI_info, 
                    min_x=ratio_area[1],
                    min_y=ratio_area[2],
                    max_x=ratio_area[3],
                    max_y=ratio_area[4],
                    lens=nil
                })
                
                -- 已经是目标通货
                if current_left and string.find(current_left, expected) then
                    poe2_api.dbgp("左边通货已经是目标通货:", expected)
                    return true, current_left
                end

                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.I_Have,refresh = true, min_x=0, max_y = 120}) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Already_owned_TWCH, min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.ALL_text_TWCH, min_x = 0}) then
                    poe2_api.dbgp("验证左边通货不正确")
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.I_Have,refresh = true, min_x=0, max_y = 120, add_x = 370, click = 2})
                    api_Sleep(1000)
                end
                
                poe2_api.find_text({UI_info = env.UI_info, text=game_str.What_I_need_TWCH,refresh = true, min_x=0, add_y=30, click=2, delay = 50})
                api_Sleep(500)
                    
                -- 需要重新选择
                local a, currency = _select_currency(expected, game_str.What_I_need_TWCH)

                api_Sleep(500)

                poe2_api.dbgp("验证左边通货:", expected)
                
                local poesition_left = poe2_api.find_text({UI_info = env.UI_info, text=game_str.What_I_need_TWCH,refresh = true, min_x=0, position=1, delay = 50})
                if not poesition_left then
                    poe2_api.dbgp("未找到'我需要的'文本")
                    return false, nil
                end
                
                local ratio_area = {poesition_left[1] - 40, 174, poesition_left[3] + 40, 234}
                local current_left = poe2_api.find_text_position({UI_info = env.UI_info, 
                    min_x=ratio_area[1],
                    min_y=ratio_area[2],
                    max_x=ratio_area[3],
                    max_y=ratio_area[4],
                    lens=nil
                })
                
                -- 已经是目标通货
                if current_left and string.find(current_left, expected) then
                    poe2_api.dbgp("左边通货已经是目标通货:", expected)
                    return true, current_left
                else
                    return false, nil
                end
                -- return a, currency
            end
        
            local function _verify_right_currency(expected)
                poe2_api.dbgp("验证右边通货:", expected)
                local poesition_left = poe2_api.find_text({UI_info = env.UI_info, text=game_str.I_Have,refresh = true, min_x=0, position=1, delay = 50})
                if not poesition_left then
                    poe2_api.dbgp("未找到'我擁有的'文本")
                    return false, nil
                end
                
                local ratio_area = {poesition_left[1] - 40, 174, poesition_left[3] + 40, 234}
                local current_right = poe2_api.find_text_position({UI_info = env.UI_info, 
                    min_x=ratio_area[1],
                    min_y=ratio_area[2],
                    max_x=ratio_area[3],
                    max_y=ratio_area[4],
                    lens=nil
                })
                
                -- 已经是目标通货
                if current_right and string.find(current_right, expected) then
                    poe2_api.dbgp("右边通货已经是目标通货:", expected)
                    return true, current_right
                end

                if not (poe2_api.find_text({UI_info = env.UI_info, text = game_str.I_Have,refresh = true, min_x=0, max_y = 120}) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Already_owned_TWCH, min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.ALL_text_TWCH, min_x = 0})) then
                    -- 左边输入（需要的数量）
                    poe2_api.find_text({UI_info = env.UI_info, text=game_str.What_I_need_TWCH,refresh = true, min_x=0, add_x=132, add_y=37, click=2, delay = 50})
                    api_Sleep(500)
                    -- poe2_api.paste_text("1")
                    poe2_api.key_board_input_text(1)
                    api_Sleep(500)
                    poe2_api.find_text({UI_info = env.UI_info, text=game_str.What_I_need_TWCH,refresh = true, min_x=0, add_x=132, add_y=37, click=2, delay = 50})

                    api_Sleep(800)

                    poe2_api.find_text({UI_info = env.UI_info, text=game_str.I_Have,refresh = true, min_x=0, add_y=30, add_x = 75, click=2, delay = 50})
                    if not (poe2_api.find_text({UI_info = env.UI_info, text = game_str.Already_owned_TWCH, min_x = 0, refresh = true}) and poe2_api.find_text({UI_info = env.UI_info, refresh = true, text = game_str.ALL_text_TWCH, min_x = 0})) then
                        for i = 1, 5 do
                            poe2_api.find_text({UI_info = env.UI_info, text=game_str.I_Have,refresh = true, min_x=0, add_y=30, add_x = 75, click=2, delay = 50})
                            i = i + 1
                        end
                    end
                    api_Sleep(500)
                end
            
                -- 需要重新选择
                poe2_api.dbgp("需要重新选择右边通货")
                local a, currency = _select_currency(expected, game_str.I_Have)

                api_Sleep(500)

                poe2_api.dbgp("再次验证右边通货:", expected)
                local poesition_left = poe2_api.find_text({UI_info = env.UI_info, text=game_str.I_Have,refresh = true, min_x=0, position=1, delay = 50})
                if not poesition_left then
                    poe2_api.dbgp("未找到'我擁有的'文本")
                    return false, nil
                end
                
                local ratio_area = {poesition_left[1] - 40, 174, poesition_left[3] + 40, 234}
                local current_right = poe2_api.find_text_position({UI_info = env.UI_info, 
                    min_x=ratio_area[1],
                    min_y=ratio_area[2],
                    max_x=ratio_area[3],
                    max_y=ratio_area[4],
                    lens=nil
                })
                
                -- 已经是目标通货
                if current_right and string.find(current_right, expected) then
                    poe2_api.dbgp("右边通货已经是目标通货:", expected)
                    return true, current_right
                else
                    return false, nil
                end
                -- return a, currency
            end

        
            local function _get_currency_amount(currency_type)
                poe2_api.dbgp("获取通货数量:", currency_type)
                
                if not env.item_nums_list then
                    poe2_api.dbgp("item_nums_list为空")
                    return 0
                end
                
                for _, item in ipairs(env.item_nums_list) do
                    if item[1] == currency_type then  -- item格式: {'通货名称', 数量}
                        poe2_api.dbgp("找到通货数量:", item[2])
                        return item[2]
                    end
                end
                
                poe2_api.dbgp("未找到该通货")
                return 0
            end
        
        
            local function _get_live_ratio()
                poe2_api.dbgp("获取实时市场比例")
                
                local poesition_left = poe2_api.find_text({UI_info = env.UI_info, text=game_str.What_I_need_TWCH,refresh = true, min_x=0, position=1, delay = 50})
                if not poesition_left then
                    poe2_api.dbgp("未找到'我需要的'文本")
                    return nil
                end
                
                local ratio_area = {poesition_left[3], poesition_left[4] - 53, poesition_left[3] + 280, poesition_left[4] + 12}
                poe2_api.dbgp("文本区域:", poesition_left[3],",", poesition_left[4] - 53,",",  poesition_left[3] + 280,",",  poesition_left[4] + 12)
                local ratio_text = poe2_api.find_text_position({UI_info = env.UI_info, 
                    refresh = true,
                    min_x=ratio_area[1],
                    min_y=ratio_area[2],
                    max_x=ratio_area[3],
                    max_y=ratio_area[4],
                    lens=4
                })
                poe2_api.dbgp("原始比例文本:", ratio_text)

                if ratio_text then
                    poe2_api.dbgp("原始比例文本:", ratio_text)
                    
                    -- 改进的文本解析逻辑，匹配<kalguurlightgrey>{数字}：<kalguurlightgrey>{数字}格式
                    local pattern = "<kalguurlightgrey>{(%d+%.?%d*)}：<kalguurlightgrey>{(%d+%.?%d*)}"
                    local need, have = string.match(ratio_text, pattern)
                    
                    if need and have then
                        need = tonumber(need)
                        have = tonumber(have)
                        if need > 0 and have > 0 then
                            poe2_api.dbgp("解析比例成功:", need, ":", have)
                            return {need, have}  -- (需要的, 拥有的)
                        end
                    end
                end
                
                poe2_api.dbgp("无法解析比例")
                return nil
            end
        
            local function _calculate_optimal_exchange(have_amount, current_ratio)
                poe2_api.dbgp("计算最优兑换量 - 当前数量:", have_amount, "市场比例:", current_ratio[1], ":", current_ratio[2])
                
                -- 检查输入有效性，若current_ratio不存在或have_amount小于等于0，则返回默认值
                if not current_ratio or have_amount <= 0 then
                    poe2_api.dbgp("无效输入")
                    return {0, 0}, {0, 0}
                end
                
                -- 提取市场所需和提供的数量
                local market_need, market_have = current_ratio[1], current_ratio[2]
                
                -- 定义计算最大公约数的辅助函数
                local function gcd(a, b)
                    while b ~= 0 do
                        a, b = b, a % b
                    end
                    return a
                end
                
                -- 对市场比例进行四舍五入处理，保留一位小数
                local rounded_need = math.floor(market_need * 10 + 0.5) / 10
                local rounded_have = math.floor(market_have * 10 + 0.5) / 10
                
                -- 将比例乘以10并转换为整数，用于计算最小单位
                local factor = 10
                local int_need = math.floor(rounded_need * factor + 0.5)
                local int_have = math.floor(rounded_have * factor + 0.5)
                
                -- 计算整数形式下的最大公约数，并得到最小兑换单位
                local common_divisor = gcd(int_need, int_have)
                local unit_need = int_need // common_divisor
                local unit_have = int_have // common_divisor
                
                poe2_api.dbgp("最小兑换单位:", unit_need, ":", unit_have)
                
                -- 如果当前持有量不足一个最小单位，则返回提示
                if have_amount < unit_have then
                    poe2_api.dbgp("持有量不足: 需要", unit_have, "当前", have_amount)
                    return {0, 0}, {unit_need, unit_have}
                end
                
                -- 计算可以进行的最大交易次数
                local max_trades = have_amount // unit_have
                local actual_trades = max_trades  -- 移除了限制
                
                poe2_api.dbgp("最大交易次数:", actual_trades)
                
                -- 返回实际交易量和最小单位
                return {unit_need * actual_trades, unit_have * actual_trades},{unit_need, unit_have}
                
            end

            local function recheck_nums(text, nums)
                poe2_api.dbgp("重新检查数量:", text, nums)
                local a = poe2_api.find_text({UI_info = env.UI_info, text = text, refresh = true, min_x=0, min_y = 120, position = 1})
                if a then
                    poe2_api.dbgp(":", a[3], "位置Y:", a[4])
                    local min_x, min_y, max_x, max_y = 0, 0, 0, 0
                    if text == game_str.What_I_need_TWCH then
                        min_x = a[3] + 30
                        min_y = a[4] + 4
                        max_x = a[3] + 112
                        max_y = a[4] + 49
                    else
                        min_x = a[1] - 115
                        min_y = a[2] + 1
                        max_x = a[1] + 32
                        max_y = a[2] + 45
                    end
                    poe2_api.dbgp(min_x, min_y, max_x, max_y)
                    the_maps_num = poe2_api.find_text_position({UI_info = env.UI_info, refresh = true, min_x = min_x, min_y = min_y, max_x = max_x, max_y = max_y, lens = 0 })
                    poe2_api.dbgp("the_maps_num-->",the_maps_num)
                    if tostring(the_maps_num) == tostring(nums) then
                        return true
                    else
                        return false
                    end
                else
                    poe2_api.dbgp("未找到文本:", text)
                    return false
                end
            end
        
            local function _execute_exchange(ratio)
                poe2_api.dbgp("执行兑换操作 - 比例:", ratio[1], ":", ratio[2])
                local need, give = ratio[1], ratio[2]
                
                -- 左边输入（需要的数量）
                poe2_api.find_text({UI_info = env.UI_info, text=game_str.What_I_need_TWCH,refresh = true, min_x=0, add_x=147, add_y=37, click=2, delay = 50})
                api_Sleep(500)
                poe2_api.key_board_input_text(tonumber(need))
                -- poe2_api.paste_text(tostring(need))
                api_Sleep(500)
                poe2_api.find_text({UI_info = env.UI_info, text=game_str.What_I_need_TWCH,refresh = true, min_x=0, add_x=147, add_y=37, click=2, delay = 50})

                if not recheck_nums(game_str.What_I_need_TWCH, need) then
                    return false
                end

                api_Sleep(1000)

                -- 右边输入（给出的数量）
                poe2_api.find_text({UI_info = env.UI_info, text=game_str.I_Have,refresh = true, min_x=0, add_x=-112, add_y=37, click=2, delay = 50})
                api_Sleep(500)
                -- poe2_api.paste_text(tostring(give))
                poe2_api.key_board_input_text(tonumber(give))
                api_Sleep(500)
                poe2_api.find_text({UI_info = env.UI_info, text=game_str.I_Have,refresh = true, min_x=0, add_x=-112, add_y=37, click=2, delay = 50})

                if not recheck_nums(game_str.I_Have, give) then
                    return false
                end
                
                -- 确认交易
                local i = 0
                while i < 3 do
                    poe2_api.find_text({UI_info = env.UI_info, text=game_str.Place_an_order_TWCH,refresh = true, click=2})
                    api_Sleep(800)
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text=game_str.The_transaction_ratio_you_have_chosen_TWCH,refresh = true, min_x=0, match=2, delay = 50}) then
                        poe2_api.dbgp("检测到低比率提示")
                        poe2_api.find_text({UI_info = env.UI_info, text=game_str.Cancel_TWCH,refresh = true, click=2})
                        return false
                    end
                    
                    if poe2_api.find_text({UI_info = env.UI_info, text=game_str.The_transaction_ratio_you_have_chosen_CHANGE_TWCH,refresh = true, min_x=0, delay = 50}) then
                        poe2_api.dbgp("检测到低比率提示(变体)")
                        poe2_api.find_text({UI_info = env.UI_info, text=game_str.Cancel_TWCH,refresh = true, click=2})
                        break
                    end
                    
                    i = i + 1
                end
                
                -- 根据数值位数调整延迟
                local delay = math.max(0.5, math.min(1.5, (string.len(tostring(need)) + string.len(tostring(give))) * 0.15))
                api_Sleep(poe2_api.toInt(delay * 1000))
                return true
            end
    
            -- 获取当前处理的通货对索引
            local current_pair_index = env.current_pair_index or 1
            poe2_api.dbgp("当前处理通货对索引:", current_pair_index)
            
            -- 获取拥有的和需要的通货列表
            local owned_currencies = env.owned_currencies or {}
            local needed_currencies = env.needed_currencies or {}
            poe2_api.dbgp("拥有的通货列表:", #owned_currencies)
            poe2_api.dbgp("需要的通货列表:", #needed_currencies)
    
            -- 检查通货对是否有效
            if #owned_currencies < current_pair_index + 1 or #needed_currencies < current_pair_index + 1 then
                poe2_api.dbgp("通货对处理完成，重置状态")
                env.last_execution_time = api_GetTickCount64()
                env.current_pair_index = 0
                env.exchange_status = true
                env.warehouse_full = false
                env.owned_currencies = {}
                env.needed_currencies = {}
                return bret.SUCCESS
            end
    
            -- 检查列表长度是否一致
            if #owned_currencies ~= #needed_currencies then
                poe2_api.dbgp("错误：'我擁有的'和'我需要的'列表长度不一致")
                return bret.FAIL
            end
    
            -- 1. 检查并修正左边通货（严格按索引匹配）
            local left_status, selected_currency_left = _verify_left_currency(needed_currencies[current_pair_index + 1])  -- Lua数组从1开始
            poe2_api.dbgp("left_status:", tostring(left_status), "selected_currency_left:", selected_currency_left)
            if not left_status then
                poe2_api.dbgp("左边通货选择失败，跳过当前对")
                env.current_pair_index = current_pair_index + 1
                return bret.RUNNING
            end
            poe2_api.dbgp("左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左")

            api_Sleep(800)
            -- 2. 检查并修正右边通货（严格按索引匹配）
            local right_status, selected_currency_right = _verify_right_currency(owned_currencies[current_pair_index + 1])
            poe2_api.dbgp("right_status:", tostring(right_status), "selected_currency_right:", selected_currency_right)
            if not right_status then
                -- poe2_api.dbgp("右边通货选择失败，跳过当前对")
                -- env.current_pair_index = current_pair_index + 1
                poe2_api.dbgp("右边通货选择失败")
                return bret.RUNNING
            end
            poe2_api.dbgp("右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右")

            api_Sleep(800)
    
            -- 3. 获取当前通货数量
            local have_amount = _get_currency_amount(selected_currency_right)
            poe2_api.dbgp("当前通货数量:", selected_currency_right, "=", have_amount)
            
            if have_amount == 0 then
                poe2_api.dbgp("通货数量为0，跳过当前对")
                env.current_pair_index = current_pair_index + 1
                return bret.RUNNING
            end
    
            -- 4. 获取实时市场比例（左边:需要的，右边:拥有的）
            local current_ratio = _get_live_ratio()
            poe2_api.dbgp("获取实时市场比例  ", current_ratio)
            if not current_ratio then
                poe2_api.dbgp("无法获取市场比例，跳过当前对")
                env.current_pair_index = current_pair_index + 1
                return bret.RUNNING
            end
            poe2_api.dbgp("当前市场比例:", current_ratio[1], ":", current_ratio[2])
    
            -- 5. 计算最优兑换量（使用当前比例）
            local adjusted_ratio, exact_units = _calculate_optimal_exchange(have_amount, current_ratio)
            poe2_api.dbgp("计算最优兑换量 - 调整后比例:", adjusted_ratio[1], ":", adjusted_ratio[2], " 最小单位:", exact_units[1], ":", exact_units[2])
            
            if adjusted_ratio[1] == 0 and adjusted_ratio[2] == 0 then
                poe2_api.dbgp("无法计算有效兑换比例，跳过当前对")
                env.current_pair_index = current_pair_index + 1
                return bret.RUNNING
            end
    
            -- 6. 执行兑换
            local exchange_result = _execute_exchange(adjusted_ratio)
            poe2_api.dbgp("兑换执行结果:", exchange_result and "成功" or "失败")
            if not exchange_result then
                poe2_api.dbgp("兑换失败,重新尝试")
                return bret.RUNNING
            end
            
            env.current_pair_index = current_pair_index + 1
            return bret.RUNNING
        end
    },

    -- 点击交互文本
    Click_Item_Text = {
        run = function(self, env)
            poe2_api.print_log("点击交互文本...")
            poe2_api.dbgp("点击交互文本...")
            local current_time = api_GetTickCount64()
            local interactive_object = env.interactive
            local player_info = env.player_info
            local current_map_info = env.current_map_info
            
            local path_list = env.path_list
            local need_item = env.need_item
            
            if not env.click_bool then
                self.is_click_z = false
                self.id1 = nil
                self.number1 = 0
                env.click_bool = true
            end
            
            -- 辅助函数定义
            local function check_in_map()
                if not current_map_info then
                    return nil
                end
                for _, k in ipairs(current_map_info) do
                    if k.name_utf8 == interactive_object and k.flagStatus == 0 and k.flagStatus1 == 1 and k.grid_x ~= 0 and k.grid_y ~= 0 then
                        return k
                    end
                end
                return nil
            end

            local function check_in_range(object)
                for _, k in ipairs(env.range_info) do
                    if object then
                        if k.name_utf8 == object or k.path_name_utf8 == object then
                            return k
                        end
                    end
                    if interactive_object == game_str.MapDevice then
                        if k.name_utf8 == game_str.MapDevice_TWCH or k.name_utf8 == game_str.Map_Device_CH then
                            return k
                        end
                    end
                    if (k.name_utf8 == interactive_object or k.path_name_utf8 == interactive_object) and k.grid_x ~= 0 and k.grid_y ~= 0 and k.is_selectable then
                        return k
                    end
                end
                return nil
            end
            
            local function need_move(obj,dis)
                local text = obj.baseType_utf8 or obj.name_utf8
                local x, y
                local point
                if poe2_api.table_contains(text, {game_str.Door_CH,game_str.Invitation_to_showcase_Skeleton_Mark_TWCH,game_str.The_Container_of_Mark_the_Skeleton_TWCH}) then
                    
                    if not next(env.target_point_sort_list) then
                        local player_position = api_CollectReachableInCircleSimple(obj.grid_x, obj.grid_y, 10)
                        local soret_list = poe2_api.sort_recent_point_list(player_position,player_info.grid_x, player_info.grid_y)
                        if not next(soret_list) then
                            point = api_FindRandomWalkablePosition(obj.grid_x, obj.grid_y, 50)
                            x, y = point.x, point.y
                        else
                            env.target_point_sort_list = soret_list
                            x, y = env.target_point_sort_list[1].x, env.target_point_sort_list[1].y
                        end
                    else
                        x, y = env.target_point_sort_list[1].x, env.target_point_sort_list[1].y
                    end
                else
                    -- poe2_api.dbgp("dgdvjinbvdijsknvijbiihjbjkdv")
                    -- x, y = obj.grid_x, obj.grid_y
                    point = api_FindNearestReachableInRange(obj.grid_x, obj.grid_y, 50, 0)
                    x, y = point.x, point.y
                    -- if not need_item then
                    --     point = api_FindNearestReachableInRange(obj.grid_x, obj.grid_y, 50, 0)
                    --     x, y = point.x, point.y
                    -- else
                    --     poe2_api.dbgp("dgdvjinbvdijsknvijbiihjbjkdv")
                    --     x, y = obj.grid_x, obj.grid_y
                    -- end
                end
                poe2_api.dbgp("移动目标点:", x, y)
                local distance = poe2_api.point_distance(x, y, player_info)
                poe2_api.dbgp("距离:", distance)
                local text = ""      
                local ok, value = pcall(function() 
                    return interactive_object.baseType_utf8 
                end)
                if ok and value ~= nil then
                    text = interactive_object.baseType_utf8 
                    -- text = ""
                else
                    text = interactive_object.name_utf8
                end
                if (distance and distance > dis) or ( not poe2_api.table_contains(text,{game_str.Switch_CH,game_str.Door_CH}) and not api_HasObstacleBetween(x, y)) then
                    env.end_point = {x, y}
                    return {x, y}
                end
                return false
            end
            
            -- 主逻辑
            if type(interactive_object) == "string" then
                local map_obj = check_in_map()
                local range_obj = check_in_range()
                
                local target_obj = map_obj or range_obj
                if not target_obj then
                    poe2_api.dbgp("未找到对象")
                    return bret.FAIL
                end
                
                local distance = poe2_api.point_distance(target_obj.grid_x, target_obj.grid_y, player_info)
                poe2_api.dbgp("交互对象: "..target_obj.name_utf8.." | 位置: "..target_obj.grid_x..","..target_obj.grid_y.." | 距离: "..distance)
                
                if need_move(target_obj,15) then
                    poe2_api.dbgp("移动交互对象")
                    return bret.FAIL
                end

                poe2_api.dbgp("点击交互对象")
                
                if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                    api_Sleep(1500)
                end
                poe2_api.dbgp("111111111")
                if target_obj.name_utf8 == game_str.MapDevice then
                    local m_list = {game_str.MapDevice_TWCH, game_str.Map_Device_CH}
                    api_Sleep(800)
                    poe2_api.dbgp("2222222222")
                    local maps = check_in_range(game_str.ZigguratMapDevice_PATH)
                    -- if maps then
                    --     -- api_ClickMove(maps.grid_x, maps.grid_y, maps.world_z + 110, 0)
                    --     api_ClickMove(poe2_api.toInt(maps.grid_x), poe2_api.toInt(maps.grid_y), 0, poe2_api.toInt(maps.world_z - 70))
                    --     api_Sleep(400)
                    -- end
                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_Device_CH, click = 2, refresh = true, print_log = true}) then
                        api_Sleep(100)
                        return bret.RUNNING
                    end
                    
                    -- for _, i in ipairs(m_list) do
                    --     if poe2_api.find_text({UI_info = env.UI_info, text = i, click = 2, refresh = true}) then
                    --         api_Sleep(100)
                    --         return bret.RUNNING
                    --     end
                    -- end
                end
                poe2_api.dbgp("33333333333")
                if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) and target_obj.name_utf8 ~= game_str.Transfer_point_CH and not map_obj then
                    poe2_api.find_text({UI_info = env.UI_info, text = interactive_object, click = 2, refresh = true})
                    api_Sleep(100)
                    return bret.RUNNING
                end
                
                if player_info.isMoving then
                    poe2_api.dbgp("等待静止")
                    api_Sleep(1000)
                    return bret.RUNNING
                end

                if not poe2_api.find_text({UI_info = env.UI_info, text = interactive_object, click = 2, max_x = 1200, refresh = true}) then
                    api_ClickMove(poe2_api.toInt(target_obj.grid_x), poe2_api.toInt(target_obj.grid_y), 1)
                end
                api_Sleep(100)
            else
                poe2_api.dbgp1("交互对象: ",interactive_object.name_utf8," | 位置: ",interactive_object.grid_x,",",interactive_object.grid_y)
                poe2_api.dbgp("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
                local a = poe2_api.point_distance(interactive_object.grid_x,interactive_object.grid_x,env.player_info)
                poe2_api.dbgp("a:",a)
                local text = ""      
                local ok, value = pcall(function() 
                    return interactive_object.baseType_utf8 
                end)
                if ok and value ~= nil then
                    text = interactive_object.baseType_utf8 
                    -- text = ""
                else
                    text = interactive_object.name_utf8
                end
                poe2_api.dbgp("text:",text)
                local point = need_move(interactive_object,30)
                if point then
                    poe2_api.dbgp("text1:",text)
                    -- poe2_api.dbgp("移动交互对象")
                    if env.path_list and next(env.path_list) then
                        local distence = poe2_api.point_distance(env.path_list[#env.path_list].x,env.path_list[#env.path_list].y,point)
                        if distence and distence > 20 and text ~= game_str.Door_CH then
                            poe2_api.dbgp("交互目标点，不一致，清空路径")
                            poe2_api.print_log("清路径555")
                            env.path_list = {}
                        end
                    end
                    poe2_api.dbgp("text2:",text)
                    -- poe2_api.printTable(point)
                    return bret.FAIL
                end
                if interactive_object then
                    if env.user_config["全局設置"]["内存模式"] and env.need_item and env.need_item == interactive_object then
                        poe2_api.dbgp("内存模式")
                        -- api_Sleep(3000)
                        -- if not poe2_api.find_text({text = text, UI_info = env.UI_info, min_x=200,max_y=750,match=2,max_x=1200,sorted = true, click=1}) then
                        --     api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), 0)
                        -- end
                        -- api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), 0)
                        api_SendActionPacket(game_str.PickUpSkillId,interactive_object.id)
                        api_Sleep(10)
                    else
                        poe2_api.dbgp("模拟模式")
                        if player_info.isMoving then
                            poe2_api.dbgp("等待静止")
                            api_Sleep(200)
                            return bret.RUNNING
                        end
                        -- api_Sleep(3000)
                        if (not text or text == "" or poe2_api.table_contains(text,{game_str.Door_CH,game_str.The_Holy_Temple_TWCH,game_str.Abyss_Pinnacle_MDANA}) or not poe2_api.find_text({text = text, UI_info = env.UI_info, min_x=200,max_y=750,match=2,max_x=1200,sorted = true, click=2})) then
                            if poe2_api.table_contains(text,{game_str.Door_CH,game_str.The_Holy_Temple_TWCH}) then
                                -- if text == game_str.Door_CH and poe2_api.find_text({text = "出土遺物", UI_info = env.UI_info, min_x=200,max_y=750,match=2,max_x=1200,sorted = true}) then
                                --     poe2_api.click_keyboard("z")
                                --     self.is_click_z = true
                                --     return bret.RUNNING
                                -- end
                                api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), 1,poe2_api.toInt(interactive_object.world_z)-40)
                            elseif poe2_api.table_contains(text,{game_str.Black_Cathedral,game_str.Abyss_Pinnacle_MDANA}) then
                                poe2_api.click_keyboard("ctrl", 1)
                                api_Sleep(200)
                                api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), 1)
                                api_Sleep(200)
                                poe2_api.click_keyboard("ctrl", 2)
                            else
                                if env.need_item and env.need_item == interactive_object then
                                    -- poe2_api.dbgp("需要物品")
                                    -- api_Sleep(2000)
                                    -- if env.user_config["全局設置"]["内存模式"] then
                                    --     -- poe2_api.dbgp("内存模式")
                                    --     -- api_Sleep(1000)
                                        
                                    -- else
                                    --     api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), 1)
                                    -- end
                                    api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), 1)
                                else
                                    -- poe2_api.dbgp("需要物品1111")
                                    -- api_Sleep(2000)
                                    local ok, value = pcall(function() 
                                        return interactive_object.path_name_utf8 
                                    end)
                                    if ok and value ~= nil then
                                        local path_name_list = {
                                            game_str.DeliriumInitiator_PATH,
                                            game_str.BreachObject_PATH
                                        }
                                        if string.find(game_str.Ritual_PATH, interactive_object.path_name_utf8) then
                                            poe2_api.find_text({text = game_str.Click_to_start_the_ritual_TWCH, UI_info = env.UI_info, min_x=200,max_y=750,match=2,max_x=1200,sorted = true, click=2})
                                        elseif game_str.Monolith_PATH == interactive_object.path_name_utf8 then
                                            poe2_api.find_text({text = game_str.Monsters_are_imprisoned_by_powerful_essence_TWCH, UI_info = env.UI_info, min_x=200,max_y=750,match=2,max_x=1200,sorted = true, click=2})
                                        elseif poe2_api.table_contains(interactive_object.path_name_utf8, path_name_list) then
                                            api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), 1)
                                        elseif interactive_object.name_utf8 == game_str.Switch_CH then
                                            api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), 1)
                                        elseif interactive_object.name_utf8 == game_str.Obtain_the_ring_TWCH then
                                            if not env.user_config["全局設置"]["骷髅马克玩法"]["骷髅马克是否打本体"] then
                                                poe2_api.find_text({text = "拿走手指", UI_info = env.UI_info, min_x=200,max_y=750,match=2,max_x=1200,sorted = true, click=2})
                                            else
                                                poe2_api.find_text({text = "返還手指", UI_info = env.UI_info, min_x=200,max_y=750,match=2,max_x=1200,sorted = true, click=2})
                                            end
                                        else
                                            if interactive_object.path_name_utf8 ~= game_str.AbyssCrack_PATH then
                                                if poe2_api.table_contains(text,my_game_info.Treasure_Chest) then
                                                    api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), 1)
                                                else
                                                    api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), 1)
                                                end
                                                
                                            end
                                        end
                                    else
                                        api_ClickMove(poe2_api.toInt(interactive_object.grid_x), poe2_api.toInt(interactive_object.grid_y), 1)
                                    end
                                end
                            end
                        end
                    end
                    -- if  then
                    if env.need_item and env.need_item == interactive_object then
                        if not self.id1 then
                            self.id1 = env.need_item.id
                        end
                        poe2_api.dbgp("tyepnumber: ",type(self.number1))
                        if self.id1 == env.need_item.id then
                            if not self.number1 then
                                    self.number1 = 0
                                end
                            self.number1 = self.number1 + 1
                        else
                            self.number1 = 1
                            self.id1 = env.need_item.id
                            -- poe2_api.dbgp("物品已捡起,更新状态")
                            -- api_Sleep(1000)
                        end
                        if self.number1 % 5 == 0 then
                            local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                            if point then
                                api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),7)
                            end
                        end
                        poe2_api.dbgp("number: "..self.number1)

                        if self.number1 >= 20 then
                            table.insert(env.pick_up_timeout,env.need_item.id)
                            -- env.need_item = nil
                            self.number1 = 0
                            poe2_api.dbgp("拾取超时")
                            -- while true do
                            --     api_Sleep(1000)

                            -- end
                            -- poe2_api.time_p("点击交互文本（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                            -- return bret.RUNNING
                        end
                    end
                end
                if text == game_str.The_Broken_Mirror_TWCH then
                    if next(interactive_object.stateMachineList) and interactive_object.stateMachineList[game_str.clicked_SML] == 1 then
                        poe2_api.find_text({text = text, UI_info = env.UI_info, min_x=200,max_y=750,match=2,max_x=1200,add_y =80,sorted = true, click=2})
                    end
                end
                if text == game_str.Door_CH and not string.find(player_info.current_map_name_utf8,game_str.Abyss) then
                    api_Sleep(400)
                    -- if self.is_click_z then
                    --     poe2_api.click_keyboard("z")
                    --     self.is_click_z = false
                    -- end
                    api_UpdateMapObstacles(100)
                end
                if text == game_str.The_arena_TWCH then
                    api_UpdateMapObstacles(100)
                end
                if poe2_api.table_contains(text,{game_str.Water_gate_control_rod_TWCH,game_str.Handle_CH,game_str.Obtain_the_ring_TWCH}) then
                    api_Sleep(500)
                    poe2_api.dbgp1("点击水闸门控制杆,等待目标")
                    poe2_api.dbgp1("wait_target: ",wait_target)
                    env.wait_target = true
                end
                local ok, value = pcall(function() 
                    return interactive_object.path_name_utf8 
                end)
                if ok and value ~= nil then
                    if string.find(game_str.Ritual_PATH, interactive_object.path_name_utf8) then
                        env.afoot_altar = interactive_object
                    end
                    if string.find(interactive_object.path_name_utf8,game_str.StrongBoxes_PATH) and (interactive_object.rarity ~= 3 or (interactive_object.rarity == 3 and interactive_object.name_utf8 ~= game_str.The_Researcher_Safe_Box_TWCH)) and env.is_open_gameplay_safe then
                        env.afoot_box = interactive_object
                    end
                    if interactive_object.path_name_utf8 == game_str.AbyssCrack_PATH then
                        -- table.insert(env.interactive_permanent_id_list,interactive_object.id)
                        table.insert(env.abyss_point_list,{interactive_object.grid_x,interactive_object.grid_y})
                        -- env.interactive_permanent_id_list
                    end 
                end
                poe2_api.print_log("清路径666")
                env.path_list = {}
                env.need_item = nil
                env.interactive = nil
                env.interaction_object = nil
                env.target_point_sort_list = {}
                env.interactiontimeout = api_GetTickCount64()
                return bret.RUNNING
            end
            return bret.RUNNING
        end
    },

    -- 对话鉴定NPC
    Dialogue_Appraisal_NPC = {
        run = function(self, env)
            poe2_api.print_log("对话鉴定NPC...")
            local start_time = api_GetTickCount64()
            local player_info = env.player_info
            local attack_dis_map = env.map_level_dis
            local stuck_monsters = env.stuck_monsters
            local not_attack_mos = env.not_attack_mos
            local config = env.user_config
            
            local current_map_info = env.current_map_info
            
            local config_name = env.item_config_name
            local config_type = env.item_config_type
            
            if not poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout) then
                poe2_api.time_p("对话鉴定NPC... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end

            -- 创建反向字典
            local reverse_type_conversion = {}
            for k, v in pairs(my_game_info.type_conversion) do
                reverse_type_conversion[v] = k
                -- poe2_api.dbgp(string.format("类型转换表: %s -> %s", k, v))
            end

            local function convert_key(key)
                local converted = my_game_info.type_conversion[key] or reverse_type_conversion[key]
                -- poe2_api.dbgp(string.format("类型转换: %s -> %s", key, converted or "无对应转换"))
                return converted
            end

            local function convert_config_type(config_type_dict)
                if not config_type_dict then
                    poe2_api.dbgp("警告: 配置类型字典为空")
                    return {}
                end
                
                local converted_dict = {}
                -- poe2_api.dbgp("开始转换配置类型...")
                
                for chinese_type, info_list in pairs(config_type_dict) do
                    local english_type = my_game_info.type_conversion[chinese_type]
                    -- poe2_api.dbgp(string.format("处理类型: %s -> %s", chinese_type, english_type or "无对应英文"))
                    
                    if english_type then
                        -- 处理内嵌'類型'字段
                        if type(info_list) == "table" and info_list["類型"] then
                            -- poe2_api.dbgp("发现嵌套类型字段，开始处理...")
                            if type(info_list["類型"]) == "table" then
                                local converted_types = {}
                                for _, t in ipairs(info_list["類型"]) do
                                    local converted = my_game_info.type_conversion[t] or t
                                    table.insert(converted_types, converted)
                                    -- poe2_api.dbgp(string.format("转换嵌套类型: %s -> %s", t, converted))
                                end
                                info_list["類型"] = converted_types
                            else
                                local converted = my_game_info.type_conversion[info_list["類型"]] or info_list["類型"]
                                info_list["類型"] = {converted}
                                -- poe2_api.dbgp(string.format("转换单类型: %s -> %s", info_list["類型"], converted))
                            end
                        end
                        converted_dict[english_type] = info_list
                    else
                        poe2_api.dbgp(string.format("严重警告: 未找到类型 '%s' 的英文转换", chinese_type))
                    end
                end
                
                -- poe2_api.dbgp("配置类型转换完成")
                return converted_dict
            end

            -- 转换配置类型
            -- poe2_api.dbgp("开始转换主配置类型...")
            config_type = convert_config_type(config_type)
            -- poe2_api.dbgp(string.format("转换后配置类型条目数: %d", table.count(config_type)))

            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Continue_Game, click = 2}) then
                poe2_api.dbgp("发现'繼續遊戲'文本，点击处理中...")
                return bret.RUNNING
            end

            local appraisal_item_list = {}

            local function need_appraisal(bag_info)
                if not bag_info then
                    -- poe2_api.dbgp("城外鉴定: 背包信息为空")
                    return false
                end
                
                -- poe2_api.dbgp(string.format("开始检查背包物品，总数: %d", #bag_info))
                
                local function get_matched_config(bag)
                    -- 初始物品信息检查
                    -- poe2_api.dbgp("\n========== 开始物品匹配流程 ==========")
                    -- poe2_api.dbgp(string.format("[物品基本信息] 名称: %s | 类型: %s | 基础类型: %s | 颜色: %d", 
                    --     bag.name_utf8 or "nil", 
                    --     bag.category_utf8 or "nil", 
                    --     bag.baseType_utf8 or "nil", 
                    --     bag.color or -1))
                    
                    -- 检查config_type是否存在
                    if not config_type then
                        poe2_api.dbgp("[错误] config_type 配置表不存在！")
                        return nil
                    end
                
                    -- 1. 首先检查类型匹配
                    -- poe2_api.dbgp("\n=== 开始类型配置匹配 ===")
                    for config_name, item_config in pairs(config_type) do
                        -- poe2_api.dbgp(string.format("\n[检查配置组] 配置组名称: %s", config_name))
                        -- poe2_api.dbgp("[配置内容] %s", poe2_api.printTable(item_config))
                        -- poe2_api.printTable(item_config)

                        for idx, item in ipairs(item_config) do
                            -- poe2_api.dbgp("\n[检查配置项] 序号: %d", idx)
                            -- poe2_api.dbgp("------------------------------------------------------------------------")
                            if type(item) ~= "table" then
                                -- poe2_api.dbgp("[警告] 配置项不是table类型，跳过")
                                goto continue
                            end
                
                            -- 类型检查
                            local item_type = item["類型"]
                            -- poe2_api.dbgp(string.format("[类型检查] 配置类型: %s | 物品类型: %s", 
                            --     poe2_api.printTable(item_type), 
                            --     bag.category_utf8 or "nil"))
                
                            -- 处理类型匹配
                            local type_match = false
                            if type(item_type) == "table" and #item_type > 0 then
                                type_match = (item_type[1] == convert_key(bag.category_utf8))
                            elseif type(item_type) == "string" then
                                type_match = (item_type == convert_key(bag.category_utf8))
                            else
                                -- poe2_api.dbgp("[警告] 配置类型格式无效")
                            end
                
                            if not type_match then
                                -- poe2_api.dbgp("-> 类型不匹配，跳过")
                                goto continue
                            end
                            poe2_api.dbgp("-> 类型匹配通过")
                
                            -- 基础类型检查
                            local base_type = item["基礎類型名"] or "nil"
                            poe2_api.dbgp(string.format("[基础类型检查] 配置基础类型: %s | 物品基础类型: %s", base_type, bag.baseType_utf8 or "nil"))
                
                            if bag.baseType_utf8 ~= base_type and base_type ~= "全部物品" and not string.find(base_type, bag.baseType_utf8) then
                                -- poe2_api.dbgp("-> 基础类型不匹配，跳过")
                                goto continue
                            end

                            -- poe2_api.dbgp("-> 基础类型匹配通过")
                
                            -- 品质检查
                            local quality_check = {
                                white = item["白裝"],
                                blue = item["藍裝"],
                                yellow = item["黃裝"],
                                unique = item["暗金"]
                            }
                            -- poe2_api.dbgp(string.format("[品质检查] 配置要求: 白=%s 蓝=%s 黄=%s 暗金=%s | 物品颜色: %d",
                            --     tostring(quality_check.white),
                            --     tostring(quality_check.blue),
                            --     tostring(quality_check.yellow),
                            --     tostring(quality_check.unique),
                            --     bag.color or -1))
                
                            local quality_ok = false
                            if bag.color == 0 and quality_check.white then
                                quality_ok = true
                            elseif bag.color == 1 and quality_check.blue then
                                quality_ok = true
                            elseif bag.color == 2 and quality_check.yellow then
                                quality_ok = true
                            -- elseif bag.color == 3 and quality_check.unique then
                            elseif bag.color == 3 then
                                quality_ok = true
                            end
                
                            if not quality_ok then
                                -- poe2_api.dbgp("-> 品质不匹配，跳过")
                                goto continue
                            end
                            -- poe2_api.dbgp("-> 品质检查通过")
                            
                            -- 名称检查
                            if item["名稱"] ~= nil or item["基礎類型名"] then
                                poe2_api.dbgp(string.format("[名称检查] 配置名称: %s | 物品名称: %s", item["名稱"], bag.name_utf8 or "nil"))
                                if item["名稱"] ~= nil or item["基礎類型名"] == bag.baseType_utf8 or string.find(item["基礎類型名"], bag.baseType_utf8) then
                                    -- poe2_api.dbgp("-> 名称完全匹配，返回配置")
                                    -- poe2_api.dbgp("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item))
                                    return item
                                else
                                    -- poe2_api.dbgp("-> 名称不匹配，继续检查")
                                end
                            else
                                -- poe2_api.dbgp("[名称检查] 配置无名称要求，检查词缀")
                                
                                -- 词缀检查
                                if item["物品詞綴"] then
                                    poe2_api.dbgp("[词缀检查] 发现词缀配置")
                                    local affix_dict = item["物品詞綴"]
                                    
                                    if affix_dict and type(affix_dict) == "table" then
                                        for affix_name, v in pairs(affix_dict) do
                                            if type(v) == "table" and v["詞綴"] then
                                                -- poe2_api.dbgp(string.format("-> 发现有效词缀: %s", affix_name))
                                                -- poe2_api.dbgp(string.format("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item)))
                                                return item
                                            end
                                        end
                                    end
                                end
                            end
                            -- 如果前面都通过但没返回，检查基础类型名
                            -- poe2_api.dbgp("[最终检查] 基础类型名匹配检查")
                            if base_type == bag.baseType_utf8 or base_type == "全部物品" or string.find(base_type, bag.baseType_utf8) then
                                -- poe2_api.dbgp("-> 基础类型名匹配，返回配置")
                                -- poe2_api.dbgp(string.format("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item)))
                                return item
                            end
                
                            ::continue::
                        end
                    end
                    
                    -- 2. 检查名称匹配
                    poe2_api.dbgp("\n=== 开始名称配置匹配 ===")
                    if not config_name then
                        poe2_api.dbgp("[警告] config_name 配置表不存在")
                    else
                        for config_name, item_config in pairs(config_name) do
                            -- poe2_api.dbgp(string.format("\n[检查名称配置组] %s", config_name))
                            
                            for idx, item in ipairs(item_config) do
                                -- poe2_api.dbgp(string.format("[检查配置项] 序号: %d", idx))
                                
                                if type(item) == "table" then
                                    -- poe2_api.dbgp(string.format("[基础类型比较] 配置: %s | 物品: %s",
                                    --     item["基礎類型名"] or "nil", bag.baseType_utf8 or "nil"))
                                    
                                    -- if item["基礎類型名"] == bag.baseType_utf8 then
                                    if string.find(item["基礎類型名"] , bag.baseType_utf8) or item["基礎類型名"] == bag.baseType_utf8 or item["名稱"] ~= "" or item["名稱"] ~= nil then
                                        poe2_api.dbgp("-> 基础类型匹配")
                                        
                                        local type_ok = true
                                        if item["類型"] and item["類型"][1] then
                                            type_ok = (item["類型"][1] == bag.category_utf8)
                                            -- poe2_api.dbgp(string.format("[类型比较] 配置: %s | 物品: %s | 结果: %s",
                                            --     item["類型"][1], bag.category_utf8 or "nil",
                                            --     type_ok and "匹配" or "不匹配"))
                                        end
                                        
                                        if type_ok then
                                            -- poe2_api.dbgp("-> 所有条件匹配，返回配置")
                                            return item
                                        end
                                    end
                                end
                            end
                        end
                    end
                
                    poe2_api.dbgp("\n[匹配结果] 未找到匹配配置")
                    return nil
                end

                local items_to_identify = {}
                poe2_api.dbgp("开始扫描背包物品...")
                
                for i, bag in ipairs(bag_info) do
                    -- poe2_api.dbgp(string.format("\n物品 %d/%d: %s (类型: %s, 基础类型: %s, 颜色: %d, 已鉴定: %s)", 
                    --     i, #bag_info, bag.name_utf8 or "无名", bag.category_utf8 or "无类型", 
                    --     bag.baseType_utf8 or "无基础类型", bag.color or -1, 
                    --     tostring(not bag.not_identified)))
                    
                    -- 基础条件：未鉴定、未污染、不在排除列表
                    if not (bag.not_identified and
                            not poe2_api.table_contains(my_game_info.not_need_identify, bag.category_utf8)) then
                        -- poe2_api.dbgp("物品已鉴定或在不需鉴定列表中，跳过")
                        goto continue_item
                    end
                    
                    -- 特殊类别直接加入鉴定列表
                    if poe2_api.table_contains({game_str.Map_EN, game_str.TowerAugmentation}, bag.category_utf8) then
                        poe2_api.dbgp("特殊类别物品，直接加入鉴定列表")
                        table.insert(items_to_identify, bag)
                        goto continue_item
                    end

                    -- 获取匹配的配置
                    poe2_api.dbgp("开始匹配配置...")
                    local matched_config = get_matched_config(bag)
                    -- 检查物品詞綴配置
                    -- poe2_api.printTable(matched_config)
                    if matched_config and matched_config["物品詞綴"] or matched_config["名稱"] then
                        poe2_api.dbgp("找到匹配配置，检查词缀内容...")
                        local affix_dict = matched_config["物品詞綴"]
                        -- poe2_api.printTable(matched_config)
                        if matched_config["名稱"] ~= nil then
                            table.insert(items_to_identify, bag)
                            poe2_api.dbgp(string.format("发现有效名稱内容: %s", matched_config["名稱"]))
                        end
                        if affix_dict and type(affix_dict) == "table" then
                            local has_content = false
                            -- 遍历所有词缀组
                            for affix_group_name, affix_group in pairs(affix_dict) do
                                if type(affix_group) == "table" then
                                    -- 检查是否有"詞綴"数组且不为空
                                    local affix_array = affix_group["詞綴"]
                                    if affix_array and type(affix_array) == "table" and #affix_array > 0 then
                                        has_content = true
                                        poe2_api.dbgp(string.format("发现有效词缀内容，组: %s, 词缀数量: %d", 
                                                                affix_group_name, #affix_array))
                                        break  -- 找到一个有效组就足够
                                    end
                                    
                                end
                            end
                            
                            if has_content then
                                poe2_api.dbgp("配置中有词缀内容，加入鉴定列表")
                                table.insert(items_to_identify, bag)
                            else
                                poe2_api.dbgp("配置中无词缀内容，跳过")
                            end
                        else
                            poe2_api.dbgp("词缀配置格式无效")
                        end
                    else
                        poe2_api.dbgp("未找到匹配配置或配置无词缀要求")
                    end
                    ::continue_item::
                end

                if #items_to_identify > 0 then
                    poe2_api.dbgp(string.format("找到 %d 件需要鉴定的物品", #items_to_identify))
                    appraisal_item_list = items_to_identify
                    return items_to_identify
                end
                poe2_api.dbgp("未找到需要鉴定的物品")
                return false
            end

            poe2_api.dbgp("开始检查是否需要鉴定...")
            local bag_info = api_Getinventorys(1, 0)
            if not bag_info then
                poe2_api.dbgp("错误: 无法获取背包信息")
                return bret.SUCCESS
            end

            local items_to_identify = need_appraisal(bag_info)
            local total_items_to_identify = poe2_api.items_not_identified(bag_info)

            if items_to_identify then
                poe2_api.dbgp("开始检查是否需要鉴定...",#items_to_identify,"-->",#total_items_to_identify)
            end

            if not items_to_identify or (#items_to_identify < #total_items_to_identify) and not env.full_map then
                poe2_api.dbgp("当前没有需要鉴定的物品 或者背包有不需要鉴定的物品")
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Identify_the_item_TWCH}) and not env.is_shop then
                    poe2_api.dbgp("发现鑑定物品界面且不在商店，点击关闭")
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Goodbye, click = 2})
                    api_Sleep(100)
                end
                -- api_Sleep(10000000)
                return bret.SUCCESS
            else
                local text = nil
                if env.user_config["全局設置"] and 
                    env.user_config["全局設置"]["剧情地图设置"] and 
                    env.user_config["全局設置"]["剧情地图设置"]["是否開啟"] then
                    env.interactive = "黑衣幽魂"
                    text = "黑衣幽魂"
                elseif (env.user_config["全局設置"]["界域之门"] and env.special_mode_enabled and env.user_config["全局設置"]["界域之门"]["地图类型"] == game_str.Skull_Mark_TWCH) and player_info.current_map_name_utf8 == "G2_town" then
                    env.interactive = "黑衣幽魂"
                    text = "黑衣幽魂"
                else
                    env.interactive = game_str.Appraisal_NPC
                    text = game_str.Appraisal_NPC
                end
                
                map_obj = poe2_api.check_in_map(current_map_info,env.interactive)
                range_obj = poe2_api.check_in_range(env.range_info, env.interactive)
                target_obj = map_obj or range_obj or nil
                poe2_api.dbgp(target_obj)
                if target_obj then
                    if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Demon_dispelling_items}) then
                        poe2_api.find_text({UI_info = env.UI_info, text = game_str.Goodbye, click = 2}) 
                        return bret.RUNNING
                    end
                    distance = poe2_api.point_distance(target_obj.grid_x,target_obj.grid_y,player_info)
                    poe2_api.dbgp("distance",distance)
                    if distance and distance > 25 then
                        poe2_api.dbgp("交互",env.interactive)
                        return bret.FAIL
                    else
                        if poe2_api.find_text({UI_info = env.UI_info, text = game_str.The_recast_platform, min_x = 0}) 
                        and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, min_x = 0}) then
                            poe2_api.dbgp("关闭重铸台界面")
                            poe2_api.dbgp1("SDGSFDGSFHBSFB")
                            poe2_api.click_keyboard("space")
                            return bret.RUNNING
                        end
                        api_Sleep(1000)
                        if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.Identify_the_item_TWCH}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = text,click=2, refresh = true})
                            api_Sleep(500)
                            return bret.RUNNING
                        else
                            poe2_api.find_text({UI_info = env.UI_info, text = game_str.Identify_the_item_TWCH, click = 2})
                            api_Sleep(500)
                            -- api_Sleep(50000)
                            return bret.RUNNING
                        end
                    end
                else
                    poe2_api.dbgp("当前没有多里亞尼")
                    return bret.FAIL
                end
            end
        end
    },

    -- 是否需要合成
    Is_Need_Conflate = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Is_Need_Conflate 检查")
            local bag_info = env.bag_info
            local map_info = env.current_map_info
            local config = env.user_config
            local need_synthesis = config["全局設置"]["刷图通用設置"]["自動合成地圖"]
            
            poe2_api.dbgp("自动合成地图设置:", need_synthesis)
            
            if not need_synthesis or env.full_map then
                poe2_api.dbgp("自动合成未开启，返回FAIL")
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.The_recast_platform, min_x = 0}) 
                   and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, min_x = 0}) then
                    poe2_api.dbgp("关闭重铸台界面")
                    poe2_api.dbgp1("SDGSFDGSFHBSFB")
                    poe2_api.click_keyboard("space")
                end
                return bret.SUCCESS
            end
            
            -- 检查宝藏金锤是否激活
            local hammer_active = nil
            if map_info then
                for _, item in ipairs(map_info) do
                    if item.name_utf8 == game_str.TreasureVaultHammerActive and item.flagStatus1 == 1 then
                        hammer_active = item
                        break
                    end
                end
            end
            
            local function check_in_range(object)
                for _, k in ipairs(env.range_info) do
                    if object then
                        if k.name_utf8 == object or k.path_name_utf8 == object then
                            return k
                        end
                    end
                end
                return false
            end

            hammer_active_range = check_in_range(game_str.The_recast_platform)
            
            if not hammer_active and not hammer_active_range then
                poe2_api.dbgp("重铸台未激活")
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.The_recast_platform, min_x = 0}) 
                   and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, min_x = 0}) then
                    poe2_api.dbgp("关闭重铸台界面")
                    poe2_api.dbgp1("SDGSFDGSFHBSFB")
                    poe2_api.click_keyboard("space")
                end
                return bret.SUCCESS
            end
            
            -- 检查是否可以合成
            local function check_synthesis_possible(bag_info)
                poe2_api.dbgp("开始检查合成可能性")
                local item_counts = {}
                
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        if item.baseType_utf8 and string.find(item.baseType_utf8, game_str.Map_Key_CH) 
                           and not item.contaminated and not item.not_identified 
                           and item.baseType_utf8 ~= game_str.Map_Key_Class_15 
                           and item.baseType_utf8 ~= game_str.Map_Key_Class_16 then
                            item_counts[item.baseType_utf8] = (item_counts[item.baseType_utf8] or 0) + 1
                        end
                    end
                end
                
                poe2_api.dbgp("地图钥匙统计:", item_counts)
                
                -- 检查是否有至少3个相同的物品
                for _, count in pairs(item_counts) do
                    if count >= 3 then
                        poe2_api.dbgp("找到可合成的地图钥匙")
                        return true
                    end
                end
                
                poe2_api.dbgp("未找到足够的地图钥匙进行合成")
                return false
            end
            
            if not check_synthesis_possible(bag_info) then
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.The_recast_platform, min_x = 0}) 
                   and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, min_x = 0}) then
                    poe2_api.dbgp("关闭重铸台界面")
                    poe2_api.dbgp1("SDGSFDGSFHBSFB")
                    poe2_api.click_keyboard("space")
                end
                return bret.SUCCESS
            end
            
            poe2_api.dbgp("满足合成条件，返回FAIL")
            return bret.FAIL
        end
    },

    -- 打开合成界面
    Open_Conflate_page = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Open_Conflate_page - 打开合成界面")
            local current_time = api_GetTickCount64()
            local bag_info = env.bag_info
            local map_info = env.current_map_info
            local player_info = env.player_info
            local config = env.user_config
            
            
            
            -- 检查重铸台是否激活
            local hammer_active = nil
            if map_info then
                for _, item in ipairs(map_info) do
                    if item.name_utf8 == game_str.TreasureVaultHammerActive and item.flagStatus1 == 1 then
                        hammer_active = item
                        break
                    end
                end
            end

            local function check_in_range(object)
                if not env.range_info then
                    return false
                end
                for _, k in ipairs(env.range_info) do
                    if object then
                        if k.name_utf8 == object or k.path_name_utf8 == object then
                            return k
                        end
                    end
                end
                return false
            end

            hammer_active_range = check_in_range(game_str.The_recast_platform)
            
            if not hammer_active and not hammer_active_range then
                poe2_api.dbgp("重铸台未激活")
                return bret.SUCCESS
            end
            
            -- 检查是否可以合成
            local function check_synthesis_possible(bag_info)
                poe2_api.dbgp("检查合成可能性")
                local item_counts = {}
                
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        if item.baseType_utf8 and string.find(item.baseType_utf8, game_str.Map_Key_CH) 
                        and not item.contaminated and not item.not_identified 
                        and item.baseType_utf8 ~= game_str.Map_Key_Class_15 then
                            item_counts[item.baseType_utf8] = (item_counts[item.baseType_utf8] or 0) + 1
                        end
                    end
                end
                
                poe2_api.dbgp("地图钥匙统计:", item_counts)
                
                -- 检查是否有至少3个相同的物品
                for _, count in pairs(item_counts) do
                    if count >= 3 then
                        return true
                    end
                end
                return false
            end
            
            if not check_synthesis_possible(bag_info) then
                poe2_api.dbgp("未找到足够的地图钥匙进行合成")
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.The_recast_platform, min_x = 0}) 
                and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, min_x = 0}) then
                    poe2_api.dbgp("关闭重铸台界面")
                    poe2_api.find_text({UI_info = env.UI_info, 
                        text = game_str.The_recast_platform,
                        click = 2,
                        add_x = 211,
                        min_x = 0
                    })
                end
                return bret.FAIL
            end
            
            -- 检查天赋重置界面
            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Reset_talent_points, min_x = 0}) 
            and poe2_api.find_text({UI_info = env.UI_info, text = game_str.The_Knowledge_Scroll, min_x = 0}) then
                poe2_api.dbgp("关闭天赋重置界面")
                poe2_api.find_text({UI_info = env.UI_info, text = game_str.Goodbye, click = 2})
                return bret.RUNNING
            end
            
            -- 尝试打开合成界面
            if not (poe2_api.find_text({UI_info = env.UI_info, text = game_str.The_recast_platform, min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, min_x = 0})) then
                poe2_api.dbgp("未找到合成界面，设置交互对象为重铸台")
                env.interactive = game_str.The_recast_platform
                return bret.SUCCESS
            else
                poe2_api.dbgp("合成界面已打开，返回")
                return bret.FAIL
            end
        end
    },

    -- 点击物品进行合成
    Click_On_The_Item_To_Synthesize = {
        run = function(self, env)
            poe2_api.dbgp("开始执行 Click_On_The_Item_To_Synthesize")
            local map_info = env.current_map_info
            local bag_info = env.bag_info
            

            if not (poe2_api.find_text({UI_info = env.UI_info, text = game_str.The_recast_platform, min_x = 0}) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, min_x = 0})) then
                poe2_api.dbgp("未找到合成界面，返回")
                return bret.RUNNING
            end
            
            -- 检查是否可以合成
            local function check_synthesis_possible(bag_info)
                poe2_api.dbgp("检查合成可能性")
                local item_counts = {}
                
                if bag_info then
                    for _, item in ipairs(bag_info) do
                        if item.baseType_utf8 and string.find(item.baseType_utf8, game_str.Map_Key_CH) 
                        and not item.contaminated and not item.not_identified 
                        and item.baseType_utf8 ~= game_str.Map_Key_Class_15 then
                            item_counts[item.baseType_utf8] = (item_counts[item.baseType_utf8] or 0) + 1
                        end
                    end
                end
                
                poe2_api.dbgp("地图钥匙统计:", item_counts)
                -- 检查是否有至少3个相同的物品
                for _, count in pairs(item_counts) do
                    if count >= 3 then
                        return true
                    end
                end
                return false
            end
            
            if not check_synthesis_possible(bag_info) then
                poe2_api.dbgp("未找到足够的地图钥匙进行合成")
                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.The_recast_platform, min_x = 0}) 
                and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, min_x = 0}) then
                    poe2_api.dbgp("关闭重铸台界面")
                    poe2_api.dbgp1("DNDBSGSDGVSDCVSDCV")
                    poe2_api.click_keyboard("space")
                end
                return bret.FAIL
            end
            
            -- 罗马数字验证函数
            local function is_valid_roman_numeral(s)
                local roman_to_int_map = {
                    I = 1, V = 5, X = 10, L = 50,
                    C = 100, D = 500, M = 1000
                }
                
                local total = 0
                for i = 1, #s do
                    if not roman_to_int_map[s:sub(i,i)] then
                        return false
                    end
                end
                
                local i = 1
                while i <= #s do
                    if i + 1 <= #s and roman_to_int_map[s:sub(i,i)] < roman_to_int_map[s:sub(i+1,i+1)] then
                        total = total + roman_to_int_map[s:sub(i+1,i+1)] - roman_to_int_map[s:sub(i,i)]
                        i = i + 2
                    else
                        total = total + roman_to_int_map[s:sub(i,i)]
                        i = i + 1
                    end
                end
                
                return total >= 1 and total <= 15
            end
            
            -- 获取所有物品名称并统计出现次数
            local item_counts = {}
            local item_counts_infos = {}
            if bag_info then
                for _, actor in ipairs(bag_info) do
                    if not actor.not_identified and actor.baseType_utf8 and string.find(actor.baseType_utf8, game_str.Map_Key_CH) 
                    and not actor.contaminated and actor.baseType_utf8 ~= game_str.Map_Key_Class_15 then
                        item_counts[actor.baseType_utf8] = (item_counts[actor.baseType_utf8] or 0) + 1
                        table.insert(item_counts_infos,actor)
                    end
                end
            end

            local ROMAN_NUMERALS = {
                "I", "II", "III", "IV", "V",
                "VI", "VII", "VIII", "IX", "X",
                "XI", "XII", "XIII", "XIV", "XV", "XVI"
            }
            -- 找到可以合成的物品名称
            for item_name, count in pairs(item_counts) do
                if count >= 3 then
                    poe2_api.dbgp("找到可合成的地图钥匙:", item_name, "数量:", count)
                    
                    -- 查找献祭按钮位置
                    local start_pos = poe2_api.find_text({UI_info = env.UI_info, text = game_str.Sacrifice_TWCH, position = 3})
                    if start_pos then
                        local start_x = start_pos[1] + 15
                        local start_y = start_pos[2] - 325
                        
                        poe2_api.find_text({UI_info = env.UI_info, text = ROMAN_NUMERALS, click = 4, min_x = start_x, min_y = start_y, max_y = 590, max_x = 1030})
                    end
                    
                    api_Sleep(80)
                    
                    -- 获取合成槽中的物品
                    local compositing_map = api_Getinventorys(0x48, 0)
                    if compositing_map then
                        -- 检查各个槽位并点击相应位置
                        for _, item in ipairs(compositing_map) do
                            if item.start_x == 0 and item.start_y == 0 then
                                poe2_api.find_text({UI_info = env.UI_info, 
                                    text = game_str.Sacrifice_TWCH, 
                                    click = 4,
                                    add_x = -107,
                                    add_y = -143
                                })
                                api_Sleep(80)
                            elseif item.start_x == 2 and item.start_y == 0 then
                                poe2_api.find_text({UI_info = env.UI_info, 
                                    text = game_str.Sacrifice_TWCH, 
                                    click = 4,
                                    add_y = -143
                                })
                                api_Sleep(80)
                            elseif item.start_x == 4 and item.start_y == 0 then
                                poe2_api.find_text({UI_info = env.UI_info, 
                                    text = game_str.Sacrifice_TWCH, 
                                    click = 4,
                                    add_x = 107,
                                    add_y = -143
                                })
                                api_Sleep(80)
                            end
                        end
                    end
                    
                    poe2_api.dbgp("准备合成:", item_name)

                    -- 筛选出名称相同的物品
                    if item_counts_infos then
                        local clicked_count = 0  -- 已点击计数器
                        
                        -- 遍历所有物品信息
                        for _, item_info in ipairs(item_counts_infos) do
                            -- 检查物品名称是否匹配
                            if item_info.baseType_utf8 == item_name then

                                center = poe2_api.get_center_position({item_info.start_x,item_info.start_y},{item_info.end_x,item_info.end_y})
                                
                                -- 点击物品（两种方式可选）
                                -- 方式1：使用坐标点击
                                poe2_api.dbgp("点击物品:", item_name, "位置:", center[1], center[2])
                                poe2_api.ctrl_left_click(center[1], center[2])
                                
                                clicked_count = clicked_count + 1
                                api_Sleep(50)  -- 短暂延迟
                                
                                -- 点击满3次就停止
                                if clicked_count >= 3 then
                                    break
                                end
                            end
                        end
                        
                        if clicked_count < 3 then
                            poe2_api.dbgp("警告: 只找到", clicked_count, "个", item_name, "无法完成合成")
                        end
                    end

                    api_Sleep(500)

                    if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.Sacrifice_TWCH, click=2, min_x = 0}) then
                        return bret.RUNNING
                    end
                    
                    api_Sleep(1000)

                    -- 处理合成后的物品
                    poe2_api.find_text({UI_info = env.UI_info, 
                        text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one,
                        click = 4,
                        add_y = 140,
                        min_x = 0
                    })
                    api_Sleep(100)
                    
                    poe2_api.dbgp("合成操作完成:", item_name)
                    return bret.RUNNING
                end
            end
            
            -- 如果没有找到可合成的物品，关闭重铸台界面
            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.The_recast_platform, min_x = 0}) 
            and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, min_x = 0}) then
                poe2_api.find_text({UI_info = env.UI_info, 
                    text = game_str.The_recast_platform,
                    click = 2,
                    add_x = 211,
                    min_x = 0
                })
            end
            
            return bret.SUCCESS
        end
    },

    -- 异界是否需要传送
    Otherworld_Is_Need_Teleport = {
        run = function(self, env)
            poe2_api.dbgp("开始执行异界传送判断函数")
            local current_time = api_GetTickCount64()

            -- 检查是否在目标区域里
            poe2_api.dbgp("检查是否在目标区域里")
            local current_map_info = env.current_map_info
            
            -- 定义检查是否有传送点的函数
            local function Is_Have_Waypoint()
                poe2_api.dbgp("检查当前地图是否有传送点")
                if next(current_map_info) then
                    for _, v in ipairs(current_map_info) do
                        -- poe2_api.dbgp(v.name_utf8)
                        if v.name_utf8 == game_str.Waypoint_EN then
                            poe2_api.dbgp("找到传送点")
                            return true
                        end
                    end
                    poe2_api.dbgp("未找到传送点")
                    return false
                end
            end
            
            -- 初始化副本地图信息
            if self.copy_map_info == nil then
                poe2_api.dbgp("初始化copy_map_info为false")
                self.copy_map_info = false
            end
            
            -- 如果没有传送点，直接返回成功
            if not Is_Have_Waypoint() then 
                poe2_api.dbgp("当前地图没有传送点，无需传送")
                return bret.SUCCESS
            end
            
            poe2_api.dbgp("当前地图有传送点，继续处理")
            
            local player_info = env.player_info
            local config = env.user_config
            local user_map_info = nil
            
        
            -- 根据任务类型设置目标地图
            local user_map_info = poe2_api.format_map_data(config)
            if not user_map_info then
                poe2_api.dbgp("无剧情地图")
                return bret.SUCCESS
            end

            local is_map_complete = env.is_map_complete
            local target_chapter_name = user_map_info[1]
            local target_map_name = user_map_info[2]
            
            poe2_api.dbgp("当前玩家位置:", player_info.current_map_name_utf8)
            poe2_api.dbgp("目标章节:", target_chapter_name)
            poe2_api.dbgp("目标地图:", target_map_name)
            
            -- 如果用户地图信息为空且玩家在藏身处且靠近传送点
            if not user_map_info and poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout) 
                and poe2_api.check_pos_dis(game_str.Waypoint_EN, current_map_info, player_info) then
                poe2_api.dbgp('user_map_info为nil且玩家在藏身处靠近传送点，设置默认目标')
                target_chapter_name = '<red>{第三章}'
                target_map_name = '高地神塔庇護所'
            end

            -- 如果有目标章节和地图名称
            if target_chapter_name and target_map_name then 
                poe2_api.dbgp("有明确的目标章节和地图名称")
                local result = poe2_api.get_map_data(target_chapter_name, target_map_name)
                poe2_api.printTable(result)
                
                if result then
                    -- poe2_api.dbgp("目标地区完成状态为：", result[2])
                    
                    -- 检查玩家是否已在目标地图
                    if player_info.current_map_name_utf8 ~= result[1] or is_map_complete then 
                        poe2_api.dbgp("人物当前位置不在目标地图")
                        env.chapter_name = target_chapter_name
                        env.map_name = result
                        poe2_api.dbgp("需要传送，目标地图:", target_map_name)
                        return bret.FAIL
                    else
                        poe2_api.dbgp("已在目标地图且地图未完成")
                        return bret.SUCCESS
                    end
                end
                poe2_api.dbgp("未能获取目标地图完成状态")
                return bret.RUNNING
            else
                poe2_api.dbgp("没有明确的目标章节和地图名称，检查副本地图信息")
                
                if self.copy_map_info and user_map_info then
                    local found = false
                    for _,map_info in ipairs(self.copy_map_info) do
                        local result = poe2_api.get_map_data(map_info[1], map_info[2])
                        if result and result[2] then
                            if player_info.current_map_name_utf8 == result[1][2] then
                                found = true
                                poe2_api.dbgp("玩家已在副本地图:", map_info[2])
                                
                                if is_map_complete then
                                    poe2_api.dbgp("地图", map_info[2], "已完成，需要移除")
                                    env.chapter_name = target_chapter_name
                                    env.map_name = result
                                    poe2_api.dbgp("进入传送逻辑，目标地图:", target_map_name)
                                    poe2_api.time_p("进入传送逻辑(FAIL)(is_map_complete) -->", api_GetTickCount64() - current_time)
                                    return bret.FAIL
                                else
                                    poe2_api.dbgp("地图", map_info[2], "未完成")
                                    return bret.SUCCESS
                                end
                            end
                        end
                    end
                    
                    if not found then 
                        poe2_api.dbgp("玩家不在任何副本地图中，寻找可传送地图")
                        for _,map_info in ipairs(self.copy_map_info) do
                            local result = poe2_api.get_map_data(map_info[1], map_info[2])
                            if result and result[2] then
                                env.chapter_name = map_info[1]
                                env.map_name = result
                                poe2_api.dbgp("进入传送逻辑，目标地图:", map_info[2])
                                poe2_api.time_p("进入传送逻辑(FAIL)(not found) -->", api_GetTickCount64() - current_time)
                                return bret.FAIL
                            end
                        end
                        poe2_api.dbgp("没有可传送地图")
                        return bret.RUNNING
                    end 
                else
                    if not self.copy_map_info and user_map_info then
                        poe2_api.dbgp("初始化副本地图信息")
                        self.copy_map_info = user_map_info
                        return bret.RUNNING
                    end
                    poe2_api.dbgp("无需传送")
                    return bret.SUCCESS
                end
            end
        end
    },

    -- 异界点击地图传送
    Otherworld_Click_Map_To_Area_Teleport = {
        run = function(self, env)
            poe2_api.print_log("开始执行异界点击地图传送...")
            local current_time = api_GetTickCount64()
            
            -- 获取环境变量
            local map_name = env.map_name
            local chapter_name = env.chapter_name
            local waypoint_open = env.waypoint
            local current_map_info = env.current_map_info
            local player_info = env.player_info
            local range_info = env.range_info
            local is_map_complete = env.is_map_complete
            
            poe2_api.dbgp("环境变量:", 
                "map_name", map_name,
                "chapter_name", chapter_name,
                "waypoint_open", waypoint_open,
                "is_map_complete", is_map_complete)

            -- 检查传送点距离
            local function check_pos_dis(name, map_info, player)
                poe2_api.dbgp("检查传送点距离...")
                for _, item in ipairs(map_info) do
                    if item.name_utf8 == name then
                        local dis = poe2_api.point_distance(item.grid_x, item.grid_y, player)
                        poe2_api.dbgp(string.format("传送点距离: %.2f", dis))
                        return dis
                    end
                end
                return false
            end

            -- 获取非地图物品
            local function get_not_map(range_info)
                poe2_api.dbgp("查找非地图交互对象...")
                for _, item in ipairs(range_info) do
                    if item.type == 5 and item.name_utf8 ~= '' and item.name_utf8 ~= game_str.Transfer_point_CH and item.name_utf8 ~= game_str.The_Gate_of_the_Outland_CH then
                        poe2_api.dbgp("找到非地图对象:", item.name_utf8)
                        return item
                    end
                end
                poe2_api.dbgp("未找到非地图对象")
                return false
            end

            -- 获取地面UI层级
            local function switch_ground()
                poe2_api.dbgp("获取地面UI层级...")
                local controls = poe2_api.get_game_control_by_rect({
                    UI_info = env.UI_info, 
                    min_x = 1525, 
                    min_y = 230, 
                    max_x = 1600,
                    max_y = 560
                })
                
                -- 使用表来筛选符合条件的控件
                local filtered_controls = {}
                for _, control in ipairs(controls) do
                    if control.name_utf8 == "" and control.left == 1544.25 then
                        table.insert(filtered_controls, control)
                    end
                end
                
                if #filtered_controls == 0 then
                    poe2_api.dbgp("未找到符合条件的UI控件")
                    return false
                end
                
                -- 使用排序方法找到最小top值
                table.sort(filtered_controls, function(a, b)
                    return a.top < b.top
                end)
                
                local min_top = filtered_controls[1].top
                poe2_api.dbgp("最小top值:", min_top)
                return min_top
            end

            -- 主逻辑
            if not check_pos_dis(game_str.Waypoint_EN, current_map_info, player_info) then
                poe2_api.dbgp("传送点不在范围内或不存在")
                return bret.FAIL
            end
            -- poe2_api.dbgp("map_name:",map_name," , map_name[2]:",map_name[2])

            if map_name then
                local task_area_name = map_name[1][1]
                poe2_api.dbgp("任务区域名称:", task_area_name)

                if poe2_api.click_text_UI({UI_info = env.UI_info, text = game_str.loading_screen_tip_label}) then
                    poe2_api.dbgp("检测到加载界面，等待5秒...")
                    api_Sleep(5000)
                    return bret.RUNNING
                end

                if player_info.current_map_name_utf8 ~= map_name[1] or is_map_complete then
                    if not poe2_api.find_text({UI_info = env.UI_info, text = game_str.teleportation, min_x = 700, max_y = 40, max_x = 830, refresh = true}) then
                        if not string.find(player_info.current_map_name_utf8, game_str.town) and not poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                            if check_pos_dis(game_str.Waypoint_EN, current_map_info, player_info) > 180 then
                                local door = get_not_map(range_info)
                                if door then
                                    poe2_api.dbgp("距离传送点过远，尝试通过门传送...")
                                    poe2_api.find_text({UI_info = env.UI_info, text = door.name_utf8, click = 2})
                                    api_Sleep(500)
                                    return bret.RUNNING
                                end
                                poe2_api.dbgp("移动到默认位置...")
                                api_ClickScreen(1230, 815, 0)
                                api_ClickScreen(1230, 815, 1)
                                api_Sleep(500)
                            end
                        end

                        poe2_api.dbgp("设置交互对象为传送点")
                        env.interactive = game_str.Waypoint_EN
                        return bret.FAIL
                    elseif poe2_api.find_text({UI_info = env.UI_info, text = game_str.teleportation, min_x = 700, max_y = 40, max_x = 830}) then
                        local min_top = switch_ground()
                        if not min_top then
                            poe2_api.dbgp("未找到地面UI层级")
                            return bret.RUNNING
                        end

                        poe2_api.dbgp("点击章节名称:", chapter_name)
                        poe2_api.find_text({UI_info = env.UI_info, text = chapter_name, click = 2})
                        
                        if poe2_api.table_contains(chapter_name, {"第 1 章", "<red>{第一章}"}) and not poe2_api.find_text({UI_info = env.UI_info, text = "奧格姆郡，約恆曆", min_x = 0, match = 2, refresh = true}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = chapter_name, click = 2, refresh = true})
                            poe2_api.dbgp("再次点击章节名称:", chapter_name)
                            return bret.RUNNING
                        elseif poe2_api.table_contains(chapter_name, {"第 2 章", "<red>{第二章}"}) and not poe2_api.find_text({UI_info = env.UI_info, text = "七大水域之地", min_x = 0, match = 2, refresh = true}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = chapter_name, click = 2, refresh = true})
                            poe2_api.dbgp("再次点击章节名称:", chapter_name)
                            return bret.RUNNING
                        elseif poe2_api.table_contains(chapter_name, {"第 3 章"}) and not poe2_api.find_text({UI_info = env.UI_info, text = "奧札爾區域草稿 #", min_x = 0, match = 2, refresh = true}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = chapter_name, click = 2, refresh = true})
                            poe2_api.dbgp("再次点击章节名称:", chapter_name)
                            return bret.RUNNING
                        elseif poe2_api.table_contains(chapter_name, {"<red>{第三章}"}) and not poe2_api.find_text({UI_info = env.UI_info, text = "古奧札爾草稿", min_x = 0, match = 2, refresh = true}) then
                            poe2_api.find_text({UI_info = env.UI_info, text = chapter_name, click = 2, refresh = true})
                            poe2_api.dbgp("再次点击章节名称:", chapter_name)
                            return bret.RUNNING
                        end

                        poe2_api.dbgp("获取传送点信息")
                        if not poe2_api.find_text({UI_info = env.UI_info, text = "新副本", click = 2, min_x = 0}) then
                            env.waypoint = api_GetTeleportationPoint()
                        end
                        if not env.waypoint then
                            poe2_api.dbgp("获取传送点信息失败")
                            return bret.RUNNING
                        else
                            poe2_api.printTable(env.waypoint)
                            poe2_api.dbgp("获取传送点信息成功")
                        end

                        local function findNameC(targetName)
                            local results = {}
                            for i, item in ipairs(env.waypoint) do
                                if item.name == targetName then
                                    -- if not item.is_open then
                                    --     return false, false
                                    -- end
                                    return (item.left + item.right)/2, (item.top + item.bottom)/2
                                end
                            end
                            return false, false
                        end

                        local screen_x, screen_y = findNameC(map_name[1])
                        poe2_api.dbgp("map_name[1]", map_name[1])
                        if not screen_x and not screen_y then
                            poe2_api.dbgp("传送点未开启或者信息有误")
                            return bret.RUNNING
                        end
                        poe2_api.dbgp("两点坐标：", screen_x," ,  ", screen_y)
                        -- api_Sleep(100000)
                        
                        -- poe2_api.printTable(env.waypoint)

                        if poe2_api.find_text({UI_info = env.UI_info, text = "奧格姆郡，約恆曆", min_x = 0, match = 2}) or 
                        poe2_api.find_text({UI_info = env.UI_info, text = "七大水域之地", min_x = 0, match = 2}) or 
                        poe2_api.find_text({UI_info = env.UI_info, text = "奧札爾區域草稿 #", min_x = 0, match = 2}) or 
                        poe2_api.find_text({UI_info = env.UI_info, text = "古奧札爾草稿", min_x = 0, match = 2}) then
                            if not poe2_api.find_text({UI_info = env.UI_info, text = task_area_name}) then
                                poe2_api.dbgp("移动到地图位置:", screen_x, screen_y)
                                api_ClickScreen(screen_x, screen_y, 0)
                                api_Sleep(1000)

                                if #map_name < 2 then
                                    if not poe2_api.find_text({UI_info = env.UI_info, text = "副本管理員"}) and not string.find(map_name[1], "own") and map_name[1] ~= "G1_7" then
                                        poe2_api.dbgp("按下Ctrl键点击...")
                                        poe2_api.click_keyboard("ctrl", 1)
                                        api_Sleep(1000)
                                        api_ClickScreen(screen_x, screen_y, 1)
                                        api_Sleep(1000)
                                        poe2_api.click_keyboard("ctrl", 2)
                                    end
                                    poe2_api.find_text({UI_info = env.UI_info, text = "新副本", click = 2, min_x = 0})
                                    env.is_map_complete = false
                                    api_Sleep(2000)
                                else
                                    poe2_api.dbgp("点击一层...")
                                    api_Sleep(1000)
                                    api_ClickScreen(screen_x, screen_y, 1)
                                    api_Sleep(1000)
                                end
                            else
                                poe2_api.dbgp("点击地面UI...")
                                api_ClickScreen(1567, min_top + 22, 0)
                                api_ClickScreen(1567, min_top + 22, 1)
                                api_Sleep(2000)
                                return bret.RUNNING
                            end

                            poe2_api.dbgp("33333333333333333:")

                            if #map_name > 1 then
                                poe2_api.dbgp("处理第二个地图位置...")
                                api_ClickScreen(screen_x, screen_y, 0)
                                api_Sleep(1000)
                                local task_two_area_name = map_name[2][1]
                                poe2_api.dbgp("二次获取传送点信息")
                                env.waypoint = api_GetTeleportationPoint()
                                poe2_api.dbgp("二次获取传送点信息成功", map_name[2][2])
                                local screen_x, screen_y = findNameC(map_name[2][2])
                                api_ClickScreen(screen_x, screen_y, 0)
                                api_Sleep(1000)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = task_two_area_name, min_x = 0, refresh = true}) then
                                    poe2_api.dbgp1("GDSBSDBCXVAFSEAD")
                                    poe2_api.click_keyboard("space")
                                    return bret.RUNNING
                                end

                                if not poe2_api.find_text({UI_info = env.UI_info, text = "副本管理員"}) and not string.find(map_name[1], "own") and map_name[1] ~= "G1_7" then
                                    poe2_api.dbgp("按下Ctrl键点击第二个位置...")
                                    poe2_api.click_keyboard("ctrl", 1)
                                    api_Sleep(1000)
                                    api_ClickScreen(screen_x, screen_y, 1)
                                    api_Sleep(1000)
                                    poe2_api.click_keyboard("ctrl", 2)
                                end
                                api_Sleep(1000)
                                poe2_api.find_text({UI_info = env.UI_info, text = "新副本", click = 2, min_x = 0, refresh = true})
                                env.is_map_complete = false
                                api_ClickScreen(screen_x, screen_y, 1)
                                api_Sleep(2000)
                            end
                            env.map_name = nil
                            env.is_map_complete = false
                            return bret.RUNNING
                        end
                        poe2_api.dbgp("未找到章节标志")
                        return bret.RUNNING
                    end
                else
                    poe2_api.dbgp("已在目标地图中")
                    return bret.SUCCESS
                end
            else
                poe2_api.dbgp("传送点未开启或地图名称无效")
                return bret.RUNNING
            end
        end
    },

    
     -- 判断是否需要交互
    Is_Interactive = {
        run = function(self, env)
            poe2_api.print_log("判断是否需要交互...")
            local current_time = api_GetTickCount64()
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.timeout = 0
                self.number = 0
                self.id1 = nil
                self.not_id = nil
                -- env.not_match_id = nil
                self.interactive_timeout = 0
                -- env.interactive_id = nil
                -- env.interactive_id_list = {}
                -- env.interactive_replytime = 0
                -- env.interactive_permanent_id_list = {}
                -- env.obj_color = nil
                self.wait = false
                self.wait_time = 0
                self.currte_time = 0
                self.bool = true
            end
            -- local range_info = env.range_info
            local player_info = env.player_info
            local stuck_monsters = env.stuck_monsters
            if not next(player_info) then
                poe2_api.dbgp("Is_Interactive 没有玩家信息")
                poe2_api.time_p("判断是否需要交互（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if not env.range_info or not next(env.range_info) then
                poe2_api.dbgp("Is_Interactive 没有周围对象信息")
                poe2_api.time_p("判断是否需要交互（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local current_map_info = env.current_map_info
            -- 判断怪物
            local function is_monster(match_data)
                local range_info = match_data.range_info
                local mate = match_data.mate
                local distance = match_data.distance
                local index = match_data.index or 0
                if index ~= 0 and distance > env.min_attack_dis then
                    distance = env.min_attack_dis  
                end
                -- for _, i in ipairs(range_info) do
                --     if i.name_utf8 == "" then
                --         goto continue
                --     end
                --     if index == 0 then
                --         if string.find(game_str.Worm_Tunnel_Destroyer_TWCH,i.name_utf8) then
                --             return i
                --         end
                --     else
                --         if i.type == 1 
                --          and not i.is_friendly 
                --          and i.life > 0 
                --          and not poe2_api.table_contains(i.name_utf8,my_game_info.not_attact_mons_CN_name) 
                --          and i.isActive 
                --          and not string.find(i.name_utf8,game_str.temple) 
                --          and i.hasLineOfSight 
                --          and i.is_selectable 
                --          and not poe2_api.table_contains(stuck_monsters,i.id) then
                --             local dis = poe2_api.point_distance(i.grid_x,i.grid_y,mate)
                --             if dis and dis <= distance then
                --                 if index == 1 then
                --                     if i.rarity ~= 3 then
                --                         return i
                --                     end 
                --                 else
                --                     return i
                --                 end
                --             end
                --         end
                --     end
                --     ::continue::
                -- end
                for _, i in ipairs(range_info) do
                    -- 调试打印当前检查的怪物信息
                    -- poe2_api.dbgp("检查怪物: ID="..i.id..", 名称="..i.name_utf8..", 类型="..i.type..", 生命="..i.life..", 稀有度="..i.rarity)
                    
                    -- 跳过名称为空的怪物
                    if i.name_utf8 == "" then
                        -- poe2_api.dbgp("跳过: 怪物名称为空")
                        goto continue
                    end
                    
                    -- 特殊处理index=0的情况(寻找特定怪物)
                    if index == 0 then
                        poe2_api.dbgp("模式0: 寻找特定怪物")
                        if string.find(game_str.Worm_Tunnel_Destroyer_TWCH, i.name_utf8) then
                            poe2_api.dbgp("找到目标怪物: "..i.name_utf8)
                            return i
                        end
                    else
                        -- 普通怪物筛选条件
                        -- poe2_api.dbgp("模式"..index..": 普通怪物筛选")
                        
                        -- 类型检查(1表示怪物)
                        if i.type ~= 1 then
                            -- poe2_api.dbgp("跳过: 类型不是怪物(类型="..i.type..")")
                            goto continue
                        end
                        
                        -- 友好性检查
                        if i.is_friendly then
                            -- poe2_api.dbgp("跳过: 是友方单位")
                            goto continue
                        end
                        
                        -- 生命值检查
                        if i.life <= 0 then
                            -- poe2_api.dbgp("跳过: 生命值为0或更低")
                            goto continue
                        end
                        
                        -- 不攻击名单检查
                        if poe2_api.table_contains(i.name_utf8, my_game_info.not_attact_mons_CN_name) then
                            -- poe2_api.dbgp("跳过: 在不攻击名单中")
                            goto continue
                        end
                        
                        -- 活动状态检查
                        if not i.isActive then
                            -- poe2_api.dbgp("跳过: 不处于活动状态")
                            goto continue
                        end
                        
                        -- 神殿怪物排除
                        if string.find(i.name_utf8, game_str.temple) then
                            -- poe2_api.dbgp("跳过: 是神殿怪物")
                            goto continue
                        end
                        
                        -- 视线检查
                        if not i.hasLineOfSight then
                            -- poe2_api.dbgp("跳过: 没有视线")
                            goto continue
                        end
                        
                        -- 可选性检查
                        if not i.is_selectable then
                            -- poe2_api.dbgp("跳过: 不可选")
                            goto continue
                        end
                        
                        -- 卡住怪物检查
                        if poe2_api.table_contains(stuck_monsters, i.id) then
                            -- poe2_api.dbgp("跳过: 怪物被标记为卡住")
                            goto continue
                        end
                        
                        -- 距离计算
                        local dis = poe2_api.point_distance(i.grid_x, i.grid_y, mate)
                        -- poe2_api.dbgp("距离计算: "..tostring(dis).." (最大允许距离: "..distance..")")
                        
                        if dis and dis <= distance then
                            -- 模式1特殊处理(排除稀有怪物)
                            if index == 1 then
                                if i.rarity ~= 3 then
                                    poe2_api.dbgp("找到合适怪物(模式1): "..i.name_utf8..", 稀有度="..i.rarity)
                                    return i
                                else
                                    -- poe2_api.dbgp("跳过: 模式1排除稀有怪物(稀有度=3)")
                                end
                            else
                                -- 其他模式直接返回
                                poe2_api.dbgp("找到合适怪物(模式"..index.."): "..i.name_utf8)
                                return i
                            end
                        else
                            -- poe2_api.dbgp("跳过: 距离超出范围或距离计算失败")
                        end
                    end
                    
                    ::continue::
                end
                return false
            end
            -- -- 判断有无地图装置
            -- local function is_map_device(obj_list)
            --     if not obj_list or #obj_list == 0 then
            --         return false
            --     end
            --     for _, i in ipairs(obj_list) do
            --         if i.name_utf8 == game_str.MapDevice then
            --             return true
            --         end
            --     end
            --     return false
            -- end
            -- 判断小地图最终boss图标是否显示
            local function is_boss_map(mini_map_info)
                if not mini_map_info or #mini_map_info == 0 then
                    return false
                end
                for _, v in ipairs(mini_map_info) do
                    if v.name_utf8 == game_str.UniqueMonsterAlive_EN and v.flagStatus == 1 then
                        return true
                    end
                end
                return false
            end
            -- 判断小地图精髓图标是否显示
            local function is_essence_map(mini_map_info)
                for _, v in ipairs(mini_map_info) do
                    if v.name_utf8 == game_str.Essence_EN then
                        return true
                    end
                end
                return false
            end
            -- 判断小地图是否精英怪显示
            local function is_elite_monster(mini_map_info)
                for _, v in ipairs(mini_map_info) do
                    if v.name_utf8 == game_str.RareMonsterAlive_EN and v.flagStatus == 1 then
                        return true
                    end
                end
                return false
            end
            -- 判断人物boss距离和竞技场boss距离
            local function get_arena_boss_distance(range_info,inter)
                local is_boss = nil
                for _, v in ipairs(range_info) do
                    if v.rarity ==3 and v.type==1 and v.life>0 then
                        is_boss = v
                        break
                    end
                end
                if is_boss and player_info.current_map_name_utf8 ~= game_str.MapVaalFoundry_MDANA then
                    local distance1 = poe2_api.point_distance(is_boss.grid_x,is_boss.grid_y,inter)
                    local distance2 = poe2_api.point_distance(is_boss.grid_x,is_boss.grid_y,player_info)
                    if distance1 and distance2 then
                        if distance1 - distance2 > 20 then
                            return true
                        end
                    end
                end
                return false
            end
            
            
            -- 等待特定交互对象时间间隔
            if env.wait_target 
             and not poe2_api.find_text({UI_info = env.UI_info, text = game_str.Handle_CH,min_x=300,max_x=1100})
             and not poe2_api.find_text({UI_info = env.UI_info, text = game_str.Water_gate_control_rod_TWCH,min_x=300,max_x=1100}) then
                if self.timeout == 0 then
                    self.timeout = api_GetTickCount64()
                end
                if api_GetTickCount64() - self.timeout < 5000 then
                    poe2_api.dbgp("等待交互把手或者水閘門控制桿时间到达")
                    poe2_api.time_p("判断是否需要交互（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                env.wait_target = false
                self.timeout = 0
            end
            -- 清空不交互对象id列表
            if env.interactive_replytime ~=0 then
                if api_GetTickCount64() - env.interactive_replytime > 15000 then
                    env.interactive_id_list = {}
                    env.interactive_replytime = 0
                    poe2_api.dbgp("交互回复时间到达,清空不交互列表id")
                    poe2_api.time_p("判断是否需要交互（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            -- 获取地图等级对应的箱子颜色
            local config = env.user_config
            local map_config = config['刷圖設置'][game_str.Map_Key_CH]
            local missions = config["執行任務"] or ""
            local is_chasing_the_soul = config["全局設置"]["刷图通用設置"]["是否追魂"] or false
            local is_perform_a_ritual_sacrifice = config["全局設置"]["刷图通用設置"]["是否打祭祀"] or false
            local is_into_the_abyss = config["全局設置"]["刷图通用設置"]["是否进深渊"] or false
            local gameplay_config = config["全局設置"]["界域之门"] or {}
            local is_gameplay_open = gameplay_config["是否開啟"] or false
            local gameplay_type = gameplay_config["地图类型"] or ""
            local skeleton_mark_gameplay = config["全局設置"]["骷髅马克玩法"] or {}
            local gameplay_skeleton = skeleton_mark_gameplay["骷髅马克buff"] or {}
            if missions == "劇情地圖" then
                env.obj_color = 0
            end
            if env.obj_color == nil then
                
                if not poe2_api.find_text({UI_info = env.UI_info, text = my_game_info.game_region,max_x=1800}) then
                    poe2_api.click_keyboard("tab")
                    api_Sleep(500)
                    poe2_api.time_p("判断是否需要交互（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local text = poe2_api.find_text({UI_info = env.UI_info, text = "怪物等級：",min_x = 0,min_y = 0,max_x = 1600,max_y = 900,match = 2,position = 2})
                if text then
                    local color_invert_int = {
                        ["黄"]=2,
                        ["蓝"]=1,
                        ["白"]=0
                    }
                    local level = string.match(text.text_utf8, "：(.*)")
                    local map_config_level = my_game_info.ui_level_map[tostring(level)]
                    local tiers = {}
                    for _, v in ipairs(map_config) do
                        table.insert(tiers,v["階級"])
                    end
                    -- poe2_api.printTable(tiers)
                    poe2_api.dbgp("地图等级:",#tiers)
                    local color = "蓝"
                    if poe2_api.table_contains(poe2_api.toInt(map_config_level),tiers) then
                        for _, v in ipairs(map_config) do
                            if v["階級"] == poe2_api.toInt(map_config_level) then
                                color = v["開箱子"]
                            end
                        end
                    else
                        -- poe2_api.printTable(tiers)
                        poe2_api.dbgp("地图等级:",#tiers)

                        local max_tier =  math.max(table.unpack(tiers))
                        for _, v in ipairs(map_config) do
                            if v["階級"] == poe2_api.toInt(max_tier) then
                                color = v["開箱子"]
                            end
                        end
                    end
                    if color == "" or not color then
                        env.obj_color = 10
                    else
                        env.obj_color = color_invert_int[color]
                    end
                else
                    env.obj_color = 1
                end
            end
            -- 判断自身一定范围内是否有激活怪
            local is_target = is_monster({range_info = env.range_info, mate = player_info, distance = 70, index = 2})
            -- local is_target = type(is_target) ~= "boolean" or true
            poe2_api.dbgp("is_target:",is_target)
            -- 判断自身一定范围内是否有激活怪，不包含特殊boss
            local is_target1 = is_monster({range_info = env.range_info, mate = player_info, distance = 70, index = 1})
            
            local is_bass = is_boss_map(current_map_info)
            local is_essence = is_essence_map(current_map_info)
            local function get_range(range_info)
                local range_sorted = poe2_api.get_sorted_list(env.range_info, env.player_info)
                -- poe2_api.printTable(range_sorted)
                -- api_Sleep(10000000)
                local function is_click()
                    local click_lt = nil
                    for _, i in ipairs(range_sorted) do
                        if i.name_utf8 ~="" and i.name_utf8 == game_str.Check_point 
                         and not string.find(i.path_name_utf8,game_str.Boss_EN) and i.grid_x and i.grid_y and i.grid_x ~= 0 and i.grid_y ~= 0 then
                            click_lt = i
                            break
                        end
                    end
                    if click_lt then
                        return true
                    end
                    return false
                end
                local currency = nil
                -- for _,v in ipairs(range_sorted) do
                --     if string.find(v.path_name_utf8,"Metadata/MiscellaneousObjects/Abyss") then
                --         poe2_api.printTable(v)
                --     end
                -- end
                -- api_Sleep(10000000)
                for _, i in ipairs(range_sorted) do
                    -- if i.path_name_utf8 ~= game_str.Ritual_PATH then
                    -- if not string.find(i.path_name_utf8,game_str.DoodadDaemonShardPack_PATH) then
                    --     goto continue
                    -- end
                    -- poe2_api.printTable(i)
                    -- poe2_api.dbgp("开始检查对象: "..(i.name_utf8 or "无名").." (ID:"..(i.id or "无ID")..")")
                    
                    -- 基础条件检查
                    local basic_checks = i.grid_x and i.grid_y and i.grid_x ~= 0 and i.grid_y ~= 0
                    -- poe2_api.dbgp("基础坐标检查: "..tostring(basic_checks).." (x:"..(i.grid_x or "nil")..", y:"..(i.grid_y or "nil")..")")
                    
                    local id_check = (not env.interactive_id_list or not next(env.interactive_id_list) or not poe2_api.table_contains(env.interactive_id_list,i.id))
                    -- poe2_api.dbgp(poe2_api.table_contains({},i.id))
                    -- poe2_api.dbgp("----------------------")
                    -- poe2_api.printTable(env.interactive_id_list)
                    -- poe2_api.dbgp("----------------------")
                    -- poe2_api.dbgp("ID检查: "..tostring(id_check)," (ID列表: ",(env.interactive_id_list and "存在" or "nil"),", 包含检查: ",(not poe2_api.table_contains(env.interactive_id_list,i.id or 0)))
                    
                    local perm_id_check = (not env.interactive_permanent_id_list or not next(env.interactive_permanent_id_list) or not poe2_api.table_contains(env.interactive_permanent_id_list,i.id))
                    -- poe2_api.dbgp("永久ID检查: "..tostring(perm_id_check).." (永久ID列表: "..(env.interactive_permanent_id_list and "存在" or "nil")..", 包含检查: "..tostring(not poe2_api.table_contains(env.interactive_permanent_id_list or {},i.id or 0)))
                    
                    if basic_checks and id_check and perm_id_check then
                        -- poe2_api.dbgp("通过基础检查，开始详细条件检查")
                        
                        -- 定义各种条件检查
                        local condition1 = (i.name_utf8 and i.name_utf8 ~= "" and poe2_api.table_contains(i.name_utf8,{game_str.Pioneer_Beacon_Tower_TWCH,game_str.The_Stone_Array_Altar_TWCH,game_str.Worm_Tunnel_Destroyer_TWCH,game_str.Treasure_binds_the_soul_TWCH}) and i.isActive and i.is_selectable and not is_target and not player_info.isInBossBattle)
                        if condition1 then
                            -- poe2_api.dbgp("条件1匹配: 特定名称对象 ("..i.name_utf8..")")
                            currency = i
                            break
                        end
                        
                        local condition2 = (i.name_utf8 and i.name_utf8 ~= "" and i.name_utf8 == game_str.The_arena_TWCH and i.isActive and i.is_selectable and i.hasLineOfSight and not is_target and not player_info.isInBossBattle)
                        if condition2 then
                            -- poe2_api.dbgp("条件2匹配: 竞技场")
                            currency = i
                            break
                        end
                        
                        local condition3 = (string.find(i.path_name_utf8,game_str.TormentedSpiritofthe_PATH) and i.life>0 and not is_target and not player_info.isInBossBattle and not i.is_friendly and is_chasing_the_soul)
                        if condition3 then
                            -- poe2_api.dbgp("条件3匹配: 受折磨的灵魂 ("..(i.path_name_utf8 or "无路径")..")")
                            currency = i
                            break
                        end
                        
                        local condition4 = (i.name_utf8 and i.name_utf8 ~= "" and i.name_utf8 == game_str.Door_CH and i.isActive and i.is_selectable and ((poe2_api.point_distance(i.grid_x,i.grid_y,player_info)>30 and not is_target) or poe2_api.point_distance(i.grid_x,i.grid_y,player_info)<30) and not player_info.isInBossBattle)
                        if condition4 then
                            -- poe2_api.dbgp(string.format("条件4匹配: 门 (距离:%.1f)", poe2_api.point_distance(i.grid_x,i.grid_y,player_info)))
                            currency = i
                            break
                        end
                        
                        local condition5 = (i.name_utf8 and i.name_utf8 ~= "" and i.name_utf8 == game_str.The_Holy_Temple_TWCH and i.isActive and i.is_selectable and ((poe2_api.point_distance(i.grid_x,i.grid_y,player_info)>60 and not is_target) or poe2_api.point_distance(i.grid_x,i.grid_y,player_info)<60) and not player_info.isInBossBattle)
                        if condition5 then
                            -- poe2_api.dbgp(string.format("条件5匹配: 圣洁神殿 (距离:%.1f)", poe2_api.point_distance(i.grid_x,i.grid_y,player_info)))
                            currency = i
                            break
                        end
                        
                        local condition6 = (i.name_utf8 and i.name_utf8 ~= "" and i.name_utf8 == game_str.Handle_CH and i.isActive and i.is_selectable and next(i.stateMachineList) and (i.stateMachineList[game_str.lever_pull_SML] == 0 or i.stateMachineList[game_str.lever_pulled_SML] == 0) and ((poe2_api.point_distance(i.grid_x,i.grid_y,player_info)>30 and not is_target) or poe2_api.point_distance(i.grid_x,i.grid_y,player_info)<30) and not player_info.isInBossBattle)
                        if condition6 then
                            -- poe2_api.dbgp(string.format("条件6匹配: 把手 (距离:%.1f, 状态: pull=%s, pulled=%s)", 
                            --     poe2_api.point_distance(i.grid_x,i.grid_y,player_info),
                            --     tostring(i.stateMachineList[game_str.lever_pull_SML]),
                            --     tostring(i.stateMachineList[game_str.lever_pulled_SML])))
                            currency = i
                            break
                        end
                        
                        local condition7 = (i.name_utf8 and i.name_utf8 ~= "" and i.name_utf8 == game_str.Water_gate_control_rod_TWCH and i.isActive and i.is_selectable and next(i.stateMachineList) and (i.stateMachineList[game_str.lever_pull_SML] == 0 or i.stateMachineList[game_str.lever_pulled_SML] == 0) and not is_target and not player_info.isInBossBattle)
                        if condition7 then
                            -- poe2_api.dbgp("条件7匹配: 水闸门控制杆 (状态: pull="..tostring(i.stateMachineList[game_str.lever_pull_SML])..", pulled="..tostring(i.stateMachineList[game_str.lever_pulled_SML])..")")
                            currency = i
                            break
                        end
                        
                        local condition8 = (i.name_utf8 and i.name_utf8 ~= "" and i.name_utf8 == game_str.Switch_CH and i.isActive and i.is_selectable and not is_target)
                        if condition8 then
                            -- poe2_api.dbgp("条件8匹配: 开关")
                            currency = i
                            break
                        end
                        
                        local condition9 = (i.name_utf8 and i.name_utf8 ~= "" and poe2_api.table_contains(i.name_utf8,my_game_info.Treasure_Chest) and (i.name_utf8 ~= game_str.Safe_deposit_box_TWCH or not string.find(i.path_name_utf8,game_str.BasicStrongbox_PATH)) and ((poe2_api.table_contains(i.name_utf8,{game_str.The_restraining_hand_of_the_cracked_king_TWCH,game_str.The_hand_of_inhibition_TWCH}) and env.is_open_crack) or i.rarity >= env.obj_color ) and not i.chestIsOpen and not is_target and not player_info.isInBossBattle)
                        if condition9 then
                            -- poe2_api.dbgp("条件9匹配: 宝箱 (名称:"..i.name_utf8..", 稀有度:"..(i.rarity or "无")..", 颜色阈值:"..(env.obj_color or "无")..")")
                            currency = i
                            break
                        end
                        
                        local condition10 = (i.name_utf8 and i.name_utf8 ~= "" and i.name_utf8 == game_str.The_Seal_of_Runes_TWCH and i.isActive and i.is_selectable)
                        if condition10 then
                            -- poe2_api.dbgp("条件10匹配: 符文之印")
                            currency = i
                            break
                        end
                        
                        local condition11 = (not i.isActive and i.is_selectable and i.rarity ==3 and i.type==1 and i.life>0 and i.name_utf8 ~= game_str.The_Container_of_Mark_the_Skeleton_TWCH and (((player_info.current_map_name_utf8 == game_str.MapVaalFoundry_MDANA and -150 < player_info.world_z - i.world_z and player_info.world_z - i.world_z < 150) or (player_info.current_map_name_utf8 == game_str.MapWetlands_MDANA and not is_monster({range_info=env.range_info,index = 0})) and is_bass) or not poe2_api.table_contains(player_info.current_map_name_utf8,{game_str.MapVaalFoundry_MDANA,game_str.MapWetlands_MDANA,game_str.MapSandspit_MDANA})) and not is_target and not poe2_api.find_text({UI_info = env.UI_info, text=game_str.The_Seal_of_Runes_TWCH,min_x=0}) and not poe2_api.table_contains(i.name_utf8,{game_str.Barbara_Soul_TWCH,game_str.The_Soul_of_Palasa_TWCH}) and ((not player_info.isInBossBattle and not is_elite_monster(current_map_info)) or player_info.isInBossBattle))
                        if condition11 then 
                            -- poe2_api.dbgp("条件11匹配: 非活跃稀有怪物 (地图:"..(player_info.current_map_name_utf8 or "无")..", Z轴差:"..(player_info.world_z - (i.world_z or 0))..")")
                            currency = i
                            break
                        end
                        
                        local condition12 = (i.isActive and i.is_selectable and i.rarity ==3 and i.type==1 and i.life>0 and ((player_info.current_map_name_utf8 == game_str.MapVaalFoundry_MDANA and is_bass) or player_info.current_map_name_utf8 ~= game_str.MapVaalFoundry_MDANA) and not is_target1 and not poe2_api.find_text({UI_info = env.UI_info,text=game_str.The_Seal_of_Runes_TWCH,min_x=0}) and not poe2_api.table_contains(i.name_utf8 ,{game_str.Barbara_Soul_TWCH,game_str.The_Soul_of_Palasa_TWCH}))
                        if condition12 then
                            -- poe2_api.dbgp("条件12匹配: 活跃稀有怪物 (地图:"..(player_info.current_map_name_utf8 or "无")..")")
                            currency = i
                            break
                        end
                        
                        local condition13 = (i.name_utf8 and i.name_utf8 == game_str.The_staircase_TWCH and not is_click() and not is_target and not player_info.isInBossBattle)
                        if condition13 then
                            -- poe2_api.dbgp("条件13匹配: 楼梯")
                            currency = i
                            break
                        end
                        
                        local condition14 = (i.path_name_utf8 == game_str.Monolith_PATH and is_essence and not is_target and (not player_info.isInBossBattle or (player_info.isInBossBattle and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH})) )  and env.is_click_essence)
                        if condition14 then
                            -- poe2_api.dbgp("条件14匹配: 精髓")
                            currency = i
                            break
                        end
                        
                        local condition15 = (env.is_deception_delusion and i.path_name_utf8 == game_str.DeliriumInitiator_PATH and next(i.stateMachineList) and i.stateMachineList[game_str.interacted_SML] == 0 and not is_target and not player_info.isInBossBattle)
                        if condition15 then
                            -- poe2_api.dbgp("条件15匹配: 谵妄之镜 (交互状态:"..tostring(i.stateMachineList[game_str.interacted_SML])..")")
                            currency = i
                            break
                        end
                        
                        
                        local condition16 = (env.is_deception_delusion and string.find(i.path_name_utf8,game_str.DoodadDaemonShardPack_PATH) and next(i.stateMachineList) and i.stateMachineList[game_str.detonate_SML] == 0  and not player_info.isInBossBattle)
                        if condition16 then
                            -- poe2_api.dbgp("判断： ",not is_target)
                            -- api_Sleep(1000)
                            -- poe2_api.dbgp("条件16匹配: 谵妄破碎之镜")
                            currency = i
                            break
                        end
                        
                        local condition17 = (i.path_name_utf8 == game_str.BreachObject_PATH and not is_target and not player_info.isInBossBattle and env.is_open_crack)
                        if condition17 then
                            -- poe2_api.dbgp("条件17匹配: 裂痕之手")
                            currency = i
                            break
                        end
                        
                        local condition18 = (i.path_name_utf8 == game_str.Ritual_PATH and next(i.stateMachineList) and i.stateMachineList.current_state == 1 and i.stateMachineList.interaction_enabled == 1 and not is_target and not player_info.isInBossBattle and env.not_more_ritual and is_perform_a_ritual_sacrifice)
                        if condition18 then
                            -- poe2_api.dbgp("条件18匹配: 祭坛 (状态:"..tostring(i.stateMachineList.current_state)..", 交互启用:"..tostring(i.stateMachineList.interaction_enabled)..")")
                            currency = i
                            break
                        end
                        
                        local condition19 = (string.find(i.path_name_utf8,game_str.StrongBoxes_PATH) and (i.name_utf8 ~= game_str.The_Researcher_Safe_Box_TWCH or (i.name_utf8 == game_str.The_Researcher_Safe_Box_TWCH and i.rarity ~=3)) and next(i.stateMachineList) and i.stateMachineList[game_str.started_SML] == 0 and i.stateMachineList[game_str.opened_SML] == 0 and not is_target and not player_info.isInBossBattle and env.is_open_gameplay_safe)
                        if condition19 then
                            -- poe2_api.dbgp("条件19匹配: 玩法保险箱 (名称:"..(i.name_utf8 or "无")..", 状态: started="..tostring(i.stateMachineList[game_str.started_SML])..", opened="..tostring(i.stateMachineList[game_str.opened_SML])..")")
                            currency = i
                            break
                        end
                        
                        local condition20 = (string.find(i.path_name_utf8,game_str.StrongBoxes_PATH) and i.name_utf8 == game_str.The_Researcher_Safe_Box_TWCH and i.rarity == 3 and next(i.stateMachineList) and ((i.stateMachineList[game_str.started_SML] == 0 and i.stateMachineList[game_str.opened_SML] == 0) or (i.stateMachineList[game_str.started_SML] == 1 and i.stateMachineList[game_str.opened_SML] == 0)) and not is_target and not player_info.isInBossBattle)
                        if condition20 then
                            -- poe2_api.dbgp("条件20匹配: 研究者保险箱 (稀有度:"..(i.rarity or "无")..", 状态: started="..tostring(i.stateMachineList[game_str.started_SML])..", opened="..tostring(i.stateMachineList[game_str.opened_SML])..")")
                            currency = i
                            break
                        end

                        local condition21 = (not i.is_friendly and i.isActive and i.is_selectable and i.rarity ==2 and i.type==1 and i.life>0 and string.find(env.player_info.current_map_name_utf8,game_str.Abyss))
                        if condition21 then
                            -- poe2_api.dbgp("条件21匹配: 活跃稀有怪物 (地图:"..(player_info.current_map_name_utf8 or "无")..")")
                            currency = i
                            break
                        end

                        local condition22 = string.find(i.path_name_utf8,game_str.Abyss_PATH) and i.is_selectable and (not next(i.stateMachineList) or (next(i.stateMachineList) and i.stateMachineList[game_str.unlocked_SML] == 1)) and not is_target and (not player_info.isInBossBattle or (player_info.isInBossBattle and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH})) )  
                        if condition22 then
                            -- poe2_api.dbgp("条件22匹配: 深淵寶箱")
                            currency = i
                            break
                        end
                        local condition23 = i.name_utf8 == game_str.Rune_Stele_TWCH and i.is_selectable and not is_target and not player_info.isInBossBattle 
                        if condition23 then
                            -- poe2_api.dbgp("条件23匹配: 符文豐碑")
                            currency = i
                            break
                        end

                        local function is_abyss_point(obj)
                            for _,v in ipairs(env.abyss_point_list) do
                                if v[1] == obj.grid_x and v[2] == obj.grid_y then
                                    return true
                                end
                            end
                            return false
                        end
                        local condition24 = i.path_name_utf8 == game_str.AbyssCrack_PATH and i.MinimapIconActive == game_str.AbyssCrackActive_EN and not is_target and not player_info.isInBossBattle and not is_abyss_point(i)
                        if condition24 then
                            -- poe2_api.dbgp("条件24匹配: 深淵裂缝绿点")
                            currency = i
                            break
                        end

                        -- local condition24 = next(i.stateMachineList) and i.stateMachineList[game_str.doomepk_SML] == 0 and i.life > 0 and i.type == 1 and not is_target and not player_info.isInBossBattle 
                        -- if condition24 then
                        --     -- poe2_api.dbgp("条件24匹配: 深淵裂缝怪物")
                        --     currency = i
                        --     break
                        -- end

                        local condition25 = i.path_name_utf8 == game_str.AbyssSubAreaTransition_PATH and not is_target and not player_info.isInBossBattle and not env.is_abyss_complete and is_into_the_abyss
                        if condition25 then
                            if env.team_info then
                                env.enter_abyss_click = (env.enter_abyss_click or 0) + 1
                                if env.enter_abyss_click > 10 and poe2_api.find_text({UI_info = env.UI_info,text=game_str.You_cannot_re_enter_this_area_after_death_TWCH,min_x=0}) then
                                    env.is_abyss_complete = true
                                    env.enter_abyss_click = 0
                                end
                            end
                            -- poe2_api.dbgp("条件25匹配: 深淵地圖")
                            currency = i
                            break
                        end

                        local condition26 = i.name_utf8 == game_str.Magical_Stone_Formation_TWCH and i.is_selectable and not is_target 
                        if condition26 then
                            -- poe2_api.dbgp("条件26匹配: 魔幻石陣")
                            currency = i
                            break
                        end

                        -- local function is_abyss_point(obj)
                        --     for _,v in ipairs(env.abyss_point_list) do
                        --         if v[1] == obj.grid_x and v[2] == obj.grid_y then
                        --             return true
                        --         end
                        --     end
                        --     return false
                        -- end
                        
                        -- -- local condition27 = i.path_name_utf8 == game_str.AbyssCrack_PATH and i.MinimapIconActive == game_str.AbyssCrackActive_EN and not is_target and not player_info.isInBossBattle 
                        -- local condition27 = i.path_name_utf8 == game_str.AbyssCrack_PATH and not is_target and not player_info.isInBossBattle and (not next(env.abyss_point_list) or not is_abyss_point(i))
                        -- if condition27 then
                        --     -- poe2_api.dbgp("条件27匹配: 深淵裂缝小点")
                        --     currency = i
                        --     break
                        -- end

                        local condition28 = i.name_utf8 == game_str.The_Stone_Coffin_TWCH and i.is_selectable and not is_target and not player_info.isInBossBattle 
                        if condition28 then
                            -- poe2_api.dbgp("条件23匹配: 符文豐碑")
                            currency = i
                            break
                        end
                        local condition29 = i.name_utf8 == game_str.The_Broken_Mirror_TWCH and next(i.stateMachineList) and i.stateMachineList[game_str.clicked_SML] == 0 and not is_target and not player_info.isInBossBattle
                        if condition29 then
                            -- poe2_api.dbgp("条件29匹配: 破碎之鏡")
                            currency = i
                            break
                        end
                        local condition30 = i.name_utf8 == game_str.The_Broken_Mirror_TWCH and next(i.stateMachineList) and i.stateMachineList[game_str.clicked_SML] == 1 and not is_target and not player_info.isInBossBattle and not poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH})
                        if condition30 then
                            -- poe2_api.dbgp("条件30匹配: 破碎之鏡")
                            currency = i
                            break
                        end
                        local condition31 = i.name_utf8 == game_str.The_Altar_of_Signs_TWCH and i.is_selectable and not is_target and not player_info.isInBossBattle 
                        if condition31 then
                            -- poe2_api.dbgp("条件31匹配: 徵兆祭壇")
                            currency = i
                            break
                        end
                        local condition32 = i.name_utf8 == game_str.Evening_Bell_TWCH and i.is_selectable and not is_target and not player_info.isInBossBattle 
                        if condition32 then
                            -- poe2_api.dbgp("条件32匹配: 晚鐘")
                            currency = i
                            break
                        end
                        local condition33 = i.name_utf8 == game_str.Rune_Giant_Stone_TWCH and i.is_selectable and not is_target and not player_info.isInBossBattle 
                        if condition33 then
                            -- poe2_api.dbgp("条件23匹配: 符文巨石")
                            currency = i
                            break
                        end
                        local condition34 = i.name_utf8 == game_str.Strengthening_Runes_TWCH and i.is_selectable and not is_target
                        if condition34 then
                            -- poe2_api.dbgp("条件34匹配: 強化符文")
                            currency = i
                            break
                        end
                        local condition35 = i.name_utf8 == game_str.The_Chain_of_Time_and_Space_TWCH and i.is_selectable and not is_target 
                        if condition35 then
                            -- poe2_api.dbgp("条件35匹配: 時空之鏈")
                            currency = i
                            break
                        end
                        local condition36 = next(i.stateMachineList) and i.stateMachineList[game_str.doomepk_SML] == 0 and i.life > 0 and i.type == 1 and not is_target and not player_info.isInBossBattle 
                        if condition36 then
                            -- poe2_api.dbgp("条件36匹配: 深淵裂缝怪物")
                            currency = i
                            break
                        end
                        -- MinimapIconActive = game_str.AfflictionInitiator_EN
                        local function is_point(grid_x,grid_y)
                            -- local point = api_FindNearestReachableInRange(math.floor(grid_x),math.floor(grid_y),15,0)
                            local ralet = api_FindPath(player_info.grid_x,player_info.grid_y,math.floor(grid_x),math.floor(grid_y))
                            return ralet
                        end

                        local condition37 =i.MinimapIconActive == game_str.AfflictionInitiator_EN and string.find(player_info.current_map_name_utf8 , game_str.Delirium_) and next(i.stateMachineList) and i.stateMachineList[game_str.active_SML] == 0 and i.stateMachineList[game_str.goodbye_SML] ~= 1 and next(is_point(i.grid_x,i.grid_y))
                        if condition37 then
                            -- poe2_api.dbgp("条件37匹配: 迷雾镜子")
                            api_UpdateMapObstacles(240)
                            currency = i
                            break
                        end

                        local condition38 = i.name_utf8 == game_str.Invitation_to_showcase_Skeleton_Mark_TWCH and i.is_selectable and next(i.stateMachineList) and i.stateMachineList[game_str.active_SML] == 0 and i.stateMachineList[game_str.open_SML] == 0
                        if condition38 then
                            -- poe2_api.dbgp("条件35匹配: 展示骷髏馬克的邀請")
                            currency = i
                            break
                        end
                        if next(gameplay_config) and is_gameplay_open and gameplay_type == game_str.Skull_Mark_TWCH and next(gameplay_skeleton) and #gameplay_skeleton == 3 then
                            local condition39 = poe2_api.table_contains(i.name_utf8, gameplay_skeleton) and i.is_selectable
                            if condition39 then
                                -- poe2_api.dbgp("条件35匹配: 骷髏馬克的buff列表")
                                currency = i
                                break
                            end
                        end
                        local function get_skeleton_buff()
                            for _, v in ipairs(range_sorted) do
                                if v.name_utf8 == game_str.The_Container_of_Mark_the_Skeleton_TWCH then
                                    if next(v.stateMachineList) and v.stateMachineList[game_str.dead_SML] == 1 and v.stateMachineList[game_str.times_revived_SML] == 3 then
                                        return true
                                    end
                                end
                            end
                            return false
                        end
                        local condition40 = i.name_utf8 == game_str.Obtain_the_ring_TWCH and i.is_selectable and next(i.stateMachineList) and i.stateMachineList[game_str.active_SML] == 1 and get_skeleton_buff()
                        if condition40 then
                            -- poe2_api.dbgp("条件35匹配: 取得戒指")
                            currency = i
                            break
                        end
                        -- local function get_Abyss_AbyssCrack()
                        --     for i, v in ipairs(env.range_info) do
                        --         if v.path_name_utf8 == game_str.AbyssCrack_PATH and not v.MinimapIconActive then
                        --             return true
                        --         end
                        --     end
                        --     return false
                        -- end
                        -- local condition25 = i.path_name_utf8 == "Metadata/MiscellaneousObjects/Abyss/AbyssFinalNodeBase" and not i.MinimapIconActive and not is_target and not player_info.isInBossBattle and not get_Abyss_AbyssCrack()
                        -- if condition25 then
                        --     -- poe2_api.dbgp("条件24匹配: 深淵裂缝坑")
                        --     currency = i
                        --     break
                        -- end
                        -- local condition22 = (i.path_name_utf8 == game_str.Ritual_PATH and next(i.stateMachineList) and i.stateMachineList.current_state == 0 and i.stateMachineList.interaction_enabled == 0 and not is_target and not player_info.isInBossBattle and env.not_more_ritual)
                        -- if condition22 then
                        --     -- poe2_api.dbgp("条件18匹配: 未激活祭坛 (状态:"..tostring(i.stateMachineList.current_state)..", 交互启用:"..tostring(i.stateMachineList.interaction_enabled)..")")
                        --     currency = i
                        --     break
                        -- end
                        
                        -- 检查是否有任何条件匹配
                        -- if condition1 or condition2 or condition3 or condition4 or condition5 or condition6 or condition7 or condition8 or condition9 or condition10 or
                        --    condition11 or condition12 or condition13 or condition14 or condition15 or condition16 or condition17 or condition18 or condition19 or condition20 then
                        --     currency = i
                        --     -- poe2_api.dbgp("对象匹配成功: "..(i.name_utf8 or "无名").." (ID:"..(i.id or "无ID").."), 类型:"..
                        --     --     (condition1 and "1" or "")..(condition2 and "2" or "")..(condition3 and "3" or "")..
                        --     --     (condition4 and "4" or "")..(condition5 and "5" or "")..(condition6 and "6" or "")..
                        --     --     (condition7 and "7" or "")..(condition8 and "8" or "")..(condition9 and "9" or "")..
                        --     --     (condition10 and "10" or "")..(condition11 and "11" or "")..(condition12 and "12" or "")..
                        --     --     (condition13 and "13" or "")..(condition14 and "14" or "")..(condition15 and "15" or "")..
                        --     --     (condition16 and "16" or "")..(condition17 and "17" or "")..(condition18 and "18" or "")..
                        --     --     (condition19 and "19" or "")..(condition20 and "20" or ""))
                        --     break
                        -- end
                    else
                        -- poe2_api.dbgp("对象未通过基础检查")
                    end
                    ::continue::
                end
                -- api_Sleep(1000000)
                if currency then
                    poe2_api.dbgp("最终选择对象: "..(currency.name_utf8 or "无名").." (ID:"..(currency.id or "无ID")..")")
                    env.interaction_object = currency
                    env.interactive = currency
                    return true
                else
                    poe2_api.dbgp("没有找到符合条件的对象")
                    return false
                end
            end
            local function get_range1(range_info)
                local range_sorted = poe2_api.get_sorted_list(env.range_info, env.player_info)
                local function get_boss_turret()
                    local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 443,min_y = 770,max_x = 639,max_y = 872})
                    for i, v in ipairs(lock) do
                        if v.name_utf8 == "quest_state_changed_button" then
                            return true
                        end
                    end
                    return false
                end
                local function get_boss_life()
                    for i, v in ipairs(range_sorted) do
                        if v.rarity == 3 and v.name_utf8 == "被束縛的恐懼" and v.life > 0 and v.isActive then
                            return v
                        end
                    end
                    return false
                end
                local boss = get_boss_life()
                if boss then
                    if self.boss_life == 0 then
                        self.boss_life = boss.life 
                    end
                    if self.boss_life_time == 0 then
                        self.boss_life_time = api_GetTickCount64()
                    end
                    if self.boss_life ~= boss.life then
                        self.boss_life = boss.life
                        self.boss_life_time = api_GetTickCount64()
                    end
                else
                    self.boss_life = 0
                    self.boss_life_time = 0
                end
                for i, v in ipairs(range_sorted) do
                    local condition = v.name_utf8 == "砲塔" and player_info.isInBossBattle and (get_boss_turret() or (self.boss_life_time ~= 0 and api_GetTickCount64()-self.boss_life_time >= 10000))
                    if condition then
                        -- poe2_api.dbgp("条件26匹配: Boss砲塔")
                        env.interaction_object = v
                        env.interactive = v
                        return true
                    end
                end
                return false
            end
            local interaction_object = env.interaction_object
            if not interaction_object then
                local interactive = get_range(env.range_info)
                local interactive1 = get_range1(env.range_info)
                if not interactive then
                    if not interactive1 then
                        env.interactive_id = nil
                        env.interactiontimeout = 0
                        poe2_api.dbgp("无需要交互的对象")
                        poe2_api.time_p("无需要交互的对象(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                        return bret.SUCCESS
                    end
                end
            end
            
            if player_info.current_map_name_utf8 == game_str.MapUniqueSelenite_MDANA and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH}) then
                env.interactive_id = nil
                env.interactiontimeout = 0
                env.interaction_object = nil
                poe2_api.dbgp("沉默洞穴完成跳出")
                poe2_api.time_p("无需要交互的对象(SUCCESS1111)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
            if poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.Citadel_map) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH}) then
                env.interactive_id = nil
                env.interactiontimeout = 0
                env.interaction_object = nil
                poe2_api.dbgp("钢铁城寨完成跳出")
                poe2_api.time_p("无需要交互的对象(SUCCESS2222)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
            local interaction_object = env.interaction_object
            if string.find(player_info.current_map_name_utf8,game_str.Abyss_EN) and interaction_object.path_name_utf8 == game_str.AbyssSubAreaTransition_PATH then
                env.interactiontimeout = 0
                env.interaction_object = nil
                env.interactive_id = nil
                poe2_api.time_p("人物在深渊地图清楚交互对象(RUNNING)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.RUNNING
            end
            if interaction_object then
                
                if string.find(player_info.current_map_name_utf8,game_str.MapSinkhole_MDANA) and poe2_api.table_contains(interaction_object.name_utf8,my_game_info.Treasure_Chest) then
                    env.interactive_id = nil
                    env.interactiontimeout = 0
                    env.interaction_object = nil
                    poe2_api.dbgp("沉洞不交互保險箱")
                    poe2_api.time_p("无需要交互的对象(SUCCESS2222)... 耗时 --> ", api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                end
                if poe2_api.table_contains(interaction_object.name_utf8,my_game_info.Treasure_Chest) then
                    local obj = nil
                    for _, v in ipairs(env.range_info) do
                        if poe2_api.table_contains(v.path_name_utf8,{game_str.Monolith_PATH,game_str.Ritual_PATH}) then -- and v.stateMachineList[game_str.current_state_SML] == 2 and v.stateMachineList[game_str.interaction_enabled_SML] == 0
                            local distance = poe2_api.point_distance(v.grid_x,v.grid_y,interaction_object)
                            if distance and distance <= 35 then
                                obj = v
                                break
                            end
                        end
                    end
                    if obj then
                        poe2_api.dbgp("交互对象为宝箱之类，并且在祭坛附近，不交互")
                        table.insert(env.interactive_permanent_id_list,interaction_object.id)
                        env.interaction_object = nil
                        poe2_api.time_p("判断是否需要交互（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                end
                local is_altar = env.afoot_altar
                if interaction_object.path_name_utf8 ~= game_str.Ritual_PATH  then -- and is_altar
                    local target = nil
                    for _, v in ipairs(env.range_info) do
                        if v.path_name_utf8 == game_str.Ritual_PATH then
                            if v.stateMachineList and next(v.stateMachineList) then
                                if (v.stateMachineList[game_str.current_state_SML] == 2 and v.stateMachineList[game_str.interaction_enabled_SML] == 0) then
                                    target = v
                                    
                                    break
                                end
                            end
                        end
                    end
                    if target then
                        local distance = poe2_api.point_distance(target.grid_x,target.grid_y,player_info)
                        if distance and distance < 105 then
                            local dis = poe2_api.point_distance(interaction_object.grid_x,interaction_object.grid_y,target)
                            if dis and dis > 97 or not poe2_api.table_contains(interaction_object.name_utf8,{game_str.Door_CH,game_str.Switch_CH,game_str.Handle_CH,game_str.The_Holy_Temple_TWCH,game_str.The_Stone_Coffin_TWCH}) then
                                poe2_api.dbgp("人物在祭坛内，物品在祭坛外不交互")
                                env.interactiontimeout = 0
                                env.interaction_object = nil
                                env.interactive_id = nil
                                poe2_api.time_p("人物在祭坛内(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                                return bret.SUCCESS
                            end
                        else
                            if not poe2_api.table_contains(interaction_object.name_utf8,{game_str.Door_CH,game_str.Switch_CH,game_str.Handle_CH,game_str.The_Holy_Temple_TWCH,game_str.The_turret_TWCH,game_str.The_Stone_Coffin_TWCH}) then
                                env.interactiontimeout = 0
                                env.interaction_object = nil
                                env.interactive_id = nil
                                poe2_api.dbgp("人物在祭坛外，交互对象不是門，開關，把手，聖潔神殿，不交互")
                                poe2_api.time_p("人物在祭坛外，交互对象不是門，開關，把手，聖潔神殿，不交互(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                                return bret.SUCCESS
                            end
                        end
                    end
                    -- local distance = poe2_api.point_distance(is_altar.grid_x,is_altar.grid_y,player_info)
                    
                end
                if env.afoot_box and env.afoot_box.stateMachineList[game_str.started_SML] == 1 and env.afoot_box.stateMachineList[game_str.opened_SML] == 0 then
                    poe2_api.dbgp("有激活玩法保险箱，不交互跳出")
                    env.interactiontimeout = 0
                    env.interaction_object = nil
                    env.interactive_id = nil
                    return bret.SUCCESS
                end
                if not env.interactive_id then
                    env.interactive_id = interaction_object.id
                    env.interactiontimeout = api_GetTickCount64()
                end
                if env.interactive_id ~= interaction_object.id then
                    env.interactive_id = interaction_object.id
                    env.interactiontimeout = api_GetTickCount64()
                end
                if interaction_object.is_selectable and interaction_object.rarity ==3 and interaction_object.type==1 and interaction_object.life>0 then
                    if is_target1 then
                        env.interactiontimeout = 0
                        env.interaction_object = nil
                        env.interactive_id = nil
                        env.interactive_timeout = nil
                        poe2_api.dbgp("交互对象为boss,但自身附近有怪，不交互")
                        poe2_api.time_p("交互对象为boss,但自身附近有怪，不交互(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                        return bret.SUCCESS
                    end
                else
                    if not poe2_api.table_contains(interaction_object.name_utf8,{game_str.Door_CH,game_str.The_Holy_Temple_TWCH}) or (interaction_object.name_utf8 == game_str.Door_CH and poe2_api.point_distance(interaction_object.grid_x,interaction_object.grid_y,player_info)>30) or (interaction_object.name_utf8 == game_str.The_Holy_Temple_TWCH and poe2_api.point_distance(interaction_object.grid_x,interaction_object.grid_y,player_info)>60) then
                        if is_target and interaction_object.name_utf8 ~= game_str.The_turret_TWCH then
                            env.interactiontimeout = 0
                            env.interaction_object = nil
                            env.interactive_id = nil
                            env.interactive_timeout = nil
                            poe2_api.dbgp("交互对象为门或聖潔神殿，但自身附近有怪，不交互")
                            poe2_api.time_p("交互对象为boss,但自身附近有怪，不交互(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                            return bret.SUCCESS
                        end
                    end
                end
                if self.wait then
                    if api_GetTickCount64() - self.current_time < self.wait_time then
                        poe2_api.dbgp("等待中")
                        poe2_api.time_p("判断是否需要交互（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    self.wait = false
                end
                local interaction_object = env.interaction_object
                if env.not_match_id then
                    if env.not_match_id == interaction_object.id then
                        env.interactive = nil
                        env.interaction_object = nil
                        env.interactiontimeout = 0
                        poe2_api.time_p("isNeeee(SUCCESS111)... 耗时 --> ", api_GetTickCount64() - current_time)
                        return bret.SUCCESS
                    end
                end
                if interaction_object.isActive and interaction_object.is_selectable and interaction_object.rarity ==3 and interaction_object.type==1 and interaction_object.life>0 then
                    local distance = poe2_api.point_distance(interaction_object.grid_x,interaction_object.grid_y,player_info)
                    if distance and distance <= 100 then
                        env.interaction_object = nil
                        env.interactiontimeout = 0
                        env.interactive_id = nil
                        env.interactive_timeout = nil
                        poe2_api.dbgp("在已激活boss附近，不交互")
                        poe2_api.time_p("在已激活boss附近，不交互(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                        return bret.SUCCESS
                    end
                elseif poe2_api.table_contains(interaction_object.name_utf8,{game_str.The_arena_TWCH,game_str.Water_gate_control_rod_TWCH,game_str.Handle_CH,game_str.The_Stone_Array_Altar_TWCH}) and poe2_api.find_text({UI_info = env.UI_info,text=game_str.Map_completed_TWCH}) then
                    env.interaction_object = nil
                    env.interactiontimeout = 0
                    env.interactive_id = nil
                    
                    poe2_api.dbgp("交互对象竞技场，水閘門控制桿，把手，石陣祭壇附近，地圖完成不交互")
                    poe2_api.time_p("交互对象竞技场(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                elseif interaction_object.name_utf8 == game_str.The_arena_TWCH and player_info.isInBossBattle then
                    env.interaction_object = nil
                    env.interactiontimeout = 0
                    env.interactive_id = nil
                    poe2_api.dbgp("交互对象竞技场,boss战，或者已在竞技场，不交互")
                    poe2_api.time_p("交互对象竞技场,boss战(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                elseif interaction_object.name_utf8 == game_str.The_staircase_TWCH then
                    if env.is_find_boss then
                        local click_lt = nil
                        for _, v in ipairs(env.range_info) do
                            if v.name_utf8 ~= "" and v.name_utf8 == game_str.Check_point and v.grid_x and v.grid_y and v.grid_x ~= 0 and v.grid_y ~= 0 then
                                click_lt = v
                                break
                            end
                        end
                        if interaction_object.id ~= self.not_id and not click_lt then
                            env.not_interactive = interaction_object
                            env.is_find_boss = false
                            poe2_api.time_p("判断是否需要交互（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end
                    if env.not_interactive then
                        if env.not_interactive.id == interaction_object.id then
                            env.interactive = nil
                            env.end_point = {}
                            env.interactiontimeout = 0
                            env.interaction_object = nil
                            env.interactive_id = nil
                            poe2_api.time_p("交互对象(樓梯)(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                            return bret.SUCCESS
                        end
                    end
                    -- Boss记录点
                    local boss_jdl = nil
                    for _, v in ipairs(env.range_info) do
                        if string.find(v.path_name_utf8,game_str.Boss_EN) and v.name_utf8 == game_str.Check_point then
                            local distance = poe2_api.point_distance(v.grid_x,v.grid_y,interaction_object)
                            if distance and distance <= 100 then
                                boss_jdl = v
                                break
                            end
                        end
                    end
                    if boss_jdl then
                        self.not_id = interaction_object.id
                        env.is_find_boss = true
                    end
                end
                if not poe2_api.table_contains(interaction_object.name_utf8,{game_str.Water_gate_control_rod_TWCH,game_str.Handle_CH}) then
                    env.wait_target = false
                end
                local distance = poe2_api.point_distance(interaction_object.grid_x,interaction_object.grid_y,player_info)
                if distance and distance < 25 then
                    local function get_item(itme_name)
                        for _, v in ipairs(env.bag_info) do
                            if v.baseType_utf8 == itme_name then
                                return true
                            end
                        end
                        return false
                    end
                    if env.is_click_essence and game_str.Monolith_PATH == interaction_object.path_name_utf8 and next(interaction_object.stateMachineList) and interaction_object.stateMachineList[game_str.is_corrupted_SML] and interaction_object.stateMachineList[game_str.is_corrupted_SML] == 0 and get_item(game_str.Vaal_Orb_TWCH) then
                        if player_info.isMoving then
                            poe2_api.dbgp("玩家正在移动，等待停止")
                            -- poe2_api.time_p("判断是否需要交互（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                        if not poe2_api.find_text({text = game_str.backpack,UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                            poe2_api.click_keyboard("i")
                            api_Sleep(100)
                            return bret.RUNNING
                        end
                    
                        poe2_api.ctrl_left_click_bag_items(game_str.Vaal_Orb_TWCH,env.bag_info,1)
                        api_Sleep(100)
                        poe2_api.find_text({text = game_str.Monsters_are_imprisoned_by_powerful_essence_TWCH, UI_info = env.UI_info, min_x=200,max_y=750,match=2,max_x=1200,sorted = true, click=2})
                        env.interactive_id = nil
                        env.interactiontimeout = 0
                        env.interaction_object = nil
                        return bret.RUNNING
                    end
                    if (string.find(interaction_object.path_name_utf8,game_str.StrongBoxes_PATH) and interaction_object.rarity < 2) and next(interaction_object.stateMachineList) and interaction_object.stateMachineList[game_str.started_SML] == 0 and interaction_object.stateMachineList[game_str.opened_SML] == 0 and env.is_open_gameplay_safe then
                        if poe2_api.find_text({UI_info = env.UI_info,text = game_str.Not_Identified_TWCH,min_x=100,max_x=1300,max_y=850,sorted=true}) then
                            if get_item(game_str.The_Knowledge_Scroll)  then
                                if player_info.isMoving then
                                    poe2_api.dbgp("玩家正在移动，等待停止")
                                    -- poe2_api.time_p("判断是否需要交互（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                                    return bret.RUNNING
                                end
                                if not poe2_api.find_text({text = game_str.backpack,UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                                    poe2_api.click_keyboard("i")
                                    api_Sleep(100)
                                    return bret.RUNNING
                                end
                            
                                poe2_api.ctrl_left_click_bag_items(game_str.The_Knowledge_Scroll,env.bag_info,1)
                                api_Sleep(100)
                                poe2_api.find_text({text = interaction_object.name_utf8, UI_info = env.UI_info, min_x=200,max_y=750,max_x=1200,match=2,sorted = true, click=2})
                                env.interactive_id = nil
                                env.interactiontimeout = 0
                                env.interaction_object = nil
                                return bret.RUNNING
                            end
                        else
                            if not poe2_api.find_text({UI_info = env.UI_info,text = game_str.Contaminated_TWCH,min_x=100,max_x=1300,max_y=850,sorted=true}) then
                                if get_item(game_str.Orb_of_Alchemy_TWCH) then
                                    if player_info.isMoving then
                                        poe2_api.dbgp("玩家正在移动，等待停止")
                                        -- poe2_api.time_p("判断是否需要交互（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                                        return bret.RUNNING
                                    end
                                    if not poe2_api.find_text({text = game_str.backpack,UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                                        poe2_api.click_keyboard("i")
                                        api_Sleep(100)
                                        return bret.RUNNING
                                    end
                                
                                    poe2_api.ctrl_left_click_bag_items(game_str.Orb_of_Alchemy_TWCH,env.bag_info,1)
                                    api_Sleep(100)
                                    poe2_api.find_text({text = interaction_object.name_utf8, UI_info = env.UI_info, min_x=200,max_y=750,max_x=1200,match=2,sorted = true, click=2})
                                    env.interactive_id = nil
                                    env.interactiontimeout = 0
                                    env.interaction_object = nil
                                    return bret.RUNNING
                                end
                            end
                        end
                    end
                    local function get_essence_unpolluted()
                        for _, v in ipairs(env.range_info) do
                            if game_str.Monolith_PATH == v.path_name_utf8 and next(v.stateMachineList) and v.stateMachineList[game_str.is_corrupted_SML] and v.stateMachineList[game_str.is_corrupted_SML] == 0 then
                                local dis = poe2_api.point_distance(v.grid_x,v.grid_y,interaction_object)
                                if dis and dis <= 25 then
                                    return v
                                end
                            end
                        end
                        return false
                    end
                    local essence_unpolluted = get_essence_unpolluted()
                    if env.is_click_essence and essence_unpolluted and get_item(game_str.Vaal_Orb_TWCH) then
                        if player_info.isMoving then
                            poe2_api.dbgp("玩家正在移动，等待停止")
                            -- poe2_api.time_p("判断是否需要交互（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                        if not poe2_api.find_text({text = game_str.backpack,UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                            poe2_api.click_keyboard("i")
                            api_Sleep(100)
                            return bret.RUNNING
                        end
                    
                        poe2_api.ctrl_left_click_bag_items(game_str.Vaal_Orb_TWCH,env.bag_info,1)
                        api_Sleep(100)
                        poe2_api.find_text({text = game_str.Monsters_are_imprisoned_by_powerful_essence_TWCH, UI_info = env.UI_info, min_x=200,max_y=750,match=2,max_x=1200,sorted = true, click=2})
                        env.interactive_id = nil
                        env.interactiontimeout = 0
                        env.interaction_object = nil
                        return bret.RUNNING
                    end
                    if interaction_object.path_name_utf8 == game_str.RitualRuneLight_PATH or interaction_object.rarity == 3 then
                        local index = math.random(100,200)
                        api_Sleep(index)
                    end
                    if self.number >= 30 then
                        poe2_api.dbgp1("超出次数，随机移动======================================================================")
                        local point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 40)
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), 0)
                            poe2_api.click_keyboard("space")
                            self.number = 0
                            poe2_api.time_p("判断是否需要交互（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end
                    
                    if not player_info.isMoving then
                        poe2_api.dbgp1(self.number)
                        if not self.id1 then
                            self.id1 = interaction_object.id
                            env.interactive_timeout = api_GetTickCount64()
                        else
                            if self.id1 == interaction_object.id then
                                self.number = self.number + 1
                                if not env.interactive_timeout then
                                    env.interactive_timeout = api_GetTickCount64()
                                end
                            else
                                self.number = 0
                                self.id1 = interaction_object.id
                                env.interactive_timeout = api_GetTickCount64()
                            end
                        end
                    end
                    -- if env.interactive_timeout and api_GetTickCount64() - env.interactive_timeout > 60000 then
                    --     if (interaction_object.type == 1 and poe2_api.table_contains(interaction_object.rarity,{2,3})) then
                    --         for _, i in ipairs(env.range_info) do
                    --             if i.name_utf8 ~= "" and i.type == 5 and poe2_api.table_contains(i.name_utf8,my_game_info.hideout_CH) then
                    --                 local dis = poe2_api.point_distance(i.grid_x, i.grid_y, player_info)
                    --                 if dis and dis < 25 then
                    --                     poe2_api.find_text({text = i.name_utf8,UI_info = env.UI_info,min_x=0,min_y=200,click=2})
                    --                     api_Sleep(200)
                    --                     env.is_map_complete = true
                    --                     poe2_api.time_p("判断是否需要交互（RUNNING8）... 耗时 --> ", api_GetTickCount64() - start_time)
                    --                     -- env.need_item = nil
                    --                     return bret.RUNNING
                    --                 end
                    --             end
                    --         end  
                    --         api_ClickMove(poe2_api.toInt(player_info.grid_x),poe2_api.toInt(player_info.grid_y),7)
                    --         api_Sleep(300) 
                    --         -- 先设置随机种子（只需执行一次）
                    --         math.randomseed(os.time())
                    --         -- 生成 [0, 25) 范围内的随机浮点数
                    --         local x = 0 + (25 - 0) * math.random()
                    --         -- 生成 [0, 25) 范围内的随机浮点数
                    --         local y = 0 + (25 - 0) * math.random()
                    --         api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),1)
                    --         self.wait = true
                    --         self.current_time = api_GetTickCount64()
                    --         self.wait_time = 1000
                    --         poe2_api.dbgp("等待回城")
                    --         poe2_api.time_p("判断是否需要交互（RUNNING9）... 耗时 --> ", api_GetTickCount64() - start_time)
                    --         return bret.RUNNING
                    --     end
                    --     -- env.is_map_complete = true
                    --     -- env.need_ReturnToTown = true
                    --     -- table.insert(env.not_interactive_object_list,interaction_object)
                    --     -- env.interactiontimeout = 0
                    --     -- env.interaction_object = nil
                    --     -- env.interactive_id = nil
                    --     -- env.not_interactive_id_list 
                    --     -- env.interactive_timeout = nil
                        
                    -- end
                elseif distance < 45 then
                    if interaction_object.path_name_utf8 == game_str.RitualRuneLight_PATH or (interaction_object.rarity == 3 and interaction_object.type==1 and not interaction_object.isActive) then
                        local index = math.random(100,200)
                        api_Sleep(index)
                    end
                elseif interaction_object.type == 1 and interaction_object.rarity == 3 and interaction_object.isActive and distance < 100 then
                    env.interactiontimeout = 0
                    env.interaction_object = nil
                    env.interactive_id = nil
                    env.interactive_timeout = nil
                    poe2_api.dbgp("已在已激活boss附近，不交互")
                    poe2_api.time_p("交互对象(已激活boss)(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                    return bret.SUCCESS

                -- elseif interaction_object.path_name_utf8 == game_str.Ritual_PATH and interaction_object.stateMachineList[game_str.current_state_SML] == 0 and interaction_object.stateMachineList[game_str.interaction_enabled_SML] == 0 and distance < 110 then
                --     env.interactiontimeout = 0
                --     env.interaction_object = nil
                --     env.interactive_id = nil
                --     poe2_api.dbgp("已在未激活祭坛附近，不交互")
                --     poe2_api.time_p("交互对象(未激活祭坛)(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
                --     return bret.SUCCESS
                end
                if string.find(interaction_object.path_name_utf8,game_str.StrongBoxes_PATH) and interaction_object.name_utf8 == game_str.The_Researcher_Safe_Box_TWCH and interaction_object.rarity == 3 then
                    -- local stateMachineList = interaction_object:GetStateMachineList()
                    if interaction_object.stateMachineList and next(interaction_object.stateMachineList) then
                        if interaction_object.stateMachineList[game_str.started_SML] == 0 and interaction_object.stateMachineList[game_str.opened_SML] == 0 then 
                            if next(interaction_object.magicProperties) then
                                local gold = 0
                                local pattern = "消耗%s*(%d+)%s*金幣開啟"  -- Lua 匹配模式
                                poe2_api.dbgp("人物金币："..player_info.gold)
                                for _, v in ipairs(interaction_object.magicProperties) do
                                    if v:match(pattern) then
                                        gold = v:match(pattern)
                                        -- poe2_api.dbgp(gold)
                                        -- api_Sleep(100000000)
                                    end
                                end
                                if gold ~= 0 then
                                    local mini = poe2_api.toInt(gold)
                                    if player_info.gold == 0 or mini / player_info.gold > 0.2 then
                                        env.not_match_id = interaction_object.id
                                        env.interaction_object = nil
                                        env.interactiontimeout = 0
                                        env.interactive_id = nil
                                        poe2_api.time_p("判断是否需要交互（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                                        return bret.SUCCESS
                                    end
                                end
                            end
                            
                        end

                    end
                end
                local crrut_time = api_GetTickCount64()
                local interactiontimeout = env.interactiontimeout
                if crrut_time - interactiontimeout > 30000 then
                    table.insert(env.interactive_id_list, interaction_object.id)
                    env.interaction_object = nil
                    env.target_point_sort_list = {}
                    env.interactive_replytime = api_GetTickCount64()
                    poe2_api.time_p("判断是否需要交互（RUNNING10）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                env.interactive = interaction_object
                poe2_api.dbgp("交互对象: "..interaction_object.name_utf8.."路径名： "..interaction_object.path_name_utf8)
                poe2_api.printTable(interaction_object)
                poe2_api.time_p("判断是否需要交互（FAIL2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            env.wait_target = false
            env.interactiontimeout = 0
            env.interactive_id = nil
            poe2_api.time_p("交互对象(return bret.SUCCESS)(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
            return bret.SUCCESS
        end
    },

    -- 是否有未激活/黑雾祭坛
    Has_Black_Mist_Altar = {
        run = function(self, env)
            poe2_api.print_log("是否有未激活/黑雾祭坛...")
            local start_time = api_GetTickCount64()
            local player_info = env.player_info
            -- local range_info = env.range_info
            if not next(player_info) then
                poe2_api.dbgp("[Has_Black_Mist_Altar] 错误：玩家信息为空")
                poe2_api.time_p("是否有未激活/黑雾祭坛（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if not env.range_info or not next(env.range_info)  then
                poe2_api.dbgp("[Has_Black_Mist_Altar] 错误：周围对象信息为空")
                poe2_api.time_p("是否有未激活/黑雾祭坛（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            
            -- 判断祭坛  
            -- index  1 未激活|黑雾  0 黑雾  2 比对周围祭坛有无记录的祭坛 
            local function get_altar(range_info,index,afoot_altar)
                -- local altar_target = {}
                for _, v in ipairs(range_info) do
                    if v.path_name_utf8 == game_str.Ritual_PATH then
                        -- local stateMachineList = v:GetStateMachineList()
                        if v.stateMachineList and next(v.stateMachineList) then
                            if index == 1 then
                                if (v.stateMachineList[game_str.current_state_SML] == 2 and v.stateMachineList[game_str.interaction_enabled_SML] == 0)
                                 or (v.stateMachineList[game_str.current_state_SML] == 0 and v.stateMachineList[game_str.interaction_enabled_SML] == 0) then
                                    -- table.insert(altar_target, {
                                    --     obj = v,                    -- userdata
                                    --     stateMachineList = stateMachineList  -- 关联的 table
                                    -- })
                                    -- v["stateMachineList"] = stateMachineList
                                    -- altar_target = v
                                    return v
                                end
                            elseif index == 0 then
                                if (v.stateMachineList[game_str.current_state_SML] == 2 and v.stateMachineList[game_str.interaction_enabled_SML] == 0) then
                                    -- table.insert(altar_target, {
                                    --     obj = v,                    -- userdata
                                    --     stateMachineList = stateMachineList  -- 关联的 table
                                    -- })
                                    return v
                                end
                            elseif index == 2 then
                                if v.id == afoot_altar.id then
                                    if (v.stateMachineList[game_str.current_state_SML] == 2 and v.stateMachineList[game_str.interaction_enabled_SML] == 0)
                                    or (v.stateMachineList[game_str.current_state_SML] == 0 and v.stateMachineList[game_str.interaction_enabled_SML] == 0) then
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end
                return false
            end
            local current_map_info = env.current_map_info
            
            -- 判断小地图上有无祭坛图标显示
            local function get_mini_altar(mini_map_info)
                for _, v in ipairs(mini_map_info) do
                    if poe2_api.table_contains(v.name_utf8,{game_str.RitualRune_EN,game_str.RitualRuneFinished_EN}) then
                        return true
                    end
                end
                return false
            end

            -- 判断怪物
            local function is_monster(macth_data)
                local range_info = macth_data.range_info
                local mate = macth_data.mate
                local distance = macth_data.distance
                local objter = macth_data.objter or nil
                for _, v in ipairs(range_info) do
                    if v.type == 1 and not v.is_friendly and v.life > 0
                     and not poe2_api.table_contains(v.name_utf8,my_game_info.not_attact_mons_CN_name)
                     and v.isActive and not string.find(v.name_utf8,game_str.temple) and v.hasLineOfSight and v.is_selectable then
                        local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                        if dis and dis < distance then
                            if objter then
                                local dis = poe2_api.point_distance(v.grid_x, v.grid_y,objter)
                                if dis and dis > 99 then
                                    return true
                                end
                            else
                                return true
                            end 
                        end
                    end
                end
                return false
            end
            
            
            if not env.not_more_ritual and not get_altar(env.range_info,0) then 
                poe2_api.dbgp("已无祭坛物品可买，不再主动打祭坛")
                env.afoot_altar = nil
                env.center_radius = 0
                env.center_point = {}
                env.prestore_list = {}
                poe2_api.time_p("是否有未激活/黑雾祭坛（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            local is_altar = nil
            if not env.afoot_altar then
                is_altar = get_altar(env.range_info,1)
            else
                is_altar = env.afoot_altar
            end
            if not is_altar then
                env.center_radius = 0
                env.center_point = {}
                poe2_api.dbgp("未找到祭坛")
                poe2_api.time_p("是否有未激活/黑雾祭坛（FAIL2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            else
                if player_info.isInBossBattle then
                    env.center_radius = 0
                    env.center_point = {}
                    env.prestore_list = {}
                    poe2_api.dbgp("Boss战，不再主动打祭坛")
                    poe2_api.time_p("是否有未激活/黑雾祭坛（FAIL3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                end
                if poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.Citadel_map) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH}) then
                    env.center_radius = 0
                    env.center_point = {}
                    env.prestore_list = {}
                    poe2_api.dbgp("")
                    poe2_api.time_p("是否有未激活/黑雾祭坛（FAIL111111）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                end
                if not get_mini_altar(current_map_info) then
                    poe2_api.dbgp("地图改变，已无祭坛")
                    env.center_radius = 0
                    env.center_point = {}
                    env.prestore_list = {}
                    env.afoot_altar = nil
                    poe2_api.time_p("是否有未激活/黑雾祭坛（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                
                local get_altar_ongoing = get_altar(env.range_info,0)
                
                if get_altar_ongoing then
                    local distance = poe2_api.point_distance(get_altar_ongoing.grid_x, get_altar_ongoing.grid_y, player_info)
                    if distance and distance < 102 then
                        is_altar = get_altar_ongoing
                    end
                end
                if env.afoot_altar then
                    local distance = poe2_api.point_distance(env.afoot_altar.grid_x, env.afoot_altar.grid_y, player_info)
                    if distance and distance < 120 then 
                        if not get_altar(env.range_info,2,env.afoot_altar) then
                            poe2_api.dbgp("该祭坛已打完，更新数据")
                            api_RestoreOriginalMap()
                            api_UpdateMapObstacles(100)
                            env.center_radius = 0
                            env.center_point = {}
                            env.prestore_list = {}
                            env.afoot_altar = nil
                            poe2_api.time_p("是否有未激活/黑雾祭坛（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end
                end
                local distance = poe2_api.point_distance(is_altar.grid_x, is_altar.grid_y, player_info)
                if distance then
                    poe2_api.dbgp("人物与祭坛的距离： "..distance)
                end
                if distance > 105 and is_monster({range_info=env.range_info,mate=player_info,distance=60,objter=is_altar}) then
                    env.center_radius = 0
                    env.center_point = {}
                    env.prestore_list = {}
                    poe2_api.time_p("是否有未激活/黑雾祭坛（FAIL4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                end
                if distance < 110 then
                    api_UpdateMapObstacles(150)
                end
                env.afoot_altar = is_altar
                poe2_api.time_p("是否有未激活/黑雾祭坛（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
        end
    },

    -- 是否需要移动祭坛
    Is_Move_Altar = {
        run = function(self, env)
            poe2_api.print_log("是否需要移动祭坛...")
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.object1 = nil
                self.time = 0
                self.break_object_list = {}
                self.target = nil
                self.target1 = nil
                self.target2 = nil
                self.bool = true
            end
            local player_info = env.player_info
            local afoot_altar = env.afoot_altar
            -- local range_info = env.range_info
            local current_map_info = env.current_map_info
            local path_list = env.path_list
            -- 判断路径
            local function is_point(grid_x,grid_y)
                local point = api_FindNearestReachableInRange(math.floor(grid_x),math.floor(grid_y),15,0)
                local ralet = api_FindPath(player_info.grid_x,player_info.grid_y,math.floor(point.x),math.floor(point.y))
                return ralet
            end
            -- 判断怪物
            local function is_monster(macth_data)
                local index = macth_data.index or 0
                local range_info = nil
                local mate = macth_data.mate
                local distance = macth_data.distance
                if index == 0 then
                    range_info = macth_data.range_info
                else
                    range_info = poe2_api.get_sorted_list(env.range_info,mate)
                end
                -- poe2_api.dbgp("怪物列表: "..#range_info)
                -- poe2_api.dbgp("index: "..index)
                local target_list = {}
                local cutt1 = api_GetTickCount64()
                for _, v in ipairs(range_info) do
                    if v.type == 1 and not v.is_friendly and v.life > 0
                     and not poe2_api.table_contains(v.name_utf8,my_game_info.not_attact_mons_CN_name)
                     and not string.find(v.name_utf8,game_str.temple) then
                        if index == 0 then
                            
                            -- poe2_api.dbgp("怪物: "..v.name_utf8)
                            -- poe2_api.dbgp("可视: "..tostring(v.hasLineOfSight))
                            -- poe2_api.dbgp("激活: "..tostring(v.isActive))
                            -- poe2_api.dbgp("========================================")
                            -- poe2_api.dbgp("距离: "..dis)
                            if v.hasLineOfSight and v.isActive then
                                poe2_api.dbgp("有视野")
                                poe2_api.dbgp("怪物: ",v.name_utf8)
                                
                                local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                                
                                poe2_api.dbgp("距离: "..dis)
                                if dis and dis < distance then
                                    local is_path = is_point(v.grid_x, v.grid_y)
                                    if is_path and next(is_path) then
                                        poe2_api.time_p("算距离耗时1... 耗时 --> ", api_GetTickCount64() - cutt1)
                                        return v
                                    end
                                end
                            end
                        elseif index == 1 then
                            poe2_api.time_p("算距离耗时... 耗时 --> ", 22222222222222)
                            if (not v.hasLineOfSight or not v.isActive) and (not poe2_api.table_contains(v.name_utf8,{game_str.The_Terracotta_Warriors_NAME,game_str.The_Stone_Soldiers_NAME,game_str.The_vivid_jellyfish_NAME,game_str.Offering_sacrifices_to_fairies_NAME}) and not string.find(v.path_name_utf8,game_str.TormentedSpiritofthe_PATH)) then
                                poe2_api.dbgp("无视野，或者未激活")
                                local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                                poe2_api.dbgp("距离: "..dis)
                                if dis and dis < distance then
                                    if not self.break_object_list or not next(self.break_object_list) then
                                        local is_path = is_point(v.grid_x, v.grid_y)
                                        if is_path and next(is_path) then
                                        -- if is_point(v.grid_x, v.grid_y) then
                                            return v
                                        end
                                    else
                                        if not poe2_api.table_contains(self.break_object_list,v.id) then
                                            local is_path = is_point(v.grid_x, v.grid_y)
                                            if is_path and next(is_path) then
                                            -- if is_point(v.grid_x, v.grid_y) then
                                                return v
                                            end
                                        end
                                    end 
                                end
                            end
                        elseif index == 2 then
                            if v.hasLineOfSight and v.isActive then
                                poe2_api.dbgp("有视野")
                                poe2_api.dbgp("怪物: ",v.name_utf8)
                                
                                local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                                
                                poe2_api.dbgp("距离: "..dis)
                                if dis and dis < distance then
                                    -- if is_point(v.grid_x, v.grid_y) then
                                    poe2_api.time_p("算距离耗时1... 耗时 --> ", api_GetTickCount64() - cutt1)
                                    table.insert(target_list,v)
                                        -- return v
                                    -- end
                                end
                            end
                        -- else
                        --     if v.hasLineOfSight and v.isActive then
                        --         poe2_api.dbgp("有视野")
                        --         poe2_api.dbgp("怪物: ",v.name_utf8)
                                
                        --         local dis = poe2_api.point_distance(v.grid_x, v.grid_y,player_info)
                        --         local distance1 = 50
                        --         if distance1 > env.min_attack_dis then
                        --             distance1 = env.min_attack_dis  
                        --         end
                        --         poe2_api.dbgp("距离: "..dis)
                        --         if dis and dis < distance1 then
                        --             if is_point(v.grid_x, v.grid_y) then
                        --                 poe2_api.time_p("算距离耗时1... 耗时 --> ", api_GetTickCount64() - cutt1)
                        --                 return v
                        --                 -- return v
                        --             end
                        --         end
                        --     end
                        end
                    end
                end
                poe2_api.time_p("算距离耗时2... 耗时 --> ", api_GetTickCount64() - cutt1)
                if index == 2 then
                    if target_list and next(target_list) then
                        return target_list
                    end
                end
                return false
            end
            -- 判断精粹
            local function is_crystal(macth_data)
                local range_info = macth_data.range_info
                local mate = macth_data.mate
                local distance = macth_data.distance
                local current_map_info = macth_data.current_map_info
                local function get_mini_crystal()
                    for _, v in ipairs(current_map_info) do
                        if v.name_utf8 == 'Essence' then
                            return true
                        end
                    end
                    return false
                end
                for _,v in ipairs(range_info) do
                    if v.path_name_utf8 == game_str.Monolith_PATH and get_mini_crystal() then
                        local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                        if dis and dis < distance then
                            return v
                        end
                    end
                end
                return false
            end
            -- 判断怪物是否存在
            local function get_monster(range_info,mate,index)
                local index1 = index or 0
                for _,v in ipairs(range_info) do
                    if v.type == 1 and v.id == mate.id and v.life > 0 then
                        if index1 == 0 then
                            if v.hasLineOfSight and v.isActive then
                                return v
                            end
                        else
                            return v
                        end
                        
                    end
                end
                return false
            end
            local distance = poe2_api.point_distance(afoot_altar.grid_x, afoot_altar.grid_y, player_info)
            if distance then
                if distance > 100 then
                    if self.target then
                        if not get_monster(env.range_info,self.target) then
                            self.target = nil
                        end
                    end
                    if not self.target then
                        local is_target = is_monster({range_info=env.range_info,mate=afoot_altar,distance=105})
                        if not is_target then
                            if env.path_list and next(env.path_list) then
                                poe2_api.dbgp("祭坛已有路径，先完成原先路径")
                                return bret.SUCCESS
                            end
                            local point = api_FindNearestReachableInRange(afoot_altar.grid_x,afoot_altar.grid_y,50,0)
                            env.end_point = {point.x,point.y}
                            poe2_api.dbgp("人物在祭坛附近，移动到祭坛1")
                            poe2_api.time_p("是否需要移动祭坛（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        else
                            local distance = poe2_api.point_distance(is_target.grid_x, is_target.grid_y, player_info)
                            if distance and distance > env.min_attack_dis then
                                poe2_api.dbgp("怪物超出攻击距离，移动")
                                env.end_point = {is_target.grid_x,is_target.grid_y}
                                poe2_api.time_p("是否需要移动祭坛（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                                return bret.SUCCESS
                            end
                            env.center_radius = 105
                            env.center_point = {afoot_altar.grid_x,afoot_altar.grid_y}
                            poe2_api.dbgp("攻击附近的怪")
                            poe2_api.time_p("是否需要移动祭坛（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.FAIL
                        end
                    else
                        local distance = poe2_api.point_distance(is_target.grid_x, is_target.grid_y, player_info)
                        if distance and distance > env.min_attack_dis then
                            poe2_api.dbgp("怪物超出攻击距离，移动")
                            env.end_point = {is_target.grid_x,is_target.grid_y}
                            poe2_api.time_p("是否需要移动祭坛（SUCCESS8）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        end
                        env.center_radius = 105
                        env.center_point = {afoot_altar.grid_x,afoot_altar.grid_y}
                        poe2_api.dbgp("攻击附近的怪")
                        poe2_api.time_p("是否需要移动祭坛（FAIL4）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.FAIL
                    end
                    
                else
                    if afoot_altar.stateMachineList[game_str.current_state_SML] == 2 and afoot_altar.stateMachineList[game_str.interaction_enabled_SML] == 0 then
                        if env.target_point and next(env.target_point) then
                            local distance = poe2_api.point_distance(env.target_point[1],env.target_point[2],afoot_altar)
                            if distance and distance >= 99 then
                                env.target_point = {}
                                if env.path_list and next(env.path_list) then
                                    table.remove(env.path_list,1)
                                end
                                poe2_api.dbgp("人物在黑雾祭坛中，当前目标点在黑雾外，移除路径")
                                poe2_api.time_p("是否需要移动祭坛（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                                return bret.RUNNING
                            end
                        end
                    end
                    if self.target1 then
                        if not get_monster(env.range_info,self.target1) then
                            self.target1 = nil
                        end
                    end
                    if not self.target1 then
                        local cutt = api_GetTickCount64()
                        local target_list = is_monster({range_info=env.range_info,mate=afoot_altar,distance=105,index = 2})
                        if target_list and next(target_list) then
                            local target_sorted_list = poe2_api.get_sorted_list(target_list,player_info)
                            for _,v in ipairs(target_sorted_list) do
                                if is_point(v.grid_x, v.grid_y) then
                                    self.target1 = v
                                    break
                                end
                            end
                        else
                            self.target1 = nil
                        end
                        poe2_api.time_p("是否需要移动祭坛找怪物... 耗时 --> ", api_GetTickCount64() - cutt)
                    end
                    
                    -- api_Sleep(10000)
                    if not self.target1 then
                        poe2_api.dbgp("人物在黑雾祭坛中，没有激活的怪物")
                        local crystal = is_crystal({range_info =env.range_info,mate = afoot_altar,distance = 99,current_map_info = current_map_info})
                        if crystal then
                            poe2_api.dbgp("人物在黑雾祭坛中，没有激活的怪物，移动到精髓")
                            env.end_point = {crystal.grid_x,crystal.grid_y}
                            local dis = poe2_api.point_distance(crystal.grid_x, crystal.grid_y,player_info)
                            if dis and dis < 25 then
                                api_ClickMove(poe2_api.toInt(crystal.grid_x), poe2_api.toInt(crystal.grid_y), 1)
                                poe2_api.time_p("是否需要移动祭坛（FAIL2）... 耗时 --> ", api_GetTickCount64() - start_time)
                                return bret.RUNNING
                            end
                            poe2_api.dbgp("人物在黑雾祭坛，移动到精髓")
                            poe2_api.time_p("是否需要移动祭坛（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        end
                        if self.target2 then
                            if not get_monster(env.range_info,self.target2,1) then
                                self.target2 = nil
                            end
                        end
                        if not self.target2 then
                            self.target2 = is_monster({range_info=env.range_info,mate=afoot_altar,distance=99,index = 1})
                        end
                        if self.target2 then
                            poe2_api.dbgp("人物在黑雾祭坛中，没有激活的怪物，移动到未激活附近怪")
                            poe2_api.printTable(self.target2)
                            if not self.object1 then
                                self.object1 = self.target2
                            end
                            if self.object1.id ~= self.target2.id then
                                self.object1 = self.target2
                                self.time = 0
                            else
                                if self.time == 0 then
                                    self.time = api_GetTickCount64()
                                end
                                if api_GetTickCount64() - self.time > 3000 then
                                    table.insert(self.break_object_list,self.target2.id)
                                    self.time = 0
                                end
                            end
                            env.end_point = {self.target2.grid_x,self.target2.grid_y}
                            local dis = poe2_api.point_distance(self.target2.grid_x,self.target2.grid_y,player_info)
                            if dis and dis < 25 then
                                api_ClickMove(poe2_api.toInt(self.target2.grid_x), poe2_api.toInt(self.target2.grid_y), 7)
                                poe2_api.time_p("是否需要移动祭坛（SUCCESS7）... 耗时 --> ", api_GetTickCount64() - start_time)
                                return bret.RUNNING
                            end
                            poe2_api.dbgp("人物在黑雾祭坛，移动到未激活附近怪")
                            poe2_api.time_p("是否需要移动祭坛（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.SUCCESS
                        else
                            if not env.prestore_list or not next(env.prestore_list) then
                                local result_list = api_GetCalculateCircleGridPoints(poe2_api.toInt(afoot_altar.grid_x),poe2_api.toInt(afoot_altar.grid_y),98,math.floor(10))
                                if result_list then
                                    env.prestore_list = result_list
                                    poe2_api.time_p("是否需要移动祭坛（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                                    return bret.RUNNING
                                else
                                    local point = api_FindRandomWalkablePosition(math.floor(afoot_altar.grid_x),math.floor(afoot_altar.grid_y),80)
                                    if point then
                                        env.end_point = {point.x,point.y}
                                    end
                                    poe2_api.dbgp("获取圆形范围内均匀分布的网格点失败,随机移动")
                                    poe2_api.time_p("是否需要移动祭坛（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                                    return bret.SUCCESS
                                end
                            else
                                local distance = poe2_api.point_distance(env.prestore_list[1].x,env.prestore_list[1].y,player_info)
                                if distance and distance < 15 then
                                    table.remove(env.prestore_list,1)
                                    poe2_api.time_p("是否需要移动祭坛（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                                    return bret.RUNNING
                                end
                                -- if not path_list or not next(path_list) then
                                --     local ralet = api_FindPath(player_info.grid_x,player_info.grid_y,env.prestore_list[1].x,env.prestore_list[1].y)
                                --     if not ralet then
                                --         table.remove(env.prestore_list,1)
                                --         local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),80)
                                --         api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), poe2_api.toInt(player_info.world_z), 7)
                                --         poe2_api.click_keyboard("space")
                                --         poe2_api.dbgp("人物在黑雾祭坛，计算到圆形范围内第一个点失败")
                                --         return bret.RUNNING
                                --     end
                                -- end
                                env.end_point = {env.prestore_list[1].x,env.prestore_list[1].y}
                                poe2_api.dbgp("人物在黑雾祭坛，移动到圆形范围内第一个点")
                                poe2_api.time_p("是否需要移动祭坛（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
                                return bret.SUCCESS
                            end
                        end
                    end
                    poe2_api.printTable(self.target1)
                    local distance = poe2_api.point_distance(self.target1.grid_x,self.target1.grid_y,player_info)
                    if distance and distance > 180 then

                        poe2_api.dbgp("怪物超出攻击距离，移动")
                        env.end_point = {self.target1.grid_x,self.target1.grid_y}
                        poe2_api.time_p("是否需要移动祭坛（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.SUCCESS
                    end
                    poe2_api.dbgp(distance)
                    self.break_object_list = {}
                    env.center_radius = 105
                    env.center_point = {afoot_altar.grid_x,afoot_altar.grid_y}
                    poe2_api.dbgp("人物在黑雾祭坛，攻击附近怪")
                    poe2_api.time_p("是否需要移动祭坛（FAIL3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL

                end
            end
            -- return bret.SUCCESS
        end
    },

    

    -- 判断地图钥匙是否需要强化
    Is_Map_Strengthened = {
        run = function(self, env)
            poe2_api.print_log("判断地图钥匙是否需要强化...")
            local start_time = api_GetTickCount64()
            local config1 = env.user_config
            if not self.bool then
                self.wait = false
                self.dq_time = 0
                self.bool = true
            end
            local player_info = env.player_info
            local current_map_info = env.current_map_info
            if not next(player_info) then
                poe2_api.dbgp("玩家信息不存在,地图钥匙强化")
                poe2_api.time_p("判断地图钥匙是否需要强化（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING 
            end
            
            local bag_info = env.bag_info
            local is_strengthened_map = env.is_strengthened_map
            local not_use_map = env.not_use_map
            -- 获取背包中不打词条的地图钥匙
            local function get_map_not_entry(map)
                -- 词条过滤
                local function match_item_suffixes(item_suffixes, config_suffixes)
                    if not item_suffixes or not next(item_suffixes) then
                        return false
                    end
                    if not config_suffixes or not next(config_suffixes) then
                        return false
                    end
                    for _, v in ipairs(item_suffixes) do
                        for _, v1 in ipairs(config_suffixes) do
                            if v.name_utf8 == v1 then
                                return true
                            end
                        end
                    end
                    return false
                end
                if map then
                    if map.color > 0 and not map.not_identified and match_item_suffixes(api_GetObjectSuffix(map.mods_obj),not_use_map) then
                        return true
                    end
                end
                return false
            end
            if env.one_other_map then
                poe2_api.dbgp("已开图，不强化")
                env.is_public_warehouse = true
                env.strengthened_map_obj = nil
                poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local max_map = poe2_api.select_best_map_key({inventory=bag_info,key_level_threshold=env.user_map,not_use_map = not_use_map})
            if not max_map then
                poe2_api.dbgp("没有最优地图，不强化地图钥匙")
                env.is_public_warehouse = true
                env.strengthened_map_obj = nil
                poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if max_map.not_identified then
                poe2_api.dbgp("最优地图，未鉴定不强化")
                env.is_public_warehouse = true
                env.strengthened_map_obj = nil
                poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS22）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local config = env.user_config["刷圖設置"][game_str.Map_Key_CH] or {}
            if not config and next(config) then
                poe2_api.dbgp("未配置地图钥匙，不强化")
                env.is_public_warehouse = true
                env.strengthened_map_obj = nil
                poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local max_map_config = nil
            for _, v in pairs(config) do
                if v["階級"] == poe2_api.extract_level(max_map.baseType_utf8) then
                    -- 先判断 v["使用通貨"] 是否存在且是表
                    if v["使用通貨"] and type(v["使用通貨"]) == "table" then
                        -- 再判断 ["是否開啟"] 是否存在
                        if v["使用通貨"]["是否開啟"] then
                            max_map_config = v["使用通貨"]
                        end
                    end
                end
            end
            if not max_map_config then
                poe2_api.dbgp("未配置最优地图的通貨或者为开启使用通货，不强化地图钥匙")
                env.is_public_warehouse = true
                env.strengthened_map_obj = nil
                poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if max_map.contaminated then
                poe2_api.dbgp("最优地图已污染，不强化地图钥匙")
                if not env.streng_map_flushed_switch then
                    env.is_public_warehouse = true
                    env.strengthened_map_obj = nil
                    poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
            end
            
            if not is_strengthened_map and not env.streng_map_flushed_switch then
                poe2_api.dbgp("不需要强化")
                env.is_public_warehouse = true
                env.strengthened_map_obj = nil
                poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if max_map.color == 2 and max_map_config[game_str.Exalted_Orb_TWCH] == 0 and max_map_config[game_str.Vaal_Orb_TWCH] == 0 then
                poe2_api.dbgp("已达到强化需求不强化111")
                if not env.streng_map_flushed_switch then
                    env.is_public_warehouse = true
                    env.strengthened_map_obj = nil
                    poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS7）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
                
            end
            if max_map.fixedSuffixCount >= 6 and max_map_config[game_str.Vaal_Orb_TWCH] == 0 then
                poe2_api.dbgp("已达到强化需求不强化2222")
                if not env.streng_map_flushed_switch then
                    env.is_public_warehouse = true
                    env.strengthened_map_obj = nil
                    poe2_api.time_p("判断地图钥匙是否需要强化（SUCCESS8）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
            end
            -- 蛻變
            local tb = max_map_config[game_str.Orb_of_Transmutation_TWCH]
            -- 增幅
            local zf = max_map_config[game_str.Orb_of_Augmentation_TWCH]
            -- 富豪
            local fh = max_map_config[game_str.Regal_Orb_TWCH]
            -- 點金
            local dj = max_map_config[game_str.Orb_of_Alchemy_TWCH]
            -- 崇高
            local cg = max_map_config[game_str.Exalted_Orb_TWCH]
            -- 瓦爾
            local wr = max_map_config[game_str.Vaal_Orb_TWCH]
            local text = nil
            if poe2_api.table_contains(max_map.color,{0,1}) and dj ~= 0 and not max_map.contaminated and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Alchemy_TWCH)) then
                text = game_str.Orb_of_Alchemy_TWCH
            elseif max_map.color == 0 and tb ~= 0 and not max_map.contaminated and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Greater_Orb_of_Transmutation_TWCH)) then
                text = game_str.Greater_Orb_of_Transmutation_TWCH
            elseif max_map.color == 0 and tb ~= 0 and not max_map.contaminated and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Transmutation_TWCH)) then
                text = game_str.Orb_of_Transmutation_TWCH
            elseif max_map.color == 1 and zf ~= 0 and not max_map.contaminated and max_map.fixedSuffixCount < 2 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Greater_Orb_of_Augmentation_TWCH)) then
                text = game_str.Greater_Orb_of_Augmentation_TWCH
            elseif max_map.color == 1 and zf ~= 0 and not max_map.contaminated and max_map.fixedSuffixCount < 2 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Augmentation_TWCH)) then
                text = game_str.Orb_of_Augmentation_TWCH
            elseif  max_map.color == 1 and fh ~= 0 and not max_map.contaminated and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Regal_Orb_TWCH)) then
                text = game_str.Regal_Orb_TWCH
            elseif max_map.color == 2 and cg ~= 0 and not max_map.contaminated and max_map.fixedSuffixCount < 6 and env.supreme_use_count < cg and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Exalted_Orb_TWCH)) then
                text = game_str.Exalted_Orb_TWCH
            elseif wr and not max_map.contaminated and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Vaal_Orb_TWCH)) then
                text = game_str.Vaal_Orb_TWCH
            else
                if not env.warehouse_type_interactive or env.warehouse_type_interactive == game_str.Guild_Warehouse_text then
                    if get_map_not_entry(max_map) then
                        env.is_public_warehouse = true
                        env.is_strengthened_map = true
                        env.supreme_use_count = 0
                        poe2_api.time_p("判断地图钥匙是否需要强化（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    env.is_public_warehouse = true
                end
                env.is_strengthened_map = false
                env.streng_map_flushed_switch = false
                poe2_api.time_p("判断地图钥匙是否需要强化（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            
            env.strengthened_map_obj = max_map
            
            if text then
                local items_info = poe2_api.get_items_config_info(config1)
                local is_text = nil
                for _,item in ipairs(items_info) do
                    if item["類型"] == "通貨" and item['存倉頁名'] and not item["不撿"] and poe2_api.table_contains(item['基礎類型名'],text) then
                        is_text = item
                        break
                    end
                end
                if is_text then
                    if is_text["工會倉庫"] then
                        env.warehouse_type_interactive = game_str.Guild_Warehouse_text
                        env.is_public_warehouse = false
                    else
                        env.warehouse_type_interactive = game_str.Warehouse_text
                    end
                else
                    local unique_storage_pages = nil
                    for _,item in ipairs(items_info) do
                        if item["類型"] == "通貨" and item['存倉頁名'] and not item["不撿"] and item['基礎類型名'] == "全部物品" and not item["工會倉庫"] then
                            unique_storage_pages = item
                            break
                        end
                    end
                    if unique_storage_pages then
                        env.warehouse_type_interactive = game_str.Warehouse_text
                    else
                        env.warehouse_type_interactive = game_str.Guild_Warehouse_text
                        env.is_public_warehouse = false
                    end
                end
            end
            poe2_api.time_p("判断地图钥匙是否需要强化（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end 
    },

    -- 强化地图钥匙找通货
    StrengthenMapKeyFindCurrency = {
        run = function(self, env)
            poe2_api.print_log("开始执行强化地图钥匙找通货...")
            local start_time = api_GetTickCount64()
            local not_use_map = env.not_use_map
            -- 获取背包中不打词条的地图钥匙
            local function get_map_not_entry(map)
                -- 词条过滤
                local function match_item_suffixes(item_suffixes, config_suffixes)
                    if not item_suffixes or not next(item_suffixes) then
                        return false
                    end
                    if not config_suffixes or not next(config_suffixes) then
                        return false
                    end
                    for _, v in ipairs(item_suffixes) do
                        for _, v1 in ipairs(config_suffixes) do
                            if v.name_utf8 == v1 then
                                return true
                            end
                        end
                    end
                    return false
                end
                if map then
                    if map.color > 0 and not map.not_identified and match_item_suffixes(api_GetObjectSuffix(map.mods_obj),not_use_map) then
                        return true
                    end
                end
                return false
            end
            if env.warehouse_type_interactive == game_str.Warehouse_text then
                -- text = game_str.Warehouse
                if poe2_api.find_text({text = game_str.Emphasize_the_item,UI_info = env.UI_info,min_x = 250,min_y = 700}) 
                and poe2_api.find_text({text = game_str.Guild_Warehouse,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=78}) then
                    -- poe2_api.click_keyboard("space")
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Guild_Warehouse, min_x=0,min_y=32,max_x=381,max_y=78, click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("强化地图钥匙找通货（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            elseif env.warehouse_type_interactive == game_str.Guild_Warehouse_text then

                -- text = game_str.Guild_Warehouse
                if poe2_api.find_text({text = game_str.Emphasize_the_item,UI_info = env.UI_info,min_x = 250,min_y = 700}) 
                and poe2_api.find_text({text = game_str.Warehouse,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=78}) then
                    -- poe2_api.click_keyboard("space")
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Warehouse, min_x=0,min_y=32,max_x=381,max_y=78, click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("强化地图钥匙找通货（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if get_map_not_entry(env.strengthened_map_obj) then
                    env.is_public_warehouse = true
                    env.is_strengthened_map = true
                    env.supreme_use_count = 0
                    poe2_api.time_p("强化地图钥匙找通货（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            else
                error("碑牌未知的仓库类型")
            end
            if not poe2_api.find_text({text = game_str.Emphasize_the_item,UI_info = env.UI_info,min_x = 250,min_y = 700})  then
            -- and poe2_api.find_text({text = text,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=78}) then
                poe2_api.time_p("强化地图钥匙找通货（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            -- 参数赋值
            local function data_assignment()
                if env.warehouse_type_interactive == game_str.Guild_Warehouse_text then
                    env.is_public_warehouse = true
                end
                env.streng_map_flushed_switch = false
                env.is_strengthened_map = false
            end
            poe2_api.print_log("强化地图钥匙找通货...")
            local strengthened_map_obj = env.strengthened_map_obj
            local config = env.user_config["刷圖設置"][game_str.Map_Key_CH]
            local max_map_config = nil
            for _, v in pairs(config) do
                if v["階級"] == poe2_api.extract_level(strengthened_map_obj.baseType_utf8) then
                    -- 先判断 v["使用通貨"] 是否存在且是表
                    if v["使用通貨"] and type(v["使用通貨"]) == "table" then
                        -- 再判断 ["是否開啟"] 是否存在
                        if v["使用通貨"]["是否開啟"] then
                            max_map_config = v["使用通貨"]
                        end
                    end
                end
            end
            -- 蛻變
            local tb = max_map_config[game_str.Orb_of_Transmutation_TWCH]
            -- 增幅
            local zf = max_map_config[game_str.Orb_of_Augmentation_TWCH]
            -- 富豪
            local fh = max_map_config[game_str.Regal_Orb_TWCH]
            -- 點金
            local dj = max_map_config[game_str.Orb_of_Alchemy_TWCH]
            -- 崇高
            local cg = max_map_config[game_str.Exalted_Orb_TWCH]
            -- 瓦爾
            local wr = max_map_config[game_str.Vaal_Orb_TWCH]
            local item_name = ""
            if strengthened_map_obj.color == 0 then
                if dj ~= 0 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Alchemy_TWCH)) then
                    item_name = game_str.Orb_of_Alchemy_TWCH
                elseif tb ~= 0 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Greater_Orb_of_Transmutation_TWCH)) then
                    item_name = game_str.Greater_Orb_of_Transmutation_TWCH
                elseif tb ~= 0 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Transmutation_TWCH)) then
                    item_name = game_str.Orb_of_Transmutation_TWCH
                elseif wr ~= 0 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Vaal_Orb_TWCH)) then
                    item_name = game_str.Vaal_Orb_TWCH
                else
                    data_assignment()
                    poe2_api.time_p("强化地图钥匙找通货（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            elseif strengthened_map_obj.color == 1 then
                if dj ~= 0 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Alchemy_TWCH)) then
                    item_name = game_str.Orb_of_Alchemy_TWCH
                elseif zf ~= 0 and strengthened_map_obj.fixedSuffixCount < 2 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Greater_Orb_of_Augmentation_TWCH)) then
                    item_name = game_str.Greater_Orb_of_Augmentation_TWCH
                elseif zf ~= 0 and strengthened_map_obj.fixedSuffixCount < 2 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Augmentation_TWCH)) then
                    item_name = game_str.Orb_of_Augmentation_TWCH
                elseif fh == 0 and wr == 0 then
                    data_assignment()
                    poe2_api.time_p("强化地图钥匙找通货（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                elseif fh ~= 0 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Regal_Orb_TWCH)) then
                    item_name = game_str.Regal_Orb_TWCH
                elseif wr ~= 0 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Vaal_Orb_TWCH)) then
                    item_name = game_str.Vaal_Orb_TWCH
                else
                    data_assignment()
                    poe2_api.time_p("强化地图钥匙找通货（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            elseif strengthened_map_obj.color == 2 then
                if cg ~= 0 and strengthened_map_obj.fixedSuffixCount < 6 and env.supreme_use_count <cg and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Exalted_Orb_TWCH)) then
                    item_name = game_str.Exalted_Orb_TWCH
                elseif wr ~= 0 and (not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,game_str.Vaal_Orb_TWCH)) then
                    item_name = game_str.Vaal_Orb_TWCH
                else
                    data_assignment()
                    poe2_api.time_p("强化地图钥匙找通货（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            env.currency_name = item_name  
            poe2_api.time_p("强化地图钥匙找通货（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 判断是否强化碑牌
    Is_Update_Plaque = {
        run = function(self, env)
            poe2_api.print_log("判断是否强化碑牌...")
            local start_time = api_GetTickCount64()
            -- local is_insert_stone = env.is_insert_stone
            -- if not is_insert_stone then
            --     poe2_api.dbgp("未开启插碑，不判断")
            --     poe2_api.time_p("判断是否强化碑牌（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
            --     return bret.SUCCESS
            -- end
            local player_info = env.player_info
            local bag_info = env.bag_info
            local current_map_info = env.current_map_info
            if not player_info or not next(player_info) then
                poe2_api.dbgp("玩家信息为空,判断强化碑牌")
                poe2_api.time_p("判断是否强化碑牌（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            -- 判断背包是否有需要强化的碑牌
            local function get_bag_plaque(bag_info)
                local function plaque_color(plaque_info)
                    for _, i in ipairs(plaque_info) do
                        if i.color == 0 or (i.color == 1 and i.fixedSuffixCount < 2) then
                            if not next(env.lack_of_currency)  then
                                return i

                            else
                                local text = nil
                                if i.color == 0 and not poe2_api.table_contains(env.lack_of_currency,game_str.Greater_Orb_of_Transmutation_TWCH) then
                                    text = game_str.Greater_Orb_of_Transmutation_TWCH
                                elseif i.color == 0 and not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Transmutation_TWCH) then
                                    text = game_str.Orb_of_Transmutation_TWCH
                                elseif i.color == 1 and not poe2_api.table_contains(env.lack_of_currency,game_str.Greater_Orb_of_Augmentation_TWCH) then
                                    text = game_str.Greater_Orb_of_Augmentation_TWCH
                                elseif i.color == 1 and not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Augmentation_TWCH) then
                                    text = game_str.Orb_of_Augmentation_TWCH
                                end
                                if text then
                                    return i
                                end
                            end
                        end
                    end
                    return false
                end
                local plaque_index = {}
                for _, v in pairs(bag_info) do
                    if v.category_utf8 == game_str.TowerAugmentation then
                        table.insert(plaque_index,v)
                    end
                end
                if #plaque_index > 0 then
                    local plaque = plaque_color(plaque_index)
                    if plaque then
                        return plaque
                    end
                end
                return false
            end
            -- 判断有无地图装置
            local function is_map_device(obj_list)
                if not obj_list or #obj_list == 0 then
                    return false
                end
                for _, i in ipairs(obj_list) do
                    if i.name_utf8 == game_str.MapDevice then
                        return true
                    end
                end
                return false
            end
            local map_device = is_map_device(current_map_info)
            -- 不在城区
            if not string.match(player_info.current_map_name_utf8,game_str.town) 
             and ( not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.hideout) or not map_device) then
                env.is_public_warehouse_plaque = true
                env.is_update_plaque = false
                poe2_api.dbgp("不在城区, 不强化碑牌")
                poe2_api.time_p("判断是否强化碑牌（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS      
            end
            if not bag_info or not next(bag_info) then
                poe2_api.dbgp("背包为空, 不强化碑牌")
                env.is_public_warehouse_plaque = true
                poe2_api.time_p("判断是否强化碑牌（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            -- if not env.is_have_stone then
            --     poe2_api.dbgp("没有可插的塔, 不强化碑牌")
            --     env.is_public_warehouse_plaque = true
            --     poe2_api.time_p("判断是否强化碑牌（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
            --     return bret.SUCCESS
            -- end
            local plaque = get_bag_plaque(bag_info)
            if not plaque then
                poe2_api.dbgp("背包没有需要强化的碑牌, 不强化碑牌")
                env.is_public_warehouse_plaque = true
                poe2_api.time_p("判断是否强化碑牌（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not env.is_update_plaque then
                poe2_api.dbgp("不需要强化碑牌")
                env.is_public_warehouse_plaque = true
                poe2_api.time_p("判断是否强化碑牌（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local config = env.user_config
            local text = ""
            if plaque.color == 0 and not poe2_api.table_contains(env.lack_of_currency,game_str.Greater_Orb_of_Transmutation_TWCH) then
                text = game_str.Greater_Orb_of_Transmutation_TWCH
            elseif plaque.color == 0 and not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Transmutation_TWCH) then
                text = game_str.Orb_of_Transmutation_TWCH
            elseif plaque.color == 1 and not poe2_api.table_contains(env.lack_of_currency,game_str.Greater_Orb_of_Augmentation_TWCH) then
                text = game_str.Greater_Orb_of_Augmentation_TWCH
            elseif iplaque.color == 1 and not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Augmentation_TWCH) then
                text = game_str.Orb_of_Augmentation_TWCH
            end
            
            if text then
                local items_info = poe2_api.get_items_config_info(config)
                local is_text = nil
                for _,item in ipairs(items_info) do
                    if item["類型"] == "通貨" and item['存倉頁名'] and not item["不撿"] and poe2_api.table_contains(item['基礎類型名'],text) then
                        is_text = item
                        break
                    end
                end
                if is_text then
                    if is_text["工會倉庫"] then
                        env.warehouse_type_interactive = game_str.Guild_Warehouse_text
                        env.is_public_warehouse_plaque = false
                    else
                        env.warehouse_type_interactive = game_str.Warehouse_text
                    end
                else
                    local unique_storage_pages = nil
                    for _,item in ipairs(items_info) do
                        if item["類型"] == "通貨" and item['存倉頁名'] and not item["不撿"] and item['基礎類型名'] == "全部物品" and not item["工會倉庫"] then
                            unique_storage_pages = item
                            break
                        end
                    end
                    if unique_storage_pages then
                        env.warehouse_type_interactive = game_str.Warehouse_text
                    else
                        env.warehouse_type_interactive = game_str.Guild_Warehouse_text
                        env.is_public_warehouse_plaque = false
                    end
                end
            end
            env.currency_name = text
            env.strengthened_map_obj = plaque
            poe2_api.time_p("判断是否强化碑牌（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end
    },

    -- 判断是否需要强化地图钥匙（腐化圣域）
    Is_Update_Map_Key = {
        run = function(self, env)
            poe2_api.print_log("判断是否需要强化地图钥匙（腐化圣域）...")
            local start_time = api_GetTickCount64() -- 开始时间
            local the_update_map = env.the_update_map
            -- local is_insert_stone = env.is_insert_stone
            local entry_length_take_map = env.entry_length_take_map
            local map_update_to =env.map_update_to
            local user_map = env.user_map
            local map_up = env.map_up
            local not_have_stackableCurrency = env.not_have_stackableCurrency
            -- if the_update_map then
            local map_level = poe2_api.select_best_map_key({inventory = env.bag_info,key_level_threshold=user_map,vall = true})
            if map_level then
                poe2_api.dbgp("map_update_to-->",4)
                if (map_level.color > 0 and map_level.fixedSuffixCount >= 4) or (next(env.lack_of_currency) and poe2_api.table_contains(env.lack_of_currency,game_str.Exalted_Orb_TWCH)) then
                    env.map_up = false
                    env.entry_length_take_map = false
                    env.the_update_map = nil
                end
            end
            -- end
            local map_up = env.map_up
            if not map_up then
                env.not_have_stackableCurrency = false
                poe2_api.time_p("    Is_Update_Map_Key(SUCCESS1)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not entry_length_take_map then
                env.not_have_stackableCurrency = false
                poe2_api.time_p("    Is_Update_Map_Key(SUCCESS2)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not env.player_info or not next(env.player_info) then
                poe2_api.time_p("    Is_Update_Map_Key(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            -- if not is_insert_stone then
            --     env.not_have_stackableCurrency = false
            --     poe2_api.time_p("    Is_Update_Map_Key(SUCCESS3)... 耗时 --> ", api_GetTickCount64() - start_time)
            --     return bret.SUCCESS
            -- end
            if not env.bag_info or not next(env.bag_info) then
                env.not_have_stackableCurrency = false
                env.entry_length_take_map = true
                poe2_api.time_p("    Is_Update_Map_Key(SUCCESS4)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not the_update_map then
                env.not_have_stackableCurrency = false
                env.entry_length_take_map = true
                poe2_api.time_p("    Is_Update_Map_Key(SUCCESS5)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if not_have_stackableCurrency then
                poe2_api.time_p("    Is_Update_Map_Key(SUCCESS6)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local config = env.user_config
            local items_info = poe2_api.get_items_config_info(config)
            local is_text = nil
            for _,item in ipairs(items_info) do
                if item["類型"] == "通貨" and item['存倉頁名'] and not item["不撿"] and poe2_api.table_contains(item['基礎類型名'],game_str.Exalted_Orb_TWCH) then
                    is_text = item
                    break
                end
            end
            if is_text then
                if is_text["工會倉庫"] then
                    env.warehouse_type_interactive = game_str.Guild_Warehouse_text
                    -- env.is_public_warehouse_plaque = false
                else
                    env.warehouse_type_interactive = game_str.Warehouse_text
                end
            else
                local unique_storage_pages = nil
                for _,item in ipairs(items_info) do
                    if item["類型"] == "通貨" and item['存倉頁名'] and not item["不撿"] and item['基礎類型名'] == "全部物品" and not item["工會倉庫"] then
                        unique_storage_pages = item
                        break
                    end
                end
                if unique_storage_pages then
                    env.warehouse_type_interactive = game_str.Warehouse_text
                else
                    env.warehouse_type_interactive = game_str.Guild_Warehouse_text
                    -- env.is_public_warehouse_plaque = false
                end
            end
            env.currency_name = game_str.Exalted_Orb_TWCH
            env.strengthened_map_obj = map_level
            poe2_api.time_p("    Is_Update_Map_Key(FAIL)... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end
    },

    -- 是否有激活的暗金保险箱
    Gameplay_Safe_Box = {
        run = function(self, env)
            poe2_api.print_log("访问游戏保险箱...")
            local start_time = api_GetTickCount64() -- 开始时间
            local player_info = env.player_info
            if not player_info or not next(player_info) then
                poe2_api.dbgp("访问游戏保险箱,玩家信息不存在")
                poe2_api.time_p("是否有激活的保险箱（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if not env.range_info or not next(env.range_info) then
                poe2_api.dbgp("访问游戏保险箱,周围对象信息不存在")
                poe2_api.time_p("是否有激活的保险箱（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if env.afoot_altar then
                poe2_api.time_p("是否有激活的保险箱（FAIL3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            if env.player_info.current_map_name_utf8 == game_str.Abyss_Pinnacle_MDANA then
                poe2_api.dbgp("在深渊地图跳出")
                poe2_api.time_p("是否有激活的保险箱（FAIL6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            if poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.Citadel_map) and poe2_api.find_text({UI_info = env.UI_info, text = game_str.Map_completed_TWCH}) then
                env.afoot_box = nil
                env.box_target = nil
                poe2_api.time_p("是否有激活的保险箱（FAIL33333333）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            local current_map_info = env.current_map_info
            -- -- 判断有无地图装置
            -- local function is_map_device(obj_list)
            --     if not obj_list or #obj_list == 0 then
            --         return false
            --     end
            --     for _, i in ipairs(obj_list) do
            --         if i.name_utf8 == game_str.MapDevice then
            --             return true
            --         end
            --     end
            --     return false
            -- end
            -- local map_device = is_map_device(current_map_info)
            -- -- 在城区
            -- if  string.match(player_info.current_map_name_utf8,game_str.town) 
            --  or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.hideout) and map_device) then
            --     env.afoot_box = nil
            --     poe2_api.dbgp("在城区, 无玩法保险箱")
            --     return bret.SUCCESS      
            -- end
            local function get_box()
                for _, v in ipairs(env.range_info) do
                    -- if v.name_utf8 ~= "" then
                    --     poe2_api.dbgp("v.name_utf8",v.name_utf8)
                    --     poe2_api.dbgp("v.type",v.type)
                    --     poe2_api.dbgp("v.rarity",v.rarity)
                    --     poe2_api.dbgp("v.started",v.stateMachineList["started"])
                    --     poe2_api.dbgp("v.opened",v.stateMachineList["opened"])
                    -- end
                    -- and not poe2_api.table_contains(v.name_utf8,{"研究者的保險箱","護甲鍛造師的保險箱","保險箱"})
                    if string.find(v.path_name_utf8,game_str.StrongBoxes_PATH) 
                    --  and v.type == -1
                     and poe2_api.table_contains(v.type,{-1,6})    
                     and (v.rarity ~= 3 or (v.rarity == 3 and v.name_utf8 ~= game_str.The_Researcher_Safe_Box_TWCH))
                     and v.stateMachineList[game_str.started_SML] == 1 
                     and v.stateMachineList[game_str.opened_SML] == 0 and not poe2_api.table_contains(env.not_box_list,v.id) then
                        return v
                    end
                end
                return false
            end
            if not env.afoot_box then
                local is_box = get_box()
                if not is_box then
                    poe2_api.dbgp("周围无激活玩法保险箱")
                    -- env.center_radius = 0
                    -- env.center_point = {}
                    env.afoot_box = nil
                    env.box_target = nil
                    poe2_api.time_p("是否有激活的保险箱（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                end
                env.afoot_box = is_box
                return bret.RUNNING
            -- local is_box = get_box()
            -- if not is_box then
            --     poe2_api.dbgp("周围无激活玩法保险箱")
            --     env.center_radius = 0
            --     env.center_point = {}
            --     env.afoot_box = nil
            --     poe2_api.time_p("是否有激活的暗金保险箱（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            --     return bret.FAIL
            else
                -- 判断怪物
                local function is_monster(data)
                    local mate = data.mate
                    local distance = data.distance
                    if distance > env.min_attack_dis then
                        distance = env.min_attack_dis  
                    end
                    for _, v in ipairs(env.range_info) do
                        if v.type == 1 and not v.is_friendly and v.life > 0
                         and not poe2_api.table_contains(v.name_utf8,my_game_info.not_attact_mons_CN_name)
                         and v.isActive and not string.find(v.name_utf8,game_str.temple) and v.hasLineOfSight and v.is_selectable then
                            local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                            if dis and dis < distance then
                                return true
                            end 
                        end
                    end
                end
                local distance = poe2_api.point_distance(env.afoot_box.grid_x,env.afoot_box.grid_y,player_info)
                if distance and distance < 150 then
                    local a = false
                    for i, v in ipairs(env.range_info) do
                        if v.stateMachineList[game_str.started_SML] == 1 and v.stateMachineList[game_str.opened_SML] == 0 then
                            env.afoot_box = v
                            a = true
                            break
                        end
                    end
                    if not a then
                        env.afoot_box = nil
                        env.box_target = nil
                        poe2_api.dbgp("周围无激活玩法保险箱")
                        return bret.RUNNING
                    end
                end
                -- if distance > 100 and is_monster({mate = player_info,distance = 70}) then
                if is_monster({mate = player_info,distance = 70}) then
                    -- env.center_radius = 0
                    -- env.center_point = {}
                    env.afoot_box_bool = false
                    poe2_api.time_p("是否有激活的保险箱（FAIL2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                end
                -- env.afoot_box = is_box
                poe2_api.time_p("是否有激活的保险箱（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
        end
    },

    -- 是否需要移动玩法保险箱
    Is_Move_Safe_Box = {
        run = function(self, env)

            poe2_api.print_log("移动到玩法保险箱...")
            if not env.afoot_box_bool then
                self.box_time = 0
                self.box_id = nil
                env.afoot_box_bool = true
            end
            local start_time = api_GetTickCount64() -- 开始时间
            local function get_box_target()
               for _, v in ipairs(env.range_info) do
                    if poe2_api.table_contains(v.type,{1,3}) and not v.is_friendly and v.life > 0
                        and not poe2_api.table_contains(v.name_utf8,my_game_info.not_attact_mons_CN_name)
                        and not string.find(v.name_utf8,game_str.temple)
                        and next(v.stateMachineList) and v.stateMachineList[game_str.EPK_SML] then
                        return v
                    end
               end 
               return false
            end
            local function get_record_box_target()
                for _, v in ipairs(env.range_info) do
                    if v.id == env.box_target.id and v.life > 0 then
                        return v
                    end
                end
                return false
            end
            if not env.box_target then
                local target = get_box_target()
                if target then
                    env.box_target = target
                    env.end_point = {target.grid_x,target.grid_y}
                    env.afoot_box_bool = false
                    poe2_api.time_p("是否需要移动玩法保险箱（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
            else
                local dis = poe2_api.point_distance(env.box_target.grid_x,env.box_target.grid_y,env.player_info)
                if dis and dis < 80 then
                    local target = get_record_box_target()
                    if target then
                        env.box_target = target
                        env.end_point = {target.grid_x,target.grid_y}
                        env.afoot_box_bool = false
                        poe2_api.time_p("是否需要移动玩法保险箱（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.SUCCESS
                    else
                        env.box_target = nil
                        return bret.RUNNING
                    end
                else
                    local target = get_record_box_target()
                    if target then
                        poe2_api.printTable(target)
                        env.box_target = target
                        env.end_point = {target.grid_x,target.grid_y}
                        env.afoot_box_bool = false
                        poe2_api.time_p("是否需要移动玩法保险箱（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.SUCCESS
                    end
                    poe2_api.printTable(env.box_target)
                    local dis = poe2_api.point_distance(env.box_target.grid_x,env.box_target.grid_y,env.player_info)
                    poe2_api.dbgp("距离：",dis)
                    env.end_point = {env.box_target.grid_x,env.box_target.grid_y}
                    env.afoot_box_bool = false
                    poe2_api.time_p("是否需要移动玩法保险箱（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end 
            end
            local dis = poe2_api.point_distance(env.afoot_box.grid_x,env.afoot_box.grid_y,env.player_info)
            if dis and dis <= 50 then
                if not self.box_id then
                    self.box_id = env.afoot_box.id
                    self.box_time = api_GetTickCount64()
                end
                if self.box_id ~= env.afoot_box.id then
                    self.box_id = env.afoot_box.id
                    self.box_time = api_GetTickCount64()
                end
                if self.box_time ~= 0 and api_GetTickCount64() - self.box_time >= 5000 then
                    table.insert(env.not_box_list,env.afoot_box.id)
                    env.afoot_box = nil
                end
                
                return bret.RUNNING
            end
            env.end_point = {env.afoot_box.grid_x,env.afoot_box.grid_y}
            poe2_api.time_p("是否需要移动玩法保险箱（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS

        end
    },

    -- 检查是否到达点(别名)
    Is_Arrive = {
        run = function(self, env)
            poe2_api.print_log("检查是否到达目标点(Is_Arrive)...")
            poe2_api.dbgp("正在前往目标点...111111")
            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            local is_arrive_end_dis = 15 -- 默认值

            if player_info.life == 0 then
                env.end_point = nil
                env.run_point = nil
                env.path_list = nil
                env.is_arrive_end = false
                env.target_point = {}
                -- return bret.FAIL
                poe2_api.dbgp("正在前往目标点...111222")
                return bret.RUNNING
            end
            
            -- 检查空路径
            if env.empty_path then
                env.is_arrive_end = true
                env.empty_path = false
                -- return bret.SUCCESS
                poe2_api.dbgp("正在前往目标点...111111")
                return bret.RUNNING
            end
            
            -- 检查是否到达终点
            local point = env.end_point
            poe2_api.printTable(point)
            if point and #point > 0 then
                local path_list = env.path_list
                if path_list ~= nil and next(path_list) ~= nil and next(path_list) > 2 then
                    -- poe2_api.time_p("检查是否到达目标点(Is_Arrive)(SUCCESS2)... 耗时 --> ", api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                end
                dis = poe2_api.point_distance(point[1], point[2], player_info)
                if api_HasObstacleBetween(point[1], point[2]) and dis and ( dis < is_arrive_end_dis ) then
                    poe2_api.dbgp1("有路径，有射线")
                    env.is_arrive_end = true
                    env.end_point = nil
                    env.path_list = nil
                    env.run_point = nil
                    poe2_api.time_p("检查是否到达目标点(Is_Arrive)(RUNNING1)... 耗时 --> ", api_GetTickCount64() - current_time)
                    return bret.RUNNING
                end
                poe2_api.dbgp("dis11===",dis)
                env.is_arrive_end = false
                poe2_api.time_p("检查是否到达目标点(Is_Arrive)(SUCCESS2)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            else
                env.is_arrive_end = false
                env.path_list = nil
                poe2_api.time_p("检查是否到达目标点(mydian)(RUNNING)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.RUNNING
            end
        end
    },

    -- 获取路径
    GET_Path = {
        initialize = function(self)
            self.last_point = nil
            self.FAIL_count = 0 -- 路径计算失败计数器
        end,

        run = function(self, env)
            poe2_api.print_log("获取路径...")
            local start_current_time = api_GetTickCount64()

            local player_info = env.player_info
            

            -- 辅助函数：检测祭坛
            -- local function get_altar(range_info)
            --     for _, entity in ipairs(env.range_info) do
            --         if entity.path_name_utf8 ==
            --             game_str.Ritual_PATH and
            --             entity.stateMachineList.current_state == 2 and
            --             entity.stateMachineList.interaction_enabled == 0 then
            --             return entity
            --         end
            --     end
            --     return nil
            -- end
            
            -- 检查终点是否存在
            local point = env.end_point
            poe2_api.dbgp("终点")
            poe2_api.printTable(env.end_point)
            if not point or not next(point) then
                poe2_api.dbgp("[GET_Path] 错误：未设置终点")
                return bret.FAIL
            end

            -- 如果已有路径，使用下一个路径点
            local path_list = env.path_list
            
            if path_list and #path_list > 1 then
                poe2_api.dbgp("路径点数env.path_list: ", #env.path_list)

                local dis = poe2_api.point_distance(path_list[1].x, path_list[1].y, player_info)
                local sight = api_HasObstacleBetween(path_list[1].x, path_list[1].y)
                if dis and dis < 20 and sight then
                    env.target_point = {path_list[1].x, path_list[1].y}
                    -- poe2_api.dbgp("len 5465 移除已使用的点")
                    -- table.remove(path_list, 1) -- 移除已使用的点
                end
                poe2_api.time_p("已有路径(SUCCESS) 耗时 -->", api_GetTickCount64() - start_current_time)
                return bret.SUCCESS
            end
            
            -- 计算最近可到达的点
            point = api_FindNearestReachableInRange(point[1],point[2], 50, 0)
            poe2_api.dbgp("计算最近可到达的点")
            poe2_api.dbgp(point.x, point.y)
            poe2_api.dbgp("yuasnhi")
            poe2_api.dbgp(env.end_point[1],env.end_point[2])

            -- 计算起点
            player_position = api_FindNearestReachableInRange(player_info.grid_x, player_info.grid_y, 50, 0)

            local result = api_FindPath(player_position.x, player_position.y, point.x, point.y)
            poe2_api.time_p("计算路径成功 耗时 -->", api_GetTickCount64() - start_current_time,"两点：{"..player_position.x..","..player_position.y.."} -> {"..point.x..","..point.y.."}")
            
            if result and #result > 0 then
                -- 处理路径结果
                local result_start_current_time = api_GetTickCount64()
                local skip_point = 18
                if poe2_api.table_contains(env.player_info.current_map_name_utf8, my_game_info.hideout) then
                    skip_point = 10
                end
                result = poe2_api.extract_coordinates(result, skip_point)
                if #result > 1 then
                    table.remove(result, 1) -- 移除起点
                    poe2_api.dbgp("移除起点")
                    env.path_list = result
                    env.target_point = {result[1].x, result[1].y}
                    -- table.insert(result, {x = env.end_point[1], y = env.end_point[2]}) -- 替换end_x,end_y为实际坐标
                    table.insert(result, {x = env.end_point[1], y = env.end_point[2]}) -- 替换end_x,end_y为实际坐标

                    poe2_api.dbgp("[GET_Path] 路径计算成功，点数: ", #result)
                end
                poe2_api.time_p("处理路径结果 耗时 -->", api_GetTickCount64() - result_start_current_time)
                return bret.SUCCESS
            else
                -- 路径计算失败处理
                -- 找黑雾祭坛
                local function get_altar(range_info)
                    if not range_info or not next(range_info) then
                        return false
                    end
                    for _, i in ipairs(range_info) do
                        if i.path_name_utf8 and i.path_name_utf8 ~= "" and string.find(game_str.Ritual_PATH,i.path_name_utf8) then
                            -- local stateMachineList = i:GetStateMachineList()
                            if i.stateMachineList and next(i.stateMachineList) then
                                local current_state = (i.stateMachineList or {}).current_state or 5
                                local interaction_enabled = (i.stateMachineList or {}).interaction_enabled or 5
                                if current_state == 2 and interaction_enabled == 0 then
                                    return i
                                end
                            end
                            
                        end
                    end
                    return false
                end
                -- 路径计算失败处理
                -- local altar = get_altar(env.range_info)
                -- if altar then
                --     if poe2_api.point_distance(altar.grid_x, altar.grid_y,player_info) > 110 then
                api_RestoreOriginalMap()

                if not string.find(player_info.current_map_name_utf8,game_str.Abyss) then
                    api_UpdateMapObstacles(100)
                end

                if string.find(player_info.current_map_name_utf8, game_str.Delirium_) then
                    -- api_UpdateMapObstacles(1000)
                    api_UpdateMapInfo()
                end
                --     end
                -- else
                --     api_RestoreOriginalMap()
                -- end
                if self.FAIL_count == nil then
                    self.FAIL_count = 0
                end
                self.FAIL_count = self.FAIL_count + 1
                env.find_path_FAIL = self.FAIL_count
                if next(env.target_point_sort_list) then
                    table.remove(env.target_point_sort_list, 1)
                end
                poe2_api.dbgp("[GET_Path] 错误：找不到路径 --> " , point[1], ",", point[2])
                -- player_position = api_FindNearestReachableInRange(player_info.grid_x, player_info.grid_y, 50, 0)
                -- api_ClickMove(poe2_api.toInt(player_position.x), poe2_api.toInt(player_position.y), poe2_api.toInt(player_info.world_z), 7)
                -- poe2_api.dbgp1("BFDSXBFDBSDBGSDFB")
                -- poe2_api.click_keyboard("space")
                -- poe2_api.time_p("错误：找不到路径 耗时 -->", api_GetTickCount64() - start_current_time)
                -- poe2_api.print_log("清路径777")
                -- env.path_list = nil
                -- env.target_point = {}
                -- env.is_arrive_end = true
                -- env.end_point = nil
                return bret.RUNNING
            end
        end
    },

    -- 点击移动
    Move_To_Target_Point = {
        run = function(self, env)
            -- 初始化逻辑直接放在 run 函数开头
            poe2_api.dbgp("点击移动 节点...")
            local start_time = api_GetTickCount64()
            
            if not self.last_move_time then
                poe2_api.dbgp("初始化 Move_To_Target_Point 节点...")
                self.last_move_time = api_GetTickCount64()
                self.last_point = nil
                return bret.RUNNING  -- 初始化后返回 RUNNING，等待下一帧继续执行
            end

            -- 正常执行移动逻辑
            poe2_api.dbgp("移动到目标点...")
            local point = env.target_point
            if not point then 
                poe2_api.dbgp("[Move_To_Target_Point] 错误：未设置目标点")
                return bret.RUNNING
            end
    
            local player_info = env.player_info
            if not player_info then
                poe2_api.dbgp("[Move_To_Target_Point] 错误：未设置玩家信息")
                return bret.RUNNING
            end
    
            
            -- 检查终点是否变化
            local end_point = env.end_point
            if not self.last_point and end_point then
                poe2_api.dbgp("设置last_point")
                self.last_point = end_point
            end
            
            -- 如果终点变化超过阈值，重置路径
            if self.last_point and end_point and env.path_list then
                local last_path_point = env.path_list[#env.path_list]
                local dis = poe2_api.point_distance(
                    self.last_point[1], self.last_point[2],
                    {end_point[1], end_point[2]}
                )
                if dis and dis > 25 then
                    self.last_point = end_point
                    poe2_api.print_log("清路径888")
                    env.path_list = nil
                    env.target_point = {}
                    env.is_arrive_end = true
                    env.end_point = nil
                    poe2_api.time_p("执行移动(RUNNING1) 耗时 -->", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end

            local current_time = api_GetTickCount64()
            local move_interval = math.random() * 0.2 + 0.2  -- 随机间隔 0.1~0.2 秒
            
            -- 如果终点变化超过阈值，重置路径
            if self.last_point and end_point and env.path_list then
                local last_path_point = env.path_list[#env.path_list]
                local dis = poe2_api.point_distance(
                    self.last_point[1], self.last_point[2],
                    {end_point[1], end_point[2]}
                )
                if dis and dis > 25 then
                    self.last_point = end_point
                    poe2_api.print_log("清路999")
                    env.path_list = nil
                    env.target_point = {}
                    env.is_arrive_end = true
                    env.end_point = nil
                    poe2_api.time_p("执行移动(RUNNING2) 耗时 -->", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            
            -- 执行移动（按时间间隔）
            if current_time - self.last_move_time >= move_interval * 800 then
                if point then
                    local dis = poe2_api.point_distance(point[1], point[2], player_info)
                    poe2_api.dbgp(point[1], ",", point[2], ",", dis)
                    poe2_api.dbgp("player_info -->", player_info.grid_x, ",", player_info.grid_y)
                    if dis and dis > 70 then
                        poe2_api.print_log("清路径10101")
                        env.path_list = nil
                        env.target_point = {}
                        env.is_arrive_end = true
                        env.end_point = nil
                        poe2_api.time_p("执行移动(RUNNING3) 耗时 -->", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    -- api_ClickMove(poe2_api.toInt(point[1]), poe2_api.toInt(point[2]), poe2_api.toInt(player_info.world_z), 0)
                    -- poe2_api.dbgp("-------")
                    poe2_api.dbgp("----点击移动----")
                    if not api_ClickMove(poe2_api.toInt(point[1]), poe2_api.toInt(point[2]), 7) then
                        poe2_api.dbgp("----点击移动失败----")
                        env.path_list = nil
                        env.target_point = {}
                        env.is_arrive_end = true
                        env.end_point = nil
                        poe2_api.time_p("执行移动(RUNNING6) 耗时 -->", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    poe2_api.dbgp("----点击移动---- 耗时 -->", api_GetTickCount64() - start_time)
                    if not string.find(player_info.current_map_name_utf8,game_str.Claimable_EN) and not string.find(player_info.current_map_name_utf8,game_str.Delirium_) then
                        api_SetExplorationArea(env.radius)
                    end

                    self.last_move_time = current_time
                end
            end

            -- 检查是否到达目标点
            if point then
                local dis = poe2_api.point_distance(point[1], point[2], player_info)
                poe2_api.dbgp("检查是否到达目标点距离：", dis)
                poe2_api.dbgp("player_info---->>", player_info.grid_x, ",", player_info.grid_y)

                local skip_dis = 25
                -- if string.find(env.player_info.current_map_name_utf8,game_str.Abyss_Boss_EN) then
                --     skip_dis = 8
                -- end

                if dis and dis < skip_dis then
                    if env.path_list and #env.path_list > 0 then
                        env.target_point = {env.path_list[1].x, env.path_list[1].y}
                        -- poe2_api.dbgp("len 5604 移除已使用的点")
                        table.remove(env.path_list, 1)
                    end
                    poe2_api.time_p("执行移动(RUNNING4) 耗时 -->", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            poe2_api.time_p("执行移动 耗时 -->", api_GetTickCount64() - start_time)
            return bret.RUNNING
        end
    },

    -- 点击队长传送
    Click_Leader_To_Teleport = {
        run = function(self, env)
            poe2_api.dbgp("点击队长传送...")
            local player_info = env.player_info
            local UI_info = env.UI_info
            local current_map_info = env.current_map_info

            local leaders = poe2_api.check_pos_dis(env.leader_name, env.range_info, env.player_info)

            local leader_area = poe2_api.party_pos(env.leader_name,env.team_info)
            poe2_api.dbgp("player_info.current_map_name_utf8 -->", player_info.current_map_name_utf8)
            poe2_api.dbgp("leader_area -->", leader_area)
            poe2_api.dbgp("leaders -->", leaders)
            poe2_api.dbgp("env.leader_name -->", env.leader_name)
            poe2_api.printTable(env.team_info)
            if poe2_api.find_text({text = game_str.Are_you_sure_you_want_to_teleport_to_this_player_location_TWCH, UI_info = UI_info, min_x = 0}) then
                poe2_api.dbgp(game_str.Are_you_sure_you_want_to_teleport_to_this_player_location_TWCH)
                if env.player_info.isInBossBattle then
                    env.need_SmallRetreat = true
                    env.initiative_SmallRetreat = true
                end
                poe2_api.find_text({text = game_str.confirm, UI_info = UI_info, min_x = 0, click = 2})
                api_Sleep(1000)
                return bret.RUNNING
            end

            -- 辅助函数定义
            local function check_in_map()
                if not current_map_info then
                    return nil
                end
                for _, k in ipairs(current_map_info) do
                    if k.name_utf8 == game_str.MapDevice and k.flagStatus == 0 and k.flagStatus1 == 1 and k.grid_x ~= 0 and k.grid_y ~= 0 then
                        return k
                    end
                end
                return nil
            end

            local function check_in_range()
                for _, k in ipairs(env.range_info) do
                    if k.name_utf8 == game_str.MapDevice_TWCH or k.name_utf8 == game_str.Map_Device_CH then
                        return k
                    end
                end
                return nil
            end

            -- 获取符合条件的非地图物品（传送点/异界之门除外）
            local function get_not_map(num)
                num = num or 1
                local valid_items = {}
                
                for _, item in ipairs(env.range_info) do
                    if item.type == 5 and item.name_utf8 ~= '' and item.name_utf8 ~= game_str.Transfer_point_CH and item.name_utf8 ~= game_str.The_Gate_of_the_Outland_CH then
                        table.insert(valid_items, item)
                    end
                end
                
                -- 检查是否达到阈值数量
                if #valid_items < num then
                    return false
                end
                
                -- 按距离排序，返回最近的物品
                if #valid_items > 0 then
                    table.sort(valid_items, function(a, b)
                        a_dis = poe2_api.point_distance(a.grid_x, a.grid_y, player_info)
                        b_dis = poe2_api.point_distance(b.grid_x, b.grid_y, player_info)
                        if a_dis and b_dis then
                            return a_dis < b_dis
                        else
                            return false
                        end
                    end)
                    
                    -- -- 打印排序后的结果（调试用）
                    -- for i, item in ipairs(valid_items) do
                    --     local distance = poe2_api.point_distance(item.grid_x, item.grid_y, player_info)
                    --     poe2_api.dbgp(string.format("[dbgp] #%d: %s 距离=%.2f", i, item.name_utf8, distance))
                    -- end
                    
                    return valid_items[1]
                end
                
                return false
            end

            
            if poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout) and (player_info.current_map_name_utf8 == leader_area or leaders ~= nil) then
                poe2_api.dbgp("当前地图与队长地图一致,在藏身处")

                local map_device = check_in_map() or check_in_range()
                if map_device then
                    local distance = poe2_api.point_distance(map_device.grid_x, map_device.grid_y, player_info)
                    if distance and distance > 25 then
                        env.end_point = {map_device.grid_x, map_device.grid_y}
                        return bret.SUCCESS
                    end
                end

                return bret.RUNNING
            elseif player_info.current_map_name_utf8 == leader_area or leaders ~= nil then
                poe2_api.dbgp("当前地图与队长地图一致")
                return bret.FAIL
            elseif leader_area and string.find(leader_area,game_str.Abyss) then
                poe2_api.dbgp("队长在深渊地图")
                return bret.FAIL
            elseif poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout)  then
                local items = get_not_map()
                local click_counter = 0
                local player_info = env.player_info 
                if items and not poe2_api.table_contains({items.name_utf8}, not_enter_map) and not poe2_api.table_contains({items.name_utf8}, my_game_info.hideout) then
                    return bret.FAIL
                end
            end

            if poe2_api.find_text({UI_info = env.UI_info, text = game_str.Return_to_the_surface_TWCH,min_x = 0,min_y = 0,add_x = -50, click = 2}) then
                api_Sleep(1000)
                return bret.RUNNING
            end

            -- local leader_area_name = poe2_api.task_area_list_data(leader_area)[1][2]

            -- if poe2_api.find_text({text = leader_area_name, UI_info = UI_info, min_x = 0, min_y = 0, max_x = 195, max_y = 590}) then
            if poe2_api.find_text({text = game_str.Are_you_sure_you_want_to_teleport_to_this_player_location_TWCH, UI_info = UI_info, min_x = 0}) then
                poe2_api.dbgp(game_str.Are_you_sure_you_want_to_teleport_to_this_player_location_TWCH)
                if env.player_info.isInBossBattle then
                    env.need_SmallRetreat = true
                    env.initiative_SmallRetreat = true
                end
                poe2_api.find_text({text = game_str.confirm, UI_info = UI_info, min_x = 0, click = 2})
                api_Sleep(1000)
                return bret.RUNNING
            end
            local leader_teleport_point = poe2_api.find_text({text = env.leader_name, UI_info = UI_info, min_x = 75, min_y = 0, max_x = 400, max_y = 666, position = 3})
            if leader_teleport_point then
                poe2_api.dbgp("找到队长传送点")
                local rand_x = 14 + math.random(-7, 7)
                local rand_y = leader_teleport_point[2] + 21 + math.random(-7, 7)
                api_ClickScreen(poe2_api.toInt(rand_x), poe2_api.toInt(rand_y), 1)
                api_Sleep(800)
                return bret.RUNNING
            end
            -- end
            poe2_api.dbgp("未找到队长")
            return bret.RUNNING 
        end
    },

    -- 点击队长传送
    Check_Leader_Position = {
        run = function(self, env)
            poe2_api.dbgp("检查大号位置...")
            local leaders = poe2_api.check_pos_dis(env.leader_name, env.range_info, env.player_info, true)
            local current_time = api_GetTickCount64()
            local player_info = env.player_info

            if leaders ~= nil then
                env.center_radius = 100
                env.center_point = {leaders[2][1], leaders[2][2]}
                if leaders[1] > 60 then
                    poe2_api.dbgp("11111111111")
                    poe2_api.dbgp(leaders[2][1], leaders[2][2])
                    -- poe2_api.printTable(leaders[2])
                    env.end_point = {leaders[2][1], leaders[2][2]}
                    return bret.SUCCESS
                elseif leaders[1] < 25 then
                    if not self.last_move_time then
                        self.last_move_time = api_GetTickCount64()
                        return bret.RUNNING
                    end
                    if current_time - self.last_move_time >= 3000 then
                        local point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 50)
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), 7)
                        end
                        api_Sleep(500)
                        poe2_api.click_keyboard("space")
                    end
                    return bret.RUNNING
                else
                    poe2_api.dbgp("3434334")
                    if not self.last_move_time then
                        self.last_move_time = api_GetTickCount64()
                        return bret.RUNNING
                    end
                    local move_interval = math.random() * 0.2 + 0.2  -- 随机间隔 0.1~0.2 秒
                    if current_time - self.last_move_time >= move_interval * 1000 then
                        api_ClickMove(poe2_api.toInt(leaders[2][1]), poe2_api.toInt(leaders[2][2]), 7)
                        self.last_move_time = current_time
                    end
                    poe2_api.dbgp("22222222")
                    return bret.RUNNING 
                end
            else
                poe2_api.dbgp("00000000000000000000000")
                local leader_info = nil
                for _, i in ipairs(env.team_info) do
                    if i.name_utf8 == env.leader_name then
                        leader_info = i
                    end
                end

                -- poe2_api.printTable(leader_info)

                if self.last_action_time == nil then
                    self.last_action_time = api_GetTickCount64()
                    self.action_interval = 1000
                    self.false_times = 0
                    self.is_wait = false
                    self.dq = 0
                end
                
                if leader_info ~= nil then
                    poe2_api.dbgp("00001")
                    if string.find(leader_info.current_map_name_utf8,game_str.Abyss) then
                        poe2_api.dbgp("00002")
                        local mini_map = nil
                        for _, item in ipairs(env.current_map_info) do
                            if string.find(item.name_utf8,game_str.Abyss) and item.flagStatus1 == 1 and not env.is_abyss_complete then
                                if not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) or (poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.PRIORITY_MAPS) and not poe2_api.find_text({text = game_str.Map_completed_TWCH})) then
                                    poe2_api.dbgp("小地图对象中深渊入口")
                                    mini_map = item
                                    break
                                end
                            end
                        end

                        local range_map = nil
                        for _, item in ipairs(env.range_info) do
                            if item.path_name_utf8 == game_str.AbyssSubAreaTransition_PATH then
                                poe2_api.dbgp("周围对象")
                                range_map = item 
                                break
                            end
                        end

                        -- 最终使用的深渊入口对象
                        local abyss_entrance = range_map or mini_map

                        poe2_api.printTable(abyss_entrance)
                        poe2_api.printTable(range_map)
                        poe2_api.printTable(mini_map)
                        
                        -- 在这里继续你的逻辑，使用 abyss_entrance 变量
                        if abyss_entrance then
                            local entrance_dis = poe2_api.point_distance(abyss_entrance.grid_x, abyss_entrance.grid_y, player_info)
                            if entrance_dis and entrance_dis > 25 then
                                env.end_point = {abyss_entrance.grid_x, abyss_entrance.grid_y}
                                return bret.SUCCESS
                            else
                                poe2_api.find_text({UI_info = env.UI_info, text = abyss_entrance.name_utf8, click = 2})
                                return bret.RUNNING
                            end
                        else
                            if current_time - self.last_action_time >= 10 then
                                point = api_GetUnexploredArea(120)
                                -- poe2_api.dbgp("radius -- > ", 120)
                                -- poe2_api.dbgp("point -- > ", point.x, "--", point.y)
                                -- poe2_api.dbgp("env.have_ritual -- > ", env.have_ritual)
                                if point.x ~= -1 and point.y ~= -1 then
                                    poe2_api.dbgp("探索找深渊========================================")
                                    env.is_map_complete = false
                                    env.end_point = {point.x, point.y}
                                    env.is_arrive_end = false
                                    self.last_action_time = current_time
                                    poe2_api.time_p("检查目标点(SUCCESS) 耗时 -->", api_GetTickCount64() - current_time)
                                    return bret.SUCCESS
                                end
                            end
                        end
                    end
                end
            -- elseif poe2_api.table_contains(env.player_info.current_map_name_utf8,my_game_info.hideout) then
            --     return bret.FAIL
            end
            poe2_api.dbgp("检查大号位置失败")
            return bret.RUNNING 
        end
    },

    -- 跟随交互
    Follow_Interactive = {
        run = function(self, env)
            poe2_api.print_log("跟随交互...")

            if not poe2_api.table_contains(env.player_info.current_map_name_utf8,my_game_info.hideout) then
                return bret.FAIL 
            end

            -- 获取符合条件的非地图物品（传送点/异界之门除外）
            local function get_not_map(num)
                num = num or 1
                local valid_items = {}
                
                for _, item in ipairs(env.range_info) do
                    if item.type == 5 and item.name_utf8 ~= '' and item.name_utf8 ~= game_str.Transfer_point_CH and item.name_utf8 ~= game_str.The_Gate_of_the_Outland_CH then
                        table.insert(valid_items, item)
                    end
                end
                
                -- 检查是否达到阈值数量
                if #valid_items < num then
                    return false
                end
                
                -- 按距离排序，返回最近的物品
                if #valid_items > 0 then
                    table.sort(valid_items, function(a, b)
                        a_dis = poe2_api.point_distance(a.grid_x, a.grid_y, player_info)
                        b_dis = poe2_api.point_distance(b.grid_x, b.grid_y, player_info)
                        if a_dis and b_dis then
                            return a_dis < b_dis
                        else
                            return false
                        end
                    end)
                    
                    -- -- 打印排序后的结果（调试用）
                    -- for i, item in ipairs(valid_items) do
                    --     local distance = poe2_api.point_distance(item.grid_x, item.grid_y, player_info)
                    --     poe2_api.dbgp(string.format("[dbgp] #%d: %s 距离=%.2f", i, item.name_utf8, distance))
                    -- end
                    
                    return valid_items[1]
                end
                
                return false
            end

            local items = get_not_map()
            local click_counter = 0
            local player_info = env.player_info 
            env.click_grid_pos = true
            if items and not poe2_api.table_contains({items.name_utf8}, not_enter_map) and not poe2_api.table_contains({items.name_utf8}, my_game_info.hideout) then
                poe2_api.dbgp("items: ", items.name_utf8)

                if poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0}) or 
                poe2_api.find_text({UI_info = env.UI_info, text = game_str.Destroy_three_similar_items_and_recast_them_into_a_new_one, min_x = 0}) then
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.World_map, min_x = 0, click = 2, add_x = 216})
                    env.click_grid_pos = true
                    return bret.RUNNING
                end

                dis = poe2_api.point_distance(items.grid_x, items.grid_y, player_info)
                if dis and dis > 30 then
                    env.end_point = {items.grid_x, items.grid_y}
                    return bret.SUCCESS
                else
                    env.enter_map_click_counter = click_counter + 1
                    if env.click_grid_pos then
                        api_ClickMove(poe2_api.toInt(items.grid_x), poe2_api.toInt(items.grid_y), 1, items.world_z)
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    
                    if player_info.isMoving then
                        poe2_api.dbgp("等待静止")
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    poe2_api.find_text({UI_info = env.UI_info, text = items.name_utf8, click = 2, sorted = true, min_x = 0})
                    api_Sleep(1000)
                    if not poe2_api.find_text({UI_info = env.UI_info, text = items.name_utf8, click = 2, sorted = true, min_x = 0}) then
                        api_ClickMove(poe2_api.toInt(items.grid_x), poe2_api.toInt(items.grid_y), 1, items.world_z)
                        api_Sleep(1000)
                    end
                    
                    return bret.RUNNING
                end
            end
            return bret.FAIL 
        end
    },

    -- 是否补满碑牌词缀
    Is_Monument_Tablet = {
        run = function(self, env)
            
            poe2_api.print_log("是否补满碑牌词缀...")
            local start_time = api_GetTickCount64()
            if not env.tower_do or not env.store then
                poe2_api.dbgp("不需要造碑牌")
                return bret.SUCCESS
            end
            -- local is_insert_stone = env.is_insert_stone
            -- if not is_insert_stone then
            --     poe2_api.dbgp("未开启插碑，不判断")
            --     poe2_api.time_p("判断是否强化碑牌（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
            --     return bret.SUCCESS
            -- end
            local player_info = env.player_info
            local bag_info = env.bag_info
            local current_map_info = env.current_map_info
            if not player_info or not next(player_info) then
                poe2_api.dbgp("玩家信息为空,判断强化碑牌")
                poe2_api.time_p("判断是否强化碑牌（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            -- 判断背包是否有需要强化的碑牌
            local function get_bag_plaque(bag_info)
                local function plaque_color(plaque_info)
                    for _, i in ipairs(plaque_info) do
                        if i.color == 0 or (i.color == 1 and i.fixedSuffixCount < 2) then
                            if not next(env.lack_of_currency)  then
                                return i

                            else
                                local text = nil
                                if i.color == 0 and not poe2_api.table_contains(env.lack_of_currency,game_str.Greater_Orb_of_Transmutation_TWCH) then
                                    text = game_str.Greater_Orb_of_Transmutation_TWCH
                                elseif i.color == 0 and not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Transmutation_TWCH) then
                                    text = game_str.Orb_of_Transmutation_TWCH
                                elseif i.color == 1 and not poe2_api.table_contains(env.lack_of_currency,game_str.Greater_Orb_of_Augmentation_TWCH) then
                                    text = game_str.Greater_Orb_of_Augmentation_TWCH
                                elseif i.color == 1 and not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Augmentation_TWCH) then
                                    text = game_str.Orb_of_Augmentation_TWCH
                                end
                                if text then
                                    return i
                                end
                            end
                            
                        end
                    end
                    return false
                end
                local plaque_index = {}
                for _, v in pairs(bag_info) do
                    if v.category_utf8 == game_str.TowerAugmentation then
                        table.insert(plaque_index,v)
                    end
                end
                if #plaque_index > 0 then
                    local plaque = plaque_color(plaque_index)
                    if plaque then
                        return plaque
                    end
                end
                return false
            end
            -- -- 判断有无地图装置
            -- local function is_map_device(obj_list)
            --     if not obj_list or #obj_list == 0 then
            --         return false
            --     end
            --     for _, i in ipairs(obj_list) do
            --         if i.name_utf8 == game_str.MapDevice then
            --             return true
            --         end
            --     end
            --     return false
            -- end
            -- local map_device = is_map_device(current_map_info)
            -- -- 不在城区
            -- if not string.match(player_info.current_map_name_utf8,game_str.town) 
            --  and ( not poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.hideout) or not map_device) then
            --     env.is_public_warehouse_plaque = true
            --     env.is_update_plaque = false
            --     poe2_api.dbgp("不在城区, 不强化碑牌")
            --     poe2_api.time_p("判断是否强化碑牌（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
            --     return bret.SUCCESS      
            -- end
            if not bag_info or not next(bag_info) then
                poe2_api.dbgp("背包为空, 不强化碑牌")
                env.is_public_warehouse_plaque = true
                poe2_api.time_p("判断是否强化碑牌（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            -- if not env.is_have_stone then
            --     poe2_api.dbgp("没有可插的塔, 不强化碑牌")
            --     env.is_public_warehouse_plaque = true
            --     poe2_api.time_p("判断是否强化碑牌（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
            --     return bret.SUCCESS
            -- end
            local plaque = get_bag_plaque(bag_info)
            if not plaque then
                poe2_api.dbgp("背包没有需要强化的碑牌, 不强化碑牌")
                -- api_Sleep(10000)
                -- env.is_public_warehouse_plaque = true
                env.plaque_upgrade = false
                poe2_api.time_p("判断是否强化碑牌（SUCCESS5）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            env.plaque_upgrade = true
            -- if not env.is_update_plaque then
            --     poe2_api.dbgp("不需要强化碑牌")
            --     env.is_public_warehouse_plaque = true
            --     poe2_api.time_p("判断是否强化碑牌（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
            --     return bret.SUCCESS
            -- end
            local config = env.user_config
            local text = ""
            if plaque.color == 0 and not poe2_api.table_contains(env.lack_of_currency,game_str.Greater_Orb_of_Transmutation_TWCH) then
                text = game_str.Greater_Orb_of_Transmutation_TWCH
            elseif plaque.color == 0 and not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Transmutation_TWCH) then
                text = game_str.Orb_of_Transmutation_TWCH
            elseif plaque.color == 1 and not poe2_api.table_contains(env.lack_of_currency,game_str.Greater_Orb_of_Augmentation_TWCH) then
                text = game_str.Greater_Orb_of_Augmentation_TWCH
            elseif plaque.color == 1 and not poe2_api.table_contains(env.lack_of_currency,game_str.Orb_of_Augmentation_TWCH) then
                text = game_str.Orb_of_Augmentation_TWCH
            end
            -- if plaque.color == 0 then
            --     text = game_str.Orb_of_Transmutation_TWCH
            -- elseif plaque.color == 1 then
            --     text = game_str.Orb_of_Augmentation_TWCH
            -- end
            
            if text then
                local items_info = poe2_api.get_items_config_info(config)
                local is_text = nil
                for _,item in ipairs(items_info) do
                    if item["類型"] == "通貨" and item['存倉頁名'] and not item["不撿"] and poe2_api.table_contains(item['基礎類型名'],text) then
                        is_text = item
                        break
                    end
                end
                if is_text then
                    if is_text["工會倉庫"] then
                        env.warehouse_type_interactive = game_str.Guild_Warehouse_text
                        -- env.is_public_warehouse_plaque = false
                    else
                        env.warehouse_type_interactive = game_str.Warehouse_text
                    end
                else
                    local unique_storage_pages = nil
                    for _,item in ipairs(items_info) do
                        if item["類型"] == "通貨" and item['存倉頁名'] and not item["不撿"] and item['基礎類型名'] == "全部物品" and not item["工會倉庫"] then
                            unique_storage_pages = item
                            break
                        end
                    end
                    if unique_storage_pages then
                        env.warehouse_type_interactive = game_str.Warehouse_text
                    else
                        env.warehouse_type_interactive = game_str.Guild_Warehouse_text
                        -- env.is_public_warehouse_plaque = false
                    end
                end
            end
            env.currency_name = text
            env.strengthened_map_obj = plaque
            poe2_api.time_p("判断是否强化碑牌（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        
        end
    },

    -- 判断是否需要售卖
    Is_Sell_Item = {
        run = function(self, env)
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.bool = true
                self.index = 0
            end
            poe2_api.print_log("判断是否需要售卖...")
            if not env.storage_complete then
                poe2_api.dbgp("未完成存储，不需要售卖")
                poe2_api.time_p("判断是否需要售卖（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if env.sale_completed then
                poe2_api.dbgp("已完成售卖，不需要售卖")
                poe2_api.time_p("判断是否需要售卖（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local config = env.user_config
            local is_decompose = config['全局設置']["刷图通用設置"]["是否分解暗金"] or false
            local altar_shop_config = config['刷圖設置']["祭祀購買"]
            -- local range_info = env.range_info
            local player_info = env.player_info
            local bag_info = env.bag_info
            local processed_configs = poe2_api.get_items_config_info(config)
            -- 是否需要丢弃
            local function get_not_item(items)
                local function is_props(bag)
                    local text_list = game_str.Task_prop_text
                    -- for _, i in ipairs(bag) do
                        -- poe2_api.dbgp("i.baseType_utf8:",i.baseType_utf8)
                        -- poe2_api.dbgp("i.category_utf8:",i.category_utf8)
                        -- poe2_api.dbgp("i.color:","----------------------------------")
                        if bag.category_utf8 == game_str.QuestItem then
                            for _, v in ipairs(text_list) do
                                if string.find(bag.baseType_utf8,v) then
                                    return true
                                end
                                
                            end
                        end
                    -- end
                    return false
                end
                local function get_not(item)
                    local props = is_props(item)
                    if props then
                        return false
                    end
                    if item.baseType_utf8 == game_str.Decayed_backpack_charging_CH then
                        return false
                    end
                    if poe2_api.is_do_without_pick_up(item,processed_configs) then
                        return true
                    end
                    for _, cfg in ipairs(processed_configs) do
                        if poe2_api.match_item(item,cfg) then
                            if cfg["不撿"] then
                                if poe2_api.table_contains(item.baseType_utf8,altar_shop_config) then
                                    return false
                                end
                                -- if is_decompose and type(is_decompose)~="table" then
                                --     if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                --         return false
                                        
                                --     end
                                -- end
                                return true
                            end
                            if item.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                local number = 0
                                for _, v in ipairs(items) do
                                    if v.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                        number = number + v.stackCount
                                    end
                                end
                                if number > 80 then
                                    return true
                                end
                            end
                            local item_entry = cfg["物品詞綴"] or {}
                            if item_entry and next(item_entry) then
                                local function get_cfg_entry(entry_list)
                                    for k, v in pairs(entry_list) do
                                        if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                            if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                return true
                                            end
                                        end
                                    end
                                    return false
                                end
                                local function get_cfg_entry_tower()
                                    for k, v in pairs(item_entry) do
                                        if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                            if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                for i, v1 in ipairs(v["詞綴"]) do
                                                    if not string.find(v1["name"],game_str.within_the_scope_CH) then
                                                        return true
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    return false
                                end
                                if get_cfg_entry(item_entry) then
                                    if item.category_utf8 == game_str.TowerAugmentation then
                                        if get_cfg_entry_tower() then
                                            if item.color ~= 1 or (item.color == 1 and item.fixedSuffixCount<2) then
                                                return false    
                                            end
                                        end
                                    end
                                    if poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) and not item.not_identified then
                                        local suffixes = api_GetObjectSuffix(item.mods_obj)
                                        -- if not suffixes or #suffixes == 0 then
                                        --     return {item}
                                        -- end
                                        if not poe2_api.filter_item(item,suffixes,config["物品過濾"]) then
                                            if is_decompose and type(is_decompose)~="table" then
                                                if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                                    return false
                                                end
                                            end
                                            return true
                                        end
                                    end
                                end
                            end
                            return false
                        end
                        -- if is_decompose and type(is_decompose)~="table" then
                        --     if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                        --         return false
                        --     end
                        -- end
                    end
                    if poe2_api.table_contains(item.baseType_utf8,altar_shop_config) then
                        return false
                    end
                    return true
                end
                if not items or not next(items) then
                    return false
                end
                for _, item in ipairs(items) do
                    if item.category_utf8 == game_str.TowerAugmentation then
                        local is_dis = get_not(item)
                        if is_dis then
                            if type(is_dis) == "table" then
                                return is_dis
                            end
                            if item.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                local mininumber = nil
                                local miniobj = nil
                                for _, v in ipairs(items) do
                                    if v.baseType_utf8 == game_str.The_Knowledge_Scroll then
                                        if not mininumber or mininumber > v.stackCount then
                                            miniobj = v
                                            mininumber = v.stackCount
                                        end
                                    end
                                end
                                env.sell_item = miniobj
                                return true
                            end
                            env.sell_item = item
                            return true
                        end
                    end
                end
                return false
            end
            local sell_item = get_not_item(bag_info)
            if not sell_item then
                poe2_api.dbgp("没有需要售卖的碑牌")
                env.sale_completed = true
                poe2_api.time_p("判断是否需要售卖（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if poe2_api.find_text({text=game_str.Purchase_or_sell,UI_info=env.UI_info,min_x=0,max_x=800}) then
                self.index = 0
                poe2_api.ctrl_left_click_bag_items(env.sell_item.obj,bag_info)
                -- api_Sleep(500)
                -- poe2_api.ctrl_left_click(((env.sell_item.RectSart_x + env.sell_item.RectEnd_x) / 2), ((env.sell_item.RectSart_y + env.sell_item.RectEnd_y) / 2))
                
                poe2_api.time_p("操作售卖碑牌（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if poe2_api.find_text({text=game_str.Choose_Hideout_TWCH,UI_info=env.UI_info,min_x=0,max_y=600}) then
                poe2_api.find_text({text=game_str.Goodbye,UI_info=env.UI_info,min_x=0,max_y=600,click = 2})
                api_Sleep(200)
                return bret.RUNNING
            end
            local current_map_info = env.current_map_info
            -- local range_info = env.range_info
            local warehouse = nil
            if (not current_map_info or not next(current_map_info)) and (not env.range_info or not next(env.range_info)) then
                poe2_api.dbgp("小地图信息和周围对象信息都为空")
                api_Sleep(1000)
                poe2_api.time_p("打开商店（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local warehouse1 = nil
            local warehouse2 = nil
            for _, v in ipairs(current_map_info) do
                if v.name_utf8 == game_str.Sale_NPC and v.flagStatus == 0 and v.flagStatus1 == 1 then
                    warehouse1 = v
                end
            end
            if not warehouse1 then
                for _, v in ipairs(env.range_info) do
                    if v.name_utf8 == game_str.Sale_NPC and v.is_selectable then
                        warehouse2 = v
                    end
                end
                if warehouse2 then
                    warehouse = warehouse2
                end
            else
                warehouse = warehouse1
            end

            if warehouse then
                local distance = poe2_api.point_distance(warehouse.grid_x,warehouse.grid_y,player_info)
                -- if poe2_api.find_text({text=game_str.Purchase_or_sell,UI_info=env.UI_info,min_x=0,max_x=800}) and distance <=25 then
                --     self.index = 0
                --     poe2_api.time_p("打开商店（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                --     return bret.SUCCESS
                -- end
                if poe2_api.find_text({text=game_str.Buy_or_Sell_items_EN,UI_info=env.UI_info,min_x=0,max_x=1600,click=2}) and distance <=25 then
                    api_Sleep(500)
                    poe2_api.time_p("打开商店（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if poe2_api.find_text({text=game_str.Buy_or_Sell_items_CH,UI_info=env.UI_info,min_x=0,max_x=1600,click=2}) and distance <=25 then
                    api_Sleep(500)
                    poe2_api.time_p("打开商店（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if distance and distance > 25 then
                    env.interactive = game_str.Sale_NPC
                    poe2_api.time_p("打开商店（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.FAIL
                else
                    api_ClickMove(poe2_api.toInt(warehouse.grid_x),poe2_api.toInt(warehouse.grid_y),1)
                    api_Sleep(500)
                    if self.index >= 10 then
                        poe2_api.dbgp1("111111111111111111111111111111111")
                        poe2_api.click_keyboard("space")
                        api_Sleep(200)
                        self.index = 0
                    end
                    self.index = self.index + 1
                    api_Sleep(200)
                    poe2_api.time_p("打开商店（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            else
                poe2_api.dbgp("找不到澤莉娜")
                poe2_api.time_p("打开商店（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            -- return bret.FAIL
        end
    },
    

    --骷髅马克安全区传送
    Skeleton_Gameplay_Teleport = {
        run = function(self, env)
            poe2_api.print_log("骷髅马克安全区传送")
            local start_time = api_GetTickCount64()
            local player_info = env.player_info
            if not player_info or not next(player_info) then
                poe2_api.dbgp("玩家信息为空")
                return bret.RUNNING
            end
            if env.user_config["全局設置"]["界域之门"] then
                if env.special_mode_enabled and env.special_map_type == game_str.The_Invitation_of_Skeleton_Mark_TWCH then
                    if player_info.current_map_name_utf8 ~= game_str.Abyss_Hub_MDANA then
                        if poe2_api.find_text({text=game_str.teleportation,UI_info=env.UI_info,min_x=0,min_y=0,max_x=1600,max_y=50}) then
                            api_Sleep(1000)
                            local area_component = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 1541,min_y = 204,max_x = 1592,max_y = 576})
                            if area_component and next(area_component) then
                                api_ClickScreen(poe2_api.toInt((area_component[1].left+area_component[1].right)/2),poe2_api.toInt((area_component[1].top+area_component[1].bottom)/2),1,100,150)
                                api_Sleep(200)
                                return bret.RUNNING
                            else
                                error("未解锁靈魂之井，请先解锁靈魂之井")
                            end
                        end
                        local function get_object(name,data_list)
                            for _, v in ipairs(data_list) do
                                if v.name_utf8 == name and v.grid_x ~= 0 and v.grid_y ~= 0 then
                                    if v.flagStatus and v.flagStatus == 0 and v.flagStatus1 == 1 then
                                        poe2_api.dbgp("get_object 找到匹配对象(flagStatus):", v)
                                        return v
                                    end
                                    if v.life and v.is_selectable then
                                        poe2_api.dbgp("get_object 找到匹配对象(life):", v)
                                        return v
                                    end
                                end
                            end
                            poe2_api.dbgp("get_object: 未找到匹配对象")
                            return false
                        end
                        local obj = nil
                        local teleport_obj = nil
                        local teleport_point = get_object(game_str.Waypoint, env.current_map_info)
                        if teleport_point then
                            obj = game_str.Waypoint
                            teleport_obj = teleport_point
                        else
                            local teleport_point1 = get_object(game_str.Transfer_point_CH,env.range_info)
                            if teleport_point1 then
                                obj = game_str.Transfer_point_CH
                                teleport_obj = teleport_point1
                            end
                        end
                        if not obj then
                            poe2_api.dbgp("未找到传送点,随机走动")
                            local point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 70)
                            api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), 7)
                            api_Sleep(1500)
                            return bret.RUNNING
                        end
                        local distance = poe2_api.point_distance(teleport_obj.grid_x,teleport_obj.grid_y,player_info)
                        if distance and distance > 25 then
                            env.interactive = obj
                            return bret.FAIL
                        else
                            poe2_api.find_text({text=game_str.Transfer_point_CH,UI_info=env.UI_info,min_x=300,min_y=300,max_x=1300,max_y=700,click=2})
                            api_Sleep(1000)
                            return bret.RUNNING
                        end
                    end
                end
            end
            return bret.SUCCESS
            
        end
    },

    -- 进入黑色大教堂
    Black_Temple_Enter = {
        run = function(self, env)
            poe2_api.print_log("进入黑色大教堂")
            local start_time = api_GetTickCount64()
            local player_info = env.player_info
            if env.user_config["全局設置"]["界域之门"] then
                if env.special_mode_enabled and env.special_map_type == game_str.The_Invitation_of_Skeleton_Mark_TWCH then
                    if player_info.current_map_name_utf8 ~= game_str.Abyss_Pinnacle_MDANA then
                        if poe2_api.find_text({text=game_str.Copy_Canager_CH,UI_info=env.UI_info,min_x=600,min_y=110,max_x=1000,max_y=150}) then
                            api_Sleep(500)
                            if poe2_api.find_text({text=game_str.Enter_CH,UI_info=env.UI_info,min_x=370,min_y=345,max_x=412,max_y=377}) then
                                poe2_api.dbgp("qwqwqwqwqwqwqwqw")
                                -- api_Sleep(3000)/
                                if not env.is_church_completed then
                                    poe2_api.find_text({text=game_str.Enter_CH,UI_info=env.UI_info,min_x=370,min_y=345,max_x=412,max_y=377,click=2})
                                    api_Sleep(200)
                                    return bret.RUNNING
                                end  
                            end
                            poe2_api.find_text({text=game_str.New_Dungeon_CH,UI_info=env.UI_info,min_x=370,min_y=272,max_x=419,max_y=300,click=2})
                            api_Sleep(200)
                            return bret.RUNNING
                        end
                        local function get_object(name,data_list)
                            for _, v in ipairs(data_list) do
                                if v.name_utf8 == name and v.grid_x ~= 0 and v.grid_y ~= 0 then
                                    if v.flagStatus and v.flagStatus == 0 and v.flagStatus1 == 1 then
                                        poe2_api.dbgp("get_object 找到匹配对象(flagStatus):", v)
                                        return v
                                    end
                                    if v.life and v.is_selectable then
                                        poe2_api.dbgp("get_object 找到匹配对象(life):", v)
                                        return v
                                    end
                                end
                            end
                            poe2_api.dbgp("get_object: 未找到匹配对象")
                            return false
                        end
                        local obj = nil
                        local Church_obj = nil
                        local Church = get_object(game_str.Abyss_Pinnacle_MDANA, env.current_map_info)
                        if Church then
                            obj = game_str.Abyss_Pinnacle_MDANA
                            Church_obj = Church
                        else
                            local Church1 = get_object(game_str.Black_Cathedral,env.range_info)
                            if Church1 then
                                obj = game_str.Black_Cathedral
                                Church_obj = Church1
                            end
                        end
                        if not obj then
                            env.interactive = game_str.Hidden_Creature
                            return bret.FAIL
                            -- poe2_api.dbgp("未找到传送点,随机走动")
                            -- local point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 70)
                            -- api_ClickMove(poe2_api.toInt(point.x), poe2_api.toInt(point.y), 7)
                            -- api_Sleep(1500)
                            -- return bret.RUNNING
                            -- 潛伏的生物
                        end
                        env.interactive = Church_obj
                        return bret.FAIL
                    end
                    return bret.RUNNING
                end
            end
            return bret.SUCCESS
        end
    },

    -- 判断是否在教堂，进行躲避技能
    Is_Player_Location = {
        run = function(self, env)
            if env.player_info.current_map_name_utf8 == game_str.Abyss_Pinnacle_MDANA then
                return bret.FAIL
            end
            return bret.SUCCESS
        end
    },
    -- 判断是否需要取保留物品
    Is_Need_Keep_Item = {
        run = function(self, env)
            poe2_api.print_log("判断是否需要取保留物品")
            -- if env.is_warehouse_wr then
            --     poe2_api.dbgp("仓库中没有保留物品，不需要取保留物品")
            --     return bret.SUCCESS
            -- end
            -- if next(env.bag_info) then
            local not_keep_item = {}
            for _, v in ipairs(game_str.Enhancement_Item_List_TWCH) do
                local a = false
                for _, v1 in ipairs(env.bag_info) do
                    if v1.baseType_utf8 == v then
                        a = true
                        -- poe2_api.dbgp("背包中有保留物品，不需要取保留物品")
                        -- return bret.SUCCESS
                    end
                end
                if not a then
                    table.insert(not_keep_item,v)
                end
                -- if not a then
                --     poe2_api.dbgp("背包中没有保留物品，需要取保留物品")
                --     return bret.FAIL
                -- end
            end
            if not next(not_keep_item) then
                poe2_api.dbgp("有保留物品，不需要取保留物品")
                return bret.SUCCESS
            end
            -- lack_of_currency
            local item = nil
            for _, v in ipairs(not_keep_item) do
                if not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,v) then
                    item = v
                    break
                    -- env.get_reserved_items = v
                    -- return bret.FAIL
                end
            end
            if not item then
                poe2_api.dbgp("仓库没有保留物品不取")
                return bret.SUCCESS
            end
            local config = env.user_config
            local items_info = poe2_api.get_items_config_info(config)
            for _,v in ipairs(items_info) do
                if string.find(v["基礎類型名"],item) and v["類型"] == "通貨" and not v["不撿"] and v["存倉頁名"] and v["存倉頁名"] ~= "" then
                    if v["工會倉庫"] then
                        env.warehouse_type_interactive = game_str.Guild_Warehouse_text
                        env.get_reserved_items = item
                        env.reserved_items_page = v["存倉頁名"]
                        return bret.FAIL
                    else
                        env.warehouse_type_interactive = game_str.Warehouse_text
                        env.get_reserved_items = item
                        env.reserved_items_page = v["存倉頁名"]
                        return bret.FAIL
                    end
                end
            end
            for _,v in ipairs(items_info) do
                if v["基礎類型名"] == "全部物品" and v["類型"] == "通貨" and not v["不撿"] and v["存倉頁名"] and v["存倉頁名"] ~= "" then
                    if v["工會倉庫"] then
                        env.warehouse_type_interactive = game_str.Guild_Warehouse_text
                        env.get_reserved_items = item
                        env.reserved_items_page = v["存倉頁名"]
                        return bret.FAIL
                    else
                        env.warehouse_type_interactive = game_str.Warehouse_text
                        env.get_reserved_items = item
                        env.reserved_items_page = v["存倉頁名"]
                        return bret.FAIL
                    end
                end
            end
                -- poe2_api.dbgp("仓库没有保留物品不取")
                -- return bret.SUCCESS
            -- else
            --     for _, v in ipairs(game_str.Enhancement_Item_List_TWCH) do
            --         if not next(env.lack_of_currency) or not poe2_api.table_contains(env.lack_of_currency,v) then
            --             env.get_reserved_items = v
            --             return bret.FAIL
            --         end
            --     end
            --     -- poe2_api.dbgp("背包为空，需要取保留物品")
            --     -- return bret.FAIL
            -- end
            
            -- poe2_api.dbgp("仓库没有保留物品不取")
            return bret.SUCCESS
        end
    },

    -- 取保留物品
    Get_Reserved_Items = {

        -- run = function(self, env)
        --     poe2_api.print_log("取保留物品")
        -- end
        run = function(self, env)
            poe2_api.print_log("取保留物品...")
            poe2_api.dbgp(env.warehouse_type_interactive)
            poe2_api.dbgp(env.get_reserved_items)
            poe2_api.dbgp(env.reserved_items_page)
            
            local start_time = api_GetTickCount64()
            if env.warehouse_type_interactive == game_str.Warehouse_text then
                -- text = game_str.Warehouse
                if poe2_api.find_text({text = game_str.Emphasize_the_item,UI_info = env.UI_info,min_x = 250,min_y = 700}) 
                and poe2_api.find_text({text = game_str.Guild_Warehouse,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=78}) then
                    -- poe2_api.click_keyboard("space")
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Guild_Warehouse, min_x=0,min_y=32,max_x=381,max_y=78, click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("取保留物品（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            elseif env.warehouse_type_interactive == game_str.Guild_Warehouse_text then

                -- text = game_str.Guild_Warehouse
                if poe2_api.find_text({text = game_str.Emphasize_the_item,UI_info = env.UI_info,min_x = 250,min_y = 700}) 
                and poe2_api.find_text({text = game_str.Warehouse,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=78}) then
                    -- poe2_api.click_keyboard("space")
                    poe2_api.find_text({UI_info = env.UI_info, text = game_str.Warehouse, min_x=0,min_y=32,max_x=381,max_y=78, click = 2, add_x = 253})
                    api_Sleep(500)
                    poe2_api.time_p("取保留物品（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                -- if get_map_not_entry(env.strengthened_map_obj) then
                --     env.is_public_warehouse = true
                --     env.is_strengthened_map = true
                --     env.supreme_use_count = 0
                --     poe2_api.time_p("强化地图钥匙找通货（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                --     return bret.RUNNING
                -- end
            else
                error("取保留物品未知的仓库类型")
            end
            if not poe2_api.find_text({text = game_str.Emphasize_the_item,UI_info = env.UI_info,min_x = 250,min_y = 700})  then
            -- and poe2_api.find_text({text = text,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=78}) then
                poe2_api.time_p("取保留物品（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.FAIL
            end
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.is_wait = false
                self.current = 0
                self.wait_item = nil  
                self.type = nil
                self.bool = true
            end

            if self.current == 0 then
                self.current = api_GetTickCount64()
            end
            if api_GetTickCount64() - self.current > 3000 then
                self.type = nil
                self.current = 0
            end
            -- poe2_api.dbgp("env.strengthened_map_obj" , env.strengthened_map_obj.category_utf8)
            -- poe2_api.dbgp("env.warehouse_type_interactive" , env.warehouse_type_interactive)
            -- poe2_api.dbgp("env.get_reserved_items" , env.get_reserved_items)
            -- api_Sleep(1000000)
            local config = env.user_config
            local item_config = poe2_api.get_items_config_info(config)
            local page = env.reserved_items_page
            local type_ck = false -- false 为个仓  true 为公仓
            local map_object = env.strengthened_map_obj
            if env.warehouse_type_interactive == game_str.Warehouse_text then
                type_ck = false
            else
                type_ck = true
            end
            -- for _, v in ipairs(item_config) do
            --     if v["類型"] == "通貨" and not v["不撿"] and string.find(env.get_reserved_items,v["基礎類型名"]) and v["工會倉庫"] == type_ck then
            --         page = v["存倉頁名"]
            --         break
            --     end
            -- end
            -- if not page then
            --     for _, v in ipairs(item_config) do
            --         if v["類型"] == "通貨" and not v["不撿"] and v["基礎類型名"] == "全部物品" and v["工會倉庫"] == type_ck then
            --             page = v["存倉頁名"]
            --             break
            --         end
            --     end
            -- end
            poe2_api.dbgp("page" , page)
            -- api_Sleep(1000000)
            local function bag_operate(godown_info,min_x,min_y,max_x,max_y)
                -- 判断背包物品
                local function get_items(bag_info,item)
                    if not bag_info or not next(bag_info) then
                        return false
                    end
                    -- poe2_api.printTable(bag_info)

                    -- api_Sleep()
                    for _, v in ipairs(bag_info) do
                        if v.baseType_utf8 == item then
                            return v
                        end
                    end
                    return false
                end
                -- 判断仓库有无通货页
                local function get_special_page(godown_info,page_type)
                    if not godown_info or not next(godown_info) then
                        return false
                    end
                    -- poe2_api.printTable(godown_info)
                    -- api_Sleep()
                    for _, v in ipairs(godown_info) do
                        if v.type == page_type then
                            if not v.name_utf8 or v.name_utf8 == "" then 
                                error("通货页未设置文本，请在游戏中设置！！！")
                            end
                            return v
                        end
                    end
                    return false
                end
                
                -- local bag_info = env.bag_info
                -- local item = get_items(bag_info,env.get_reserved_items)
                -- if item then
                --     local point = poe2_api.get_center_position({item.start_x,item.start_y},{item.end_x,item.end_y})
                --     api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                --     api_Sleep(300)
                --     api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),2)
                --     api_Sleep(300)
                --     local point = poe2_api.get_center_position({map_object.start_x,map_object.start_y},{map_object.end_x,map_object.end_y})
                --     api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                --     api_Sleep(300)
                --     api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                --     api_Sleep(300)
                --     if env.get_reserved_items == "崇高石" then
                --         env.supreme_use_count = env.supreme_use_count + 1
                --     end
                --     env.streng_map_flushed_switch = true
                --     return false
                -- end
                local precut_page = nil
                for _, v in ipairs(godown_info) do
                    if v.name_utf8 == page then
                        precut_page = v
                        break
                    end
                end
                if not precut_page then 
                    error("未找到预设存仓页 ->"..tostring(page).."<-,请检查预设存仓页与游戏仓库页是否一致")
                    
                elseif precut_page.manage_index == 0 then
                    if poe2_api.find_text({text = page,UI_info = env.UI_info,max_y=max_y,min_x=min_x,max_x=max_x,min_y=min_y,click = 2}) then 
                        self.is_wait = true
                        self.current = api_GetTickCount64()
                        self.wait_item = 500
                        self.type = page
                    end
                    return false
                end
                local index = nil
                if not type_ck then
                    index = 0
                else
                    index = 2
                end
                
                local currency = api_Getinventorys(precut_page.manage_index,index)
                if currency and next(currency) then
                    
                    local item = get_items(currency,env.get_reserved_items)
                    if item then
                        -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk11111")
                        -- api_Sleep(10000000000000000)
                        if self.type ~= page then
                            if poe2_api.find_text({text = page,UI_info = env.UI_info,max_y=max_y,min_x=min_x,max_x=max_x,min_y=min_y,click = 2}) then 
                                self.is_wait = true
                                self.current = api_GetTickCount64()
                                self.wait_item = 500
                                self.type = page
                                return false
                            end
                        end
                        local point = nil
                        if poe2_api.table_contains(precut_page.type,{0,1}) then
                            point = poe2_api.get_center_position_store({item.start_x,item.start_y},{item.end_x,item.end_y})
                        elseif precut_page.type == 3 then
                            local item_list = api_GetInventoryItemsInRect(17,109,536,626)
                            local function get_item_point()
                                for _,v in ipairs(item_list) do
                                    if v.baseType_utf8 == item.baseType_utf8 then
                                        local point = {(v.RectSart_x + v.RectEnd_x) / 2, (v.RectSart_y + v.RectEnd_y) / 2}
                                        return point
                                    end
                                end
                            end
                            point = get_item_point()
                        elseif precut_page.type == 7 then
                            point = poe2_api.get_center_position_store_max({item.start_x,item.start_y},{item.end_x,item.end_y})
                        end
                        if not point then
                            -- env.streng_map_flushed_switch = true
                            return false    
                        end
                        api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                        api_Sleep(200)
                        -- if index == 0 then
                        --     api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),2)
                        --     api_Sleep(200)
                        --     local point = poe2_api.get_center_position({map_object.start_x,map_object.start_y},{map_object.end_x,map_object.end_y})
                        --     api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                        --     api_Sleep(200)
                        --     api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                        --     api_Sleep(200)
                        --     if env.get_reserved_items == "崇高石" then
                        --         env.supreme_use_count = env.supreme_use_count + 1
                        --     end
                        -- else
                        poe2_api.ctrl_left_click(point[1],point[2])
                        api_Sleep(800)
                        -- end
                        
                        -- env.streng_map_flushed_switch = true
                        return false
                    end
                end
                -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk222222")
                -- api_Sleep(10000000000000000)
                local page_type = get_special_page(godown_info,3)
                poe2_api.dbgp("precut_page.type",precut_page.type)
                poe2_api.dbgp("page_type",page_type)
                -- api_Sleep(10000000000)
                if precut_page.type == 3 or not page_type then
                    -- if string.find(map_object.baseType_utf8,"碑牌") then
                    --     env.is_public_warehouse_plaque = true
                    --     env.is_update_plaque = false
                    --     table.insert(env.lack_of_currency,env.get_reserved_items)
                    -- else
                    table.insert(env.lack_of_currency,env.get_reserved_items)
                        -- env.is_strengthened_map = false
                        -- env.streng_map_flushed_switch = false
                        -- env.is_public_warehouse = true
                    -- end
                    -- env.item_state[env.get_reserved_items] = false
                    return false
                end
                
                if page_type.manage_index == 0 then
                    if poe2_api.find_text({text = page_type.name_utf8,UI_info = env.UI_info,max_y=max_y,min_x=min_x,max_x=max_x,min_y=min_y,click = 2}) then 
                        self.is_wait = true
                        self.current = api_GetTickCount64()
                        self.wait_item = 500
                        self.type = page_type.name_utf8
                        return false
                    end
                end
                -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk44444")
                -- api_Sleep(10000000000000000)
                local currency = api_Getinventorys(page_type.manage_index,index)
                if currency and next(currency) then
                    -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk6666")
                    -- api_Sleep(10000000000000000)
                    poe2_api.dbgp("TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT")
                    local item = get_items(currency,env.get_reserved_items)
                    poe2_api.dbgp(env.get_reserved_items)
                    if item then
                        -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk")
                        -- api_Sleep(10000000000000000)
                        if self.type ~= page_type.name_utf8 then
                            if poe2_api.find_text({text = page_type.name_utf8,UI_info = env.UI_info,max_y=max_y,min_x=min_x,max_x=max_x,min_y=min_y,click = 2}) then 
                                self.is_wait = true
                                self.current = api_GetTickCount64()
                                self.wait_item = 500
                                self.type = page_type.name_utf8
                                return false
                            end
                        end
                        local item_list = api_GetInventoryItemsInRect(17,109,536,626)
                        local function get_item_point()
                            for _,v in ipairs(item_list) do
                                if v.baseType_utf8 == item.baseType_utf8 then
                                    local point = {(v.RectSart_x + v.RectEnd_x) / 2, (v.RectSart_y + v.RectEnd_y) / 2}
                                    return point
                                end
                            end
                        end
                        -- local point = my_game_info.currency_page[item.baseType_utf8]
                        local point = get_item_point()
                        if not point then
                            -- env.streng_map_flushed_switch = true
                            return false    
                        end
                        api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                        api_Sleep(200)
                        -- if index == 0 then
                        --     api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),2)
                        --     api_Sleep(200)
                        --     local point = poe2_api.get_center_position({map_object.start_x,map_object.start_y},{map_object.end_x,map_object.end_y})
                        --     api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                        --     api_Sleep(200)
                        --     api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                        --     api_Sleep(200)
                        --     if env.get_reserved_items == "崇高石" then
                        --         env.supreme_use_count = env.supreme_use_count + 1
                        --     end
                        -- else
                        poe2_api.ctrl_left_click(point[1],point[2])
                        api_Sleep(800)
                        -- end
                        -- env.streng_map_flushed_switch = true
                        return false
                    end
                end
                -- poe2_api.dbgp("jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjk555555")
                -- api_Sleep(10000000000000000)
                -- if string.find(map_object.baseType_utf8,"碑牌") then
                --     env.is_public_warehouse_plaque = true
                --     env.is_update_plaque = false
                --     table.insert(env.lack_of_currency,env.get_reserved_items)
                -- else
                table.insert(env.lack_of_currency,env.get_reserved_items)
                    -- env.is_strengthened_map = false
                    -- env.streng_map_flushed_switch = false
                    -- env.is_public_warehouse = true
                -- end
                -- env.item_state[env.get_reserved_items] = false
                return false
            end
            
            if self.is_wait then
                if api_GetTickCount64() - self.current > self.wait_item then 
                    poe2_api.dbgp("等待间隔时间到达")
                    poe2_api.time_p("取保留物品（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                self.is_wait = false
            end
            if not poe2_api.find_text({UI_info=env.UI_info,text=game_str.backpack,min_x = 1020,min_y=32,max_x=1600,max_y=78}) then
                poe2_api.click_keyboard("i")
                api_Sleep(500)
                self.is_wait = true
                self.current = api_GetTickCount64()
                self.wait_item = 1000
                poe2_api.time_p("取保留物品（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local tab_list_button = poe2_api.click_text_UI({text = game_str.tab_list_button, UI_info = env.UI_info,ret_data = true})
            if not tab_list_button then
                local godown_info
                if not type_ck then
                    godown_info = api_GetRepositoryPages(0)
                else
                    godown_info = api_GetRepositoryPages(1)
                end
                if not bag_operate(godown_info,10,0,500,90) then
                    poe2_api.time_p("取保留物品（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            else
                
                local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
                local lock_button = {}
                for _,v in ipairs(lock) do
                    if v.name_utf8 == "" and v.text_utf8 == "" then
                        table.insert(lock_button,v)
                    end
                end
                if not lock_button or not next(lock_button) then
                    api_ClickScreen(poe2_api.toInt((tab_list_button.left+tab_list_button.right)/2),poe2_api.toInt((tab_list_button.top+tab_list_button.bottom)/2),1)
                    api_Sleep(2000)
                    api_ClickScreen(poe2_api.toInt(((tab_list_button.left+tab_list_button.right)/2) + 30),poe2_api.toInt(((tab_list_button.top+tab_list_button.bottom)/2) - 30),1)
                    api_Sleep(1000)
                    poe2_api.time_p("取保留物品（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local godown_info
                if not type_ck then
                    godown_info = api_GetRepositoryPages(0)
                else
                    godown_info = api_GetRepositoryPages(1)
                end
                if not bag_operate(godown_info,556,20,851,800) then
                    poe2_api.time_p("取保留物品（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            poe2_api.time_p("取保留物品（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.RUNNING
        end
    },
}
-- 自定义节点实现
local plot_nodes = {
    -- 获取用户配置信息
    Get_User_Config_Info = {
        run = function(self, env)
            poe2_api.print_log("获取用户配置信息...")
            local start_time = api_GetTickCount64() -- 开始时间
            if not env.user_config then
                local config = poe2_api.load_config(json_path)
                local user_info = poe2_api.load_ini(user_info_path)["UserInfo"]
                -- 玩法優先級
                local map_priority = config["刷圖設置"]["玩法優先級"]
                local map_sorted_items_sort = poe2_api.sort_map_by_key(map_priority)
                poe2_api.printTable(map_sorted_items_sort)
                if map_priority['是否開啟'] then
                    env.sorted_map = map_sorted_items_sort
                else
                    env.sorted_map = nil
                end
                poe2_api.dbgp("1111111111...")
                -- # 碑牌順序
                local play_priority = config["刷圖設置"]["碑牌優先級"]
                local sorted_keys = poe2_api.sort_map_by_key(play_priority)
                local result = {}
                for _, key in ipairs(sorted_keys) do
                    if my_game_info.map_type[key] then
                        table.insert(result, my_game_info.map_type[key])
                    end
                end         
                env.user_config = config
                env.user_info = user_info
                env.stone_order = result
                env.is_insert_stone = play_priority["是否開啟"]

                -- 检查是否需要售卖地图
                env.need_sale_map = config["全局設置"]["刷图通用設置"]["自动清理地图(个人仓库)"]
                
                local item_filters = config["物品過濾"] or {}  -- 获取物品过滤配置数组
                -- 两种独立的分类表
                local item_config_by_type = {}      -- 按【類型】分类
                local item_config_by_base_type = {} -- 按【基礎類型名】分类

                for _, filter in ipairs(item_filters) do
                    if not filter["不撿"] then
                        -- ========== 按【類型】分类 ==========
                        local item_type = filter["類型"] or "未分类"
                        if not item_config_by_type[item_type] then
                            item_config_by_type[item_type] = {}
                        end
                        table.insert(item_config_by_type[item_type], filter)  -- 直接引用原数据

                        -- ========== 按【基礎類型名】分类 ==========
                        local base_type = filter["基礎類型名"] or "全部物品"
                        if not item_config_by_base_type[base_type] then
                            item_config_by_base_type[base_type] = {}
                        end
                        table.insert(item_config_by_base_type[base_type], filter)  -- 直接引用原数据
                    end
                end

                env.item_config_name = item_config_by_base_type
                env.item_config_type = item_config_by_type

                -- 滴注操作
                local map_cfg = config['刷圖設置'] or {}
                poe2_api.process_void_maps(map_cfg)
                env.dist_ls = config["刷圖設置"]['異界地圖索引']["涂油设置"] or {}
                -- 更新地图相关设置（添加空值保护）
                env.user_map = (config["刷圖設置"] or {})["地圖鑰匙"] or ""
                -- poe2_api.printTable(env.user_map)
                -- api_Sleep(100000)
                env.not_use_map = (config['刷圖設置'] or {})["不打地圖詞綴"] or {}
                env.priority_map = (config["刷圖設置"] or {})["優先打地圖詞綴"] or {}
                env.not_enter_map = (config["刷圖設置"] or {})["不打地圖名"] or {}

                -- 处理怪物躲避设置（添加空值保护）
                local global_settings = config["全局設置"] or {}
                local common_settings = global_settings["刷图通用設置"] or {}
                local monster_avoid = common_settings["怪物近距離躲避"] or {}

                env.space = monster_avoid["是否開啟"] or false
                env.space_time = monster_avoid["閾值"] or 0
                env.space_config = monster_avoid

                local space_monster = {}

                -- 检查每种怪物类型是否存在，不存在则默认为false
                if monster_avoid["白"] then
                    table.insert(space_monster, 0)
                end
                if monster_avoid["藍"] then
                    table.insert(space_monster, 1)
                end
                if monster_avoid["黃"] then
                    table.insert(space_monster, 2)
                end
                if monster_avoid["Boss"] then
                    table.insert(space_monster, 3)
                end

                env.space_monster = space_monster

                env.is_bird = env.user_config["全局設置"]["刷图通用設置"]["是否骑鸟"] or false

                -- 处理保护设置
                local protection_cfg = config["全局設置"]["保護設置"] or {}
                
                -- 解析保护配置的辅助函数
                local function parse_protection(item_cfg)
                    item_cfg = item_cfg or {}
                    local enable_flag = item_cfg["是否開啟"]
                    
                    -- 处理启用标志
                    local enabled
                    if type(enable_flag) == "boolean" then
                        enabled = enable_flag
                    elseif type(enable_flag) == "string" then
                        enabled = (enable_flag:lower():gsub("%s+", "") == "true" or 
                                enable_flag == "1" or 
                                enable_flag:lower() == "yes")
                    else
                        enabled = false
                    end
                    
                    -- 处理数值
                    local function parse_number(value, default)
                        if value == nil then return default end
                        local num = tonumber(value)
                        return num or default
                    end
                    
                    return {
                        enable = enabled,
                        threshold = parse_number(item_cfg["閾值"], 0),
                        interval = parse_number(item_cfg["使用間隔"], 0)
                    }
                end
                
                -- 解析保护设置
                local protection_settings = {
                    health_recovery = parse_protection(protection_cfg["血少回血"]),
                    mana_recovery = parse_protection(protection_cfg["藍少回藍"]),
                    shield_recovery = parse_protection(protection_cfg["盾少回血"])
                }
                
                -- 解析紧急设置
                local emergency_settings = {
                    low_health = parse_protection(protection_cfg["血少逃跑"]),
                    low_mana = parse_protection(protection_cfg["藍少逃跑"]),
                    low_shield = parse_protection(protection_cfg["盾少逃跑"]),
                }
                
                -- 设置到黑板
                env.protection_settings = protection_settings
                env.emergency_settings = emergency_settings

                -- 查找最小攻击距离
                local skill_config = config["技能設置"]
                local min_distance = math.huge  -- 初始化为一个很大的数

                for _, v in pairs(skill_config) do 
                    -- if v["启用"] and v["技能屬性"] == "攻击技能" and (v["白怪"] or v["藍怪"] or v["黃怪"] or v["Boss"]) then
                    if v["启用"] and v["技能屬性"] == "攻击技能" and (v["白怪"] or v["藍怪"] or v["黃怪"]) then
                        if v["攻擊距離"] < min_distance then
                            min_distance = v["攻擊距離"]
                        end
                    end
                end

                -- 边走边释放技能
                -- env.walk_attack = env.user_config["全局設置"]["刷图通用設置"]["边走边释放技能"] or false

                -- 如果没有找到符合条件的技能，设置默认值
                if min_distance == math.huge then
                    min_distance = 100  -- 默认攻击距离
                    -- print("警告：未找到符合条件的攻击技能，使用默认攻击距离：" .. min_distance)
                end

                env.min_attack_dis = min_distance
                poe2_api.dbgp("env.min_attack_dis ==>>", env.min_attack_dis)
                -- api_Sleep(1000000)

                -- 加载躲避技能

                if not self.open_mos_skill then
                    self.open_mos_skill = true
                    local skills = config["全局設置"]["刷图通用設置"]["是否躲避技能"]
                    if skills then
                        -- 圆形
                        for _,k in ipairs(my_game_info.MonitoringSkills_Circle) do
                            -- poe2_api.dbgp(k[2])
                            api_RegisterCircle(k[2] , k[3])
                        end

                        -- 扇形
                        for _,k in ipairs(my_game_info.MonitoringSkills_Sector) do
                            -- poe2_api.dbgp(k[2])
                            api_RegisterSector(k[1] , 0, k[2], k[3])
                        end

                        -- 矩形
                        for _,k in ipairs(my_game_info.MonitoringSkills_Rect) do
                            -- poe2_api.dbgp(k[2])
                            api_RegisterRect(k[1] , k[2], k[3])
                        end
                    end
                    -- # 高傷害技能
                    for _,k in ipairs(my_game_info.High_Damage_Skill) do
                        api_RegisterCircle(k[2] , k[3], 2)
                    end
                end

                --  获取配置中的大号名字
                env.leader_name = config["全局設置"]["跟随设置"]["大号名称"] or nil
                env.follow_move = config["全局設置"]["跟随设置"]["是否開啟"] or false
                if not env.team_info then
                    -- 组队信息初始化
                    env.team_info = {
                        ["大號名"] = config["劇情設置"]["大號名"] or "",
                        ["隊長名"] = config["劇情設置"]["隊長名"] or "",
                        ["小號名"] = {}
                    }
                end
            end
            poe2_api.time_p("Get_User_Config_Info... 耗时 --> ", api_GetTickCount64() - start_time)

            -- while true do
            --     Actors:Update() 
            --     api_Sleep(100)
            --     return bret.RUNNING
            -- end

            return bret.SUCCESS
        end
    },

    -- 判断游戏窗口 poe2_api.time_p("判断游戏窗口... 耗时 --> ", api_GetTickCount64() - current_time)
    Is_Game_Windows = {
        run = function(self, env)
            poe2_api.print_log("判断游戏窗口")
            local current_time = api_GetTickCount64()

            if not env.user_info then
                local user_info = poe2_api.load_ini(user_info_path)["UserInfo"]
                env.user_info = user_info
            end
            local game_path = env.user_info["gamedir"]
            poe2_api.dbgp("game_path:" .. game_path)
            
            
            local process_name = string.find(game_path:lower(), "steam.exe") and "PathOfExileSteam.exe" or
                "PathOfExile.exe"
            if not env.config_file then
                -- 获取文档目录路径
                env.documents_path = os.getenv('USERPROFILE') .. '\\Documents'
                -- 构建配置目录路径
                env.config_dir = env.documents_path .. '\\My Games\\Path of Exile 2'
                -- 构建配置文件路径
                env.config_file = env.config_dir .. '\\poe2_production_Config.ini'
            end

            poe2_api.dbgp("hwrd_time1:" .. env.hwrd_time)
            if env.hwrd_time == 0 or os.time() - env.hwrd_time >= 60 then
                env.game_window = api_FindWindowByProcess("", "Path of Exile 2", process_name, 0)
                poe2_api.dbgp("game_window:" .. env.game_window)
                env.hwrd_time = os.time()
                poe2_api.dbgp("------------------")
                poe2_api.dbgp("hwrd_time2:" .. env.hwrd_time)
                -- api_Sleep(5000)
                -- elapsed_ms = (api_GetTickCount64()) - start_time
                -- poe2_api.dbgp("获取窗口句柄:"..string.format( elapsed_ms))
            end


            -- 判断游戏窗口
            if (not env.game_window or env.game_window == 0) and not env.error_kill then
                poe2_api.dbgp("窗口不存在==================================================")
                -- 判断游戏配置文件是否存在
                local file = io.open(env.config_file, "r")
                if file then
                    file:close()
                    if poe2_api.check_NCStorageLocalData_config(env.config_dir) then
                        poe2_api.print_log("游戏配置文件异常,替换配置文件")
                        poe2_api.set_NCStorageLocalData_config(env.config_file)
                        poe2_api.time_p("判断游戏窗口(RUNNING)... 耗时 --> ", api_GetTickCount64() - current_time)
                        return bret.RUNNING
                    end
                end
                local log_path = poe2_api.load_config(json_path)["劇情設置"]["日志路径"]
                poe2_api.dbgp("log_path:" .. log_path)
                if env.delete_log == false or self.delete_log == nil then
                    poe2_api.dbgp("尝试删除日志文件: " .. log_path)
                    
                    -- 检查路径是否有效
                    if log_path and log_path ~= "" then
                        -- 使用双引号包裹路径，避免空格或特殊字符问题
                        local command = 'del /f /q "' .. log_path .. '"'
                        local success, error_msg = os.execute(command)
                        
                        if success then
                            poe2_api.dbgp("日志文件删除成功")
                            env.delete_log = true
                            self.delete_log = true
                            return bret.RUNNING
                        else
                            poe2_api.dbgp("日志文件删除失败: " .. (error_msg or "未知错误"))
                            return bret.RUNNING
                        end
                    else
                        poe2_api.dbgp("日志路径无效或为空")
                        return bret.RUNNING
                    end
                end
                env.is_set = false
                env.take_rest = false
                env.game_window = 0
                env.hwrd_time = 0
                -- error("窗口不存在=")
                -- api_Sleep(5000)
                -- elapsed_ms = (api_GetTickCount64()) - start_time
                -- poe2_api.dbgp("判断游戏窗口:"..string.format( elapsed_ms))
                poe2_api.time_p("判断游戏窗口(FAIL)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.FAIL
            end
            poe2_api.time_p("判断游戏窗口(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
            return bret.SUCCESS
        end
    },

    -- 加入游戏异界
    Join_Game = {
        run = function(self, env)
            poe2_api.print_log("加入异界游戏...")
            if self.bool == nil then
                self.config_exe = false
                self.bool = false
                self.bool1 = false
            end
            local start_time = api_GetTickCount64() -- 转换为 ms

            local game_path = env.user_info["gamedir"]
            poe2_api.dbgp("game_path:" .. game_path)
            local process_name = string.find(game_path:lower(), "steam.exe") and "PathOfExileSteam.exe" or
                "PathOfExile.exe"


            if env.time_out == 0 then
                env.time_out = os.time()
            end
            -- 判断是否关闭游戏
            if env.speel_ip_number >= 50
                or env.error_kill
                or env.is_set
                or env.switching_lines >= 120
                or poe2_api.find_text({ text = "This operation requires the account to be logged in.", UI_info = env.UI_info })
                or poe2_api.find_text({ text = "> 已斷線: Unable to deserialise packet with pid", UI_info = env.UI_info, min_x = 0 }) then
                poe2_api.dbgp("error_kill:", env.error_kill)
                poe2_api.dbgp("speel_ip_number:", env.speel_ip_number)
                poe2_api.dbgp("is_set:", env.is_set)
                poe2_api.dbgp("switching_lines:", env.switching_lines)
                poe2_api.dbgp("find_test (to be logged in.):",
                    poe2_api.find_text({
                        text = "This operation requires the account to be logged in.",
                        UI_info = env
                            .UI_info
                    }))
                poe2_api.dbgp("find_test (packet with pid):",
                    poe2_api.find_text({ text = "> 已斷線: Unable to deserialise packet with pid", UI_info = env.UI_info, min_x = 0 }))
                env.is_game_exe = false
                env.login_state = nil
                env.speel_ip_number = 0
                env.switching_lines = 0
                env.account_state = nil
                env.time_out = 0
                env.error_kill = false
                
                env.hwrd_time = 0
                local pid = api_EnumProcess(process_name)

                if pid and next(pid) and pid[1] ~= 0 then
                    api_SetWindowState(env.game_window, 13)
                    env.game_window = 0
                    api_Sleep(10000)
                    return bret.RUNNING
                end

                -- error("关闭游戏===============")
                -- api_Sleep(5000)
                poe2_api.time_p("关闭游戏(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            local elapsed_ms = (api_GetTickCount64()) - start_time
            poe2_api.dbgp("判断是否关闭游戏:" .. string.format(elapsed_ms))
            -- 加载中
            if poe2_api.click_text_UI({ UI_info = env.UI_info, text = "loading_screen_tip_label" }) then
                env.last_exp_check = api_GetTickCount64()
                env.last_exception_time = 0
                env.need_SmallRetreat = false
                env.need_ReturnToTown = false
                env.enter_map_click_counter = 0
                env.sacrificial_refresh = 0
                env.have_ritual = false
                env.find_path_FAIL = 0
                env.stuck_monsters = nil
                env.is_dizhu = false
                env.click_grid_pos = false
                env.need_item = nil
                env.interactive = nil
                env.not_items_buy = false
                env.open_map_UI = false -- 重置地图UI信息
                env.afoot_altar = nil
                env.record_map = nil
                env.path_list = {}
                env.end_point = nil
                env.one_other_map = nil
                env.is_timeout = false
                env.is_timeout_exit = false
                env.roll_time = nil
                env.exit_time = nil
                -- self.reset_states()
                local current_time = api_GetTickCount64()
                env.last_exception_time_move = 0.0
                env.last_exp_check_move = current_time
                if env.player_info and env.player_info.grid_x ~= 0 then
                    env.last_exp_value = env.player_info.currentExperience
                end
                poe2_api.dbgp("已重置所有经验监控状态")
                api_Sleep(2000)
                env.switching_lines = env.switching_lines + 1
                poe2_api.time_p("Join_Game_Otherworld(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if poe2_api.find_text({UI_info = env.UI_info, text = "選擇一種位移類型", min_x = 0}) then
                poe2_api.find_text({UI_info = env.UI_info, text = "滑鼠", min_x = 0,click = 2 })
                return bret.RUNNING
            end
            if poe2_api.click_text_UI({ text = "life_orb", UI_info = env.UI_info })
                or poe2_api.click_text_UI({ text = "resume_game", UI_info = env.UI_info })
                or poe2_api.find_text({ text = "清單", UI_info = env.UI_info, min_x = 0, min_y = 0, max_x = 400 }) then
                local player_info = env.player_info
                env.kill_process = true
                env.switching_lines = 0
                if not self.config_exe then
                    local file = io.open(env.config_file, "r")
                    if file then
                        file:close()
                        if poe2_api.check_NCStorageLocalData_config(env.config_dir) then
                            poe2_api.print_log("游戏配置文件异常,需要关闭游戏")
                            env.is_set = true
                            poe2_api.time_p("游戏配置文件异常,需要关闭游戏(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        else
                            self.config_exe = true
                        end
                    end
                end

                if poe2_api.find_text({ UI_info = env.UI_info, text = "你無法在遊戲暫停時使用該道具。", min_x = 0 }) and not self.bool1 then
                    self.bool1 = true
                    poe2_api.click_keyboard("space")
                end
                if not self.bool and not poe2_api.table_contains(poe2_api.get_team_info(env.team_info, env.user_config, env.player_info, 2), { "大號名", "未知" }) then
                    poe2_api.print_log("等待获取任务信息")
                    poe2_api.dbgp("等待获取任务信息")
                    self.bool = true
                end
                poe2_api.dbgp("已进入游戏")
                -- 计算当前 Tick 耗时（毫秒）
                poe2_api.time_p("已进入游戏耗时(SUCCESS)... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local text_list = { "與副本連線失敗。", "伺服器斷線。", "> Steam：未連接到 Steam", "Steam：未連接到 Steam", "已斷線", "操作逾時","由於在短時間內執行過多指令，因此被伺服器暫時切斷連線。" }
            if poe2_api.find_text({ text = text_list, UI_info = env.UI_info, min_x = 0 }) then
                poe2_api.find_text({ text = "確定", UI_info = env.UI_info, min_x = 0, click = 2 })
                api_Sleep(1000)
                return bret.RUNNING
            end
            if poe2_api.find_text({ text = "伺服器關閉維修中，請稍後再試。", UI_info = env.UI_info, min_x = 0 }) then
                error("服务器维护中,已停止运行")
            end
            if poe2_api.find_text({ text = "Your account has been banned by an administrator.", UI_info = env.UI_info }) then
                error("封号!!!")
            end
            if poe2_api.find_text({ text = "登入錯誤", UI_info = env.UI_info }) then
                error("账号或者密码错误")
            end
            if poe2_api.find_text({ text = { "此帳號已被鎖定，請至信箱確認解鎖郵件中的解鎖碼並在此輸入。", "重新寄送解鎖信" }, UI_info = env.UI_info, min_x = 0 }) then
                error("请手动处理邮箱验证")
            end
            if poe2_api.find_text({ text = "此帳號已被其他使用者登入。", UI_info = env.UI_info }) then
                error("此帳號已被其他使用者登入。")
            end

            local text_list1 = { "Login Error", "The operation timed out.", "Entry to this league has closed.",
                "Abnormal Disconnection", "Disconnection", "Disconnected", "偵測到老舊的 GPU 驅動程式。請更新至最新版本。",
                "你的帳號沒有《流亡黯道 2》的搶 先體驗資格。立即在我們的網站上領取搶先體驗金鑰或購買資格。", "搶先體驗" }
            if poe2_api.find_text({ text = text_list1, UI_info = env.UI_info }) then
                poe2_api.find_text({ text = "確定", UI_info = env.UI_info, min_x = 0, click = 2 })
                api_Sleep(1000)
                return bret.RUNNING
            end
            if poe2_api.find_text({ text = "Your IP has been banned. Please contact support if you think this is a mistake.", UI_info = env.UI_info }) then
                env.speel_ip_number = env.speel_ip_number + 1
                poe2_api.find_text({ text = "確定", UI_info = env.UI_info, min_x = 0, click = 2 })
                api_Sleep(1000)
                return bret.RUNNING
            end
            if poe2_api.find_text({ text = "同意", UI_info = env.UI_info }) then
                poe2_api.find_text({ text = "同意", UI_info = env.UI_info, min_x = 0, add_x = 150, click = 2 })
                poe2_api.find_text({ text = "繼續", UI_info = env.UI_info, min_x = 800, min_y = 450, click = 2 })
                api_Sleep(1000)
                return bret.RUNNING
            end
            if poe2_api.find_text({ text = "建立帳號", UI_info = env.UI_info, min_x = 0, max_y = 790 })
                or poe2_api.find_text({ text = "若要使用 Steam 登入，你必須先建立一個 Steam 的《流亡黯道》帳號。", UI_info = env.UI_info, min_x = 0 }) then
                poe2_api.find_text({ text = "帳號名稱", UI_info = env.UI_info, min_x = 0, add_x = 161, click = 2 })
                api_Sleep(500)
                local text = poe2_api.generate_random_string(math.random(8, 10))

                poe2_api.paste_text(text)
                api_Sleep(500)
                poe2_api.find_text({ text = "帳號名稱", UI_info = env.UI_info, min_x = 0, add_x = 110, add_y = 53, click = 2 })
                api_Sleep(500)
                return bret.RUNNING
            end
            local account = env.user_info["account"]
            local password = env.user_info["password"]
            if poe2_api.click_text_UI({ text = "username_textbox", UI_info = env.UI_info }) and not poe2_api.find_text({ text = account, UI_info = env.UI_info, min_x = 646, min_y = 572, max_x = 953, max_y = 609 }) then
                poe2_api.click_text_UI({ text = "username_textbox", UI_info = env.UI_info, click = 1 })
                api_Sleep(500)
                poe2_api.paste_text(account)
                api_Sleep(500)
                return bret.RUNNING
            end
            if poe2_api.click_text_UI({ text = "password_textbox", UI_info = env.UI_info }) and not poe2_api.find_text({ text = password, UI_info = env.UI_info, min_x = 646, min_y = 623, max_x = 953, max_y = 660 }) then
                poe2_api.click_text_UI({ text = "password_textbox", UI_info = env.UI_info, click = 1 })
                api_Sleep(500)
                poe2_api.paste_text(password)
                api_Sleep(500)
                return bret.RUNNING
            end
            if poe2_api.click_text_UI({ text = "login_button", UI_info = env.UI_info }) then
                poe2_api.find_text({ text = "登入", UI_info = env.UI_info, click = 2 })
                api_Sleep(1000)
                return bret.RUNNING
            end
            if poe2_api.find_text({ text = "已驗證。", UI_info = env.UI_info, min_x = 0 })
                and poe2_api.find_text({ text = "開始遊戲", UI_info = env.UI_info }) then
                poe2_api.dbgp1("dsgvfsdvsdzvdv")
                poe2_api.click_keyboard("space")
                return bret.RUNNING
            end
            if poe2_api.find_text({ text = "Standard", UI_info = env.UI_info }) then
                poe2_api.find_text({ text = "Standard", UI_info = env.UI_info, click = 2 })
                api_Sleep(1000)
                return bret.RUNNING
            end
            local creat_new_role = env.creat_new_role
            if poe2_api.find_text({ text = "開始遊戲", UI_info = env.UI_info })
                and not creat_new_role then
                poe2_api.find_text({ text = "開始遊戲", UI_info = env.UI_info, click = 2 })
                api_Sleep(1000)
                return bret.RUNNING
            else
                poe2_api.find_text({ text = "建立角色", UI_info = env.UI_info, click = 2 })
                api_Sleep(1000)
                return bret.RUNNING
            end
            poe2_api.dbgp("UI未找到任何元素")
            return bret.RUNNING
        end
    },

    -- 官方加入游戏
    Official_Join_Game = {
        run = function(self, env)
            poe2_api.print_log("通过官方渠道加入游戏...")
            local current_time = api_GetTickCount64()

            local function launch_poe2(game_path, game_dir)
                --[[
                专门用于启动Path of Exile 2的函数

                参数:
                    game_path: PoE2主程序路径
                    game_dir: PoE2安装目录
                返回:
                    bool: 启动是否成功
                ]] --

                -- 检查文件和目录是否存在
                local file = io.open(game_path, "r")
                if not file then
                    poe2_api.dbgp(string.format("游戏程序未找到: %s", game_path))
                    return false
                end
                file:close()

                -- 检查目录是否存在
                local dir_handle = io.popen('cd "' .. game_dir .. '" 2>&1')
                local dir_result = dir_handle:read("*a")
                dir_handle:close()
                if dir_result:find("系统找不到指定的路径") or dir_result:find("cannot find the path") then
                    poe2_api.dbgp(string.format("游戏目录未找到: %s", game_dir))
                    return false
                end

                -- 启动游戏

                local command = string.format('start "" /D "%s" "%s"', game_dir, game_path)
                local launch_ok = os.execute(command)

                -- 检查启动结果
                if launch_ok then
                    poe2_api.print_log("游戏启动成功")
                    return true
                else
                    poe2_api.dbgp(string.format("游戏启动失败: %s", launch_ok))
                    return false
                end
            end
            local function get_dirname(path)
                -- 处理 Windows 路径分隔符
                path = path:gsub("/", "\\")
                -- 移除末尾的斜杠（如果有）
                path = path:gsub("[\\/]+$", "")
                -- 获取最后一个斜杠之前的部分
                local dir = path:match("^(.*)[\\/]") or "."
                return dir
            end
            local launch_timeout = env.launch_timeout
            local game_path = env.user_info["gamedir"]
            local is_steam_version = string.find(game_path:lower(), "steam.exe")
            -- 判断官方/steam
            if is_steam_version then
                poe2_api.print_log("steam版本============================================")
                return bret.FAIL
            end
            if launch_timeout ~= 0 and launch_timeout then
                if os.time() - launch_timeout > 120 then
                    poe2_api.print_log("官方游戏启动超时2分钟，重新启动")
                    local pid = api_EnumProcess("PathOfExile.exe")
                    local game_window = api_FindWindowByProcess("", "Path of Exile 2", "PathOfExile.exe", 0)
                    if pid and next(pid) and pid[1] ~= 0 and game_window and game_window ~= 0 then
                        api_SetWindowState(game_window, 13)
                        -- poe2_api.terminate_process(pid)
                        env.game_window = 0
                        env.hwrd_time = 0
                        api_Sleep(10000)
                        return bret.RUNNING
                    end
                    env.kill_process = false
                    env.launch_timeout = 0
                    return bret.RUNNING
                else
                    poe2_api.print_log("等待游戏窗口")
                    return bret.RUNNING
                end
            end
            -- 判断游戏窗口
            -- local pid = nil
            local pid1 = false

            local window_handlesteam = api_FindWindowByProcess("", "Path of Exile 2", "PathOfExileSteam.exe", 0)
            if window_handlesteam and window_handlesteam ~= 0 then
                pid1 = true
            end

            local window_handle = api_FindWindowByProcess("", "Path of Exile 2", "PathOfExile.exe", 0)
            if window_handle and window_handle ~= 0 then
                pid1 = true
            end
            if pid1 then
                poe2_api.print_log("第一次启动,清理游戏进程")
                if window_handlesteam and window_handlesteam ~= 0 then
                    api_SetWindowState(window_handlesteam, 13)
                    env.game_window = 0
                    env.hwrd_time = 0
                    api_Sleep(10000)
                    return bret.RUNNING
                end
                if window_handle and window_handle ~= 0 then
                    api_SetWindowState(window_handle, 13)
                    env.game_window = 0
                    env.hwrd_time = 0
                    api_Sleep(10000)
                    return bret.RUNNING
                end
                -- poe2_api.terminate_process(pid)
            end

            -- 启动游戏
            local game_dir = get_dirname(game_path)
            local launch_result = launch_poe2(game_path, game_dir)
            if launch_result then
                poe2_api.print_log("游戏启动成功")
                if launch_timeout == 0 then
                    env.launch_timeout = os.time()
                end
                api_Sleep(5000)
            else
                poe2_api.print_log("游戏启动失败")
            end
            return bret.RUNNING
        end
    },

    -- 通过Steam启动游戏
    Launch_Game_Steam = {
        
        run = function(self, env)
            poe2_api.print_log("通过Steam启动游戏...")
            -- local login_state = env.login_state
            local game_path = env.user_info["gamedir"]
            if not self.last_time then
                self.last_time = 0
                return bret.RUNNING
            end
            poe2_api.dbgp("login_state: "..tostring(env.login_state))
            if not env.login_state then
                poe2_api.print_log("清空数据")
                env.kill_process=false
                env.game_window = 0
                env.hwrd_time = 0
                poe2_api.delete_steam_account_history(game_path)
                local steam_pid = api_EnumProcess("steam.exe")
                poe2_api.dbgp(tostring(#steam_pid.."==========================="))
                poe2_api.dbgp(tostring(steam_pid[1].."==========================="))
                -- for k, v in pairs(steam_pid) do
                --     poe2_api.dbgp(tostring(k) .. tostring(v))
                -- end
                poe2_api.dbgp("steam_pid: "..tostring(steam_pid))
                if steam_pid and next(steam_pid) and steam_pid[1] ~= 0 then
                    poe2_api.exec_cmd("taskkill /f /im steam.exe")
                    api_Sleep(2000)
                    return bret.RUNNING
                end
                local steamwebhelper_pid = api_EnumProcess("steamwebhelper.exe")
                poe2_api.dbgp(tostring(#steamwebhelper_pid.."===========================1111"))
                if steamwebhelper_pid and next(steamwebhelper_pid) and  steamwebhelper_pid[1] ~= 0 then
                    poe2_api.exec_cmd("taskkill /f /im steamwebhelper.exe")
                    api_Sleep(2000)
                    return bret.RUNNING
                end
                env.login_state = "启动登录窗口"
                if self.last_time == 0 then
                    self.last_time = os.time()
                end
                return bret.RUNNING
            end
            if env.login_state == "启动登录窗口" then
                -- local start_path = string.format("%s -applaunch %d", game_path, 2694490)
                local start_cmd = string.format('start "" "%s" -applaunch %d', game_path, 2694490)
                local steam_pid = api_EnumProcess("steam.exe")
                if not steam_pid or not next(steam_pid) or steam_pid[1] == 0 then
                    poe2_api.exec_cmd(start_cmd)
                    poe2_api.dbgp("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
                    api_Sleep(5000)
                    env.login_state = "等待登录窗口"
                    self.last_time = os.time()
                    return bret.RUNNING
                end
            end
            if env.login_state == "等待登录窗口" then
                local steam_login_hwnd = api_FindWindow("SDL_app", "登录 Steam",0)
                if steam_login_hwnd and steam_login_hwnd ~= 0 then
                    env.login_state = "输入帳號"
                    self.last_time = os.time()
                    return bret.RUNNING
                end
                poe2_api.print_log("等待登录窗口")
                if os.time() - self.last_time > 120 then
                    poe2_api.print_log("等待登录窗口超时")
                    env.login_state = nil
                    self.last_time = 0
                    return bret.RUNNING
                end
                api_Sleep(2000)
                return bret.RUNNING
            end
            if env.login_state == "输入帳號" then
                local account = env.user_info["account"]
                local password = env.user_info["password"]
                -- local steam_login_hwnd = api_FindWindow("Chrome_RenderWidgetHostHWND","Chrome Legacy Window",0)
                local steam_login_hwnd = api_FindWindow("SDL_app", "登录 Steam",0)
                -- poe2_api.dbgp("111:",steam_login_hwnd)
                -- api_Sleep(10000000)
                if steam_login_hwnd and steam_login_hwnd ~= 0 then
                    api_SetWindowState(steam_login_hwnd, 8)
                    api_Sleep(1000)
                    -- api_SetWindowState(steam_login_hwnd, 9)
                    -- api_Sleep(1000)
                    local left, top, right, bottom = api_GetWindowRect(steam_login_hwnd)
                    api_ClickScreen(poe2_api.toInt(left + 345),poe2_api.toInt(top + 140) , 1)
                    api_Sleep(1000)
                    poe2_api.paste_text(account)
                    api_Sleep(1000)
                    api_ClickScreen(poe2_api.toInt(left + 345), poe2_api.toInt(top + 206) , 1)
                    api_Sleep(1000)
                    poe2_api.paste_text(password)
                    api_Sleep(1000)
                    poe2_api.click_keyboard("enter",0)     
                    env.login_state = "等待steam主窗口"
                    self.last_time = os.time()
                    return bret.RUNNING

                else
                    poe2_api.print_log("登录窗口不存在")
                    env.login_state = nil
                    self.last_time = 0
                    return bret.RUNNING
                end
                
                -- 根据窗口句柄 获取窗口坐标
                return bret.RUNNING
            end
            if env.login_state == "等待steam主窗口" then
                poe2_api.print_log("等待steam主窗口")
                local steam_login_hwnd = api_FindWindowByProcess("","Steam","steamwebhelper.exe",0)
                if steam_login_hwnd and steam_login_hwnd ~= 0 then
                    env.login_state = "等待游戏窗口"
                    self.last_time = os.time()
                    return bret.RUNNING
                end
                if os.time() - self.last_time > 120 then
                    poe2_api.print_log("等待steam主窗口超时")
                    env.login_state = nil
                    self.last_time = 0
                    return bret.RUNNING
                end
                api_Sleep(2000)
                return bret.RUNNING
            end
            if env.login_state == "等待游戏窗口" then
                poe2_api.print_log("等待steam游戏窗口")
                if os.time() - self.last_time > 120 then
                    poe2_api.print_log("等待steam游戏窗口超时")
                    env.login_state = nil
                    self.last_time = 0
                    return bret.RUNNING
                end
                api_Sleep(2000)
                return bret.RUNNING
            end
            return bret.RUNNING
        end
    },

    -- 获取UI信息
    Get_UI_Info = {
        run = function(self, env)
            poe2_api.print_log("获取UI信息...")
            local start_time = api_GetTickCount64() -- 开始时间
            env.UI_info = UiElements:Update()
            if #env.UI_info < 1 then
                api_Sleep(4000)
                return bret.RUNNING
            end
            -- for _,k in ipairs(env.UI_info) do
            --     if k.text_utf8 ~= "" then
            --         poe2_api.dbgp(k.text_utf8)
            --     end
            -- end
            poe2_api.time_p("Get_UI_Info... 耗时 --> ", api_GetTickCount64() - start_time)
            -- api_Sleep(4000)
            return bret.SUCCESS
        end
    },

    -- 获取信息
    Get_Info = {
        run = function(self, env)
            poe2_api.print_log("获取游戏信息...")
            local start_time = api_GetTickCount64() -- 开始时间

            local player_info_start_time = api_GetTickCount64()
            env.player_info = api_GetLocalPlayer()
            poe2_api.printTable(env.player_info)
            if poe2_api.countTableItems(env.player_info) < 1 then
                poe2_api.dbgp("空人物信息")
                return bret.RUNNING
            end
            poe2_api.time_p("    获取人物信息... 耗时 --> ", api_GetTickCount64() - player_info_start_time)

            local range_info_start_time = api_GetTickCount64() -- 记录开始时间(毫秒)
            if not self.last_check then
                self.last_check = range_info_start_time
            end
            if range_info_start_time - self.last_check > 0 or not env.range_info or #env.range_info < 1 then
                env.range_info = Actors:Update()
                self.last_check = range_info_start_time
                if #env.range_info < 1 then
                    poe2_api.dbgp("等待获取周围对象信息...")
                    return bret.RUNNING
                end
                poe2_api.time_p("    获取周围对象信息... 耗时 --> ", api_GetTickCount64() - range_info_start_time)
            end
            -- api_GetMinimapActorInfo() - 获取小地图周围对象信息
            local current_map_info_start_time = api_GetTickCount64()
            env.current_map_info = api_GetMinimapActorInfo()
            if not env.current_map_info then
                poe2_api.dbgp("空小地图周围对象信息")
                return bret.RUNNING
            end
        --    for _,k in ipairs(env.current_map_info) do
        --         poe2_api.dbgp(k.name_utf8)
        --         poe2_api.dbgp(k.grid_x)
        --         poe2_api.dbgp(k.grid_y)
        --         poe2_api.dbgp(k.flagStatus)
        --         poe2_api.dbgp(k.flagStatus1)
        --         poe2_api.dbgp("==============================")
        --     end
            -- poe2_api.printTable(api_GetTeleportationPoint())
            -- poe2_api.printTable(api_GetQuestList())
            -- poe2_api.printTable(api_GetTeamInfo())
            -- while true do
            --     api_Sleep(1000)
            -- end
            poe2_api.time_p("    获取小地图周围对象信息... 耗时 --> ", api_GetTickCount64() - current_map_info_start_time)

            -- 队伍数据信息
            local team_info_data_start_time = api_GetTickCount64()
            env.team_info_data = api_GetTeamInfo()
            poe2_api.dbgp('获取队伍信息')
            poe2_api.time_p("    获取队伍信息... 耗时 --> ", api_GetTickCount64() - team_info_data_start_time)
            -- 周围装备信息
            local range_items_start_time = api_GetTickCount64()
            env.range_items = WorldItems:Update()
            poe2_api.time_p("    获取周围装备信息... 耗时 --> ", api_GetTickCount64() - range_items_start_time)

            -- 背包信息（主背包）
            local bag_info_start_time = api_GetTickCount64()
            env.bag_info = api_Getinventorys(1, 0)
            poe2_api.time_p("    获取背包信息信息... 耗时 --> ", api_GetTickCount64() - bag_info_start_time)

            -- api_GetTeleportationPoint() - 获取传送点信息

            -- 测试函数
            local function dumpInventory(inventory)
                local itemFields = {
                    "name_utf8", "baseType_utf8", "start_x", "start_y", "end_x", "end_y",
                    "not_identified", "category_utf8", "color", "world_x", "world_y", "grid_x", "grid_y",
                    "skillGemLevel", "skillStoneLevel", "isWearable", "DemandStrength", "DemandAgility",
                    "DemandWisdom", "DemandLevel", "obj", "contaminated", "id", "tribute",
                    "totalDeferredConsumption", "fixedSuffixCount", "mods_obj", "stackCount"
                }

                for _, item in ipairs(inventory) do
                    api_Log("==============================")
                    -- local Suffix = api_GetObjectSuffix(item.mods_obj)
                    -- local Suffix1 = api_GetObjectSuffix(item.obj)
                    -- poe2_api.printTable(item.fixedSuffixCount)
                    -- poe2_api.printTable(Suffix)
                    -- poe2_api.printTable(Suffix1)
                    -- api_Log("Suffix")
                    -- api_Log(Suffix)
                    -- api_Log("Suffix1")
                    -- api_Log(Suffix1)
                    -- 遍历预定义的属性列表，确保按固定顺序输出
                    for _, field in ipairs(itemFields) do
                        local value = item[field]
                        api_Log(string.format("%-25s: %s", field, tostring(value)))
                    end

                    api_Log("----------------------------------")
                end

                api_Sleep(1000000) -- 暂停程序（注意：长时间暂停可能导致游戏无响应）
            end

            -- 测试函数
            local function dumprange(inventory)
                local itemFields = {
                    "obj", "name_utf8", "world_x", "world_y", "world_z", "grid_x", "grid_y", "max_life",
                    "life", "max_mana", "mana", "max_shield",
                    "shield", "type", "current_map_name_utf8", "is_selectable",
                    "level", "strength", "dexterity", "intelligence",
                    "spirit_max", "spirit_use", "is_friendly", "hasTasksToAccept",
                    "hasLineOfSight", "isActive", "rarity", "path_name_utf8",
                    "currentExperience", "id", "isInDangerArea", "stateMachineList", "gold",
                    "isInBossBattle", "remainingPortalCount", "isMoving", "magicProperties"
                }

                for _, item in ipairs(inventory) do
                    if item.name_utf8 == "" or item.life == 0 or not item.isActive then
                        goto continue
                    end
                    api_Log("==============================")
                    -- 遍历预定义的属性列表，确保按固定顺序输出
                    for _, field in ipairs(itemFields) do
                        local value = item[field]
                        api_Log(string.format("%-25s: %s", field, tostring(value)))
                    end

                    api_ClickMove(item.grid_x, item.grid_y, 0)
                    api_Sleep(1000)

                    api_Log("----------------------------------")
                    ::continue::
                end

                api_Sleep(1000000) -- 暂停程序（注意：长时间暂停可能导致游戏无响应）
            end

            -- 调用函数
            -- dumpInventory(env.range_items)
            -- dumprange(env.range_info)
            -- poe2_api.printTable(api_GetQuestList(0))
            -- api_Sleep(1000000) -- 暂停程序（注意：长时间暂停可能导致游戏无响应）
            
            if self.wear_items == nil then
                self.wear_items = true
            end
            -- 其他物品栏信息（批量处理）
            if self.wear_items then
                local inventory_sections = {
                    { 2, "item2" }, { 3, "item3" }, { 4, "item4" },
                    { 5, "item5" }, { 6, "item6" }, { 7, "item7" },
                    { 8, "item8" }, { 9, "item9" }, { 0xa, "item0xa" }, { 0xb, "item0xb" }
                }
                for _, section in ipairs(inventory_sections) do
                    local section_id = section[1]
                    local section_name = section[2]
                    if not env[section_name] then
                        local items = api_Getinventorys(section_id, 0)
                        env[section_name] = items
                    end
                end
                self.wear_items = false
            end

            poe2_api.time_p("Get_Info... 总耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 清理
    Clear = {
        run = function(self, env)
            poe2_api.print_log("执行清理...")
            local start_time = api_GetTickCount64()
            if not env.clear_time then
                env.clear_bool = false
                env.clear_time = 0
                poe2_api.dbgp("初始化")
            end
            local player_info = env.player_info
            if not player_info or not next(player_info) then
                poe2_api.dbgp("人物信息为空")
                return bret.RUNNING
            end
            if env.clear_time == 0 then
                env.clear_time = api_GetTickCount64()
            end
            if poe2_api.find_text({ UI_info = env.UI_info, text = "私訊", add_x = 265, min_x = 0, max_x = 400, click = 2 }) then
                return bret.RUNNING
            end
            if not env.clear_click_bool then
                env.clear_click_bool = true
                poe2_api.dbgp("点击清理")
                api_ClickMove(poe2_api.toInt(player_info.grid_x), poe2_api.toInt(player_info.grid_y),7)
            end
            if player_info.life ~= 0 and not poe2_api.click_text_UI({ text = "respawn_at_checkpoint_button", UI_info = env.UI_info }) then
                if (string.match(player_info.current_map_name_utf8, "own") and not env.clear_bool) or start_time - env.clear_time > 5 * 60 * 1000 then
                    if not poe2_api.find_text({ UI_info = env.UI_info, text = "/clear", min_x = 0 }) then
                        poe2_api.click_keyboard("enter")
                        api_Sleep(500)
                        poe2_api.click_keyboard("backspace")
                        api_Sleep(500)
                        poe2_api.paste_text("/clear")
                        api_Sleep(500)
                        poe2_api.click_keyboard("enter")
                        api_Sleep(500)
                        env.clear_bool = true
                        env.clear_time = 0
                        return bret.RUNNING
                    end
                elseif not string.match(player_info.current_map_name_utf8, "") then
                    env.clear_bool = false
                end
            end
            poe2_api.time_p("执行清理... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 休息控制
    RestController = {
        run = function(self, env)
            poe2_api.print_log("执行休息控制...")
            poe2_api.dbgp("执行休息控制...")
            local player_info = env.player_info
            local start_time = api_GetTickCount64() -- 开始时间
            -- 特殊情况跳出
            if poe2_api.get_team_info(env.team_info, env.user_config, player_info, 2) ~= "大號名" or player_info.isInBossBattle or poe2_api.is_have_mos({ range_info = env.range_info, player_info = player_info, dis = 80, stuck_monsters = env.stuck_monsters, not_attack_mos = env.not_attack_mos }) then
                return bret.SUCCESS
            end
            -- 初始化检查
            if not self._is_initialized then
                poe2_api.dbgp("初始化休息控制器...")
                local config = env.user_config["全局設置"]["刷图通用設置"]["定時休息"] or {}
                
                -- 工作时间配置（单位：分钟→毫秒）
                local base_work = tonumber(config["運行時間"]) or 60  -- 默认60分钟
                local work_random_range = math.min(tonumber(config["工作時間隨機範圍"]) or 0.1, 0.3) -- 限制最大30%波动
                self.work_duration_ms = math.floor(base_work * 60 * 1000 * (1 + (math.random() * work_random_range * 2 - work_random_range)))
                
                -- 休息时间配置（单位：分钟→毫秒）
                local base_rest = tonumber(config["休息時間"]) or 10  -- 默认10分钟
                local rest_random_range = math.min(tonumber(config["休息時間隨機範圍"]) or 0.1, 0.3) -- 限制最大30%波动
                self.rest_duration_ms = math.floor(base_rest * 60 * 1000 * (1 + (math.random() * rest_random_range * 2 - rest_random_range)))

                -- 功能开关
                self.is_open = config["是否開啟"] or false
                self.is_kill_game = config["休息时是否关闭游戏"] or false
                
                -- 初始化状态（使用毫秒时间戳）
                local current_time_ms = api_GetTickCount64()
                self._is_resting = false
                self._next_state_change_time_ms = current_time_ms + self.work_duration_ms
                self._last_update_time_ms = current_time_ms
                self._is_initialized = true
                
                poe2_api.dbgp("初始化完成 - 工作时间:%d分钟 休息时间:%d分钟", self.work_duration_ms/(60*1000), self.rest_duration_ms/(60*1000))
                return bret.RUNNING
            end

            -- 功能关闭直接返回成功
            if not self.is_open then
                poe2_api.dbgp("休息功能未开启，直接返回SUCCESS")
                poe2_api.time_p("休息功能未开启... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            
            local current_time_ms = api_GetTickCount64()

            local function _perform_rest_actions()
                poe2_api.dbgp("执行休息操作...")
                if not (poe2_api.find_text({UI_info = env.UI_info, text = "回到角色選擇畫面"}) or poe2_api.click_text_UI({UI_info = env.UI_info, text = "exit_to_character_selection"})) then
                    if poe2_api.click_text_UI({UI_info = env.UI_info, text = "life_orb"}) and poe2_api.click_text_UI({UI_info = env.UI_info, text = "mana_orb"}) then
                        poe2_api.click_keyboard("esc")
                    end
                end
                api_Sleep(1000)
            end

            local function _handle_state_transition()
                self._is_resting = not self._is_resting
                local duration_ms = self._is_resting and self.rest_duration_ms or self.work_duration_ms
                self._next_state_change_time_ms = current_time_ms + duration_ms
                self._last_update_time_ms = current_time_ms
                
                -- 更新环境变量
                env.take_rest = self._is_resting
                
                if self._is_resting then
                    poe2_api.dbgp("切换到休息状态")
                    
                    if not string.find(player_info.current_map_name_utf8, "own") then
                        poe2_api.dbgp("休息回城")
                        for _, name in ipairs(my_game_info.city_map) do
                            poe2_api.find_text({ UI_info = env.UI_info, text = name, click = 2 })
                        end
                        api_ClickScreen(1230, 815, 0)
                        api_Sleep(500)
                        api_ClickScreen(1230, 815, 1)
                        api_Sleep(2000)
                        return bret.RUNNING
                    end
                    
                    -- 进入休息状态
                    if self.is_kill_game then
                        env.error_kill = true
                        poe2_api.dbgp("设置需要关闭游戏")
                    end
                    poe2_api.dbgp(string.format("工作时间到，开始休息 (%d分钟)", math.floor(self.rest_duration_ms/(60*1000))))
                    -- _perform_rest_actions()
                    -- poe2_api.dbgp(string.format("工作时间到，开始休息 (%d分钟)", math.floor(self.rest_duration_ms/(60*1000))))
                    -- api_Sleep(11000000)
                    return bret.RUNNING
                else
                    -- 返回工作状态
                    env.error_kill = false
                    poe2_api.dbgp(string.format("休息结束，开始工作 (%d分钟)",  math.floor(self.work_duration_ms/(60*1000))))
                    self._is_initialized = false
                    return bret.SUCCESS
                end
            end

            local function _update_status()
                local time_remaining_ms = math.max(0, self._next_state_change_time_ms - current_time_ms)
                
                if self._is_resting then
                    poe2_api.dbgp("当前处于休息状态")

                    
                    -- 休息状态更新（每分钟60000毫秒）
                    if current_time_ms - self._last_update_time_ms >= 60000 then
                        self._last_update_time_ms = current_time_ms
                        local mins = math.floor(time_remaining_ms/(60*1000))
                        local secs = math.floor((time_remaining_ms%(60*1000))/1000)
                        poe2_api.print_log(string.format("休息中... 剩余时间: %02d分%02d秒", mins, secs))
                        env.take_rest = true
                        
                        if not string.find(player_info.current_map_name_utf8, "own") then
                            poe2_api.dbgp("休息回城(状态更新)")
                            for _, k in ipairs(my_game_info.city_map) do
                                poe2_api.find_text({ UI_info = env.UI_info, text = k.name_utf8, click = 2 })
                            end
                            api_ClickScreen(1230, 815, 0)
                            api_Sleep(500)
                            api_ClickScreen(1230, 815, 1)
                        end
                        api_Sleep(1000)
                    end
                    api_Sleep(2000)
                    return bret.RUNNING
                else
                    -- 工作状态更新（每5分钟300000毫秒）
                    if current_time_ms - self._last_update_time_ms >= 300000 then
                        self._last_update_time_ms = current_time_ms
                        local hours = math.floor(time_remaining_ms/(3600*1000))
                        local mins = math.floor((time_remaining_ms%(3600*1000))/(60*1000))
                        local secs = math.floor((time_remaining_ms%(60*1000))/1000)
                        poe2_api.print_log(string.format("工作中... 距离休息还有: %d小时%02d分钟%02d秒", hours, mins, secs))
                        env.take_rest = false
                    end
                    return bret.SUCCESS
                end
            end

            -- 状态切换检查（毫秒级比较）
            if current_time_ms >= self._next_state_change_time_ms then
                poe2_api.dbgp("检测到状态切换时间到达")
                poe2_api.time_p("检测到状态切换时间到达... 耗时 --> ", api_GetTickCount64() - start_time)
                return _handle_state_transition()
            end
                
            -- 状态更新
            poe2_api.dbgp("更新当前状态...")
            poe2_api.time_p("更新当前状态... 耗时 --> ", api_GetTickCount64() - start_time)
            return _update_status()
        end
    },

    -- 检查长时间未移动
    Check_LongTime_Not_Move = {
        run = function(self, env)
            poe2_api.print_log("开始执行长时间经验检查...")
            
            local current_time = api_GetTickCount64()
            local take_rest = env.take_rest
            local player_info = env.player_info
        -- 特殊情况跳出
            if player_info.isInBossBattle or poe2_api.get_team_info(env.team_info, env.user_config, player_info, 2) ~= "大號名" then
                return bret.SUCCESS
            end
            if not env.louti_space then
                return bret.SUCCESS
            end
            --- 辅助函数
            -- 检查是否处于停滞移动状态
            local function _check_stagnant_movement()
                local current = env.player_info
                if not current then return false end
                
                local last_pos = env.last_position or {0, 0}
                local distance = poe2_api.point_distance(last_pos[1], last_pos[2], current)
                
                -- 更新位置记录
                env.last_position = {current.grid_x, current.grid_y}
                
                poe2_api.dbgp(string.format("移动距离检查: %.2f (阈值:15)", distance))
                return distance < 15
            end
            -- 重置移动检查状态
            local function reset_states_move()
                local current_time = api_GetTickCount64()
                local current = env.player_info
                env.last_exception_time_move = 0.0
                env.last_exp_check_move = current_time
                env.last_exp_value_move = env.player_info.currentExperience
                env.last_position = {current.grid_x, current.grid_y}
                poe2_api.dbgp("已重置所有移动监控状态")
            end

            -- 获取可交互对象
            local function get_range()
                local valid_objects = {
                    "甕", "壺", "屍體", "巢穴", "籃子", "小雕像", "石塊",
                    "鬆動碎石", "瓶子", "盒子", "腐爛木材", "保險箱", "腐爛木材","祕寶"
                }
                
                -- 对范围对象进行排序
                local sorted_range = poe2_api.get_sorted_list(env.range_info, env.player_info)
                if not sorted_range then
                    poe2_api.dbgp("警告: 无法获取排序后的范围列表")
                    return false
                end

                poe2_api.dbgp(string.format("检查 %d 个范围内的对象", #sorted_range))
                
                -- 遍历查找符合条件的对象
                for _, obj in ipairs(sorted_range) do
                    -- 调试输出当前对象信息
                    poe2_api.dbgp(string.format("检查对象: %s (类型: %s, 激活: %s, 可选: %s)", 
                        obj.name_utf8 or "无名", 
                        obj.type or "未知", 
                        tostring(obj.isActive), 
                        tostring(obj.is_selectable)))
                    
                    if obj.name_utf8 and 
                    poe2_api.table_contains(valid_objects, obj.name_utf8) and
                    obj.isActive and 
                    obj.is_selectable and
                    obj.grid_x and obj.grid_y then
                        
                        local distance = poe2_api.point_distance(obj.grid_x, obj.grid_y, player_info)
                        if distance then
                            poe2_api.dbgp(string.format("对象 %s 距离: %.2f", obj.name_utf8, distance))
                            
                            if distance <= 20 then
                                poe2_api.dbgp("找到符合条件的交互对象: ", obj.name_utf8)
                                return obj
                            end
                        end
                    end
                end
                
                poe2_api.dbgp("未找到符合条件的交互对象")
                return false
            end
            
            -- 节流控制
            if self.last_check and current_time - self.last_check < 500 then
                poe2_api.dbgp("节流控制: 检查间隔小于0.5秒，跳过")
                poe2_api.time_p("Check_LongTime_EXP_Add(节流控制)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end

            self.last_check = current_time   

            if take_rest then
                poe2_api.dbgp("正在休息，跳过异常处理")
                return bret.SUCCESS
            end

            -- 检查移动状态
            local is_moving = _check_stagnant_movement()
            poe2_api.dbgp("移动状态检查: ", is_moving and "未移动" or "移动中")
            -- 移动状态变化时重置状态
            if not is_moving then
                poe2_api.dbgp("移动状态变化，重置移动检查状态")
                reset_states_move()
            end

            -- 计算真实停滞时间
            local space_time = 10
            local real_stagnation_time_move = current_time - (env.last_exp_check_move or 0)
            
            poe2_api.dbgp(string.format("移动停滞时间: %.2f秒", real_stagnation_time_move / 1000))

            -- 处理长时间未移动情况
            if is_moving and real_stagnation_time_move > space_time * 1000 then
                poe2_api.dbgp(string.format("长时间未移动(%.2f秒 > %d秒)，执行恢复操作", 
                    real_stagnation_time_move / 1000, space_time))
                
                if not take_rest then
                    poe2_api.print_log("清路径333")
                    env.end_point = nil
                    env.target_point = nil
                    env.path_list = {}
                    env.is_arrive_end = true
                    env.mouse_check = true
                    poe2_api.dbgp1("sgewgbfdbgfdhn")
                    poe2_api.click_keyboard("space")
                    
                    if env.range_info and player_info then
                        local target = get_range()
                        if target then
                            api_ClickMove(poe2_api.toInt(target.grid_x), poe2_api.toInt(target.grid_y), 0)
                            api_Sleep(500)
                            api_ClickMove(poe2_api.toInt(target.grid_x), poe2_api.toInt(target.grid_y), 1)
                            api_Sleep(500)
                            poe2_api.find_text({UI_info = env.UI_info, text = target.name_utf8, click = 2, refresh = true, min_x = 0})
                            api_Sleep(500)
                        end
                        
                        local walkpoint = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y,50)
                        api_ClickMove(poe2_api.toInt(walkpoint.x), poe2_api.toInt(walkpoint.y),
                             7)
                        api_Sleep(500)
                        poe2_api.dbgp1("fdgrgrfhfhdfhb")
                        poe2_api.click_keyboard("space")
                        api_Sleep(100)
                    end
                    env.last_exp_check_move = api_GetTickCount64()
                    return bret.RUNNING
                end
            end
            poe2_api.time_p("Check_LongTime_EXP_Add(SUCCESS)... 耗时 --> ", api_GetTickCount64() - current_time)
            return bret.SUCCESS
        end
    },
    -- 检查异界死亡
    Is_Deth = {
        run = function(self, env)
            poe2_api.print_log("死亡初始化")
            poe2_api.dbgp("死亡初始化")
            local start_time = api_GetTickCount64()
            local player_info = env.player_info

            if not self.respawn_wait_start then
                self.respawn_wait_start = 0
                self.click_time = 0
                self.death_time = 0
            end
            if not player_info then
                poe2_api.dbgp("玩家信息不存在，跳过死亡初始化")
                return bret.RUNNING
            end
            if player_info.life ~= 0 then
                self.click_time = 0
                self.death_time = 0
                poe2_api.time_p("Is_Deth... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if player_info.life == 0 and poe2_api.find_text({ UI_info = env.UI_info, text = "在記錄點重生" }) then
                if poe2_api.click_text_UI({ UI_info = env.UI_info, text = "respawn_at_checkpoint_button" }) and not env.is_timeout and not env.is_timeout_exit then
                    poe2_api.dbgp1("rewyrejhgfdbnsdbvs")
                    poe2_api.click_keyboard("space")
                end
                poe2_api.dbgp("点击确认")
                poe2_api.find_text({ UI_info = env.UI_info, text = "確定", click = 2, min_x = 0 })
                api_ClickScreen(915, 490, 1)
                local relife_text = { "在記錄點重生", "在城鎮重生" }
                local point = poe2_api.find_text({ UI_info = env.UI_info, text = relife_text, min_x = 0, position = 3 })
                if not point then
                    poe2_api.time_p("Is_Deth(RUNNING)... 耗时 --> ", api_GetTickCount64() - start_time)
                    poe2_api.dbgp("Is_Deth(RUNNING1)")
                    return bret.RUNNING
                end

                api_ClickScreen(point[1], point[2], 0)
                api_Sleep(1000)
                api_ClickScreen(point[1], point[2], 1)
                if self.death_time == 0 then
                    self.death_time = api_GetTickCount64()
                end
                if self.click_time == 0 then
                    self.click_time = api_GetTickCount64()
                end
                if (start_time - self.death_time >= 60 * 1000) and (poe2_api.get_team_info(env.team_info, env.user_config, player_info, 2) == "大號名") then
                    env.is_timeout_exit = true
                end
                if start_time - self.click_time >= 5 * 1000 then
                    poe2_api.find_text({ UI_info = env.UI_info, text = "在記錄點重生", click = 2 })
                    self.click_time = 0
                end
                env.area_list = {}
                env.is_need_check = false
                env.stuck_monsters = nil
                env.item_name = nil
                env.item_pos = nil
                env.afoot_altar = nil
                env.record_map = nil
                env.check_all_points = false
                env.empty_path = false
                env.map_name = nil
                env.interaction_object = nil
                env.item_move = false
                env.item_end_point = { 0, 0 }
                env.attack_move = false
                env.ok = false
                env.not_need_wear = false
                env.currency_check = false
                env.sell_end_point = { 0, 0 }
                env.is_better = false
                env.mos_out = 0
                env.is_arrive_end = false
                env.not_need_pick = false
                env.is_not_ui = false
                env.no_item_wear = false
                env.my_role = nil
                env.is_set = false
                env.end_point = nil
                env.path_list = {}
                env.run_point = nil
                env.teleport_area = nil
                env.follow_role = nil
                env.one_other_map = nil
                env.need_item = nil
                env.center_radius = 0
                env.center_point = {}

                if self.respawn_wait_start == 0 then
                    self.respawn_wait_start = api_GetTickCount64()
                    return bret.RUNNING
                elseif api_GetTickCount64() - self.respawn_wait_start < 2 then
                    return bret.RUNNING
                else
                    self.respawn_wait_start = 0
                end
            end
            poe2_api.time_p("Is_Deth... 耗时 --> ", api_GetTickCount64() - start_time)
            poe2_api.dbgp("Is_Deth(SUCCESS2)")
            return bret.SUCCESS
        end
    },

    -- 检查低血量/蓝量
    CheckLowHpMp = {
        run = function(self, env)
            local start_time = api_GetTickCount64()
            poe2_api.dbgp("开始执行蓝血检查:")
            
            local player = env.player_info
            local prot = env.protection_settings
            local emerg = env.emergency_settings
            
            -- 初始化计时器（如果不存在）
            if self.last_health_recovery_time == nil then
                self.last_health_recovery_time = api_GetTickCount64()
                self.last_mana_recovery_time = api_GetTickCount64()
                self.last_shield_recovery_time = api_GetTickCount64()
                self._emergency_cooldown = 0
                poe2_api.dbgp("初始化计时器完成")
            end
            
            -- 检查玩家信息
            if not player then
                poe2_api.dbgp("错误: 玩家信息为空")
                return bret.RUNNING
            end

            local function _handle_regular_recovery(player, prot, now)
                poe2_api.dbgp("开始处理常规恢复...")
                poe2_api.dbgp("当前生命值:", player.life, "/", player.max_life)
                poe2_api.dbgp("当前法力值:", player.mana, "/", player.max_mana)
                poe2_api.dbgp("当前护盾值:", player.shield, "/", player.max_shield)
                
                -- 血量恢复
                local hp_cfg = prot.health_recovery or {}
                if hp_cfg.enable then
                    local threshold = player.max_life * (hp_cfg.threshold / 100)
                    local interval = (hp_cfg.interval or 0) / 1000
                    
                    poe2_api.dbgp(string.format("血量检查: 当前 %.1f < 阈值 %.1f (%.1f%%) 且冷却 %.1fs >= 间隔 %.1fs", 
                        player.life, threshold, hp_cfg.threshold, 
                        start_time - self.last_health_recovery_time, interval))
                    
                    if player.life < threshold and now - self.last_health_recovery_time >= interval then
                        poe2_api.dbgp("触发血量恢复 - 按下1键")
                        poe2_api.click_keyboard("1")
                        self.last_health_recovery_time = now
                    end
                end
                
                -- 蓝量恢复
                local mp_cfg = prot.mana_recovery or {}
                if mp_cfg.enable then
                    local threshold = player.max_mana * (mp_cfg.threshold / 100)
                    local interval = (mp_cfg.interval or 0) / 1000
                    
                    poe2_api.dbgp(string.format("蓝量检查: 当前 %.1f < 阈值 %.1f (%.1f%%) 且冷却 %.1fs >= 间隔 %.1fs", 
                        player.mana, threshold, mp_cfg.threshold, 
                        now - self.last_mana_recovery_time, interval))
                    
                    if player.mana < threshold and now - self.last_mana_recovery_time >= interval then
                        poe2_api.dbgp("触发蓝量恢复 - 按下2键")
                        poe2_api.click_keyboard("2")
                        self.last_mana_recovery_time = now
                    end
                end
                
                -- 护盾恢复
                local shield_cfg = prot.shield_recovery or {}
                if shield_cfg.enable then
                    local threshold = player.max_shield * (shield_cfg.threshold / 100)
                    local interval = (shield_cfg.interval or 0) / 1000
                    
                    poe2_api.dbgp(string.format("护盾检查: 当前 %.1f < 阈值 %.1f (%.1f%%) 且冷却 %.1fs >= 间隔 %.1fs", 
                        player.shield, threshold, shield_cfg.threshold, 
                        now - self.last_shield_recovery_time, interval))
                    
                    if player.shield < threshold and now - self.last_shield_recovery_time >= interval then
                        poe2_api.dbgp("触发护盾恢复 - 按下1键")
                        poe2_api.click_keyboard("1")
                        self.last_shield_recovery_time = now
                    end
                end
                
                return bret.SUCCESS
            end
            
            -- 检查是否在安全区域
            if poe2_api.table_contains(my_game_info.hideout, player.current_map_name_utf8) or 
            string.find(player.current_map_name_utf8, "own") then
                poe2_api.dbgp("在安全区域，跳过检查")
                return bret.SUCCESS
            end
            
            -- 处理常规恢复
            local regular_status = _handle_regular_recovery(player, prot, start_time)
            if regular_status ~= bret.SUCCESS then
                poe2_api.dbgp("常规恢复处理返回:", regular_status)
                return regular_status
            end

            poe2_api.time_p("CheckLowHpMp_Otherworld... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.SUCCESS
        end
    },

    -- 检查是否在主页面
    Not_Main_Page = {
        run = function(self, env)
            poe2_api.print_log("检查是否在主页面...")
            local strat_time = api_GetTickCount64()

            local current_map_info = env.current_map_info
            local player_info = env.player_info
            if not self.time1 or self.time1 == 0 then
                self.time1 = api_GetTickCount64()
                self.exit_time = nil
                self.life_time = 0
            end
            local ctime = strat_time - self.time1
            if ctime > 120 * 1000 and player_info.life > 0 then
                env.is_timeout_exit = true
                self.time1 = 0
            elseif player_info.life == 0 then
                self.time1 = 0
            end
            local function have_roman_number()
                local ROMAN_NUMERALS = {
                    "I", "II", "III", "IV", "V",
                    "VI", "VII", "VIII", "IX", "X",
                    "XI", "XII", "XIII", "XIV", "XV", "XVI"
                }
                if poe2_api.find_text({ UI_info = env.UI_info, text = ROMAN_NUMERALS, min_x = 520, min_y = 420, max_x = 560, max_y = 470 }) then
                    return true
                else
                    return false
                end
            end
            if poe2_api.find_text({ UI_info = env.UI_info, text = "你的天賦樹", min_x = 0 }) then
                api_Sleep(500)
                api_ClickScreen(800,510,1)
                return bret.RUNNING
            end
            if player_info and player_info.current_map_name_utf8 == 'G1_1' then
                poe2_api.dbgp("当前地图为G1_1，开始检查教学提示")
                
                -- 检查使用新技能提示
                if poe2_api.find_text({UI_info = env.UI_info, text = "按下<normal>{<n>{W}}來使用你的新技能"}) or 
                   poe2_api.find_text({UI_info = env.UI_info, text = "按下<normal>{<n>{滑鼠左鍵}}來使用你的新技能"}) then
                    poe2_api.dbgp("找到使用新技能提示，按下w键")
                    poe2_api.click_keyboard('w')
                end
                
                -- 检查躲避攻击提示
                if poe2_api.find_text({UI_info = env.UI_info, text = "按下<normal>{<n>{空白鍵}}躲避攻擊", min_x = 0}) then
                    poe2_api.dbgp("找到躲避攻击提示，按下空格键")
                    poe2_api.click_keyboard("space")
                end
                
                -- 检查跳过教学提示
                if poe2_api.find_text({UI_info = env.UI_info, text = "略過教學"}) then
                    poe2_api.dbgp("找到跳过教学提示，点击跳过")
                    poe2_api.find_text({UI_info = env.UI_info, text = "略過教學", click = 2, min_x = 0})
                    return bret.RUNNING
                end
                
                -- 检查开启天赋树提示
                if poe2_api.find_text({UI_info = nil, text = "開啟天賦樹畫面"}) then
                    poe2_api.dbgp("找到开启天赋树提示")
                    -- 如果没有跳过教学提示，则按ESC
                    if not poe2_api.find_text({UI_info = nil, text = "略過教學", min_x = 0}) then
                        poe2_api.dbgp("按ESC键关闭提示")
                        poe2_api.click_keyboard("esc")
                        poe2_api.sleep(2000)
                        poe2_api.infos_time(current_time, self.name)
                        return bret.RUNNING
                    end
                end
            end
            -- 大号，小号更新障碍
            if poe2_api.get_team_info(env.team_info, env.user_config, player_info, 2) == "大號名" then
                if not poe2_api.table_contains(player_info.current_map_name_utf8, { "G2_3","G2_9_1","G3_17","G4_10","P1_6"}) or poe2_api.find_text({ UI_info = env.UI_info, text = "競技場", min_x = 0 }) then
                    if player_info.current_map_name_utf8 == "G2_2" then
                        api_UpdateMapObstacles(180)
                    else
                        api_UpdateMapObstacles(100)
                    end
                end
            else
                if not poe2_api.table_contains(player_info.current_map_name_utf8, { "G1_12","G2_9_2"}) then
                    api_UpdateMapObstacles(100)
                end
            end
            
            local click_2 = { "接受任務", "繼續" }
            if poe2_api.find_text({ UI_info = env.UI_info, text = click_2, click = 2 }) then
                api_Sleep(500) -- Equivalent to api_Sleep(500)
                return bret.RUNNING
            end
            -- 检查交易拒绝情况
            local refuse_click = { "等待玩家接受交易請求..." }
            if poe2_api.find_text({ UI_info = env.UI_info, text = refuse_click, min_x = 0, add_x = 253, click = 2 }) then
                poe2_api.dbgp("检测到交易请求等待，将执行拒绝操作")
                return bret.RUNNING
            end

            -- 传送确认遮挡
            if poe2_api.find_text({ UI_info = env.UI_info, text = "你確定要傳送至此玩家的位置？" }) then
                api_ClickScreen(916, 467, 0)
                api_Sleep(500)
                api_ClickScreen(916, 467, 1)
                api_Sleep(500)
                self.life_time = 0
                return bret.RUNNING
            end

            -- 世界地图遮挡
            if poe2_api.find_text { UI_info = env.UI_info, text = "世界地圖", min_x = 0, add_x = 215, click = 2 } then
                return bret.RUNNING
            end

            -- 检查点遮挡
            local a = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 985,min_y = 5,max_x = 1034,max_y = 47})
            if poe2_api.find_text({UI_info = env.UI_info, text="記錄點", add_x = 213, max_y = 50}) and a and next(a) then
                poe2_api.find_text({UI_info = env.UI_info, text="記錄點", click=2, add_x = 213, max_y = 50})
                return bret.RUNNING
            end

            -- 领取任务奖励
            if poe2_api.find_text({ UI_info = env.UI_info, text = "獎勵", min_x = 100 }) then
                poe2_api.dbgp("领取任务奖励")
                if player_info.current_map_name_utf8 == "G4_4_2" then
                    poe2_api.find_text({ UI_info = env.UI_info, text = "獎勵", min_x = 100, add_x = 50,add_y = 100 , click = 2 })
                else
                    poe2_api.find_text({ UI_info = env.UI_info, text = "獎勵", min_x = 100, add_y = 100, click = 2 })
                end
                api_Sleep(500)
                if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81,refresh = true}) then
                    poe2_api.dbgp("背包已打开")
                    if have_roman_number() then
                        poe2_api.dbgp("是宝石")
                        poe2_api.get_space_point({ width = 1, height = 1, click = 1 })
                    else
                        poe2_api.dbgp("是其它")
                        poe2_api.get_space_point({ width = 4, height = 2, click = 1 })
                    end
                    return bret.RUNNING
                else
                    poe2_api.dbgp("打開背包")
                    poe2_api.click_keyboard("i")
                    return bret.RUNNING
                end
            end

            -- 团队队友死亡长时间未救其它小号处理
            local function count_gravestones(map_info)
                if not map_info or #map_info == 0 then
                    return 0
                end
                local count = 0
                for _, obj in ipairs(map_info) do
                    if obj.name_utf8 == "PlayerGravestone" then
                        count = count + 1
                    end
                end
                return count
            end
            if count_gravestones(current_map_info) == 0 then
                if not env.is_timeout and not env.is_timeout_exit then
                    if poe2_api.find_text({ UI_info = env.UI_info, text = "回到角色選擇畫面" }) then
                        poe2_api.click_keyboard("space")
                    end
                end
                self.life_time = 0
                env.is_timeout = false
            elseif count_gravestones(current_map_info) > 0 and poe2_api.get_team_info(env.team_info, env.user_config, player_info, 2) ~= "大號名" and player_info.life > 0 and player_info.isInBossBattle and not poe2_api.is_have_mos({ range_info = env.range_info, player_info = player_info }) then
                if self.life_time == 0 then
                    self.life_time = api_GetTickCount64()
                end
                if api_GetTickCount64() - self.life_time > 90 * 1000 and poe2_api.table_contains(player_info.current_map_name_utf8, { "G1_15", "C_G1_15" }) then
                    if not poe2_api.find_text({ UI_info = env.UI_info, text = "回到角色選擇畫面" }) then
                        poe2_api.click_keyboard("esc")
                        env.is_timeout = true
                    end
                    api_Sleep(500)
                    return bret.RUNNING
                end
            end

            -- 不在城镇
            if not string.find(player_info.current_map_name_utf8, "own") then
                -- 超时记录点重生
                if env.is_timeout and poe2_api.get_team_info(env.team_info, env.user_config, player_info, 2) == "大號名" then
                    if poe2_api.click_text_UI({ UI_info = env.UI_info, text = "respawn_at_checkpoint_button", refresh = true }) then
                        poe2_api.find_text({ UI_info = env.UI_info, text = "在記錄點重生", min_x = 0, click = 2 })
                        api_Sleep(500)
                        poe2_api.find_text({ UI_info = env.UI_info, text = "確認", min_x = 0, click = 2, refresh = true })
                        api_Sleep(500)
                        env.end_point = nil
                        env.is_arrive_end = false
                        env.path_list = {}
                        env.target_point = nil
                        env.is_timeout = false
                    else
                        poe2_api.click_keyboard("esc")
                        api_Sleep(500)
                        return bret.RUNNING
                    end
                end

                -- 小退
                if env.is_timeout_exit then
                    if self.exit_time then
                        if strat_time - self.exit_time > 30 * 1000 then
                            poe2_api.print_log("小退超时")
                            env.error_kill = true
                            self.exit_time = nil -- 重置计时器
                        elseif poe2_api.find_text({ text = "開始遊戲", UI_info = env.UI_info, click = 2 }) and poe2_api.find_text({ text = "建立角色", UI_info = env.UI_info, click = 2 }) then
                            self.exit_time = nil
                            env.error_kill = false
                            env.is_timeout_exit = false
                        end
                    end
                    if poe2_api.find_text({ UI_info = env.UI_info, text = "回到角色選擇畫面", click = 2 }) then
                        if not self.exit_time then
                            self.exit_time = strat_time --# 开始计时
                        end
                        api_Sleep(6000)
                        return bret.RUNNING
                    elseif poe2_api.click_text_UI({ UI_info = env.UI_info, text = "exit_to_character_selection", click = 1, index = 1 }) then
                        if not self.exit_time then
                            self.exit_time = strat_time
                        end
                        api_Sleep(6000)
                        return bret.RUNNING
                    end
                    -- # 打开选项菜单
                    if not (poe2_api.find_text({ UI_info = env.UI_info, text = "回到角色選擇畫面" }) or
                            poe2_api.click_text_UI({ UI_info = env.UI_info, text = "exit_to_character_selection" })) and
                        poe2_api.click_text_UI({ UI_info = env.UI_info, text = "life_orb" }) and
                        poe2_api.click_text_UI({ UI_info = env.UI_info, text = "mana_orb" }) then
                        if not self.exit_time then
                            self.exit_time = strat_time
                        end
                        poe2_api.click_keyboard("esc")
                        return bret.RUNNING
                    end
                end

                -- 回城
                if env.back_city then
                    poe2_api.dbgp("回城操作")
                    for _, name in ipairs(my_game_info.city_map) do
                        if poe2_api.find_text({ UI_info = env.UI_info, text = name, click = 2 }) then
                            if string.find(player_info.current_map_name_utf8, "own") then
                                env.back_city = false
                                return bret.RUNNING
                            end
                        end
                    end
                    api_ClickScreen(1230, 815, 0)
                    api_Sleep(500)
                    api_ClickScreen(1230, 815, 1)
                    api_Sleep(2000)
                    return bret.RUNNING
                end
            else
                env.is_timeout = false
                env.back_city = false
                env.is_timeout_exit = false
            end

            -- 城镇遮挡
            if player_info and string.find(player_info.current_map_name_utf8, "own") then
                

                if poe2_api.find_text({ UI_info = env.UI_info, text = "你無法將此道具丟置於此。請問要摧毀它嗎？", min_x = 0, min_y = 0 }) then
                    poe2_api.find_text({ UI_info = env.UI_info, text = "保留", min_x = 0, min_y = 0, click = 2 })
                    return bret.RUNNING
                end
                if poe2_api.find_text({ UI_info = env.UI_info, text = "回收具有品質或插槽的裝備，以獲得品質通貨和工匠碎片", min_x = 0 }) then
                    poe2_api.click_keyboard('space')
                    return bret.RUNNING
                end
                local item = api_Getinventorys(0xd, 0)
                if item and #item > 0 then
                    local point = poe2_api.get_space_point({
                        width = item[1].end_x - item[1].start_x,
                        height = item[1]
                            .end_y - item[1].start_y
                    })
                    if point then
                        if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                            api_ClickScreen(poe2_api.toInt(point[1]), poe2_api.toInt(point[2]), 1)
                            api_Sleep(500)
                            return bret.RUNNING
                        else
                            poe2_api.click_keyboard("i")
                            return bret.RUNNING
                        end
                    end
                end
            end
            if poe2_api.find_text({UI_info = env.UI_info, text = "繼續遊戲", click = 2}) then
                poe2_api.dbgp("发现'繼續遊戲'文本，点击处理中...")
                return bret.RUNNING
            end
            self.time1 = 0
            poe2_api.time_p("Not_Main_Page 耗时 -->", api_GetTickCount64() - strat_time)
            return bret.SUCCESS
        end
    },

    -- 设置基础技能
    Set_Base_Skill = {
        run = function(self, env)
            poe2_api.print_log("设置基础技能...")
            poe2_api.dbgp("设置基础技能...")
            local start_time = api_GetTickCount64()

            if not self.is_initialized then
                poe2_api.dbgp("初始化设置基础技能")
                self.bool = false  -- 初始化时间戳
                self.bool1 = false
                self.is_initialized = true
            end

            local skill_location = function(skill_name, skill_pos, selectable_skills)
                if not selectable_skills then
                    return false
                end
                -- 获取指定位置
                poe2_api.dbgp("skill_location", skill_name, skill_pos, selectable_skills)
                local point = my_game_info.skill_pos[skill_pos]
                -- 将所有 text_utf8 属性的值存储在一个集合中
                local skill_names = {}
                for _, skill_control in ipairs(selectable_skills) do
                    if skill_control.text_utf8 then
                        skill_names[skill_control.text_utf8] = true
                    end
                end
                
                -- 检查 skill_name 是否在集合中
                if not skill_names[skill_name] then
                    return false
                end
                
                -- 遍历所有可选择的技能控件
                for _, skill_control in ipairs(selectable_skills) do
                    if skill_name == skill_control.text_utf8 then
                        -- 计算中间位置
                        local center_x = (skill_control.left + skill_control.right) / 2
                        local center_y = (skill_control.top + skill_control.bottom) / 2
                        
                        -- 检查位置是否在指定范围内
                        if point[1] - 5 < center_x and center_x < point[1] + 5 and 
                        point[2] - 5 < center_y and center_y < point[2] + 5 then
                            return true
                        end
                    end
                end
                return false
            end

            local get_move_skill = function(selectable_skills)
                poe2_api.dbgp("get_move_skill", selectable_skills)
                if not skill_location("", "MIDDLE", selectable_skills) then
                    return false
                end
                return true
            end
            
            local set_pos = function(skill_name, rom_x, rom_y, selectable_skills)
                poe2_api.dbgp("set_pos", skill_name, rom_x, rom_y, selectable_skills)
                if not selectable_skills then
                    return false
                end
                for _, k in ipairs(selectable_skills) do
                    if 1104 <= k.left and k.left <= 1597 and k.bottom <= 770 and skill_name == k.text_utf8 then
                        local center_x = (k.left + k.right) / 2 + rom_x
                        local center_y = (k.top + k.bottom) / 2 + rom_y
                        api_ClickScreen(math.floor(center_x), math.floor(center_y),1)
                        api_Sleep(500)
                        return true
                    end
                end
                return false
            end
            
            local cancel_left_skill = function(selectable_skills)
                poe2_api.dbgp("cancel_left_skill", selectable_skills)
                if not selectable_skills then
                    return false
                end
                for _, k in ipairs(selectable_skills) do
                    if 1277 <= k.left and k.left <= 1285 and k.top > 790 and k.bottom <= 832 and k.right < 1316 then
                        return true
                    end
                end
                return false
            end

            if not env.mouse_check then
                poe2_api.dbgp("mouse_check", env.mouse_check)
                poe2_api.time_p("mouse_check... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end

            if poe2_api.find_text({UI_info = env.UI_info, text = "繼續遊戲", click = 2}) then
                poe2_api.dbgp("发现'繼續遊戲'文本，点击处理中...")
                return bret.RUNNING
            end

            if not (poe2_api.click_text_UI({UI_info = env.UI_info, text = "life_orb"})
             or poe2_api.click_text_UI({UI_info = env.UI_info, text = "resume_game"})
             or poe2_api.find_text({UI_info = env.UI_info, text = "清單",min_x = 0,min_y = 0,max_x = 400})) then
                poe2_api.print_log("未找到游戏界面")
                return bret.RUNNING
            end
            poe2_api.dbgp("获取技能")
            local selectable_skills = api_GetSelectableSkillControls()
            local allskill_info = api_GetAllSkill()
            local skill_slots = api_GetSkillSlots()
            -- poe2_api.dbgp("1111")
            -- poe2_api.printTable(selectable_skills)
            -- poe2_api.dbgp("2222")
            -- poe2_api.printTable(allskill_info)
            -- poe2_api.dbgp("3333")
            -- poe2_api.printTable(skill_slots)
            
            if not selectable_skills then
                poe2_api.print_log("获取可选技能技能控件信息失败")
                return bret.RUNNING
            end
            if not allskill_info then
                poe2_api.print_log("获取全部技能信息失败")
                return bret.RUNNING
            end
            if not skill_slots then
                poe2_api.print_log("获取快捷栏技能信息失败")
                return bret.RUNNING
            end
            self.bool = cancel_left_skill( selectable_skills)
            self.bool1 = get_move_skill(selectable_skills)
            poe2_api.print_log("self.bool",self.bool)
            if not self.bool1 then
                poe2_api.dbgp("未设鼠标中键")
                if not set_pos("", 0, 0, selectable_skills) then
                    local point = my_game_info.skill_pos["MIDDLE"]
                    api_ClickScreen(math.floor(point[1]), math.floor(point[2]),1)
                    api_Sleep(500)
                end
                return bret.RUNNING
            end
            
            if self.bool then
                poe2_api.dbgp("取消鼠标左键技能")
                if not set_pos('', 50, 0, selectable_skills) then
                    local point = my_game_info.skill_pos["P"]
                    api_ClickScreen(math.floor(point[1]), math.floor(point[2]),1)
                    api_Sleep(500)
                end
                return bret.RUNNING
            end
            poe2_api.time_p("检查基础技能... 耗时 --> ", api_GetTickCount64() - start_time)
            env.mouse_check = false
            return bret.SUCCESS
        end
    },

    -- 使用任务道具
    Use_Task_Props = {
        run = function(self, env)
            poe2_api.print_log("使用任务道具...")
            poe2_api.dbgp("使用任务道具")
            local bag_info = env.bag_info
            local player_info = env.player_info
            local function is_props(bag)
                local QUEST_PROPS = {
                    "知識之書", "火焰核心", "寶石花顱骨", "寶石殼顱骨",
                    "專精之書", "凜冬狼的頭顱", "燭光精髓", "傑洛特顱骨",
                    "染怒之書"
                }
                for _, item in ipairs(bag) do
                    if item.baseType_utf8 and item.category_utf8 then
                        if poe2_api.table_contains(QUEST_PROPS, item.baseType_utf8) and item.category_utf8 == "QuestItem" then
                            return item
                        end
                        if  not string.find(item.baseType_utf8, "空白刺青") and string.find(item.baseType_utf8, "刺青") and item.category_utf8 == "QuestItem" then
                            return item
                        end
                    end
                end
                return nil
            end
            if bag_info and next(bag_info) then
                local props = is_props(bag_info)
                if (poe2_api.check_item_in_inventory("寶石花顱骨", bag_info) or poe2_api.check_item_in_inventory("寶石殼顱骨", bag_info) or poe2_api.check_item_in_inventory("傑洛特顱骨", bag_info)) and not string.find(player_info.current_map_name_utf8, "own") then
                    return bret.SUCCESS
                end
                if poe2_api.check_item_in_inventory("火焰核心", bag_info) and player_info.current_map_name_utf8 ~= "G3_6_2" then
                    return bret.SUCCESS
                end
                if props and next(props) then
                    if not poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                        poe2_api.click_keyboard("i")
                        return bret.RUNNING
                    end
                    local point = poe2_api.get_center_position({ props.start_x, props.start_y },
                        { props.end_x, props.end_y })
                    if next(point) then
                        poe2_api.right_click(point[1], point[2])
                        return bret.RUNNING
                    end
                end
            end
            return bret.SUCCESS
        end
    },

    -- 是否存储物品
    Is_Store_Items = {
        run = function(self, env)
            poe2_api.print_log("是否存储...")
            local config = env.user_config
            local map_config = config['刷圖設置']["地圖鑰匙"]
            local altar_shop_config = config['刷圖設置']["祭祀購買"]
            -- local dist_ls = config['刷圖設置']['異界地圖']['涂油设置']
            local not_use_map = env.not_use_map
            local user_map = env.user_map
            local priority_map = env.priority_map
            local player_info = env.player_info
            local items_info = poe2_api.get_items_config_info(config)
            local current_map = api_GetTickCount64()
            -- 不在城区
            if not string.match(player_info.current_map_name_utf8, "own") then
                env.not_exist_stone = {}
                env.is_get_plaque_node = true
                poe2_api.time_p("Is_Store_Items", api_GetTickCount64() - current_map)
                return bret.SUCCESS
            end
            -- 判断两个键值对表是否相等
            local function deep_equal_unordered_full(a, b)
                if type(a) ~= type(b) then return false end
                if type(a) ~= "table" then return a == b end

                -- 检查所有键值对（包括非数字键）
                local visited = {}
                for k, v in pairs(a) do
                    if not deep_equal_unordered_full(v, b[k]) then
                        return false
                    end
                    visited[k] = true
                end

                -- 检查 b 中有没有 a 没有的键
                for k, _ in pairs(b) do
                    if not visited[k] then
                        return false
                    end
                end

                return true
            end
            local function get_object(name, data_list)
                for _, v in ipairs(data_list) do
                    if v.name_utf8 == name and v.grid_x ~= 0 and v.grid_y ~= 0 then
                        if v.flagStatus and v.flagStatus == 0 and v.flagStatus1 == 1 then
                            poe2_api.dbgp("get_object 找到匹配对象(flagStatus):", v)
                            return v
                        end
                        if v.life and v.is_selectable then
                            poe2_api.dbgp("get_object 找到匹配对象(life):", v)
                            return v
                        end
                    end
                end
                poe2_api.dbgp("get_object: 未找到匹配对象")
                return false
            end
            -- 词条过滤
            local function match_item_suffixes(item_suffixes, config_suffixes)
                if not item_suffixes or not next(item_suffixes) then
                    return false
                end
                if not config_suffixes or not next(config_suffixes) then
                    return false
                end
                for _, v in ipairs(item_suffixes) do
                    for _, v1 in ipairs(config_suffixes) do
                        if v.name_utf8 == v1 then
                            return true
                        end
                    end
                end
                return false
            end
            -- 祭祀购买是否配置了存储页
            local function is_not_altar_shop(item)
                local text = poe2_api.get_item_type(item)
                poe2_api.print_log("祭祀购买物品类型:" .. text)
                local item_key = ""
                if text ~= "" then
                    item_key = text
                else
                    poe2_api.dbgp("999999999999999999")
                    poe2_api.dbgp("item.category_utf8:" .. item.category_utf8)
                    for k, v in pairs(my_game_info.type_conversion) do
                        -- poe2_api.dbgp("k:"..k.." v:"..v)
                        if item.category_utf8 == v then
                            item_key = k
                            break
                        end
                    end
                end
                poe2_api.dbgp("item_key:" .. type(item_key))
                if item_key and item_key ~= "" then
                    local item_type_list = {}
                    for _, v in ipairs(items_info) do
                        poe2_api.dbgp("type(v):" .. v['類型'])

                        if v['類型'] == item_key then
                            poe2_api.dbgp("10101010101")
                            table.insert(item_type_list, v)
                        end
                    end

                    if item_type_list and next(item_type_list) then
                        for _, v in ipairs(item_type_list) do
                            if not v["不撿"] then
                                if v['基礎類型名'] == "全部物品" or string.find(v['基礎類型名'], item.baseType_utf8) then
                                    return true
                                end
                            end
                        end
                    end
                else
                    error("物品名称:" .. item.name_utf8 .. "新物品类型:" .. item.category_utf8 .. "请联系我们添加，感谢您的支持")
                end
                return false
            end
            -- 背包排序
            local function get_store_bag_info(bag)
                local function item_save_as1(goods, cfg_object)
                    local satisfy = {}
                    for _, v in ipairs(items_info) do
                        if not v["不撿"] and v["存倉頁名"] and v["存倉頁名"] ~= "" and string.find(v["基礎類型名"], goods.baseType_utf8) then
                            table.insert(satisfy, v)
                        end
                    end
                    if next(satisfy) then
                        for _, v in ipairs(satisfy) do
                            if not deep_equal_unordered_full(v, cfg_object) then
                                if v["工會倉庫"] then
                                    return 1
                                else
                                    return 2
                                end
                            end
                        end
                    end
                    return false
                end
                local store_bag = {}
                local store_bag1 = {}
                local store_bag2 = {}
                for _, v in ipairs(bag) do
                    for _, item in ipairs(items_info) do
                        if poe2_api.match_item(v, item, 1) and not item["工會倉庫"] and not item["不撿"] then
                            local a = item_save_as1(v, item)
                            if a then
                                if a == 1 then
                                    table.insert(store_bag2, v)
                                    break
                                end
                            end
                            table.insert(store_bag1, v)
                        elseif poe2_api.match_item(v, item, 1) and item["工會倉庫"] and not item["不撿"] then
                            local a = item_save_as1(v, item)
                            if a then
                                if a == 2 then
                                    table.insert(store_bag1, v)
                                    break
                                end
                            end
                            table.insert(store_bag2, v)
                        end
                    end
                end
                poe2_api.dbgp("store_bag1:" .. #store_bag1)
                poe2_api.dbgp("store_bag2:" .. #store_bag2)
                for _, v in ipairs(store_bag1) do
                    table.insert(store_bag, v)
                end

                for _, v in ipairs(store_bag2) do
                    table.insert(store_bag, v)
                end

                return store_bag
            end
            -- 判断是否需要存储
            local function get_store_item(bag, is_insert_stone, unique_storage_pages, public_warehouse_pages,
                                          map_ys_level_min)
                -- 获取背包中的地图钥匙
                local function get_map_number()
                    local items = {}
                    for _, item in ipairs(bag) do
                        if item.category_utf8 == "Map" then
                            table.insert(items, item)
                        end
                    end
                    if items and next(items) then
                        return items
                    end
                    return false
                end

                -- 获取背包中不打等级的地图钥匙
                local function get_map_not_level()
                    local map = get_map_number()
                    if map then
                        local tiers = {}
                        for _, v in ipairs(map_config) do
                            table.insert(tiers, tonumber(v["階級"]))
                        end
                        if tiers and next(tiers) then
                            for _, v1 in ipairs(map) do
                                if not poe2_api.table_contains(poe2_api.extract_level(v1.baseType_utf8), tiers) then
                                    return v1
                                end
                            end
                        end
                    end
                    return false
                end
                -- 获取背包中不打词条的地图钥匙
                local function get_map_not_entry()
                    local map = get_map_number()
                    if map then
                        for _, item in ipairs(map) do
                            if item.color > 0 and not item.not_identified and match_item_suffixes(api_GetObjectSuffix(item.mods_obj), not_use_map) then
                                return item
                            end
                        end
                    end
                    return false
                end
                -- 找不是疯癫的地图
                local function get_map_not_crazy()
                    local map = get_map_number()
                    local max_map = poe2_api.select_best_map_key({
                        inventory = bag,
                        key_level_threshold = user_map,
                        not_use_map =
                            not_use_map,
                        priority_map = priority_map
                    })
                    if max_map then
                        local max_map_level = poe2_api.extract_level(max_map.baseType_utf8)
                        local is_oiled = nil
                        for _, v in ipairs(map_config) do
                            if v["階級"] == max_map_level then
                                is_oiled = v["塗油設置"]["是否塗油"]
                            end
                        end
                        if is_oiled then
                            local function is_crazy(item)
                                local item_entry = api_GetObjectSuffix(item.mods_obj)
                                if item_entry and next(item_entry) then
                                    for _, entry in ipairs(item_entry) do
                                        if string.find(entry.name_utf8, "譫妄") then
                                            -- table.insert()
                                            return true
                                        end
                                    end
                                end
                            end
                            for _, v in ipairs(map) do
                                if not is_crazy(v) then
                                    if v.obj ~= max_map.obj then
                                        return v
                                    end
                                end
                            end
                        end
                    end
                    return false
                end

                -- 是否另存为
                local function item_save_as(goods, cfg_object)
                    local satisfy = {}
                    for _, v in ipairs(items_info) do
                        if not v["不撿"] and v["存倉頁名"] and v["存倉頁名"] ~= "" and string.find(v["基礎類型名"], goods.baseType_utf8) then
                            table.insert(satisfy, v)
                        end
                    end
                    if satisfy and next(satisfy) then
                        for _, v in ipairs(satisfy) do
                            if not deep_equal_unordered_full(v, cfg_object) then
                                if v["工會倉庫"] then
                                    return { goods, v["存倉頁名"], 1 }
                                else
                                    return { goods, v["存倉頁名"], 0 }
                                end
                            end
                        end
                    end
                    return false
                end
                -- 判断是否设置了词缀
                local function is_valid_affix(affix)
                    return affix and (affix["name"] and affix.name ~= "")
                end
                local function get_ct_config(object_cfg)
                    local affixes = object_cfg["物品詞綴"] or {}
                    for _, affix_group in pairs(affixes) do
                        if affix_group and type(affix_group) == "table" then
                            local affix_list = affix_group["詞綴"]
                            if affix_list then
                                for _, affix in ipairs(affix_list) do
                                    if is_valid_affix(affix) then
                                        -- poe2_api.dbgp("找到有效詞綴："..affix.name)
                                        return true
                                    end
                                end
                            end
                        end
                    end
                    return false
                end
                local min_map = poe2_api.select_best_map_key({
                    inventory = bag,
                    index = 1,
                    no_categorize_suffixes = 1,
                    min_level =
                        map_ys_level_min,
                    trashest = true
                })

                if unique_storage_pages and next(unique_storage_pages) then
                    for _, i in ipairs(unique_storage_pages) do
                        for _, b in ipairs(bag) do
                            -- poe2_api.dbgp("b.baseType_utf8:"..b.baseType_utf8)
                            for _, item in ipairs(items_info) do
                                if poe2_api.match_item(b, item, 1) and item["存倉頁名"] == i and not item["工會倉庫"] and not item["不撿"] then
                                    if ((item["名稱"] and item["名稱"] ~= "" and item["名稱"] ~= "全部物品") or get_ct_config(item)) and b.not_identified then
                                        poe2_api.dbgp("1")
                                        break
                                    end
                                    if b.baseType_utf8 == "知識卷軸" then
                                        break
                                    end
                                    if b.category_utf8 ~= "StackableCurrency" and poe2_api.is_do_without_pick_up(b, items_info) then
                                        poe2_api.dbgp("2")
                                        break
                                    end
                                    if b.category_utf8 == "QuestItem" then
                                        poe2_api.dbgp("3")
                                        break
                                    end
                                    if b.category_utf8 == "Map" then
                                        local map_not_level = get_map_not_level()
                                        if map_not_level then
                                            env.store_item = { map_not_level, i, 0 }
                                            poe2_api.dbgp("4")
                                            return true
                                        end
                                        if b.color > 0 then
                                            if not_use_map then
                                                local not_entry = get_map_not_entry()
                                                if not_entry then
                                                    env.store_item = { not_entry, i, 0 }
                                                    poe2_api.dbgp("5")
                                                    return true
                                                end
                                            end
                                        end
                                        local crazy = get_map_not_crazy()
                                        if crazy then
                                            env.store_item = { crazy, i, 0 }
                                            poe2_api.dbgp("7")
                                            return true
                                        end
                                        if min_map and b.obj ~= min_map.obj then
                                            poe2_api.dbgp("8")
                                            break
                                        end
                                    end
                                    if is_insert_stone then
                                        if b.category_utf8 == "TowerAugmentation" and env.is_get_plaque then
                                            poe2_api.dbgp("9")
                                            break
                                        end
                                    end
                                    if poe2_api.table_contains(b.category_utf8, my_game_info.equip_type) and b.color > 0 and not b.not_identified then
                                        local suffixes = api_GetObjectSuffix(b.mods_obj)
                                        if suffixes and next(suffixes) and not poe2_api.filter_item(b, suffixes, config["物品過濾"]) then
                                            poe2_api.dbgp("10")
                                            break
                                        end
                                    end
                                    local save_as = item_save_as(b, item)
                                    if save_as and next(save_as) then
                                        env.store_item = save_as
                                        poe2_api.dbgp("11")
                                        return true
                                    end
                                    env.store_item = { b, i, 0 }
                                    return true
                                end
                            end
                        end
                    end
                end
                if public_warehouse_pages and next(public_warehouse_pages) then
                    for _, i in ipairs(public_warehouse_pages) do
                        for _, b in ipairs(bag) do
                            for _, item in ipairs(items_info) do
                                if poe2_api.match_item(b, item, 1) and item["存倉頁名"] == i and item["工會倉庫"] and not item["不撿"] then
                                    if ((item["名稱"] and item["名稱"] ~= "" and item["名稱"] ~= "全部物品") or get_ct_config(item)) and b.not_identified then
                                        break
                                    end
                                    if b.baseType_utf8 == "知識卷軸" then
                                        break
                                    end
                                    if b.category_utf8 ~= "StackableCurrency" and poe2_api.is_do_without_pick_up(b, items_info) then
                                        break
                                    end
                                    if b.category_utf8 == "QuestItem" then
                                        break
                                    end
                                    if b.category_utf8 == "Map" then
                                        local map_not_level = get_map_not_level()
                                        if map_not_level then
                                            env.store_item = { map_not_level, i, 1 }
                                            return true
                                        end
                                        if b.color > 0 then
                                            if not_use_map then
                                                local not_entry = get_map_not_entry()
                                                if not_entry then
                                                    env.store_item = { not_entry, i, 1 }
                                                    return true
                                                end
                                            end
                                        end
                                        local crazy = get_map_not_crazy()
                                        if crazy then
                                            env.store_item = { crazy, i, 1 }
                                            return true
                                        end
                                        if min_map and b.obj ~= min_map.obj then
                                            break
                                        end
                                    end
                                    if is_insert_stone then
                                        if b.category_utf8 == "TowerAugmentation" and env.is_get_plaque then
                                            break
                                        end
                                    end
                                    if poe2_api.table_contains(b.category_utf8, my_game_info.equip_type) and b.color > 0 and not b.not_identified then
                                        local suffixes = api_GetObjectSuffix(b.mods_obj)
                                        if suffixes and next(suffixes) and not poe2_api.filter_item(b, suffixes, config["物品過濾"]) then
                                            break
                                        end
                                    end
                                    local save_as = item_save_as(b, item)
                                    if save_as and next(save_as) then
                                        env.store_item = save_as
                                        return true
                                    end
                                    env.store_item = { b, i, 1 }
                                    return true
                                end
                            end
                        end
                    end
                end
                return false
            end
            local player_info = env.player_info
            local bag_info = env.bag_info
            local current_map_info = env.current_map_info
            -- 没有人物信息
            if not next(player_info) then
                poe2_api.time_p("Is_Store_Items", api_GetTickCount64() - current_map)
                return bret.RUNNING
            end
            if not get_object("倉庫", env.range_info) then
                poe2_api.time_p("Is_Store_Items", api_GetTickCount64() - current_map)
                return bret.SUCCESS
            end
            -- 是否需要合成
            if env.is_need_strengthen then
                poe2_api.time_p("Is_Store_Items", api_GetTickCount64() - current_map)
                return bret.SUCCESS
            end
            -- 背包为空
            if not bag_info or not next(bag_info) then
                poe2_api.time_p("Is_Store_Items", api_GetTickCount64() - current_map)
                return bret.SUCCESS
            end
            -- 是否需要点金
            if not env.is_public_warehouse then
                poe2_api.time_p("Is_Store_Items", api_GetTickCount64() - current_map)
                return bret.SUCCESS
            end
            -- 碑牌是否需要点金
            if not env.is_public_warehouse_plaque then
                poe2_api.time_p("Is_Store_Items", api_GetTickCount64() - current_map)
                return bret.SUCCESS
            end
            local items_info = poe2_api.get_items_config_info(config)
            local unique_storage_pages = {}
            for _, v in ipairs(items_info) do
                if v['存倉頁名'] and v['存倉頁名'] ~= "" and not v['工會倉庫'] and not v["不撿"] then
                    table.insert(unique_storage_pages, v['存倉頁名'])
                end
            end

            local public_warehouse_pages = {}
            for _, v in ipairs(items_info) do
                if v['存倉頁名'] and v['存倉頁名'] ~= "" and v['工會倉庫'] and not v["不撿"] then
                    table.insert(public_warehouse_pages, v['存倉頁名'])
                end
            end
            -- 未配置物品过滤
            if (not unique_storage_pages or not next(unique_storage_pages)) and (not public_warehouse_pages or not next(public_warehouse_pages)) then
                poe2_api.time_p("Is_Store_Items", api_GetTickCount64() - current_map)
                return bret.SUCCESS
            end
            local map_level_type = {}
            local map_ys_level_min = 0
            for _, v in ipairs(items_info) do
                if string.find(v["類型"], "地圖鑰匙") and not v["不撿"] then
                    table.insert(map_level_type, v['等級'])
                end
            end
            if next(map_level_type) then
                local map_type = map_level_type[1]["type"]
                if map_type == "exact" then
                    local item_level = map_level_type[1]["value"]
                    map_ys_level_min = item_level - 3
                else
                    local min_level = map_level_type[1]["min"]
                    map_ys_level_min = min_level
                end
            end
            -- 是否需要插入碑牌
            local is_insert_stone = env.is_insert_stone
            local bag_store_info = get_store_bag_info(bag_info)
            -- poe2_api.dbgp("bag_store_info",type(bag_store_info),#bag_store_info)
            local store = get_store_item(bag_store_info, is_insert_stone, unique_storage_pages, public_warehouse_pages,
                map_ys_level_min)

            if not store then
                -- poe2_api.dbgp("ooooooooooooooo")
                local not_config_altar_item = nil
                for _, v in ipairs(bag_info) do
                    if poe2_api.table_contains(altar_shop_config, v.baseType_utf8) then
                        not_config_altar_item = v
                    end
                end
                if not_config_altar_item then
                    if not is_not_altar_shop(not_config_altar_item) then
                        local text = poe2_api.get_item_type(not_config_altar_item)
                        local item_key = ""
                        if text ~= "" then
                            item_key = text
                        else
                            for k, v in ipairs(my_game_info.type_conversion) do
                                if not_config_altar_item.category_utf8 == v then
                                    item_key = k
                                    break
                                end
                            end
                        end
                        error("未配置购物祭祀物品：->" ..
                            not_config_altar_item.name_utf8 .. "<-,物品类型为:->" .. item_key .. "<-,相关存储页请在物品配置中添加")
                    end
                end
                env.exchange_status = false
                if poe2_api.find_text({ UI_info = env.UI_info, text = "強調物品", min_y = 700, min_x = 250 }) then
                    poe2_api.click_keyboard('space')
                    api_Sleep(500)
                end
                poe2_api.time_p("Is_Store_Items", api_GetTickCount64() - current_map)
                return bret.SUCCESS
            end
            poe2_api.find_text({ text = "再會", UI_info = env.UI_info, click = 2 })
            if poe2_api.find_text({ text = { '重鑄台' }, UI_info = env.UI_info, min_x = 0 }) and poe2_api.find_text({ text = '摧毀三個相似的物品，重鑄為一個新的物品', UI_info = env.UI_info, min_x = 0 }) then
                poe2_api.click_keyboard('space')
                api_Sleep(500)
                poe2_api.time_p("Is_Store_Items", api_GetTickCount64() - current_map)
                return bret.RUNNING
            end
            -- if poe2_api.find_text({text = {'世界地圖',"購買或販賣物品"}, UI_info=env.UI_info,min_x=0}) then
            if poe2_api.find_text({ text = { '世界地圖' }, UI_info = env.UI_info, min_x = 0 }) then
                -- poe2_api.dbgp("999999999999999999999999999999999999999999")
                poe2_api.click_keyboard('space')
                api_Sleep(500)
                poe2_api.time_p("Is_Store_Items", api_GetTickCount64() - current_map)
                return bret.RUNNING
            end
            local store_item = env.store_item
            poe2_api.dbgp("store_item", store_item[1].baseType_utf8, store_item[3])
            -- api_Sleep(5000)
            if store_item[3] == 0 then
                if poe2_api.find_text({ UI_info = env.UI_info, text = "強調物品", min_y = 700, min_x = 250 }) and poe2_api.find_text({ UI_info = env.UI_info, text = "公會倉庫", min_x = 0, min_y = 32, max_x = 381, max_y = 81 }) then
                    poe2_api.click_keyboard('space')
                    api_Sleep(500)
                    poe2_api.time_p("Is_Store_Items", api_GetTickCount64() - current_map)
                    return bret.RUNNING
                end
            elseif store_item[3] == 1 then
                poe2_api.dbgp("公仓")
                if poe2_api.find_text({ UI_info = env.UI_info, text = "強調物品", min_y = 700, min_x = 250 }) and poe2_api.find_text({ UI_info = env.UI_info, text = "倉庫", min_x = 0, min_y = 32, max_x = 381, max_y = 81 }) then
                    poe2_api.click_keyboard('space')
                    api_Sleep(500)
                    poe2_api.time_p("Is_Store_Items", api_GetTickCount64() - current_map)
                    return bret.RUNNING
                end
            end
            if env.store_item[3] == 0 then
                env.warehouse_type_interactive = "个仓"
            else
                env.warehouse_type_interactive = "公仓"
            end
            poe2_api.dbgp("存仓-----------------------------------------------1010101")
            poe2_api.time_p("Is_Store_Items", api_GetTickCount64() - current_map)
            return bret.FAIL
        end
    },

    -- 存储动作
    Store_Items = {
        run = function(self, env)
            poe2_api.print_log("存储行为...")
            poe2_api.dbgp("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
            local current_time = api_GetTickCount64()
            local text = ""
            if env.warehouse_type_interactive == "个仓" then
                text = "倉庫"
                if poe2_api.find_text({ text = "強調物品", UI_info = env.UI_info, min_x = 250, min_y = 700 })
                    and poe2_api.find_text({ text = "公會倉庫", UI_info = env.UI_info, min_x = 0, min_y = 32, max_x = 381, max_y = 81 }) then
                    poe2_api.click_keyboard("space")
                    api_Sleep(500)
                    return bret.RUNNING
                end
            elseif env.warehouse_type_interactive == "公仓" then
                text = "公會倉庫"
                if poe2_api.find_text({ text = "強調物品", UI_info = env.UI_info, min_x = 250, min_y = 700 })
                    and poe2_api.find_text({ text = "倉庫", UI_info = env.UI_info, min_x = 0, min_y = 32, max_x = 381, max_y = 81 }) then
                    poe2_api.click_keyboard("space")
                    api_Sleep(500)
                    return bret.RUNNING
                end
            else
                error("未知的仓库类型")
            end
            if not poe2_api.find_text({ text = "強調物品", UI_info = env.UI_info, min_x = 250, min_y = 700 }) then
                -- and poe2_api.find_text({text = text,UI_info = env.UI_info,min_x=0,min_y=32,max_x=381,max_y=81}) then
                poe2_api.dbgp("存仓11111-----------------------------------------------1010101")
                return bret.FAIL
            end

            if not self.bool then
                self.type = 0
                self.timeout = 0
                self.is_wait = false
                self.wait_item = nil
                self.current = nil
                self.obj = nil
                self.num = 0
                self.bool = true
                return bret.RUNNING
            end
            local store_item = env.store_item
            local bag_info = env.bag_info
            local current_map_info = env.current_map_info
            local config = env.user_config
            local map_config = config['刷圖設置']["地圖鑰匙"]
            local currency_exchange_is_opens = config['刷圖設置']["通貨交換設置"]
            -- return bret.SUCCESS
            local function map_color()
                local color_map = {}
                if not map_config or not next(map_config) then
                    return false
                end
                for _, i in ipairs(map_config) do
                    local color = {}
                    if i["白"] then table.insert(color, 0) end
                    if i["藍"] then table.insert(color, 1) end
                    if i["黃"] then table.insert(color, 2) end
                    color_map[i["階級"]] = color
                end
                return color_map
            end
            local function is_get_map_color(map_info, map)
                if not map_info or not next(map_info) then
                    return false
                end
                for k, v in ipairs(map_info) do
                    if poe2_api.extract_level(map.baseType_utf8) == k then
                        if v then
                            if poe2_api.table_contains(map.color, v) then
                                return true
                            end
                        end
                    end
                end
                return false
            end
            local map_color_info = map_color()
            -- 检测某物品是否超过三
            local function has_three_duplicates(lst)
                local counter = {}
                for _, v in ipairs(lst) do
                    counter[v] = (counter[v] or 0) + 1
                end
                for _, count in pairs(counter) do
                    if count >= 3 then
                        return true
                    end
                end
                return false
            end
            local items_info = poe2_api.get_items_config_info(config)

            local page = {}
            local index = 0
            if store_item[3] == 0 then
                for _, item in ipairs(items_info) do
                    if not item["不撿"] and string.find(item["類型"], "地圖鑰匙") and not item["工會倉庫"] then
                        table.insert(page, item["存倉頁名"])
                        index = 0
                    end
                end
            else
                for _, item in ipairs(items_info) do
                    if not item["不撿"] and string.find(item["類型"], "地圖鑰匙") and item["工會倉庫"] then
                        table.insert(page, item["存倉頁名"])
                        index = 2
                    end
                end
            end
            if self.timeout == 0 then
                self.timeout = api_GetTickCount64()
            end
            if api_GetTickCount64() - self.timeout > 5000 then
                self.type = 0
                self.timeout = 0
            end
            if store_item[3] == 1 then
                if self.num > 16 then
                    error("仓库已满，手动清理1111")
                end
            else
                if self.num > 8 then
                    currency_exchange_is_opens = currency_exchange_is_opens["是否自動對換"] or false
                    if currency_exchange_is_opens then
                        if env.exchange_status then
                            error("仓库已满，手动清理1111")
                        end
                        if env.warehouse_full and not poe2_api.get_space_point({ width = 2, height = 4, info = bag_info }) then
                            error("仓库已满，手动清理1111")
                        end
                        env.warehouse_full = store_item[2]
                        self.num = 0
                        return bret.RUNNING
                    else
                        error("仓库已满，手动清理1111")
                    end
                end
            end
            if self.is_wait then
                if api_GetTickCount64() - self.current < self.wait_item then
                    poe2_api.print_log("等待间隔时间到达")
                    return bret.RUNNING
                end
            end
            if not poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                poe2_api.click_keyboard("i")
                poe2_api.dbgp("开背包5")
                self.is_wait = true
                self.current = api_GetTickCount64()
                self.wait_item = 1000
                return bret.RUNNING
            end
            self.is_wait = false
            local tab_list_button = poe2_api.click_text_UI({ text = "tab_list_button", UI_info = env.UI_info, ret_data = true })
            local godown_info = api_GetRepositoryPages(store_item[3])
            local precut_page = nil
            -- poe2_api.dbgp(store_item[1].name_utf8)
            for _, v in ipairs(godown_info) do
                -- poe2_api.dbgp(v.name_utf8)
                if v.name_utf8 == tostring(store_item[2]) then
                    precut_page = v
                    break
                end
            end
            if not precut_page then
                poe2_api.print_log("找不到仓库页2222 ->" .. store_item[2] .. "<-")
                api_Sleep(1000)
                return bret.RUNNING
            end
            if not tab_list_button then
                if self.type ~= store_item[2] or precut_page.manage_index == 0 then
                    if poe2_api.find_text({ text = store_item[2], UI_info = env.UI_info, max_y = 90, min_x = 0, max_x = 500, click = 2 }) then
                        self.is_wait = true
                        self.current = api_GetTickCount64()
                        self.wait_item = 500
                        self.type = store_item[2]
                        return bret.RUNNING
                    else
                        poe2_api.print_log("找不到仓库页333 ->" .. store_item[2], "<-")
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                end
            else
                poe2_api.dbgp("tab_list_button")
                local lock = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 549,min_y = 34,max_x = 585,max_y = 75})
                local lock_button = {}
                for _, v in ipairs(lock) do
                    if v.name_utf8 == "" and v.text_utf8 == "" then
                        table.insert(lock_button, v)
                    end
                end
                if not lock_button or not next(lock_button) then
                    api_ClickScreen(poe2_api.toInt((tab_list_button.left + tab_list_button.right) / 2),
                        poe2_api.toInt((tab_list_button.top + tab_list_button.bottom) / 2), 1)
                    api_Sleep(2000)
                    api_ClickScreen(poe2_api.toInt(((tab_list_button.left + tab_list_button.right) / 2) + 30),
                        poe2_api.toInt(((tab_list_button.top + tab_list_button.bottom) / 2) - 30), 1)
                    api_Sleep(1000)
                    return bret.RUNNING
                end
                if self.type ~= store_item[2] or precut_page.manage_index == 0 then
                    if poe2_api.find_text({ text = store_item[2], UI_info = env.UI_info, max_y = 469, min_x = 556, min_y = 20, max_x = 851, click = 2 }) then
                        self.is_wait = true
                        self.current = api_GetTickCount64()
                        self.wait_item = 500
                        self.type = store_item[2]
                        return bret.RUNNING
                    else
                        poe2_api.print_log("找不到仓库页1111 ->", store_item[2], "<-")
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                end
            end
            local need_synthesis = config["全局設置"]["刷图通用設置"]["自動合成地圖"]
            if need_synthesis then
                local is_czt = nil
                for _, v in ipairs(current_map_info) do
                    if v.name_utf8 == "TreasureVaultHammerActive" and v.flagStatus1 == 1 then
                        is_czt = v
                        break
                    end
                end
                if is_czt and page and next(page) and self.type == page[1] then
                    local warehouse = api_Getinventorys(precut_page.manage_index, index)
                    if warehouse and next(warehouse) then
                        local a = {}
                        for _, v in ipairs(warehouse) do
                            if v.category_utf8 == "Map" and not v.contaminated and poe2_api.extract_level(v.baseType_utf8) < 15 and is_get_map_color(map_color_info, v) then
                                table.insert(a, v.baseType_utf8)
                            end
                        end
                        if a and next(a) then
                            if has_three_duplicates(a) then
                                env.is_need_strengthen = true
                                return bret.RUNNING
                            else
                                env.is_need_strengthen = false
                            end
                        else
                            env.is_need_strengthen = false
                        end
                    end
                end
            end
            if poe2_api.table_contains(precut_page.type, { 0, 1 }) then
                local warehouse = api_Getinventorys(precut_page.manage_index, index)
                if warehouse and next(warehouse) then
                    local w = store_item[1].end_x - store_item[1].start_x
                    local h = store_item[1].end_y - store_item[1].start_y
                    local point = poe2_api.get_space_point({
                        width = w,
                        height = h,
                        w = 12,
                        h = 12,
                        gox = 14,
                        goy = 99,
                        info =
                            warehouse
                    })
                    if not point then
                        currency_exchange_is_opens = currency_exchange_is_opens["是否自動對換"] or false
                        if currency_exchange_is_opens then
                            if env.exchange_status then
                                error("仓库已满，手动清理2222")
                            end
                            if env.warehouse_full and not poe2_api.get_space_point({ width = 2, height = 4, info = bag_info }) then
                                error("仓库已满，手动清理2222")
                            end
                            if store_item[3] == 0 then
                                env.warehouse_full = store_item[2]
                                return bret.RUNNING
                            else
                                error("仓库已满，手动清理2222")
                            end
                        else
                            error("仓库已满，手动清理2222")
                        end
                    end
                end
            elseif precut_page.type == 7 then
                local warehouse = api_Getinventorys(precut_page.manage_index, index)
                if warehouse and next(warehouse) then
                    local w = store_item[1].end_x - store_item[1].start_x
                    local h = store_item[1].end_y - store_item[1].start_y
                    local point = poe2_api.get_space_point({
                        width = w,
                        height = h,
                        w = 24,
                        h = 24,
                        gox = 15,
                        goy = 100,
                        grid_x = 22,
                        grid_y = 22,
                        info =
                            warehouse
                    })
                    if not point then
                        currency_exchange_is_opens = currency_exchange_is_opens["是否自動對換"] or false
                        if currency_exchange_is_opens then
                            if env.exchange_status then
                                error("仓库已满，手动清理3333")
                            end
                            if env.warehouse_full and not poe2_api.get_space_point({ width = 2, height = 4, info = bag_info }) then
                                error("仓库已满，手动清理3333")
                            end
                            if store_item[3] == 0 then
                                env.warehouse_full = store_item[2]
                                return bret.RUNNING
                            else
                                error("仓库已满，手动清理3333")
                            end
                        else
                            error("仓库已满，手动清理3333")
                        end
                    end
                end
            end
            if self.obj and self.obj == store_item[1].obj then
                self.num = self.num + 1
            end
            if not self.obj then
                self.obj = store_item[1].obj
            end
            if self.obj ~= store_item[1].obj then
                self.obj = store_item[1].obj
                self.num = 0
            end
            if self.num and self.num ~= 0 and self.num % 3 == 0 then
                local x = math.random(100, 1500)
                local y = math.random(50, 100)
                api_ClickScreen(poe2_api.toInt(x), poe2_api.toInt(y), 0)
                api_Sleep(300)
                poe2_api.click_keyboard('alt')
                api_Sleep(300)
                if poe2_api.find_text({ UI_info = env.UI_info, text = "私訊", add_x = 265, min_x = 0, max_x = 400, click = 2 }) then
                    return bret.RUNNING
                end
            end
            poe2_api.ctrl_left_click_bag_items(store_item[1].obj, bag_info, 3)
            api_Sleep(300)
            return bret.RUNNING
        end
    },

    -- 物品丢弃
    Story_Discard = {
        run = function(self, env)
            poe2_api.print_log("物品丢弃...")
            local start_time = api_GetTickCount64()
            if not self.bool then
                self.item_name = nil
                self.index = 0
                self.bool = true
            end
            local config = env.user_config
            local is_decompose = config['全局設置']["刷图通用設置"]["是否分解暗金"] or false
            local altar_shop_config = config['刷圖設置']["祭祀購買"]
            -- local range_info = env.range_info
            local player_info = env.player_info
            local bag_info = env.bag_info
           
            local processed_configs = poe2_api.get_items_config_info(config)
            local Attachments = api_Getinventorys(0xd,0)
            -- 背包和附着物为空
            if (not bag_info or not next(bag_info)) and (not Attachments or not next(Attachments)) then
                poe2_api.dbgp("背包和附着物为空,不丢弃")
                poe2_api.time_p("物品丢弃（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS 
            end
            if poe2_api.table_contains(player_info.current_map_name_utf8,my_game_info.hideout) then
                poe2_api.dbgp("在城镇不丢弃")
                return bret.SUCCESS     
            end
            -- 是否需要丢弃
            local function get_not_item(items)
                local function is_props(bag)
                    if poe2_api.table_contains(bag.category_utf8, {'QuestItem','InstanceLocalItem'}) then
                        return true
                    end
                    return false
                end
                local function get_not(item)
                    local props = is_props(item)
                    if props then
                        return false
                    end
                    if poe2_api.is_do_without_pick_up(item,processed_configs) then
                        return true
                    end
                    for _, cfg in ipairs(processed_configs) do
                        if poe2_api.match_item(item,cfg,1) then
                            if cfg["不撿"] then
                                if poe2_api.table_contains(item.baseType_utf8,altar_shop_config) then
                                    return false
                                end
                                if is_decompose and type(is_decompose)~="table" then
                                    if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                        return false
                                        
                                    end
                                end
                                return true
                            end
                            if item.baseType_utf8 == "知識卷軸" then
                                local number = 0
                                for _, v in ipairs(items) do
                                    if v.baseType_utf8 == "知識卷軸" then
                                        number = number + v.stackCount
                                    end
                                end
                                if number > 80 then
                                    return true
                                end
                            end
                            if poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) and not item.not_identified then
                                local suffixes = api_GetObjectSuffix(item.mods_obj)
                                if not suffixes or #suffixes == 0 then
                                    return {item}
                                end
                                if not poe2_api.filter_item(item,suffixes,config["物品過濾"]) then
                                    if is_decompose and type(is_decompose)~="table" then
                                        if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                            return false
                                        end
                                    end
                                    return true
                                end
                            end
                            return false
                        end
                        if is_decompose and type(is_decompose)~="table" then
                            if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                return false
                            end
                        end
                    end
                    if poe2_api.table_contains(item.baseType_utf8,altar_shop_config) then
                        return false
                    end
                    return true
                end
                if not items or not next(items) then
                    return false
                end
                for _, item in ipairs(items) do
                    local is_dis = get_not(item)
                    if is_dis then
                        if type(is_dis) == "table" then
                            return is_dis
                        end
                        if item.baseType_utf8 == "知識卷軸" then
                            local mininumber = nil
                            local miniobj = nil
                            for _, v in ipairs(items) do
                                if v.baseType_utf8 == "知識卷軸" then
                                    if not mininumber or mininumber > v.stackCount then
                                        miniobj = v
                                        mininumber = v.stackCount
                                    end
                                end
                            end
                            env.discard_item = miniobj
                            return true
                        end
                        env.discard_item = item
                        return true
                    end
                end
                return false
            end
            -- 找黑雾祭坛
            local function get_altar(range_info)
                if not range_info or not next(range_info) then
                    return false
                end
                for _, i in ipairs(range_info) do
                    if i.path_name_utf8 and i.path_name_utf8 ~= "" and string.find("Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable",i.path_name_utf8) then
                        -- local stateMachineList = i:GetStateMachineList()
                        if i.stateMachineList and next(i.stateMachineList) then
                            local current_state = (i.stateMachineList or {}).current_state or 5
                            local interaction_enabled = (i.stateMachineList or {}).interaction_enabled or 5
                            if current_state == 2 and interaction_enabled == 0 then
                                return i
                            end
                        end
                        
                    end
                end
                return false
            end
            -- 判断自身一定范围内是否有激活怪
            local function get_monster(range_info,mate,distance)
                if not range_info or not next(range_info) then
                    return false
                end
                for _, v in ipairs(range_info) do
                    if v.type == 1 and not v.is_friendly and v.life > 0
                     and not poe2_api.table_contains(v.name_utf8,my_game_info.not_attact_mons_CN_name)
                     and v.isActive and not string.find(v.name_utf8,"神殿") and v.is_selectable then
                        local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                        if dis and dis < distance then
                            return true
                        end
                    end
                end
                return false
            end
            local is_not_item = get_not_item(bag_info)
            -- 没有要丢弃物品和附着物为空
            if not is_not_item and (not Attachments or not next(Attachments)) then
                poe2_api.dbgp("没有要丢弃物品和附着物为空,不丢弃")
                poe2_api.time_p("物品丢弃（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            local is_altar = get_altar(env.range_info)
            if is_altar then
                local dis = poe2_api.point_distance(is_altar.grid_x, is_altar.grid_y,player_info)
                if dis and dis < 105 then
                    poe2_api.dbgp("在黑屋祭坛,不丢弃")
                    poe2_api.time_p("物品丢弃（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
            end
            local mon = get_monster(env.range_info,player_info,100)
            if mon then
                poe2_api.dbgp("在怪附近,不丢弃")
                poe2_api.time_p("物品丢弃（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if player_info.isInDangerArea then
                poe2_api.dbgp("玩家是否在危险区域:", player_info.isInDangerArea)
                local point = api_GetSafeAreaLocation(player_info.grid_x, player_info.grid_y, 60, 10, 0, 0.5)
                if point then
                    api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),7)
                    api_Sleep(100)
                    poe2_api.dbgp1("+++++++++++++++++++++++++++++++++++++++++++++++")
                    poe2_api.click_keyboard("space")
                    poe2_api.time_p("物品丢弃（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            if type(is_not_item) == "table" then
                if not poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                    poe2_api.click_keyboard("i")
                    api_Sleep(300)
                    poe2_api.dbgp("开背包,刷新词条")
                    poe2_api.time_p("物品丢弃（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local point = poe2_api.get_center_position({is_not_item[1].start_x,is_not_item[1].start_y},{is_not_item[1].end_x,is_not_item[1].end_y})
                if point and next(point) then
                    api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),0)
                    poe2_api.time_p("物品丢弃（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            if not Attachments or not next(Attachments) then
                if not bag_info or not next(bag_info) then
                    env.discard_item = nil
                    poe2_api.time_p("物品丢弃（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local obj = nil
                for _, v in ipairs(bag_info) do
                    if v.obj == env.discard_item.obj then
                        obj = v
                    end
                end
                if not obj then
                    env.discard_item = nil
                    poe2_api.time_p("物品丢弃（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                if not poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                    poe2_api.click_keyboard("i")
                    api_Sleep(300)
                    poe2_api.dbgp("开背包,丢弃1")
                    poe2_api.time_p("物品丢弃（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                local point = poe2_api.get_center_position({env.discard_item.start_x,env.discard_item.start_y},{env.discard_item.end_x,env.discard_item.end_y})
                api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                api_Sleep(500)
                poe2_api.time_p("物品丢弃（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            else
                local index_list ={2,3,4,5,6,7,8,9,0xa,0xb}
                local point_list = {
                    [2] = {1320,250},
                    [3] = {1151,191},
                    [4] = {1493,191},
                    [5] = {1322,133},
                    [6] = {1410,201},
                    [7] = {1237,255},
                    [8] = {1410,255},
                    [9] = {1213,330},
                    [0xa] = {1431,330},
                    [0xb] = {1322,353},
                }
                local point = nil
                for _, v in ipairs(index_list) do
                    local item = env["item"..v]
                    if item and next(item) then
                        if Attachments[1].baseType_utf8 == item[1].baseType_utf8 
                        and Attachments[1].DemandStrength == item[1].DemandStrength
                        and Attachments[1].DemandAgility == item[1].DemandAgility
                        and Attachments[1].DemandWisdom == item[1].DemandWisdom
                        and Attachments[1].DemandLevel == item[1].DemandLevel
                        and Attachments[1].not_identified == item[1].not_identified
                        and Attachments[1].category_utf8 == item[1].category_utf8
                        and Attachments[1].color == item[1].color then
                            local current_item = api_Getinventorys(v,0)
                            if current_item and next(current_item) then
                                if current_item[1].baseType_utf8 == item[1].baseType_utf8 
                                and current_item[1].DemandStrength == item[1].DemandStrength
                                and current_item[1].DemandAgility == item[1].DemandAgility
                                and current_item[1].DemandWisdom == item[1].DemandWisdom
                                and current_item[1].DemandLevel == item[1].DemandLevel
                                and current_item[1].not_identified == item[1].not_identified
                                and current_item[1].category_utf8 == item[1].category_utf8
                                and current_item[1].color == item[1].color then
                                else
                                    point = point_list[v]
                                    break
                                end
                            else
                                point = point_list[v]
                                break
                            end
                        end
                    end
                end
                if point then
                    if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                        api_ClickScreen(poe2_api.toInt(point[1]),poe2_api.toInt(point[2]),1)
                        api_Sleep(100)
                        poe2_api.time_p("物品丢弃（RUNNING8）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    else
                        poe2_api.dbgp("开背包,丢弃2")
                        poe2_api.click_keyboard("i")
                        api_Sleep(300)
                        poe2_api.time_p("物品丢弃（RUNNING9）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                else     
                    -- 先设置随机种子（只需执行一次）
                    math.randomseed(os.time())
                    -- 生成 [20, 450) 范围内的随机浮点数
                    local x = 20 + (450 - 20) * math.random()
                    -- 生成 [50, 500) 范围内的随机浮点数
                    local y = 50 + (500 - 50) * math.random()
                    api_ClickScreen(poe2_api.toInt(x),poe2_api.toInt(y),1)
                    api_Sleep(200)
                    if not self.item_name then
                        self.item_name = Attachments[1].baseType_utf8
                    end
                    if self.item_name ~= Attachments[1].baseType_utf8 then
                        self.item_name = Attachments[1].baseType_utf8
                    else
                        self.index = self.index + 1
                    end
                    if self.index > 8 then
                        if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                            poe2_api.click_keyboard("i")
                            poe2_api.dbgp("关背包6")
                            api_Sleep(300)
                        end
                        local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),50)
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),1)
                            api_Sleep(200)
                            poe2_api.dbgp1("rsdgjtgjasdvzxbfdhfsdh")
                            poe2_api.click_keyboard("space")
                            self.index = 0
                        end
                    end
                    poe2_api.time_p("物品丢弃（RUNNING10）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
            end
            poe2_api.time_p("物品丢弃（RUNNING11）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.RUNNING
        end
    },
    
    -- 鉴定指定装备
    Identify_designated_equipment = {
        run = function(self, env)
            poe2_api.print_log("鉴定指定装备...") 
            local player_info = env.player_info
            local attack_dis_map = env.map_level_dis
            local stuck_monsters = env.stuck_monsters
            local not_attack_mos = env.not_attack_mos
            local config = env.user_config

            if self.need_identify_in_map == nil then
                self.need_identify_in_map = config["全局設置"]["刷图通用設置"]["是否图内鉴定"]
                return bret.RUNNING
            end

            if not self.need_identify_in_map then
                return bret.SUCCESS
            end

            local config_name = env.item_config_name
            local config_type = env.item_config_type

            poe2_api.dbgp(string.format("当前地图: %s, 危险区域: %s", 
                player_info.current_map_name_utf8 or "未知", 
                tostring(player_info.isInDangerArea)))
            
            if poe2_api.table_contains(player_info.current_map_name_utf8, my_game_info.hideout) then
                return bret.SUCCESS
            end

            -- poe2_api.dbgp("====== 开始装备鉴定流程 ======")

            -- 创建反向字典
            local reverse_type_conversion = {}
            for k, v in pairs(my_game_info.type_conversion) do
                reverse_type_conversion[v] = k
                -- poe2_api.dbgp(string.format("类型转换表: %s -> %s", k, v))
            end

            local function convert_key(key)
                local converted = my_game_info.type_conversion[key] or reverse_type_conversion[key]
                -- poe2_api.dbgp(string.format("类型转换: %s -> %s", key, converted or "无对应转换"))
                return converted
            end

            local function convert_config_type(config_type_dict)
                if not config_type_dict then
                    poe2_api.dbgp("警告: 配置类型字典为空")
                    return {}
                end
                
                local converted_dict = {}
                poe2_api.dbgp("开始转换配置类型...")
                
                for chinese_type, info_list in pairs(config_type_dict) do
                    local english_type = my_game_info.type_conversion[chinese_type]
                    -- poe2_api.dbgp(string.format("处理类型: %s -> %s", chinese_type, english_type or "无对应英文"))
                    
                    if english_type then
                        -- 处理内嵌'類型'字段
                        if type(info_list) == "table" and info_list["類型"] then
                            poe2_api.dbgp("发现嵌套类型字段，开始处理...")
                            if type(info_list["類型"]) == "table" then
                                local converted_types = {}
                                for _, t in ipairs(info_list["類型"]) do
                                    local converted = my_game_info.type_conversion[t] or t
                                    table.insert(converted_types, converted)
                                    -- poe2_api.dbgp(string.format("转换嵌套类型: %s -> %s", t, converted))
                                end
                                info_list["類型"] = converted_types
                            else
                                local converted = my_game_info.type_conversion[info_list["類型"]] or info_list["類型"]
                                info_list["類型"] = {converted}
                                -- poe2_api.dbgp(string.format("转换单类型: %s -> %s", info_list["類型"], converted))
                            end
                        end
                        converted_dict[english_type] = info_list
                    else
                        poe2_api.dbgp(string.format("严重警告: 未找到类型 '%s' 的英文转换", chinese_type))
                    end
                end
                
                poe2_api.dbgp("配置类型转换完成")
                return converted_dict
            end

            -- 转换配置类型
            poe2_api.dbgp("开始转换主配置类型...")
            config_type = convert_config_type(config_type)
            -- poe2_api.dbgp(string.format("转换后配置类型条目数: %d", table.count(config_type)))

            if poe2_api.find_text({UI_info = env.UI_info, text = "繼續遊戲", click = 2}) then
                poe2_api.dbgp("城外鉴定: 发现'繼續遊戲'文本，点击处理中...")
                return bret.RUNNING
            end

            local appraisal_item_list = {}

            local function need_appraisal(bag_info)
                if not bag_info then
                    poe2_api.dbgp("城外鉴定: 背包信息为空")
                    return false
                end
                
                -- poe2_api.dbgp(string.format("开始检查背包物品，总数: %d", #bag_info))
                
                local function get_matched_config(bag)
                    -- 初始物品信息检查
                    -- poe2_api.dbgp("\n========== 开始物品匹配流程 ==========")
                    -- poe2_api.dbgp(string.format("[物品基本信息] 名称: %s | 类型: %s | 基础类型: %s | 颜色: %d", 
                    --     bag.name_utf8 or "nil", 
                    --     bag.category_utf8 or "nil", 
                    --     bag.baseType_utf8 or "nil", 
                    --     bag.color or -1))
                    
                    -- 检查config_type是否存在
                    if not config_type then
                        -- poe2_api.dbgp("[错误] config_type 配置表不存在！")
                        return nil
                    end
                
                    -- 1. 首先检查类型匹配
                    -- poe2_api.dbgp("\n=== 开始类型配置匹配 ===")
                    for config_name, item_config in pairs(config_type) do
                        -- poe2_api.dbgp(string.format("\n[检查配置组] 配置组名称: %s", config_name))
                        -- poe2_api.dbgp("[配置内容] %s", poe2_api.printTable(item_config))

                        for idx, item in ipairs(item_config) do
                            -- poe2_api.dbgp("\n[检查配置项] 序号: %d", idx)
                            -- poe2_api.dbgp("------------------------------------------------------------------------")
                            if type(item) ~= "table" then
                                -- poe2_api.dbgp("[警告] 配置项不是table类型，跳过")
                                goto continue
                            end
                
                            -- 类型检查
                            local item_type = item["類型"]
                            -- poe2_api.dbgp(string.format("[类型检查] 配置类型: %s | 物品类型: %s", 
                            --     poe2_api.printTable(item_type), 
                            --     bag.category_utf8 or "nil"))
                
                            -- 处理类型匹配
                            local type_match = false
                            if type(item_type) == "table" and #item_type > 0 then
                                type_match = (item_type[1] == convert_key(bag.category_utf8))
                            elseif type(item_type) == "string" then
                                type_match = (item_type == convert_key(bag.category_utf8))
                            else
                                -- poe2_api.dbgp("[警告] 配置类型格式无效")
                            end
                
                            if not type_match then
                                -- poe2_api.dbgp("-> 类型不匹配，跳过")
                                goto continue
                            end
                            -- poe2_api.dbgp("-> 类型匹配通过")
                
                            -- 基础类型检查
                            local base_type = item["基礎類型名"] or "nil"
                            -- poe2_api.dbgp(string.format("[基础类型检查] 配置基础类型: %s | 物品基础类型: %s", 
                            --     base_type, bag.baseType_utf8 or "nil"))
                
                            if bag.baseType_utf8 ~= base_type and base_type ~= "全部物品" then
                                -- poe2_api.dbgp("-> 基础类型不匹配，跳过")
                                goto continue
                            end
                            poe2_api.dbgp("-> 基础类型匹配通过")
                
                            -- 品质检查
                            local quality_check = {
                                white = item["白裝"],
                                blue = item["藍裝"],
                                yellow = item["黃裝"],
                                unique = item["暗金"]
                            }
                            -- poe2_api.dbgp(string.format("[品质检查] 配置要求: 白=%s 蓝=%s 黄=%s 暗金=%s | 物品颜色: %d",
                            --     tostring(quality_check.white),
                            --     tostring(quality_check.blue),
                            --     tostring(quality_check.yellow),
                            --     tostring(quality_check.unique),
                            --     bag.color or -1))
                
                            local quality_ok = false
                            if bag.color == 0 and quality_check.white then
                                quality_ok = true
                            elseif bag.color == 1 and quality_check.blue then
                                quality_ok = true
                            elseif bag.color == 2 and quality_check.yellow then
                                quality_ok = true
                            elseif bag.color == 3 and quality_check.unique then
                                quality_ok = true
                            end
                
                            if not quality_ok then
                                poe2_api.dbgp("-> 品质不匹配，跳过")
                                goto continue
                            end
                            poe2_api.dbgp("-> 品质检查通过")
                
                            -- 名称检查
                            if item["名稱"] then
                                -- poe2_api.dbgp(string.format("[名称检查] 配置名称: %s | 物品名称: %s",
                                --     item["名稱"], bag.name_utf8 or "nil"))
                                
                                if item["名稱"] == bag.name_utf8 then
                                    -- poe2_api.dbgp("-> 名称完全匹配，返回配置")
                                    -- poe2_api.dbgp("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item))
                                    return item
                                else
                                    -- poe2_api.dbgp("-> 名称不匹配，继续检查")
                                end
                            else
                                -- poe2_api.dbgp("[名称检查] 配置无名称要求，检查词缀")
                                
                                -- 词缀检查
                                if item["物品詞綴"] then
                                    poe2_api.dbgp("[词缀检查] 发现词缀配置")
                                    local affix_dict = item["物品詞綴"]
                                    
                                    if affix_dict and type(affix_dict) == "table" then
                                        for affix_name, v in pairs(affix_dict) do
                                            if type(v) == "table" and v["詞綴"] then
                                                -- poe2_api.dbgp(string.format("-> 发现有效词缀: %s", affix_name))
                                                -- poe2_api.dbgp(string.format("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item)))
                                                return item
                                            end
                                        end
                                    end
                                end
                            end
                
                            -- 如果前面都通过但没返回，检查基础类型名
                            -- poe2_api.dbgp("[最终检查] 基础类型名匹配检查")
                            if base_type == bag.baseType_utf8 or base_type == "全部物品" then
                                -- poe2_api.dbgp("-> 基础类型名匹配，返回配置")
                                -- poe2_api.dbgp(string.format("[匹配成功] 配置详情:\n%s", poe2_api.printTable(item)))
                                return item
                            end
                
                            ::continue::
                        end
                    end
                    
                    -- 2. 检查名称匹配
                    poe2_api.dbgp("\n=== 开始名称配置匹配 ===")
                    if not config_name then
                        poe2_api.dbgp("[警告] config_name 配置表不存在")
                    else
                        for config_name, item_config in pairs(config_name) do
                            -- poe2_api.dbgp(string.format("\n[检查名称配置组] %s", config_name))
                            
                            for idx, item in ipairs(item_config) do
                                -- poe2_api.dbgp(string.format("[检查配置项] 序号: %d", idx))
                                
                                if type(item) == "table" then
                                    -- poe2_api.dbgp(string.format("[基础类型比较] 配置: %s | 物品: %s",
                                    --     item["基礎類型名"] or "nil", bag.baseType_utf8 or "nil"))
                                    
                                    if item["基礎類型名"] == bag.baseType_utf8 then
                                        poe2_api.dbgp("-> 基础类型匹配")
                                        
                                        local type_ok = true
                                        if item["類型"] and item["類型"][1] then
                                            type_ok = (item["類型"][1] == bag.category_utf8)
                                            -- poe2_api.dbgp(string.format("[类型比较] 配置: %s | 物品: %s | 结果: %s",
                                            --     item["類型"][1], bag.category_utf8 or "nil",
                                            --     type_ok and "匹配" or "不匹配"))
                                        end
                                        
                                        if type_ok then
                                            -- poe2_api.dbgp("-> 所有条件匹配，返回配置")
                                            return item
                                        end
                                    end
                                end
                            end
                        end
                    end
                
                    poe2_api.dbgp("\n[匹配结果] 未找到匹配配置")
                    return nil
                end

                local items_to_identify = {}
                poe2_api.dbgp("开始扫描背包物品...")
                
                for i, bag in ipairs(bag_info) do
                    -- poe2_api.dbgp(string.format("\n物品 %d/%d: %s (类型: %s, 基础类型: %s, 颜色: %d, 已鉴定: %s)", 
                    --     i, #bag_info, bag.name_utf8 or "无名", bag.category_utf8 or "无类型", 
                    --     bag.baseType_utf8 or "无基础类型", bag.color or -1, 
                    --     tostring(not bag.not_identified)))
                    
                    -- 基础条件：未鉴定、未污染、不在排除列表
                    if not (bag.not_identified and
                            not poe2_api.table_contains(my_game_info.not_need_identify, bag.category_utf8)) then
                        -- poe2_api.dbgp("物品已鉴定或在不需鉴定列表中，跳过")
                        goto continue_item
                    end
                    
                    -- 特殊类别直接加入鉴定列表
                    if poe2_api.table_contains({"Map", "TowerAugmentation"}, bag.category_utf8) then
                        poe2_api.dbgp("特殊类别物品，直接加入鉴定列表")
                        table.insert(items_to_identify, bag)
                        goto continue_item
                    end

                    -- 获取匹配的配置
                    poe2_api.dbgp("开始匹配配置...")
                    local matched_config = get_matched_config(bag)
                    
                    -- 检查物品詞綴配置
                    if matched_config and matched_config["物品詞綴"] then
                        poe2_api.dbgp("找到匹配配置，检查词缀...")
                        local affix_dict = matched_config["物品詞綴"]
                        if affix_dict and type(affix_dict) == "table" then
                            local has_valid_affix = false
                            for affix_name, v in pairs(affix_dict) do
                                if type(v) == "table" and v["詞綴"] then
                                    poe2_api.dbgp(string.format("发现有效词缀: %s", affix_name))
                                    has_valid_affix = true
                                    break
                                end
                            end
                            
                            if has_valid_affix then
                                poe2_api.dbgp("物品有有效词缀，加入鉴定列表")
                                table.insert(items_to_identify, bag)
                            else
                                poe2_api.dbgp("配置中无有效词缀，跳过")
                            end
                        end
                    else
                        poe2_api.dbgp("未找到匹配配置或配置无词缀要求")
                    end
                    ::continue_item::
                end

                if #items_to_identify > 0 then
                    poe2_api.dbgp(string.format("找到 %d 件需要鉴定的物品", #items_to_identify))
                    appraisal_item_list = items_to_identify
                    return items_to_identify
                end
                poe2_api.dbgp("未找到需要鉴定的物品")
                return false
            end

            poe2_api.dbgp("开始检查是否需要鉴定...")
            local bag_info = api_Getinventorys(1, 0)
            if not bag_info then
                poe2_api.dbgp("错误: 无法获取背包信息")
                return bret.SUCCESS
            end

            local items_to_identify = need_appraisal(bag_info)
            if not items_to_identify then
                poe2_api.dbgp("当前没有需要鉴定的物品")
                return bret.SUCCESS
            end

            poe2_api.dbgp(string.format("需要鉴定的物品数量: %d", #items_to_identify))
            
            if player_info.isInDangerArea then
                poe2_api.dbgp("警告: 玩家处于危险区域，暂停鉴定")
                return bret.SUCCESS
            end

            local has_monsters = poe2_api.is_have_mos({range_info = env.range_info, 
                player_info = player_info, 
                attack_dis_map = attack_dis_map, 
                stuck_monsters = stuck_monsters, 
                not_attack_mos = not_attack_mos,
                not_sight = true
            })
            
            if has_monsters then
                poe2_api.dbgp("警告: 周围有怪物，暂停鉴定")
                return bret.SUCCESS
            end

            local function use_items(bag_info, click)
                if not bag_info then 
                    poe2_api.dbgp("错误: use_items 传入的背包信息为空")
                    return false 
                end
                
                poe2_api.dbgp("开始查找知识卷轴...")
                for _, actor in ipairs(bag_info) do
                    if actor.baseType_utf8 == "知識卷軸" then
                        poe2_api.dbgp(string.format("找到知识卷轴，位置: %d,%d - %d,%d", 
                            actor.start_x, actor.start_y, actor.end_x, actor.end_y))
                        
                        if click == 1 then
                            -- 计算中心坐标
                            local start_cell = {actor.start_x, actor.start_y}
                            local end_cell = {actor.end_x, actor.end_y}
                            local center_position = poe2_api.get_center_position(start_cell, end_cell)
                            
                            poe2_api.dbgp(string.format("卷轴中心位置: %d, %d", center_position[1], center_position[2]))
                            
                            poe2_api.dbgp("点击卷轴...")
                            api_ClickScreen(center_position[1], center_position[2],0)
                            api_Sleep(200)
                            api_ClickScreen(center_position[1], center_position[2],2)
                            api_Sleep(500)
                        end
                        return true
                    end
                end
                poe2_api.dbgp("警告: 背包中没有找到知识卷轴")
                return false
            end

            poe2_api.dbgp("准备使用卷轴...")
            if not use_items(bag_info) then
                poe2_api.dbgp("错误: 无法使用知识卷轴")
                return bret.SUCCESS
            end

            -- 重新获取背包信息
            poe2_api.dbgp("重新获取背包信息...")
            bag_info = api_Getinventorys(1, 0)
            if not bag_info then
                poe2_api.dbgp("错误: 重新获取背包信息失败")
                return bret.SUCCESS
            end

            items_to_identify = need_appraisal(bag_info)
            if not items_to_identify then
                poe2_api.dbgp("重新检查后没有需要鉴定的物品")
                return bret.SUCCESS
            end

            if (poe2_api.is_have_mos({range_info = env.range_info, player_info = player_info}) and 
                (poe2_api.table_contains(my_game_info.hideout_CH, player_info.current_map_name_utf8) or 
                string.find(player_info.current_map_name_utf8, "own"))) then
                poe2_api.dbgp("警告: 安全区域发现怪物，暂停鉴定")
                return bret.SUCCESS
            end
            
            poe2_api.dbgp("开始鉴定物品...")
            for _, items in ipairs(bag_info) do
                for _, k in ipairs(items_to_identify) do
                    if items.obj == k.obj then
                        poe2_api.dbgp(string.format("鉴定物品: %s (类型: %s)", 
                            items.name_utf8 or "无名", items.category_utf8 or "无类型"))
                        
                        if not poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                            poe2_api.dbgp("未检测到背包UI，尝试打开背包...")
                            poe2_api.click_keyboard("i")
                            api_Sleep(500)
                        end

                        use_items(bag_info, 1)
                        api_Sleep(500)
                        
                        -- 计算中心坐标
                        local start_cell = {items.start_x, items.start_y}
                        local end_cell = {items.end_x, items.end_y}
                        local center_position = poe2_api.get_center_position(start_cell, end_cell)
                        poe2_api.dbgp(string.format("物品中心位置: %d, %d", center_position[1], center_position[2]))

                        poe2_api.dbgp("左键点击物品...")
                        api_ClickScreen(center_position[1], center_position[2],0)
                        api_Sleep(200)
                        poe2_api.dbgp("右键点击物品...")
                        api_ClickScreen(center_position[1], center_position[2],1)
                        api_Sleep(200)
                        
                        poe2_api.dbgp("物品鉴定完成")
                        return bret.RUNNING
                    end
                end
            end

            poe2_api.dbgp("错误: 未找到匹配的需要鉴定的物品")
            return bret.SUCCESS
        end
    },

    -- 检查是否拾取
    Is_Pick_UP = {
        run = function(self, env)
            poe2_api.print_log("检查是否需要拾取...")
            local start_time = api_GetTickCount64()
            local current_time = api_GetTickCount64()
            if not self.bool then
                self.id1 = nil
                self.number = 0
                self.bool = true
                self.wait = false
                self.wait_time = 0
                self.currte_time = 0
            end
            local config = env.user_config
            local need_item = env.need_item
            local is_decompose = config["全局設置"]["刷图通用設置"]["是否分解暗金"] or false
            local altar_shop_config = config['刷圖設置']["祭祀購買"]
            local stuck_monsters = env.stuck_monsters
            -- local item_list = env.range_items
            local player_info = env.player_info
            -- local range_info = env.range_info
            local bag_info = env.bag_info
            -- local current_map_info = env.current_map_info
            if not next(player_info) then
                poe2_api.dbgp("人物信息为空")
                poe2_api.time_p("检查是否拾取（RUNNING1）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            if string.find(player_info.current_map_name_utf8,"own") then
                env.need_item = nil
                env.boss_drop = nil
                env.interactive = nil
                return bret.SUCCESS
            end
            local function get_item(items,processed_configs)
                
                local sorted_items = poe2_api.get_sorted_list(items,player_info)
                if not sorted_items or not next(sorted_items) then
                    poe2_api.dbgp("数据有问题2222")
                    return false
                end
                -- for _, v in ipairs(sorted_items) do
                --     poe2_api.dbgp(v.name_utf8)
                --     poe2_api.dbgp(v.baseType_utf8)
                --     poe2_api.dbgp(v.category_utf8)
                --     poe2_api.dbgp(tostring(v.grid_x))
                --     poe2_api.dbgp(tostring(v.grid_y))
                --     poe2_api.dbgp(tostring("========================================"))
                -- end
                poe2_api.dbgp(tostring(#sorted_items))
                for _, item in ipairs(sorted_items) do
                    -- api_Sleep(5000)
                    -- poe2_api.dbgp(item.name_utf8)
                    -- poe2_api.dbgp(item.baseType_utf8)
                    -- poe2_api.dbgp(item.category_utf8)
                    -- poe2_api.dbgp(tostring(item.grid_x))
                    -- poe2_api.dbgp(tostring(item.grid_y))
                    -- poe2_api.dbgp(tostring("========================================"))
                    if item.grid_x ~= 0 and item.grid_y ~= 0 then
                        -- poe2_api.dbgp("cccccccccccccccccccccccccccccccccc")
                        for _, cfg in ipairs(processed_configs) do
                            
                            if poe2_api.match_item(item,cfg,1) then
                                -- poe2_api.dbgp("999================================================")
                                if env.pick_up_timeout and next(env.pick_up_timeout) and poe2_api.table_contains(item.id,env.pick_up_timeout) then
                                    break
                                end
                                if not cfg['不撿'] then
                                    if poe2_api.is_do_without_pick_up(item,processed_configs) then
                                        break
                                    end
                                    local item_entry = cfg["物品詞綴"] or {}
                                    if item_entry and next(item_entry) then
                                        local function get_cfg_entry(entry_list)
                                            for k, v in pairs(entry_list) do
                                                if v and type(v) ~= "boolean" then  -- 确保 v 不是 nil 且不是 boolean
                                                    if v["詞綴"] and next(v["詞綴"]) then  -- 检查 "詞綴" 是否存在
                                                        return true
                                                    end
                                                end
                                            end
                                            return false
                                        end
                                        if get_cfg_entry(item_entry) then
                                            if poe2_api.table_contains(item.category_utf8,my_game_info.equip_type)
                                             and not item.not_identified then
                                                local suffixes = api_GetObjectSuffix(item.mods_obj)
                                                if suffixes and next(suffixes) then
                                                    if not poe2_api.filter_item(item,suffixes,config["物品過濾"]) then
                                                        poe2_api.dbgp("词缀不符合*******************************************")
                                                        break
                                                    end
                                                else
                                                    poe2_api.dbgp("未找到物品词缀——————————————————————————————————————————————")
                                                    break
                                                end
                                                
                                            end
                                        end
                                    end
                                    if bag_info and next(bag_info) then
                                        if item.baseType_utf8 == "知識卷軸" then
                                            local number = 0
                                            for _, v in ipairs(bag_info) do
                                                if v.baseType_utf8 == "知識卷軸" then
                                                    number = number + v.stackCount
                                                end
                                            end
                                            if number >= 80 then
                                                break
                                            end
                                        end
                                    end
                                    local distance = poe2_api.point_distance(item.grid_x,item.grid_y,player_info)
                                    local function is_point(grid_x,grid_y)
                                        local point = api_FindNearestReachableInRange(math.floor(grid_x),math.floor(grid_y),15)
                                        local ralet = api_FindPath(player_info.grid_x,player_info.grid_y,math.floor(point.x),math.floor(point.y))
                                        return ralet
                                    end
                                    if distance and distance > 15 then
                                        local ralet = is_point(item.grid_x,item.grid_y)
                                        if not ralet or not next(ralet) then
                                            poe2_api.dbgp("无路径")
                                            break
                                        end
                                    end
                                    env.interactive = item
                                    env.need_item = item
                                    return true
                                end
                                break
                            end

                        end
                        if poe2_api.table_contains(item.baseType_utf8,altar_shop_config) then
                            -- poe2_api.dbgp("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk")
                            if env.pick_up_timeout and next(env.pick_up_timeout) and poe2_api.table_contains(item.id,env.pick_up_timeout) then
                                break
                            end
                            env.interactive = item
                            env.need_item = item
                            return true
                        end
                        if is_decompose then
                            -- poe2_api.dbgp("mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm")
                            if item.color == 3 and poe2_api.table_contains(item.category_utf8,my_game_info.equip_type) then
                                if env.pick_up_timeout and next(env.pick_up_timeout) and poe2_api.table_contains(item.id,env.pick_up_timeout) then
                                    -- poe2_api.dbgp("jjjjjjjjjjjjjjjjjjjjjjjjjjjjjj")
                                    break
                                end
                                env.interactive = item
                                env.need_item = item
                                -- poe2_api.dbgp("hhhhhhhhhhhhhhhhhhhhhh")
                                return true
                            end
                        end
                    end
                end
                return false
            end
            
            if (not env.range_items or not next(env.range_items)) and not env.need_item then
                poe2_api.dbgp("无物品可捡1")
                poe2_api.time_p("无物品可捡1(SUCCESS1)... 耗时 -->", api_GetTickCount64() - current_time )
                return bret.SUCCESS
            end
            local processed_configs = poe2_api.get_items_config_info(config)
            if not need_item then
                if not get_item(env.range_items,processed_configs) then
                    poe2_api.dbgp("无物品可捡2")
                    poe2_api.time_p("检查是否拾取（SUCCESS2）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.SUCCESS
                end
            end
            poe2_api.dbgp("1")
            -- 判断自身一定范围内是否有激活怪
            local function is_monster(range_info,mate,distance)
                if not range_info or not next(range_info) then
                    return false
                end
                if distance > env.min_attack_dis then
                    distance = env.min_attack_dis  
                end
                for _, v in ipairs(range_info) do
                    if v.type == 1 and not v.is_friendly and v.life > 0
                     and not poe2_api.table_contains(v.name_utf8,my_game_info.not_attact_mons_CN_name)
                     and v.isActive and not string.find(v.name_utf8,"神殿") and v.hasLineOfSight and v.is_selectable
                     and (not stuck_monsters or not next(stuck_monsters) or not stuck_monsters[v.id]) then
                        local dis = poe2_api.point_distance(v.grid_x, v.grid_y,mate)
                        if dis and dis < distance then
                            return true
                        end
                    end
                end
                return false
            end
            local is_target = is_monster(env.range_info, player_info,40)
            if is_target and player_info.name_utf8 == env.user_config["劇情設置"]["大號名"] then
                poe2_api.dbgp("附近有怪，不捡")
                poe2_api.time_p("检查是否拾取（SUCCESS3）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            if self.wait then
                if api_GetTickCount64() - self.current_time < self.wait_time then
                    poe2_api.dbgp("等待中")
                    poe2_api.time_p("检查是否拾取（SUCCESS4）... 耗时 --> ", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                self.wait = false
            end
            poe2_api.dbgp("2")
            -- 判断特殊交互对象
            local function get_interactive(range_info)
                if not range_info or not next(range_info) then
                    return false
                end
                for _, v in ipairs(range_info) do
                    if v.name_utf8 ~= "" and poe2_api.table_contains(v.name_utf8,{"開關","門","把手"}) and v.isActive and v.is_selectable
                     and v.grid_x ~= 0 and v.grid_y ~= 0 then
                        if poe2_api.table_contains(v.name_utf8,{"開關","把手"}) then
                            local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                            if dis and dis <= 70 then
                                return v
                            end
                        end
                        if v.name_utf8 == "門" then
                            local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                            if dis and dis <= 25 then
                                return v
                            end
                        end
                        
                    end
                end
                return false
            end
            local is_interactive = get_interactive(env.range_info)
            if is_interactive then
                poe2_api.dbgp("特殊交互对象，不捡:  "..is_interactive.name_utf8)
                poe2_api.time_p("检查是否拾取（SUCCESS6）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.SUCCESS
            end
            poe2_api.dbgp("3")
            need_item = env.need_item
            env.interactive = need_item
            if self.currte_time == 0 then
                self.currte_time = api_GetTickCount64()
            end
            if api_GetTickCount64() - self.currte_time > 10*1000 then
                local path = api_FindPath(need_item.grid_x, need_item.grid_y,player_info.grid_x,player_info.grid_y)
                if not path or #path == 0  then
                    poe2_api.dbgp("物品无路径")
                    env.need_item = nil
                    env.interactive = nil
                    self.currte_time = 0
                    return bret.SUCCESS
                end
            end
            local distance = poe2_api.point_distance(need_item.grid_x, need_item.grid_y,player_info)
            poe2_api.dbgp("距离: "..distance)
            if distance then
                if distance < 25 then
                    local is_item = nil
                    poe2_api.dbgp("need_item.id: "..need_item.id)
                    for _, i in ipairs(env.range_items) do 
                        poe2_api.dbgp("i.id: "..i.id)
                        if i.id == need_item.id then 
                            is_item = i
                            break
                        end 
                    end
                    if not is_item then
                        env.need_item = nil
                        poe2_api.dbgp("物品已捡起1")
                        poe2_api.time_p("检查是否拾取（RUNNING2）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    poe2_api.dbgp("111================")
                    local size = my_game_info.item_size[need_item.category_utf8]
                    poe2_api.dbgp("size:"..size[1],size[2])
                    local point = poe2_api.get_space_point({width=size[1],height=size[2],info=bag_info})
                    if not point and not player_info.isInBossBattle then
                        poe2_api.dbgp("背包空间不足，回城")
                        for _, i in ipairs(env.range_info) do
                            if i.name_utf8 ~= "" and i.type == 5 and poe2_api.table_contains(i.name_utf8,my_game_info.hideout_CH) then
                                local dis = poe2_api.point_distance(i.grid_x, i.grid_y, player_info)
                                if dis and dis < 25 then
                                    poe2_api.find_text({text = i.name_utf8,UI_info = env.UI_info,min_x=0,min_y=200,click=2})
                                    api_Sleep(200)
                                    env.need_item = nil
                                    poe2_api.time_p("检查是否拾取（RUNNING3）... 耗时 --> ", api_GetTickCount64() - start_time)
                                    return bret.RUNNING
                                end
                            end
                        end  
                        api_ClickMove(poe2_api.toInt(player_info.grid_x),poe2_api.toInt(player_info.grid_y),7)
                        api_Sleep(300) 
                        -- 先设置随机种子（只需执行一次）
                        math.randomseed(os.time())
                        -- 生成 [0, 25) 范围内的随机浮点数
                        local x = 0 + (5 - 0) * math.random()
                        -- 生成 [0, 25) 范围内的随机浮点数
                        local y = 0 + (5 - 0) * math.random()
                        api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),0)
                        api_Sleep(50)
                        api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),1)
                        self.wait = true
                        self.current_time = api_GetTickCount64()
                        self.wait_time = 2000
                        poe2_api.dbgp("等待回城")
                        poe2_api.time_p("检查是否拾取（RUNNING4）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    local bool = false
                    for _, i in ipairs(env.range_info) do
                        if i.name_utf8 ~= "" and i.type == 5 and poe2_api.table_contains(i.name_utf8,my_game_info.hideout_CH) then
                            local dis = poe2_api.point_distance(i.grid_x, i.grid_y, need_item)
                            if dis and dis < 25 then
                                bool = true
                                break
                            end
                        end
                    end
                    poe2_api.dbgp("是否在隐藏点: "..tostring(bool))
                    if bool then
                        for _, v in ipairs(env.range_info) do
                            if v.name_utf8 ~= "" and v.type == 5 and poe2_api.table_contains(v.name_utf8,my_game_info.hideout_CH) then
                                local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                                if dis and dis < 25 then
                                    local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                                    if point then
                                        api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),0)
                                        -- api_Sleep(200)
                                        poe2_api.dbgp1("fdgherhtfbfdbsrghdghjm")
                                        poe2_api.click_keyboard("space")
                                        api_Sleep(200)
                                        poe2_api.time_p("检查是否拾取（RUNNING5）... 耗时 --> ", api_GetTickCount64() - start_time)
                                        return bret.RUNNING
                                    end
                                end
                            end
                        end
                        local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),7)
                            api_Sleep(300)
                            -- 先设置随机种子（只需执行一次）
                            math.randomseed(os.time())
                            -- 生成 [0, 25) 范围内的随机浮点数
                            local x = 0 + (5 - 0) * math.random()
                            -- 生成 [0, 25) 范围内的随机浮点数
                            local y = 0 + (5 - 0) * math.random()
                            api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),0)
                            api_Sleep(50)
                            api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),1)
                            self.wait = true
                            self.current_time = api_GetTickCount64()
                            self.wait_time = 2000
                            -- -- api_Sleep(200)
                            -- poe2_api.click_keyboard("space")
                            poe2_api.time_p("检查是否拾取（RUNNING6）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end   
                    if not player_info.isMoving then
                        if not self.id1 then
                            self.id1 = env.need_item.id
                        end
                        if self.id1 == env.need_item.id then
                            self.number = self.number + 1
                        else
                            self.number = 1
                            self.id1 = env.need_item.id
                            -- poe2_api.dbgp("物品已捡起,更新状态")
                            -- api_Sleep(1000)
                        end
                        if self.number % 10 == 0 then
                            local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                            if point then
                                api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),7)
                            end
                        end
                        poe2_api.dbgp("number: "..self.number)
                        if self.number >= 50 then
                            table.insert(env.pick_up_timeout,env.need_item.id)
                            env.need_item = nil
                            self.number = 0
                            poe2_api.time_p("检查是否拾取（RUNNING7）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end
                    poe2_api.dbgp("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")   
                elseif distance < 50 then
                    local is_item = nil
                    for _, i in ipairs(env.range_items) do 
                        if i.id == need_item.id then 
                            is_item = i
                            break
                        end 
                    end
                    if not is_item then
                        env.need_item = nil
                        poe2_api.dbgp("物品已捡起2")
                        poe2_api.time_p("检查是否拾取（SUCCESS1）... 耗时 --> ", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    local bool = false
                    for _, i in ipairs(env.range_info) do
                        if i.name_utf8 ~= "" and i.type == 5 and poe2_api.table_contains(i.name_utf8,my_game_info.hideout_CH) then
                            local dis = poe2_api.point_distance(i.grid_x, i.grid_y, need_item)
                            if dis and dis < 25 then
                                bool = true
                                break
                            end
                        end
                    end
                    if bool then
                        for _, v in ipairs(env.range_info) do
                            if v.name_utf8 ~= "" and v.type == 5 and poe2_api.table_contains(v.name_utf8,my_game_info.hideout_CH) then
                                local dis = poe2_api.point_distance(v.grid_x, v.grid_y, player_info)
                                if dis and dis < 30 then
                                    local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                                    if point then
                                        api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),0)
                                        -- api_Sleep(200)
                                        poe2_api.dbgp1("fdsvsdvsdvdsfdrsfv")
                                        poe2_api.click_keyboard("space")
                                        poe2_api.time_p("检查是否拾取（RUNNING8）... 耗时 --> ", api_GetTickCount64() - start_time)
                                        return bret.RUNNING
                                    end
                                end
                            end
                        end
                        local point = api_FindRandomWalkablePosition(math.floor(player_info.grid_x),math.floor(player_info.grid_y),70)
                        
                        if point then
                            api_ClickMove(poe2_api.toInt(point.x),poe2_api.toInt(point.y),7)
                            api_Sleep(300)
                            -- 先设置随机种子（只需执行一次）
                            math.randomseed(os.time())
                            -- 生成 [0, 25) 范围内的随机浮点数
                            local x = 0 + (5 - 0) * math.random()
                            -- 生成 [0, 25) 范围内的随机浮点数
                            local y = 0 + (5 - 0) * math.random()
                            api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),0)
                            api_Sleep(50)
                            api_ClickScreen(poe2_api.toInt(x+1230),poe2_api.toInt(y+815),1)
                            self.wait = true
                            self.current_time = api_GetTickCount64()
                            self.wait_time = 2000                            -- -- api_Sleep(200)
                            -- poe2_api.click_keyboard("space")
                            poe2_api.time_p("检查是否拾取（RUNNING9）... 耗时 --> ", api_GetTickCount64() - start_time)
                            return bret.RUNNING
                        end
                    end
                       
                end
                
            end
            if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                poe2_api.click_keyboard("i")
                poe2_api.dbgp("关背包7")
                api_Sleep(200)
                poe2_api.time_p("检查是否拾取（RUNNING10）... 耗时 --> ", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
            self.currte_time = 0
            poe2_api.dbgp("背包已關閉*********************************************************")
            poe2_api.time_p("检查是否拾取（FAIL1）... 耗时 --> ", api_GetTickCount64() - start_time)
            return bret.FAIL
        end
    },
    
    -- 打开仓库(warehouse_type_interactive 为空情况在调用之前，提前处理)
    Open_Warehouse = {
        run = function(self, env)
            poe2_api.print_log("开始执行 Open_Warehouse")

            if not self.nubmer_index then
                self.nubmer_index = 0
                poe2_api.dbgp("初始化完成，设置 nubmer_index = 0")
                return bret.RUNNING
            end

            -- poe2_api.dbgp("打开仓库,.")
            local obj = nil
            local text = nil
            local warehouse = nil
            local current_map_info = env.current_map_info

            local player_info = env.player_info
            local warehouse_type_interactive = env.warehouse_type_interactive

            poe2_api.dbgp("环境变量检查:", {
                warehouse_type_interactive = warehouse_type_interactive,
                current_map_info = current_map_info and #current_map_info or "nil",
                player_info = player_info and "exists" or "nil"
            })

            local function get_object(name, data_list)
                for _, v in ipairs(data_list) do
                    if v.name_utf8 == name and v.grid_x ~= 0 and v.grid_y ~= 0 then
                        if v.flagStatus and v.flagStatus == 0 and v.flagStatus1 == 1 then
                            poe2_api.dbgp("get_object 找到匹配对象(flagStatus):", v)
                            return v
                        end
                        if v.life and v.is_selectable then
                            poe2_api.dbgp("get_object 找到匹配对象(life):", v)
                            return v
                        end
                    end
                end
                poe2_api.dbgp("get_object: 未找到匹配对象")
                return false
            end

            poe2_api.dbgp("仓库类型:", warehouse_type_interactive)

            if warehouse_type_interactive == "个仓" then
                poe2_api.dbgp("查找个人仓库...")
                local warehouse_obj = get_object("StashPlayer", current_map_info)
                if warehouse_obj then
                    obj = 'StashPlayer'
                    text = "倉庫"
                    warehouse = warehouse_obj
                    poe2_api.dbgp("找到 StashPlayer 仓库:", warehouse_obj)
                else
                    local warehouse_obj1 = get_object("倉庫", env.range_info)
                    if warehouse_obj1 then
                        obj = '倉庫'
                        text = "倉庫"
                        warehouse = warehouse_obj1
                        poe2_api.dbgp("找到 倉庫 (备用):", warehouse_obj1)
                    end
                end
            elseif warehouse_type_interactive == "公仓" then
                poe2_api.dbgp("查找公会仓库...")
                local warehouse_obj = get_object("StashGuild", current_map_info)
                if warehouse_obj then
                    obj = 'StashGuild'
                    text = "公會倉庫"
                    warehouse = warehouse_obj
                    poe2_api.dbgp("找到 StashGuild 仓库:", warehouse_obj)
                else
                    local warehouse_obj1 = get_object("公會倉庫", env.range_info)
                    if warehouse_obj1 then
                        obj = '公會倉庫'
                        text = "公會倉庫"
                        warehouse = warehouse_obj1
                        poe2_api.dbgp("找到 公會倉庫 (备用):", warehouse_obj1)
                    end
                end
            else
                poe2_api.dbgp("错误: 仓库类型未配置", warehouse_type_interactive)
                error("在配置物品过滤中,有物品的存仓页未配置")
            end

            if not warehouse then
                poe2_api.dbgp("错误: 找不到仓库对象")
                error("找不到仓库或者公会仓库")
            end

            poe2_api.dbgp("最终仓库对象:",
                obj,
                text,
                warehouse
            )

            -- 检查是否已经打开仓库界面
            local emphasize_text = poe2_api.find_text({ UI_info = env.UI_info, text = "強調物品", min_x = 250, min_y = 700 })
            local warehouse_text = poe2_api.find_text({ UI_info = env.UI_info, text = text, min_x = 0, min_y = 32, max_x = 381, max_y = 81 })

            poe2_api.dbgp("界面检查结果:", {
                emphasize_text = emphasize_text and "found" or "not found",
                warehouse_text = warehouse_text and "found" or "not found"
            })

            if emphasize_text and warehouse_text then
                poe2_api.dbgp("仓库界面已打开，返回SUCCESS")
                return bret.SUCCESS
            end

            local distance = poe2_api.point_distance(warehouse.grid_x, warehouse.grid_y, player_info)
            poe2_api.dbgp("与仓库的距离:", distance)

            if distance > 30 then
                poe2_api.dbgp("距离仓库太远(", distance, ")，返回FAIL")
                env.interactive = obj
                return bret.FAIL
            else
                local continue_game = poe2_api.find_text({ UI_info = env.UI_info, text = "繼續遊戲", click = 2 })
                if continue_game then
                    poe2_api.dbgp("发现'繼續遊戲'文本，返回RUNNING")
                    return bret.RUNNING
                end

                poe2_api.dbgp("尝试移动到仓库位置:", warehouse.grid_x, warehouse.grid_y)

                api_ClickMove(poe2_api.toInt(warehouse.grid_x), poe2_api.toInt(warehouse.grid_y), 1)

                if self.nubmer_index >= 10 then
                    poe2_api.dbgp("尝试次数超过10次(", self.nubmer_index, ")，执行ESC并重置计数器")
                    poe2_api.click_keyboard("space")
                    api_Sleep(500)
                    self.nubmer_index = 0
                end

                self.nubmer_index = self.nubmer_index + 1
                poe2_api.dbgp("当前尝试次数:", self.nubmer_index)

                api_Sleep(500)
                return bret.RUNNING
            end
        end
    },

    -- 城镇任务接收
    Interactive_Npc_In_Town = {
        run = function(self, env)
            poe2_api.print_log("城镇交互-任务")
            poe2_api.dbgp("[Interactive_Npc_In_Town]开始处理城镇任务")
            local range_info = env.range_info
            local team_info = env.team_info
            local user_config = env.user_config
            local player_info = env.player_info
            local current_time = api_GetTickCount64()
            if not string.find(player_info.current_map_name_utf8, "own") or poe2_api.get_team_info(team_info, user_config, player_info, 2) == "大號名" then
                poe2_api.dbgp("[The_Interactive_Npc_Exist]不在城镇或为大号,不进行任何操作")
                poe2_api.time_p("Interactive_Npc_In_Town",api_GetTickCount64() - current_time)
                return bret.FAIL
            end
            local function is_have_active_npc(ranges)
                if ranges then
                    for _, m in pairs(ranges) do
                        if m.name_utf8 and m.hasTasksToAccept then
                            if poe2_api.table_contains(player_info.current_map_name_utf8 , {"G1_town","G4_town","P2_Town"}) and m.name_utf8 == "黑衣幽魂" then
                               goto continue
                            end
                            if poe2_api.table_contains(m.name_utf8, {'沙漠',"安潔"}) then
                                goto continue
                            end
                            return m
                        end
                        ::continue::
                    end
                end
                return false
            end

            if string.find(player_info.current_map_name_utf8, "own") then
                local npc_names = is_have_active_npc(range_info)
                if npc_names then
                    env.npc_names = npc_names
                    poe2_api.dbgp("Interactive_Npc_In_Town(SUCCESS1)")
                    poe2_api.time_p("Interactive_Npc_In_Town",api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                end
            end
            poe2_api.dbgp("[The_Interactive_Npc_Exist]未找到城镇任务npc")
            poe2_api.time_p("Interactive_Npc_In_Town",api_GetTickCount64() - current_time)
            return bret.FAIL
        end
    },

    -- 城镇任务npc是否存在
    The_Interactive_Npc_Exist = {
        run = function(self, env)
            poe2_api.print_log("城镇任务npc是否存在")
            poe2_api.dbgp("[The_Interactive_Npc_Exist]城镇任务npc是否存在")
            if self.last_click_time == nil then
                poe2_api.dbgp("[The_Interactive_Npc_Exist]初始化")
                self.last_click_time = 0
                self.click_cooldown = 1000
            end
            local npc_names = env.npc_names
            local player_info = env.player_info
            local current_time = api_GetTickCount64()
            if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                poe2_api.click_keyboard("space")
                poe2_api.dbgp("The_Interactive_Npc_Exist(RUNNING1)")
                return bret.RUNNING
            end
            if npc_names and string.find(player_info.current_map_name_utf8, "own") then
                local distance = poe2_api.point_distance(npc_names.grid_x, npc_names.grid_y, player_info)
                local point = api_FindNearestReachableInRange(npc_names.grid_x, npc_names.grid_y, 15)
                if distance <= 25 then
                    poe2_api.dbgp("[The_Interactive_Npc_Exist]与城镇npcdistance:", distance)
                    if poe2_api.find_text({ UI_info = env.UI_info, text = npc_names.name_utf8}) then
                        poe2_api.dbgp("[The_Interactive_Npc_Exist]找到城镇任务npc:", npc_names.name_utf8)
                        if self.last_click_time == 0 then
                            self.last_click_time = api_GetTickCount64()
                        end
                        if api_GetTickCount64() - self.last_click_time > self.click_cooldown then
                            if poe2_api.find_text({ UI_info = env.UI_info, text = "再會", refresh = true }) then
                                poe2_api.dbgp("打开Npc对话选项")
                                poe2_api.time_p("The_Interactive_Npc_Exist",api_GetTickCount64() - current_time)
                                
                                return bret.FAIL
                            end
                            poe2_api.dbgp("[The_Interactive_Npc_Exist]点击城镇任务npc:", npc_names.name_utf8)
                            poe2_api.find_text({ UI_info = env.UI_info, text = npc_names.name_utf8, click = 2 })
                            self.last_click_time = 0
                        end
                        poe2_api.dbgp("The_Interactive_Npc_Exist(RUNNING1)")
                        return bret.RUNNING
                    end
                    poe2_api.dbgp("[The_Interactive_Npc_Exist]未找到城镇任务npc")
                end
                poe2_api.dbgp("[The_Interactive_Npc_Exist]与城镇npcdistance:", distance)
                env.end_point = { point.x, point.y }
                poe2_api.dbgp("The_Interactive_Npc_Exist(SUCCESS1)")
                poe2_api.time_p("The_Interactive_Npc_Exist",api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
            poe2_api.dbgp("The_Interactive_Npc_Exist(FAIL1)")
            poe2_api.time_p("The_Interactive_Npc_Exist",api_GetTickCount64() - current_time)
            return bret.FAIL
        end
    },
    -- 组队
    Team = {
        run = function(self, env)
            poe2_api.print_log("组队")
            poe2_api.dbgp("组队")
            local player_info = env.player_info
            local range_info = env.range_info
            local captain_name = env.user_config["劇情設置"]["隊長名"] or ""
            local leader_name = env.user_config["劇情設置"]["大號名"] or ""
            local team_info_data = env.team_info_data
            local log_path = poe2_api.load_config(json_path)["劇情設置"]["日志路径"]
            local current_time = api_GetTickCount64()
            if player_info.current_map_name_utf8 == "G1_1" then
                poe2_api.dbgp("在新手剧情不组队")
                poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
            if not self.current_time then
                self.current_time = 0
            end
            local num = env.user_config["劇情設置"]["隊伍人數"]
            if team_info_data and #team_info_data == num then
                if env.bool then
                    self.current_time = 0
                    if poe2_api.find_text({ text = "社交", UI_info = env.UI_info, min_x=0, min_y=32, max_x=381, max_y=81}) then
                        poe2_api.click_keyboard("j")
                        api_Sleep(500)
                        poe2_api.dbgp("Team(RUNNING1)")
                        poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                        return bret.RUNNING
                    end
                    
                    -- 检查队伍数据一致性
                    local current_team_info = api_GetTeamInfo()
                    local is_consistent = true
                    
                    -- 检查队伍人数是否一致
                    if #current_team_info ~= #env.team_info_data then
                        is_consistent = false
                    else
                        -- 检查每个队员信息是否一致
                        for i, member in ipairs(current_team_info) do
                            local expected_member = env.team_info_data[i]
                            if not expected_member or member.name_utf8 ~= expected_member.name_utf8 or 
                               member.roleStatus ~= expected_member.roleStatus then
                                is_consistent = false
                                break
                            end
                        end
                    end
                    
                    if not is_consistent then
                        poe2_api.dbgp("队伍数据不一致，需要重新组队")
                        env.bool = false  -- 重置状态，触发重新组队
                        env.team_info_data = nil  -- 清除旧的队伍数据
                        return bret.RUNNING  -- 返回RUNNING让行为树重新执行组队逻辑
                    end
                    
                    poe2_api.dbgp("Team(SUCCESS1)")
                    poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                end
                
                local a = 0
                for _, member in ipairs(team_info_data) do
                    if member.roleStatus == 2 or (member.roleStatus == 0 and member.name_utf8 == captain_name) then
                        a = a + 1
                    end
                end
                if a == num then
                    
                    poe2_api.dbgp("将小号加入到team_info")
                    for _, member in ipairs(team_info_data) do
                        if not poe2_api.table_contains(member.name_utf8,{ captain_name,leader_name}) and not poe2_api.table_contains(member.name_utf8,env.team_info["小號名"])then
                            table.insert(env.team_info["小號名"], member.name_utf8)
                        end
                    end
                    if poe2_api.find_text({ text = "社交", UI_info = env.UI_info, min_x=0, min_y=32, max_x=381, max_y=81}) then
                        poe2_api.click_keyboard("j")
                        api_Sleep(500)
                        poe2_api.dbgp("Team(RUNNING2)")
                        poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                        return bret.RUNNING
                    end
                    env.bool = true
                    env.team_info_data = api_GetTeamInfo()
                    poe2_api.dbgp("Team(SUCCESS2)")
                    poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                end
            elseif player_info.name_utf8 ~= captain_name then
                if poe2_api.find_text({UI_info = env.UI_info, text = "私訊", add_x = 265, min_x = 0, max_x = 400, click = 2}) then
                    return bret.RUNNING
                end
                for _, member in ipairs(team_info_data) do
                    if member.roleStatus == 0 and member.name_utf8 == captain_name then
                        poe2_api.dbgp("是指定队长")
                        if player_info.name_utf8 == leader_name and poe2_api.is_have_mos({range_info = range_info, player_info = player_info, dis = 70}) then
                            poe2_api.dbgp("Team(SUCCESS3)")
                            poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                            return bret.SUCCESS
                        end
                        if poe2_api.find_text({ text = "社交", UI_info = env.UI_info, min_x=0, min_y=32, max_x=381, max_y=81}) then
                            poe2_api.click_keyboard("j")
                            api_Sleep(500)
                            poe2_api.dbgp("Team(RUNNING3)")
                            poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                            return bret.RUNNING
                        end
                        poe2_api.dbgp("Team(RUNNING4)")
                        poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                        return bret.RUNNING
                    elseif member.roleStatus == 0 and member.name_utf8 ~= captain_name then
                        poe2_api.dbgp("不是指定队长")
                        break
                    end
                end
            end
            if player_info.name_utf8 == captain_name then
                
                local function direct_parse_log_line(line, max_age_ms)
                    -- 直接按位置提取
                    -- 格式: 2025/09/13 14:37:31 447941390 3ef232c2 [INFO Client 10252] @來自 king_qq: king_qq
                    
                    -- 提取时间部分（前19个字符）
                    local date_time = line:sub(1, 19)
                    
                    -- 将日期时间转换为毫秒
                    local year, month, day, hour, minute, second = date_time:match("^(%d+)/(%d+)/(%d+)%s+(%d+):(%d+):(%d+)$")
                    
                    if not (year and month and day and hour and minute and second) then
                        return nil
                    end
                    
                    -- 创建时间对象
                    local time_table = {
                        year = tonumber(year),
                        month = tonumber(month),
                        day = tonumber(day),
                        hour = tonumber(hour),
                        min = tonumber(minute),
                        sec = tonumber(second)
                    }
                    
                    local log_timestamp = os.time(time_table) * 1000  -- 转换为毫秒
                    local current_timestamp = api_GetTickCount64()  -- 当前时间（毫秒）
                    
                    -- 检查时间是否在指定毫秒范围内
                    if current_timestamp - log_timestamp > max_age_ms then
                        -- 日志时间太旧，跳过
                        return nil
                    end
                    
                    -- 找到@來自的位置
                    local at_pos = line:find("@來自")
                    if at_pos then
                        poe2_api.dbgp("我是队长")
                        -- 找到冒号的位置
                        local colon_pos = line:find(":", at_pos)
                        if colon_pos then
                            -- 只提取接收者名称（: 之后）
                            local receiver_name = line:sub(colon_pos + 1):gsub("^%s*(.-)%s*$", "%1")
                            
                            return {
                                timestamp = log_timestamp,
                                receiver_name = receiver_name
                            }
                        end
                    end
                    
                    return nil
                end
                -- 从文件末尾向前读取并解析，只读取指定毫秒时间范围内的内容
                local function process_recent_logs_unique(file_path, max_age_ms)
                    local file = io.open(file_path, "r")
                    if not file then
                        print("无法打开文件: " .. file_path)
                        return {}
                    end
                    
                    -- 读取整个文件内容
                    local content = file:read("*a")
                    file:close()
                    
                    -- 按行分割
                    local lines = {}
                    for line in content:gmatch("[^\r\n]+") do
                        table.insert(lines, line)
                    end
                    
                    -- 反转行顺序（从后往前，最新的在前面）
                    local reversed_lines = {}
                    for i = #lines, 1, -1 do
                        table.insert(reversed_lines, lines[i])
                    end
                    
                    local unique_receivers = {}  -- 使用表来去重
                    local receiver_names = {}    -- 最终结果：存储唯一的接收者名称
                    
                    for _, line in ipairs(reversed_lines) do
                        local parsed_line = direct_parse_log_line(line, max_age_ms)
                        if parsed_line then
                            local receiver_name = parsed_line.receiver_name
                            -- 检查是否已经存在，如果不存在则添加
                            if not unique_receivers[receiver_name] then
                                unique_receivers[receiver_name] = true
                                table.insert(receiver_names, receiver_name)
                            end
                        else
                            -- 如果遇到超时的记录，提前停止
                            break
                        end
                    end
                    
                    return receiver_names  -- 返回格式：{"king_qq", "other_name", ...}（唯一）
                end
                -- 处理日志文件，获取最近的接收者名称（5分钟内）
                local recent_receivers = process_recent_logs_unique(log_path, 5 * 60 * 1000)
                
                -- 过滤掉大号名，只保留小号名
                local small_account_names = {}
                for _, name in ipairs(recent_receivers) do
                    if name ~= leader_name then
                        table.insert(small_account_names, name)
                    end
                end
                
                -- 将小号名加入到 env.team_info["小號名"]
                if not env.team_info then
                    env.team_info = {}
                end
                env.team_info["小號名"] = small_account_names
                
                poe2_api.dbgp("找到的小号名: " .. table.concat(small_account_names, ", "))
            elseif player_info.name_utf8 ~= leader_name then
                if self.current_time == 0  then
                    self.current_time = api_GetTickCount64()
                end
                if (not env.bool1) or (api_GetTickCount64() - self.current_time > 1000*10) then
                    poe2_api.dbgp("发送名字给队长")
                    env.bool1 = true
                    poe2_api.click_keyboard("enter")
                    api_Sleep(200)
                    poe2_api.paste_text("@"..captain_name.." "..player_info.name_utf8)
                    api_Sleep(200)
                    poe2_api.click_keyboard("enter")
                    -- 使用临时表进行去重检查
                    local temp_table = {}
                    for _, name in ipairs(env.team_info["小號名"]) do
                        temp_table[name] = true
                    end
                    
                    -- 如果不存在才添加
                    if not temp_table[player_info.name_utf8] then
                        table.insert(env.team_info["小號名"], player_info.name_utf8)
                        poe2_api.dbgp("添加小号名: " .. player_info.name_utf8)
                    else
                        poe2_api.dbgp("小号名已存在: " .. player_info.name_utf8)
                    end
                end
            end
            local function get_valid_members()
                -- 获取有效成员名单
                poe2_api.dbgp("获取有效成员名单")
                local members = {}
                if env.team_info["大號名"] and env.team_info["大號名"] ~= "" then
                    table.insert(members, {"大號名", env.team_info["大號名"]})
                end
                if env.team_info["隊長名"] and env.team_info["隊長名"] ~= "" then
                    table.insert(members, {"隊長名", env.team_info["隊長名"]})
                end
                if env.team_info["小號名"] then
                    for _, name in ipairs(env.team_info["小號名"]) do
                        table.insert(members, {"小號名", name})
                    end
                end
                return members
            end
            
            local function get_player_info()
                -- 获取当前玩家信息
                local current_player = player_info.name_utf8
                local result = {}
                for _, m in ipairs(get_valid_members()) do
                    if m[2] == current_player then
                        table.insert(result, m)
                    end
                end
                return result
            end
            
            local function get_team_info()
                -- 获取队友信息（排除自己）
                local current_player = player_info.name_utf8
                local result = {}
                for _, m in ipairs(get_valid_members()) do
                    if m[2] ~= current_player then
                        table.insert(result, m)
                    end
                end
                return result
            end
            
            local function get_game_not_team_info(team_members)
                -- 获取不在游戏队伍中的成员
                if team_info_data ~= nil then
                    local game_team_names_set = {}
                    for _, member in ipairs(team_info_data) do
                        game_team_names_set[member.name_utf8] = true
                    end
                    
                    local teams_names_set = {}
                    for _, member in ipairs(team_members) do
                        teams_names_set[member[2]] = true
                    end
                    
                    local not_in_team_names = {}
                    for name in pairs(teams_names_set) do
                        if not game_team_names_set[name] then
                            table.insert(not_in_team_names, name)
                        end
                    end
                    
                    if #not_in_team_names > 0 then
                        return not_in_team_names
                    else
                        return false
                    end
                end
                
                local result = {}
                for _, member in ipairs(team_members) do
                    table.insert(result, member[2])
                end
                return result
            end

            local player = get_player_info()
            if not player or #player == 0 then
                error("该号不在组队信息中，请修改组队配置信息")
            end
            if team_info_data and #team_info_data >= num and captain_name == player_info.name_utf8 then
                for _, member in ipairs(team_info_data) do
                    -- 检查成员是否不在队伍信息中
                    local found = false
                    for _, value in pairs(env.team_info) do
                        if type(value) == "table" then
                            for _, name in ipairs(value) do
                                if name == member.name_utf8 then
                                    found = true
                                    break
                                end
                            end
                        else
                            if value == member.name_utf8 then
                                found = true
                                break
                            end
                        end
                        if found then break end
                    end
                    
                    if not found then
                        if not poe2_api.find_text({ text = "社交", UI_info = env.UI_info, min_x=0, min_y=32, max_x=381, max_y=81}) then
                            poe2_api.click_keyboard("j")
                            api_Sleep(500)
                            poe2_api.dbgp("Team(RUNNING5)")
                            poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                            return bret.RUNNING
                        end
                        poe2_api.find_text({UI_info = env.UI_info, text = "目前隊伍", min_x = 0, click = 2,refresh = true})
                        poe2_api.find_text({UI_info = env.UI_info, text = "離開", min_x = 0, click = 2,refresh = true})
                        poe2_api.dbgp("Team(RUNNING6)")
                        poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                        return bret.RUNNING
                    end
                end
            end
            -- 判断队伍是否完成
            if team_info_data ~= nil then
                local game_team_names_set = {}
                for _, member in ipairs(team_info_data) do
                    if member.roleStatus ~= 1 then
                        game_team_names_set[member.name_utf8] = true
                    end
                end
                
                local all_names = {}
                for _, role_type_value in pairs(env.team_info) do
                    if type(role_type_value) == "table" then
                        for _, name in ipairs(role_type_value) do
                            if name ~= nil then
                                all_names[name] = true
                            end
                        end
                    else
                        if role_type_value ~= nil then
                            all_names[role_type_value] = true
                        end
                    end
                end
                
                -- 检查all_names是否是game_team_names_set的子集
                local is_subset = true
                for name in pairs(all_names) do
                    if not game_team_names_set[name] then
                        is_subset = false
                        break
                    end
                end
                
                if is_subset then
                    if poe2_api.find_text({UI_info = env.UI_info, text = "社交", min_x = 0, min_y = 32, max_x = 381, max_y = 81}) then
                        poe2_api.click_keyboard("j")
                        api_Sleep(500)
                        poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                        return bret.RUNNING
                    end
                    poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                end
            end

            if player[1][1] == "隊長名" then
                if not poe2_api.find_text({UI_info = env.UI_info, text = "社交", min_x = 0, min_y = 32, max_x = 381, max_y = 81}) then
                    poe2_api.click_keyboard("j")
                    api_Sleep(500)
                    poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                    return bret.RUNNING
                end

                if not poe2_api.find_text({UI_info = env.UI_info, text = "隊伍邀請：", min_x = 0,refresh = true}) then
                    poe2_api.find_text({UI_info = env.UI_info, text = "建立隊伍", min_x = 0, click = 2,refresh = true})
                    poe2_api.find_text({UI_info = env.UI_info, text = "目前隊伍", min_x = 0, click = 2,refresh = true})
                    api_Sleep(500)
                    poe2_api.dbgp("Team(RUNNING7)")
                    poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                    return bret.RUNNING
                end

                local members = get_team_info()
                if members and #members > 0 then
                    local not_teams = get_game_not_team_info(members)
                    if not_teams then
                        poe2_api.find_text({UI_info = env.UI_info,text ="隊伍邀請：", min_x = 0, click = 2, add_x = 100,refresh = true})
                        api_Sleep(200)
                        poe2_api.paste_text(not_teams[1])  -- 获取第一个不在队伍中的成员
                        api_Sleep(200)
                        poe2_api.find_text({UI_info = env.UI_info,text = "隊伍邀請：", min_x = 0, click = 2, add_x = 274,refresh = true})
                        api_Sleep(5*1000)
                        poe2_api.dbgp("Team(RUNNING8)")
                        poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                        return bret.RUNNING
                    end
                end
                poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                poe2_api.dbgp("Team(RUNNING9)")
                return bret.RUNNING

            elseif player[1][1] ~= "隊長名" then
                if not poe2_api.find_text({UI_info = env.UI_info, text = "社交", min_x = 0, min_y = 32, max_x = 381, max_y = 81}) then
                    poe2_api.click_keyboard("j")
                    api_Sleep(500)
                    poe2_api.dbgp("Team(RUNNING10)")
                    poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                    return bret.RUNNING
                end

                if not poe2_api.find_text({UI_info = env.UI_info, text = "隊伍邀請：", min_x = 0}) then
                    poe2_api.find_text({UI_info = env.UI_info, text = "建立隊伍", min_x = 0, click = 2})
                    poe2_api.find_text({UI_info = env.UI_info, text = "目前隊伍", min_x = 0, click = 2})
                    api_Sleep(500)
                    poe2_api.dbgp("Team(RUNNING11)")
                    poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                    return bret.RUNNING
                end

                local members = get_team_info()
                local function get_captain_name()
                    for _, member in ipairs(members) do
                        if member[1] == "隊長名" then
                            return member[2]
                        end
                    end
                    return false
                end

                if members and #members > 0 then
                    local captain = get_captain_name()
                    local game_team_names_set = {}
                    if team_info_data then
                        for _, member in ipairs(team_info_data) do
                            if member.roleStatus == 0 then
                                game_team_names_set[member.name_utf8] = true
                            end
                        end
                    end
                    
                    if captain then
                        if team_info_data and #team_info_data > 0 then
                            if not game_team_names_set[captain] then
                                poe2_api.find_text({UI_info = env.UI_info, text = "目前隊伍", min_x = 0, click = 2})
                                poe2_api.find_text({UI_info = env.UI_info, text = "離開", min_x = 0, click = 2})
                                api_Sleep(500)
                                poe2_api.dbgp("Team(RUNNING12)")
                                poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                                return bret.RUNNING
                            end
                            
                            local game_team_names_set2 = {}
                            for _, member in ipairs(team_info_data) do
                                if member.roleStatus == 2 then
                                    game_team_names_set2[member.name_utf8] = true
                                end
                            end
                            
                            if game_team_names_set2[player[1][2]] then
                                api_Sleep(1000)
                                poe2_api.dbgp("Team(RUNNING13)")
                                poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                                return bret.RUNNING
                            end
                        else
                            poe2_api.dbgp("接受")
                            if poe2_api.find_text({UI_info = env.UI_info, text = "接受", min_x = 0, max_x = 515, click = 2}) then
                                api_Sleep(500)
                                poe2_api.dbgp("Team(RUNNING14)")
                                poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                                return bret.RUNNING
                            end
                            api_Sleep(1000)
                            poe2_api.dbgp("Team(RUNNING15)")
                            poe2_api.time_p("Team", api_GetTickCount64() - current_time)
                            return bret.RUNNING
                        end
                    else
                        error("隊長信息获取失败,组队配置异常")
                    end
                end
            end
        end
    },
    -- 检查是否为大号
    Check_Role = {
        run = function(self, env)
            poe2_api.print_log("检查是否为大号")
            poe2_api.dbgp("[Check_Role]检查是否为大号")
            local player_info = env.player_info
            local team_info = env.team_info
            local current_time = api_GetTickCount64()
            local user_config = env.user_config
            local log_path = user_config["劇情設置"]["日志路径"]
            local leader_name = env.user_config["劇情設置"]["大號名"] or ""
            if player_info.name_utf8 ~= leader_name then
                poe2_api.dbgp("Check_Role(FAIL1)")
                return bret.FAIL
            end
             
            -- 将字符串转换为Lua表格式
            local function parse_data_string(data_str)
                -- 输入: 'user_name': player_info.name_utf8, 'map_name': task.map_name, 'task_name': task.task_name, 'task_index': task.index
                -- 输出: {user_name = "player_info.name_utf8", map_name = "task.map_name", task_name = "task.task_name", task_index = "task.index"}
                local result = {}
                
                -- 使用正则表达式匹配键值对
                for key, value in data_str:gmatch("([^=,]+)=([^,]+)") do
                    -- 去除键和值的前后空格
                    key = key:gsub("^%s*(.-)%s*$", "%1")
                    value = value:gsub("^%s*(.-)%s*$", "%1")
                    result[key] = value
                end
                
                return result
            end

            -- 直接按位置提取（移除时间检查）
            local function direct_parse_log_line(line)
                -- 提取时间部分（前19个字符）
                local date_time = line:sub(1, 19)
                
                -- 将日期时间转换为毫秒
                local year, month, day, hour, minute, second = date_time:match("^(%d+)/(%d+)/(%d+)%s+(%d+):(%d+):(%d+)$")
                
                if not (year and month and day and hour and minute and second) then
                    return nil
                end
                
                -- 创建时间对象
                local time_table = {
                    year = tonumber(year),
                    month = tonumber(month),
                    day = tonumber(day),
                    hour = tonumber(hour),
                    min = tonumber(minute),
                    sec = tonumber(second)
                }
                
                local log_timestamp = os.time(time_table) * 1000  -- 转换为毫秒
                
                -- 找到%的位置
                local percent_pos = line:find("%%")
                if percent_pos then
                    -- 找到冒号的位置
                    local colon_pos = line:find(":", percent_pos)
                    if colon_pos then
                        -- 提取名称（%和:之间）
                        local name = line:sub(percent_pos + 1, colon_pos - 1)
                        -- 提取数据（:之后）
                        local data = line:sub(colon_pos + 2)  -- +2 跳过冒号和空格
                        
                        -- 解析数据字符串为Lua表
                        local parsed_data = parse_data_string(data)
                        
                        return {
                            timestamp = log_timestamp,
                            name = name,
                            data = parsed_data,
                        }
                    end
                end
                
                return nil
            end

            -- 从文件末尾向前读取并解析，只读取指定毫秒时间范围内的内容
            local function process_recent_logs_unique(file_path, max_age_ms)
                local file = io.open(file_path, "r")
                if not file then
                    print("无法打开文件: " .. file_path)
                    return {}
                end
                
                -- 读取整个文件内容
                local content = file:read("*a")
                file:close()
                
                -- 按行分割
                local lines = {}
                for line in content:gmatch("[^\r\n]+") do
                    table.insert(lines, line)
                end
                
                -- 反转行顺序（从后往前，最新的在前面）
                local reversed_lines = {}
                for i = #lines, 1, -1 do
                    table.insert(reversed_lines, lines[i])
                end
                
                local latest_data = {}  -- 最终结果：{name = parsed_data}
                local seen_names = {}   -- 跟踪每个名称的最新时间戳
                local current_timestamp = os.time() * 1000
                
                for _, line in ipairs(reversed_lines) do
                    -- 先快速检查时间格式
                    local date_time = line:sub(1, 19)
                    local year, month, day, hour, minute, second = date_time:match("^(%d+)/(%d+)/(%d+)%s+(%d+):(%d+):(%d+)$")
                    
                    if not (year and month and day and hour and minute and second) then
                        -- 不是有效的时间格式，跳过这行
                        goto continue
                    end
                    
                    -- 创建时间对象
                    local time_table = {
                        year = tonumber(year),
                        month = tonumber(month),
                        day = tonumber(day),
                        hour = tonumber(hour),
                        min = tonumber(minute),
                        sec = tonumber(second)
                    }
                    
                    local log_timestamp = os.time(time_table) * 1000
                    
                    -- 检查时间是否在指定毫秒范围内
                    if current_timestamp - log_timestamp > max_age_ms then
                        -- 日志时间太旧，提前返回
                        return latest_data
                    end
                    
                    -- 解析日志行（不再传递max_age_ms参数）
                    local parsed_line = direct_parse_log_line(line)
                    if parsed_line then
                        local name = parsed_line.name
                        local data = parsed_line.data
                        local timestamp = parsed_line.timestamp
                        
                        -- 如果这个名称还没有处理过，或者当前记录的时间戳更新，则更新数据
                        if not seen_names[name] or timestamp > seen_names[name] then
                            seen_names[name] = timestamp
                            latest_data[name] = data
                        end
                    end
                    
                    ::continue::
                end
                
                return latest_data
            end
            -- 获取队伍成员列表（排除自己）
            local function get_team_members()
                local members = {}
                
                -- 检查 team_info 中是否有 "小號名" 这个键
                if team_info["小號名"] then
                    -- 遍历小号列表
                    for _, small_name in ipairs(team_info["小號名"]) do
                        if small_name and small_name ~= player_info.name_utf8 then
                            table.insert(members, small_name)
                        end
                    end
                end
                
                -- 检查是否有队长且不是当前玩家
                if team_info["隊長名"] and team_info["隊長名"] ~= player_info.name_utf8 then
                    table.insert(members, team_info["隊長名"])
                end
                
                return members
            end

            -- 主逻辑
            local team_members = get_team_members()
            local num = env.user_config["劇情設置"]["隊伍人數"] or 1
            local expected_mission_count = num - 1

            -- 设置超时时间（如果在藏身处则30秒，否则5分钟）
            local max_time = 1000 * 60 * 10  -- 10分钟

            poe2_api.dbgp(max_time)
            -- 解析日志获取成员任务信息
            local member_task_info = process_recent_logs_unique(log_path, max_time)
            poe2_api.printTable(member_task_info)
            if not member_task_info or next(member_task_info) == nil then
                poe2_api.dbgp("没有找到队友发送的任务信息")
                poe2_api.time_p("Check_Role",api_GetTickCount64()- current_time)
                return bret.RUNNING
            end

            -- 检查接收到的任务数量
            local received_count = 0
            local stored_missions = {}
            local received_missions = {}

            -- 统计有效任务数量
            for name, mission_data in pairs(member_task_info) do
                if poe2_api.table_contains(name,team_members ) then
                    received_count = received_count + 1
                    stored_missions[name] = mission_data
                    table.insert(received_missions, mission_data)
                end
            end

            poe2_api.dbgp("接收到 " .. received_count .. " 个队友的任务信息，期望数量: " .. expected_mission_count)

            -- 检查是否所有小号信息都已接收完成
            if received_count >= expected_mission_count then
                poe2_api.dbgp("所有队友信息已接收完成")
                
                -- 查找最小任务索引
                local min_index = math.huge
                local task_name = "无"
                
                for _, mission_data in pairs(stored_missions) do
                    local current_index = tonumber(mission_data.task_index or math.huge)
                    
                    if current_index < min_index then
                        min_index = current_index
                        task_name = mission_data.task_name or "无"
                    end
                end
                                
                if task_name == "无" or not task_name or task_name == "" then
                    env.map_name = player_info.current_map_name_utf8 
                    env.task_name = nil
                    env.task_index = nil
                    poe2_api.dbgp("Check_Role(SUCCESS1)")
                    poe2_api.time_p("Check_Role",api_GetTickCount64() - current_time)
                    return bret.SUCCESS
                end
                
                -- 设置任务信息
                env.task_name = task_name
                env.task_index = tostring(min_index)
                if api_GetTickCount64() - current_time > 50 then 
                    poe2_api.dbgp("大号获取任务信息大于50ms，删除日志")
                    env.delete_log = false
                end
                poe2_api.dbgp("选择任务: " .. task_name .. ", 索引: " .. min_index)
                poe2_api.dbgp("Check_Role(SUCCESS2)")
                poe2_api.time_p("Check_Role",api_GetTickCount64() - current_time)
                return bret.SUCCESS
            else
                poe2_api.dbgp("等待更多队友信息，当前: " .. received_count .. "/" .. expected_mission_count)
                poe2_api.dbgp("Check_Role(RUNNING1)")
                poe2_api.time_p("Check_Role",api_GetTickCount64() - current_time)
                return bret.RUNNING
            end
        end
    },

    -- 大号查询本地任务信息
    Query_Current_Task_Information_Local = {
        run = function(self, env)
            poe2_api.print_log("大号查询本地任务信息")
            poe2_api.dbgp("[Query_Current_Task_Information_Local]大号查询本地任务信息")
            local team_info_data = env.team_info_data
            local task_name = env.task_name
            local player_info = env.player_info
            local current_time = api_GetTickCount64()
            local team_info = env.team_info
            local user_config = env.user_config

            -- 获取队友位置
            local function party_pos(name)
                poe2_api.dbgp("[party_pos]获取队友位置:", name)
                for _, member in ipairs(team_info_data) do
                    if member["name_utf8"] == name then
                        return member["current_map_name_utf8"]
                    end
                end
                return nil
            end

            -- 判断队友当前位置
            local function party_member_map(map)
                poe2_api.dbgp("[party_member_map]判断队友当前位置:", map)
                for _, member in ipairs(team_info_data) do
                    if poe2_api.table_contains(map, member["current_map_name_utf8"]) and member["name_utf8"] ~= player_info.name_utf8 then
                        return true
                    end
                end
                return false
            end


            local task = poe2_api.get_task_info(main_task.tasks_data, task_name)
            if next(task) then
                if poe2_api.click_text_UI({ UI_info = env.UI_info, text = "respawn_at_checkpoint_button" }) and not env.special_relife_point then
                    poe2_api.click_keyboard("space")
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]RUNNING1")
                    return bret.RUNNING
                end

                if task.boss_name then
                    poe2_api.dbgp("检测到boss_name：", task.boss_name)
                    env.boss_name = task.boss_name
                else
                    env.boss_name = nil
                end

                if task.map_name then
                    poe2_api.dbgp("检测到map_name：", task.map_name)
                    env.map_name = task.map_name
                else
                    env.map_name = nil
                end

                if task.interaction_object then
                    poe2_api.dbgp("检测到interaction_object：", task.interaction_object)
                    env.interaction_object = task.interaction_object
                else
                    env.interaction_object = nil
                end

                if task.interaction_ui then
                    poe2_api.dbgp("检测到interaction_ui：", task.interaction_ui)
                    env.interaction_ui = task.interaction_ui
                else
                    env.interaction_ui = nil
                end

                if task.grid_x then
                    poe2_api.dbgp("检测到grid_x：", task.grid_x)
                    env.grid_x = task.grid_x
                else
                    env.grid_x = nil
                end

                if task.grid_y then
                    poe2_api.dbgp("检测到grid_y：", task.grid_y)
                    env.grid_y = task.grid_y
                else
                    env.grid_y = nil
                end

                if task.special_map_point then
                    poe2_api.dbgp("检测到special_map_point：", task.special_map_point)
                    env.special_map_point = task.special_map_point
                else
                    env.special_map_point = nil
                end

                if task.interaction_object_map_name then
                    poe2_api.dbgp("检测到interaction_object_map_name：", task.interaction_object_map_name)
                    env.interaction_object_map_name = task.interaction_object_map_name
                else
                    env.interaction_object_map_name = nil
                end

                if party_member_map({ "G3_6_2"}) and task.task_name == "與艾瓦對話" then
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]與艾瓦對話")
                    env.map_name = "G3_6_2"
                    env.interaction_object_map_name = { "艾瓦" }
                    env.interaction_object = { "艾瓦" }
                elseif party_member_map({ "G3_town"}) and task.task_name == "與艾瓦對話" then
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]與艾瓦對話")
                    env.map_name = "G3_town"
                    env.grid_x = 494
                    env.grid_y = 823
                elseif party_member_map({ "G3_6_1"}) and task.task_name == "召喚艾瓦詢問她的建議" then
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]召喚艾瓦詢問她的建議")
                    env.map_name = "G3_6_1"
                    env.interaction_object_map_name = {'艾瓦'}
                    env.interaction_object = {'召喚艾瓦', '艾瓦', '門'}
                elseif party_member_map({ "G4_10"}) and task.task_name == "尋找重鑄武器的方法" then
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]尋找重鑄武器的方法")
                    env.map_name = "G4_10"
                    env.interaction_object_map_name = {'G4_10_BossActive'}
                    env.boss_name={"烏托邦的第一使者．本篤特斯"}
                    env.interaction_object = nil
                elseif party_member_map({ "G3_6_2"}) and task.task_name == "召喚艾瓦，尋求她的意見" then
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]召喚艾瓦，尋求她的意見")
                    env.map_name = "G3_6_2"
                    env.interaction_object = { '中型靈魂核心', ' <questitem>{發電機}', '門' }
                elseif party_member_map({ "G2_3a"}) and task.task_name == "使用貧脊之地的地圖前往哈拉妮關口所在之處" then
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]G2_3a使用貧脊之地的地圖前往哈拉妮關口所在之處")
                    env.map_name = "G2_3a"
                    env.grid_x = 587
                    env.grid_y = 733
                    env.interaction_object = { "絲克瑪．阿薩拉" }
                elseif (party_member_map({ "G2_town"}) or player_info.current_map_name_utf8 =="G2_3a") and task.task_name == "返回車隊，與芮蘇討論封閉的古老關口" then
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]返回車隊，與芮蘇討論封閉的古老關口")
                    env.map_name = "G2_town"
                    env.interaction_object = { "芮蘇" }
                elseif party_member_map({ "P2_Town"}) and task.task_name == "與阿薩拉對話" then
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]與阿薩拉對話")
                    env.map_name = "P2_Town"
                    env.grid_y = 382
                    env.grid_x = 326
                    env.interaction_object = { "絲克瑪．阿薩拉" } 
                elseif party_member_map({ "P2_3"}) and task.task_name == "與阿薩拉對話" then
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]與阿薩拉對話")
                    env.map_name = "P2_3"
                    env.grid_y = nil
                    env.grid_x = nil
                    env.interaction_object = { "絲克瑪．阿薩拉" } 
                    env.interaction_object_map_name= {'賈多'}
                elseif party_member_map({  "G2_9_2" }) and task.boss_name and poe2_api.table_contains(task.boss_name, "憎惡者．賈嫚拉") then
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]憎惡者．賈嫚拉")
                    env.map_name = "G2_9_2"
                    env.boss_name = { "玷汙者托爾．谷爾" }
                    env.interaction_object = { "ToGuive", "卡洛翰的姐妹" }
                    env.interaction_object_map_name = { "TorGulActive" }
                elseif string.find(task.map_name,"G4_4_") and party_member_map({  "G4_4_2" }) and (not env.pick_up_fire or not env.pick_up_ice or not env.pick_up_Electricity) then
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]探索亡者之殿")
                    env.map_name = "G4_4_2"
                    env.interaction_object = { "祖靈" }
                elseif party_member_map({"Abyss_Hub"}) and task.task_name == "靈魂深井" then
                    poe2_api.print_log("任務完成") 
                    return bret.RUNNING
                end
                poe2_api.dbgp("[Query_Current_Task_Information_Local]SUCCESS1")
                poe2_api.time_p("[Query_Current_Task_Information_Local]",(api_GetTickCount64() - current_time))
                return bret.SUCCESS
            end
            if poe2_api.find_text({ UI_info = env.UI_info, text = "快行" }) then
                poe2_api.dbgp("[Query_Current_Task_Information_Local]SUCCESS2")
                return bret.SUCCESS
            end
            if not next(task) then
                local maps = env.map_name
                if maps then
                    if maps == "ctask" then
                        error("任务完成")
                    end
                    if maps == "G3_7" then
                        poe2_api.dbgp("检测到G3_7：")
                        if poe2_api.table_contains(player_info.current_map_name_utf8, { "G3_7", "G3_town", "G3_8" }) then
                            env.map_name = "G3_town"
                        end
                        env.interaction_object = { "召喚瑟維", "瑟維" }
                    end
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]SUCCESS3")
                    return bret.SUCCESS
                end
                if not maps then
                    poe2_api.dbgp("未识别到小号任务")
                    return bret.RUNNING
                end
            end
            poe2_api.dbgp("[Query_Current_Task_Information_Local]SUCCESS4")
            return bret.SUCCESS
        end
    },

    -- 小号查询任务信息
    Query_Current_Task_Information = {
        run = function(self, env)
            poe2_api.print_log("小号查询任务信息")
            local current_time = api_GetTickCount64()
            poe2_api.dbgp("[Query_Current_Task_Information]小号查询任务信息")
            if self.raw_time == nil then
                env.raw = {}
                self.raw_time = 0
                self.update = {}
                self.mas = nil
            end
            local range_info = env.range_info
            local player_info = env.player_info
            local waypoint = env.waypoint
            local bag_info = env.bag_info
            local current_map_info = env.current_map_info
            local team_info = env.team_info
            local config = env.user_config
            local max_time = 1000 * 60 * 5  -- 5分钟
            local function bag_object_sum(name)
                poe2_api.dbgp("[Query_Current_Task_Information]检测背包中的物品数量：")
                if not bag_info then
                    return false
                end
                local a = 0
                for _, obj in pairs(bag_info) do
                    if obj.baseType_utf8 == name then
                        a = a + 1
                    end
                end
                return a
            end
            local function mini_map_obj(name)
                poe2_api.dbgp("[Query_Current_Task_Information]检测地图上是否存在物体：", name)
                for _, item in ipairs(current_map_info) do
                    if item.name_utf8 == name and item.flagStatus1 == 1 then
                        return item  -- 直接返回第一个匹配项
                    end
                end
                return nil -- 无匹配时返回nil
            end

            local function deep_equal_unordered(a, b)
                poe2_api.dbgp("[Query_Current_Task_Information]两个table是否完全相同")
                if type(a) ~= type(b) then return false end
                if type(a) ~= "table" then return a == b end
                if #a ~= #b then return false end

                -- 统计 a 的元素（支持嵌套 table）
                local count = {}
                for _, v in ipairs(a) do
                    local key = type(v) == "table" and table.concat(v, ",") or tostring(v)
                    count[key] = (count[key] or 0) + 1
                end

                -- 检查 b 的元素
                for _, v in ipairs(b) do
                    local key = type(v) == "table" and table.concat(v, ",") or tostring(v)
                    if not count[key] then return false end
                    count[key] = count[key] - 1
                end

                return true
            end

            local function paste_text(text)
                poe2_api.click_keyboard("ctrl", 1)
                api_Sleep(200)
                poe2_api.click_keyboard("a", 0)
                api_Sleep(200)
                poe2_api.click_keyboard("ctrl", 2)
                api_Sleep(200)
                -- 然后输入百分号（Shift+5）
                poe2_api.click_keyboard("shift", 1)  -- 按下shift
                api_Sleep(200)
                poe2_api.click_keyboard("5", 0)      -- 按下5（配合shift产生%）
                api_Sleep(200)
                poe2_api.click_keyboard("shift", 2)  -- 释放shift
                api_Sleep(200)
                -- 先输入原有文本
                api_SetClipboard(text)
                api_Sleep(200)
                poe2_api.click_keyboard("ctrl", 1)
                api_Sleep(200)
                poe2_api.click_keyboard("v", 0)
                api_Sleep(200)
                poe2_api.click_keyboard("ctrl", 2)
                api_Sleep(200)
            end

            --- 根据主任务顺序获取任务状态
            -- @param api_result api_GetQuestList(0)返回的结果
            -- @param main_task_order 主任务顺序列表
            -- @return 按主任务顺序排列的未完成子任务详情列表（如果主任务完成则跳过）
            local function get_ordered_quest_status(api_result, main_task_order)
                -- 创建主任务到任务详情的映射
                local task_dict = {}
                for _, task in ipairs(api_result) do
                    local main_quest = task.MainQuestName
                    local sub_quest_state = task.SubQuestState
                    local description = task.Description
                    
                    if not main_quest then
                        poe2_api.dbgp("[Query_Current_Task_Information]获取不到任务信息")
                        return bret.RUNNING
                    end
                    
                    if not task_dict[main_quest] then
                        task_dict[main_quest] = {}
                    end
                    
                    -- 只添加未完成的任务
                    if sub_quest_state ~= "任務完成" and description ~= "" then
                        table.insert(task_dict[main_quest], {
                            state = sub_quest_state,
                            description = description
                        })
                    end
                end
                local quest_details = {}
                local seen_details = {} -- 用于快速查找重复项
                
                for _, main_task in ipairs(main_task_order) do
                    if task_dict[main_task] and #task_dict[main_task] > 0 then
                        -- 遍历该主任务的所有未完成子任务
                        for _, quest in ipairs(task_dict[main_task]) do
                            local detail = quest.description
                            -- 检查是否已经存在相同的详情且不为空
                            if detail and detail ~= "" and not seen_details[detail] then
                                table.insert(quest_details, detail)
                                seen_details[detail] = true -- 标记为已存在
                            end
                        end
                    end
                end
                
                return quest_details
            end
            poe2_api.printTable(api_GetQuestList(0))
            local main_task_info = get_ordered_quest_status(api_GetQuestList(0), my_game_info.mian_task)
            if next(main_task_info) then
                -- 处理main_task_info中的反斜杠和换行符
                for i = 1, #main_task_info do
                    if type(main_task_info[i]) == "string" then
                        -- 移除反斜杠和数字序列（如\13），换行符和所有空格
                        main_task_info[i] = main_task_info[i]:gsub("\\%d+", ""):gsub("\\", ""):gsub("[\n%s]", "")
                    end
                end
                poe2_api.printTable(main_task_info)
                if (poe2_api.table_contains(main_task_info, "追尋傳奇人物奧爾巴拉的腳步，重鑄瓦斯提里的戰角") or poe2_api.table_contains(main_task_info, "跟艾瓦談談發生的事")) and #(main_task_info) > 1 then
                    task = poe2_api.get_task_info(main_task.tasks_data,main_task_info[2]) 
                else
                    task = poe2_api.get_task_info(main_task.tasks_data,main_task_info[1])
                end
                poe2_api.printTable(task)
                if task and next(task) and task.task_name == "金司馬區" then
                    local rel_task = nil
                    for _, task in ipairs(api_GetQuestList(0)) do
                        if task.MainQuestName == "部落復仇" then
                            rel_task = true
                        end
                    end
                    if not rel_task then
                        task = nil
                    end
                end
                if task and next(task) and task.task_name == "與黑衣幽魂對話" then
                    local rel_task = true
                    for _, task in ipairs(api_GetQuestList(0)) do
                        if poe2_api.table_contains(task.MainQuestName , {"大搜索","奧瑞亞圍城戰"}) then
                            rel_task = false
                        end
                    end
                    if not rel_task then
                        task = poe2_api.get_task_info(main_task.tasks_data,"金司馬區") 
                    end
                end
            else
                task = nil
            end
            if poe2_api.find_text({UI_info = env.UI_info, text = "私訊", add_x = 265, min_x = 0, max_x = 400, click = 2, refresh = true}) then
                poe2_api.dbgp("[Query_Current_Task_Information]关闭私信")
                return bret.RUNNING
            end
            
            if task and next(task) then
                self.mas = nil
                env.special_relife_point = false
                env.task_name = task.task_name
                if poe2_api.click_text_UI({ UI_info = env.UI_info, text = "respawn_at_checkpoint_button" }) then
                    poe2_api.click_keyboard("space")
                    poe2_api.dbgp("[Query_Current_Task_Information]RUNNING1")
                    return bret.RUNNING
                end
                if task.boss_name then
                    poe2_api.dbgp("检测到boss_name：", task.boss_name)
                    env.boss_name = task.boss_name
                else
                    env.boss_name = nil
                end

                if task.map_name then
                    poe2_api.dbgp("检测到map_name：", task.map_name)
                    env.map_name = task.map_name
                else
                    env.map_name = nil
                end

                if task.interaction_object then
                    poe2_api.dbgp("检测到interaction_object：", task.interaction_object)
                    env.interaction_object = task.interaction_object
                else
                    env.interaction_object = nil
                end

                if task.interaction_ui then
                    poe2_api.dbgp("检测到interaction_ui：", task.interaction_ui)
                    env.interaction_ui = task.interaction_ui
                else
                    env.interaction_ui = nil
                end

                if task.grid_x then
                    poe2_api.dbgp("检测到grid_x：", task.grid_x)
                    env.grid_x = task.grid_x
                else
                    env.grid_x = nil
                end

                if task.grid_y then
                    poe2_api.dbgp("检测到grid_y：", task.grid_y)
                    env.grid_y = task.grid_y
                else
                    env.grid_y = nil
                end

                if task.special_map_point then
                    poe2_api.dbgp("检测到special_map_point：", task.special_map_point)
                    env.special_map_point = task.special_map_point
                else
                    env.special_map_point = nil
                end

                if task.interaction_object_map_name then
                    poe2_api.dbgp("检测到interaction_object_map_name：", task.interaction_object_map_name)
                    env.interaction_object_map_name = task.interaction_object_map_name
                else
                    env.interaction_object_map_name = nil
                end

                if not poe2_api.table_contains(player_info.current_map_name_utf8, { "G3_town" }) and task.task_name == "回到過去，進入奧札爾" then
                    poe2_api.dbgp("[Query_Current_Task_Information]回到過去，進入奧札爾")
                    env.map_name = "G3_town"
                    task.task_name = "高地神塔營地"
                    env.task_name = task.task_name
                elseif player_info.current_map_name_utf8 ==  "G3_town" and task.task_name == "與艾瓦對話" then
                    poe2_api.dbgp("[Query_Current_Task_Information]與艾瓦對話")
                    env.map_name = "G3_town"
                    env.interaction_object_map_name = { "艾瓦" }
                    env.grid_x = 494
                    env.grid_y = 823
                    env.interaction_object = { "艾瓦" }
                elseif player_info.current_map_name_utf8 == "P2_Town" and task.task_name == "與阿薩拉對話" then
                    poe2_api.dbgp("[Query_Current_Task_Information]與阿薩拉對話")
                    env.map_name = "P2_Town"
                    env.grid_y = 382
                    env.grid_x = 326
                    env.interaction_object = { "絲克瑪．阿薩拉" } 
                elseif player_info.current_map_name_utf8 == "P2_3" and task.task_name == "與阿薩拉對話" then
                    poe2_api.dbgp("[Query_Current_Task_Information]與阿薩拉對話")
                    env.map_name = "P2_3"
                    env.grid_y = nil
                    env.grid_x = nil
                    env.interaction_object = { "絲克瑪．阿薩拉" } 
                    env.interaction_object_map_name= {'賈多'}
                elseif player_info.current_map_name_utf8 == "P3_7" and task.task_name == "與多里亞尼對話" then
                    poe2_api.dbgp("[Query_Current_Task_Information]與多里亞尼對話")
                    env.map_name = "P3_7"
                    env.grid_y = nil
                    env.grid_x = nil
                    env.interaction_object = { "多里亞尼" } 
                    env.interaction_object_map_name= {'多里亞尼'}
                elseif poe2_api.table_contains(player_info.current_map_name_utf8, { "G3_6_2" }) and task.task_name == "與艾瓦對話" then
                    poe2_api.dbgp("[Query_Current_Task_Information]與艾瓦對話")
                    env.map_name = "G3_6_2"
                    env.interaction_object_map_name = { "艾瓦" }
                    env.interaction_object = { "艾瓦" }
                elseif string.find(task.map_name,"G4_4_") and poe2_api.table_contains(player_info.current_map_name_utf8, { "G4_4_2" }) and (not env.pick_up_fire or not env.pick_up_ice or not env.pick_up_Electricity) then
                    poe2_api.dbgp("[Query_Current_Task_Information]探索亡者之殿")
                    task.task_name = "探索亡者之殿"
                    env.map_name = "G4_4_2"
                    env.interaction_object = { "祖靈" }
                elseif poe2_api.table_contains(player_info.current_map_name_utf8, { "G3_6_2" }) and task.task_name == "召喚艾瓦，尋求她的意見" then
                    poe2_api.dbgp("[Query_Current_Task_Information]召喚艾瓦，尋求她的意見")
                    env.map_name = "G3_6_2"
                    env.interaction_object = { '中型靈魂核心', ' <questitem>{發電機}', '門' }
                elseif player_info.current_map_name_utf8 == "G3_6_1" and task.task_name == "召喚艾瓦詢問她的建議" then
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]召喚艾瓦詢問她的建議")
                    env.map_name = "G3_6_1"
                    env.interaction_object_map_name = {'艾瓦'}
                    env.interaction_object = {'召喚艾瓦', '艾瓦', '門'}
                elseif player_info.current_map_name_utf8 == "G4_10" and task.task_name == "尋找重鑄武器的方法" then
                    poe2_api.dbgp("[Query_Current_Task_Information_Local]尋找重鑄武器的方法")
                    env.map_name = "G4_10"
                    env.interaction_object_map_name = {'G4_10_BossActive'}
                    env.boss_name={"烏托邦的第一使者．本篤特斯"}
                    env.interaction_object = nil
                elseif player_info.current_map_name_utf8 == "G2_3a" and task.task_name == "使用貧脊之地的地圖前往哈拉妮關口所在之處" then
                    poe2_api.dbgp("[Query_Current_Task_Information]G2_3a使用貧脊之地的地圖前往哈拉妮關口所在之處")
                    env.map_name = "G2_3a"
                    env.grid_x = 587
                    env.grid_y = 733
                    env.interaction_object = { "絲克瑪．阿薩拉" }
                elseif poe2_api.table_contains(player_info.current_map_name_utf8, { "G2_town"}) and task.task_name == "返回車隊，與芮蘇討論封閉的古老關口" then
                    poe2_api.dbgp("[Query_Current_Task_Information]返回車隊，與芮蘇討論封閉的古老關口")
                    env.map_name = "G2_town"
                    env.interaction_object = { "芮蘇" }
                elseif poe2_api.table_contains(player_info.current_map_name_utf8, {  "G2_9_2" }) then
                    poe2_api.dbgp("[Query_Current_Task_Information]前往戴斯哈尖塔")
                    local sister = poe2_api.get_sorted_obj("卡洛翰的姐妹", range_info, player_info)
                    if ((task.boss_name and poe2_api.table_contains('憎惡者．賈嫚拉', task.boss_name))) or not mini_map_obj('SacredSpiresShrineLandmarkInactive') or (sister and #sister > 0 and sister[1].stateMachineList and sister[1].stateMachineList.active == 0) then
                        env.map_name = "G2_9_2"
                        task.task_name = "戴斯哈尖塔"
                        env.task_name = task.task_name
                        env.boss_name = { "玷汙者托爾．谷爾" }
                        env.interaction_object = { "ToGuive", "卡洛翰的姐妹" }
                        env.interaction_object_map_name = { "TorGulActive" }
                    end
                elseif poe2_api.table_contains(player_info.current_map_name_utf8, { "G1_12" }) and not poe2_api.check_item_in_inventory("寶石花顱骨", bag_info) then
                    poe2_api.dbgp("[Query_Current_Task_Information]收集寶石花顱骨")
                    task.task_name = "擊敗迷霧之王"
                    env.task_name = task.task_name
                    env.map_name = "G1_12"
                    env.boss_name = { "迷霧之王" }
                    env.interaction_object = { " 祭祀神壇", "寶石花顱骨" }
                elseif poe2_api.table_contains(player_info.current_map_name_utf8, { "G2_4_1" }) and not poe2_api.check_item_in_inventory("卡巴拉部落聖物", bag_info) then
                    poe2_api.dbgp("[Query_Current_Task_Information]收集卡巴拉部落聖物 - 1")
                    task.task_name = "凱斯城"
                    env.task_name = task.task_name
                    env.map_name = "G2_4_1"
                    env.boss_name = { "異界．干擾女王．卡巴拉" }
                    env.interaction_object = { "卡巴拉部落聖物" }
                    env.interaction_object_map_name = nil
                elseif poe2_api.table_contains(player_info.current_map_name_utf8, { "G2_5_2" }) and not poe2_api.check_item_in_inventory("太陽部落聖物", bag_info) then
                    poe2_api.dbgp("[Query_Current_Task_Information]收集太陽部落聖物 - 1")
                    task.task_name = "骨坑"
                    env.task_name = task.task_name
                    env.map_name = "G2_5_2"
                    env.interaction_object = { "太陽部落聖物" }
                    env.interaction_object_map_name = nil
                elseif poe2_api.table_contains(player_info.current_map_name_utf8, { "G3_14" }) and not poe2_api.check_item_in_inventory("犧牲之心", bag_info) then
                    poe2_api.dbgp("[Query_Current_Task_Information]收集犧牲之心 - 1")
                    task.task_name = "奧札爾"
                    env.task_name = task.task_name
                    env.map_name = "G3_14"
                    env.interaction_object = { "犧牲之心" }
                    env.interaction_object_map_name = nil
                elseif poe2_api.table_contains(player_info.current_map_name_utf8, { "G3_6_1" }) and env.map_name == "G3_6_1"  and not poe2_api.check_item_in_inventory("火焰核心", bag_info) then
                    poe2_api.dbgp("[Query_Current_Task_Information]收集-火焰核心 - 1")
                    task.task_name = "在吉卡尼的機械迷城尋找小型靈魂核心以開啟大門"
                    env.task_name = task.task_name
                    env.map_name = "G3_6_1"
                    env.boss_name = { "遺忘的黑顎" }
                    env.interaction_object ={'門', '小型靈魂核心', '石陣祭壇',"火焰核心"}
                    env.interaction_object_map_name = {"BlackjawBossInactive"}
                elseif poe2_api.table_contains(player_info.current_map_name_utf8, { "G3_7" }) and not poe2_api.check_item_in_inventory("傑洛特顱骨", bag_info) then
                    poe2_api.dbgp("[Query_Current_Task_Information]收集傑洛特顱骨")
                    task.task_name = "阿札克泥沼"
                    env.task_name = task.task_name
                    env.map_name = "G3_7"
                    env.interaction_object = { "傑洛特顱骨" }
                    env.interaction_object_map_name = nil
                elseif poe2_api.table_contains(player_info.current_map_name_utf8, { "G4_3_1" }) and not poe2_api.check_item_in_inventory("鯊魚鰭", bag_info) then
                    poe2_api.dbgp("[Query_Current_Task_Information]收集-鯊魚鰭")
                    task.task_name = "擊敗大白鯊"
                    env.task_name = task.task_name
                    env.map_name = "G4_3_1"
                    env.interaction_object = { "鯊魚鰭" }
                    env.interaction_object_map_name = {"G4_3_1_BossActive"}
                elseif player_info.current_map_name_utf8 == "G2_1" and env.map_name ~="G2_1" and string.find(env.map_name, "G2") then
                    task.task_name = "進入阿杜拉車隊"
                    env.task_name = task.task_name
                    env.map_name = "G2_1"
                    env.interaction_object = {'阿杜拉車隊'}
                    env.interaction_object_map_name = {'G2_town'}
                elseif player_info.current_map_name_utf8 == "G3_1" and env.map_name ~="G3_1" and string.find(env.map_name, "G3") then
                    task.task_name = "高地神塔營地"
                    env.task_name = task.task_name
                    env.map_name = "G3_town"
                end
                if poe2_api.get_team_info(team_info, config, player_info, 1) ~= "大號名" then
                    poe2_api.dbgp("[Query_Current_Task_Information]有task发送任务信息")
                    if not poe2_api.table_contains(player_info.current_map_name_utf8, { "G1_1" }) and not poe2_api.find_text({ UI_info = env.UI_info, text = "抵達皆伐" }) then
                        if not next(env.raw) or (self.raw_time ~= 0 and api_GetTickCount64() - self.raw_time > max_time) then
                            -- 发送任务信息
                            local task_text = "task_name=" .. task.task_name .. ",task_index=" .. task.index ..",map_name=" .. env.map_name
                            poe2_api.click_keyboard("enter")
                            api_Sleep(200)
                            poe2_api.click_keyboard("backspace")
                            api_Sleep(500)
                            paste_text(task_text)
                            api_Sleep(500)
                            if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                return bret.RUNNING
                            end
                            poe2_api.click_keyboard("enter")
                            api_Sleep(200)
                            self.raw_time = api_GetTickCount64()
                            env.raw = { task.task_name, task.index }
                        end
                        env.update = { task.task_name, task.index }
                        if not deep_equal_unordered(env.raw, env.update) then
                            env.raw = {}
                            poe2_api.dbgp("[Query_Current_Task_Information]RUNNING2")
                            return bret.RUNNING
                        end
                    end
                end
            else
                poe2_api.dbgp("[Query_Current_Task_Information]无task发送任务信息")
                env.task_name = nil
                env.map_name = nil
                env.interaction_object = nil
                env.interaction_object_map_name = nil
                self.mas = nil
                if poe2_api.click_text_UI({ UI_info = env.UI_info, text = "respawn_at_checkpoint_button" }) then
                    poe2_api.click_keyboard("space")
                    poe2_api.dbgp("[Query_Current_Task_Information]RUNNING3")
                    return bret.RUNNING
                end
                if not self.mas then
                    self.mas, finished_tasks = poe2_api.check_task_map_without()
                    if not self.mas and not next(finished_tasks) then
                        poe2_api.print_log("没有任务信息")
                        poe2_api.dbgp("[Query_Current_Task_Information]RUNNING4")
                        return bret.RUNNING
                    end
                end
                if player_info.level < 2 or player_info.current_map_name_utf8 == "G1_1" then
                    poe2_api.dbgp("[Query_Current_Task_Information]新手剧情")
                    env.task_name = "與受傷的居民交談"
                    env.map_name = "G1_1"
                    env.interaction_object = { "受傷的男人" }
                    poe2_api.dbgp("[Query_Current_Task_Information]SUCCESS1")
                    poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                    return bret.SUCCESS
                else
                    if self.mas == "G2_town" then
                        poe2_api.dbgp("[Query_Current_Task_Information]获取G2_town地图任务信息")
                        
                        if not poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖",refresh = true}) then
                            poe2_api.click_keyboard("u")
                        end
                        api_Sleep(200)
                        env.waypoint = api_GetTeleportationPoint()
                        api_Sleep(200)
                        poe2_api.click_keyboard("u")
                        if poe2_api.Waypoint_is_open("G3_town", waypoint) then
                            poe2_api.dbgp("[Query_Current_Task_Information]RUNNING5")
                            return bret.RUNNING
                        end
                        if poe2_api.get_team_info(team_info, config, player_info, 2) ~= "大號名" then
                            local task_text = "task_name=" .. "返回阿杜拉車隊，並與札卡交談" .. ",task_index=" .. 83 ..",map_name=" .. self.mas
                            poe2_api.click_keyboard("enter")
                            api_Sleep(500)
                            paste_text(task_text)
                            api_Sleep(500)
                            if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                return bret.RUNNING
                            end
                            poe2_api.click_keyboard("enter")
                            api_Sleep(500)
                            env.map_name = self.mas
                            poe2_api.dbgp("[Query_Current_Task_Information]SUCCESS2")
                            poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                            return bret.SUCCESS
                        end
                    elseif self.mas == "G3_town" then
                        poe2_api.dbgp("[Query_Current_Task_Information]获取G3_town地图任务信息")
                        if poe2_api.get_team_info(team_info, config, player_info, 2) ~= "大號名" then
                            if not next(env.raw) or (self.raw_time ~= 0 and api_GetTickCount64() - self.raw_time > max_time) then
                                -- 发送任务信息
                                local task_text = "task_name=" .. "高地神塔營地" .. ",task_index=" .. 179 ..",map_name=" .. self.mas
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                paste_text(task_text)
                                api_Sleep(500)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                    poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                    return bret.RUNNING
                                end
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                self.raw_time = api_GetTickCount64()
                                env.raw = { "高地神塔營地", 179 }
                            end
                            env.update = { "高地神塔營地", 179 }
                            if not deep_equal_unordered(env.raw, env.update) then
                                env.raw = {}
                                poe2_api.dbgp("[Query_Current_Task_Information]RUNNING2")
                                return bret.RUNNING
                            end
                            env.map_name = self.mas
                            poe2_api.dbgp("[Query_Current_Task_Information]SUCCESS3")
                            poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                            return bret.SUCCESS
                        end
                    elseif self.mas == "G1_12" then
                        poe2_api.dbgp("[Query_Current_Task_Information]获取G1_12地图任务信息")
                        if poe2_api.get_team_info(team_info, config, player_info, 2) ~= "大號名" then
                            if not next(env.raw) or (self.raw_time ~= 0 and api_GetTickCount64() - self.raw_time > max_time) then
                                -- 发送任务信息
                                local task_text = "task_name=" .. "尋找祭祀神壇並淨化它們" .. ",task_index=" .. 80 ..",map_name=" .. self.mas
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                paste_text(task_text)
                                api_Sleep(500)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                    poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                    return bret.RUNNING
                                end
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                self.raw_time = api_GetTickCount64()
                                env.raw = { "尋找祭祀神壇並淨化它們", 80 }
                            end
                            env.update = { "尋找祭祀神壇並淨化它們", 80 }
                            if not deep_equal_unordered(env.raw, env.update) then
                                env.raw = {}
                                poe2_api.dbgp("[Query_Current_Task_Information]RUNNING2")
                                return bret.RUNNING
                            end
                            env.map_name = self.mas
                            poe2_api.dbgp("[Query_Current_Task_Information]SUCCESS4")
                            poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                            return bret.SUCCESS
                        end
                    elseif self.mas == "G3_7" then
                        poe2_api.dbgp("[Query_Current_Task_Information]获取G3_7地图任务信息")
                        if poe2_api.table_contains(player_info.current_map_name_utf8, { "G3_town", "G3_7", "G3_8" }) then
                            env.grid_x = nil
                            env.grid_y = nil
                            env.interaction_object = { "召喚瑟維", "瑟維" }
                            if poe2_api.get_team_info(team_info, config, player_info, 2) ~= "大號名" then
                                if not next(env.raw) or (self.raw_time ~= 0 and api_GetTickCount64() - self.raw_time > max_time) then
                                    -- 发送任务信息
                                    local task_text = "task_name=" .. "阿札克泥沼" .. ",task_index=" .. 250 ..",map_name=" .. self.mas
                                    poe2_api.click_keyboard("enter")
                                    api_Sleep(500)
                                    paste_text(task_text)
                                    api_Sleep(500)
                                    if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                        poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                        return bret.RUNNING
                                    end
                                    poe2_api.click_keyboard("enter")
                                    api_Sleep(500)
                                    self.raw_time = api_GetTickCount64()
                                    env.raw = { "阿札克泥沼", 250 }
                                end
                                env.update = { "阿札克泥沼", 250 }
                                if not deep_equal_unordered(env.raw, env.update) then
                                    env.raw = {}
                                    poe2_api.dbgp("[Query_Current_Task_Information]RUNNING2")
                                    return bret.RUNNING
                                end
                                env.map_name = self.mas
                                poe2_api.dbgp("[Query_Current_Task_Information]SUCCESS5")
                                poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                                return bret.SUCCESS
                            end
                        else
                            poe2_api.dbgp("[Query_Current_Task_Information]前往G3_7,先前往G3_town地图")
                            if poe2_api.get_team_info(team_info, config, player_info, 2) ~= "大號名" then
                                if not next(env.raw) or (self.raw_time ~= 0 and api_GetTickCount64() - self.raw_time > max_time) then
                                    -- 发送任务信息
                                    local task_text = "task_name=" .. "高地神塔營地" .. ",task_index=" .. 0 ..",map_name=" .. "G3_town"
                                    poe2_api.click_keyboard("enter")
                                    api_Sleep(500)
                                    paste_text(task_text)
                                    api_Sleep(500)
                                    if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                        poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                        return bret.RUNNING
                                    end
                                    poe2_api.click_keyboard("enter")
                                    api_Sleep(500)
                                    self.raw_time = api_GetTickCount64()
                                    env.raw = { "高地神塔營地", 0 }
                                end
                                env.update = { "高地神塔營地", 0 }
                                if not deep_equal_unordered(env.raw, env.update) then
                                    env.raw = {}
                                    poe2_api.dbgp("[Query_Current_Task_Information]RUNNING2")
                                    return bret.RUNNING
                                end
                                env.map_name = "G3_town"
                                poe2_api.dbgp("[Query_Current_Task_Information]SUCCESS6")
                                poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                                return bret.SUCCESS
                            end
                        end
                    elseif self.mas == "G4_1_1" then
                        poe2_api.dbgp("[Query_Current_Task_Information]获取G4_1_1地图任务信息")
                        if poe2_api.get_team_info(team_info, config, player_info, 2) ~= "大號名" then
                            if not next(env.raw) or (self.raw_time ~= 0 and api_GetTickCount64() - self.raw_time > max_time) then
                                -- 发送任务信息
                                local task_text = "task_name=" .. "金氏島" .. ",task_index=" .. 278 ..",map_name=" .. self.mas
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                paste_text(task_text)
                                api_Sleep(500)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                    poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                    return bret.RUNNING
                                end
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                self.raw_time = api_GetTickCount64()
                                env.raw = { "金氏島", 278 }
                            end
                            env.update = { "金氏島", 278 }
                            if not deep_equal_unordered(env.raw, env.update) then
                                env.raw = {}
                                poe2_api.dbgp("[Query_Current_Task_Information]金氏島RUNNING2")
                                return bret.RUNNING
                            end
                            env.map_name = self.mas
                            poe2_api.dbgp("[Query_Current_Task_Information]金氏島SUCCESS3")
                            poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                            return bret.SUCCESS
                        end
                    elseif self.mas == "G4_4_1" then
                        poe2_api.dbgp("[Query_Current_Task_Information]获取G4_4_1地图任务信息")
                        if poe2_api.get_team_info(team_info, config, player_info, 2) ~= "大號名" then
                            if not next(env.raw) or (self.raw_time ~= 0 and api_GetTickCount64() - self.raw_time > max_time) then
                                -- 发送任务信息
                                local task_text = "task_name=" .. "悉妮蔻拉之眼" .. ",task_index=" .. 278 ..",map_name=" .. self.mas
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                paste_text(task_text)
                                api_Sleep(500)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                    poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                    return bret.RUNNING
                                end
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                self.raw_time = api_GetTickCount64()
                                env.raw = { "悉妮蔻拉之眼", 278 }
                            end
                            env.update = { "悉妮蔻拉之眼", 278 }
                            if not deep_equal_unordered(env.raw, env.update) then
                                env.raw = {}
                                poe2_api.dbgp("[Query_Current_Task_Information]悉妮蔻拉之眼-RUNNING2")
                                return bret.RUNNING
                            end
                            env.map_name = self.mas
                            poe2_api.dbgp("[Query_Current_Task_Information]-悉妮蔻拉之眼-SUCCESS3")
                            poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                            return bret.SUCCESS
                        end
                    elseif self.mas == "G4_3_1" then
                        poe2_api.dbgp("[Query_Current_Task_Information]获取-G4_3_1-地图任务信息")
                        if poe2_api.get_team_info(team_info, config, player_info, 2) ~= "大號名" then
                            if not next(env.raw) or (self.raw_time ~= 0 and api_GetTickCount64() - self.raw_time > max_time) then
                                -- 发送任务信息
                                local task_text = "task_name=" .. "瓦卡帕努島" .. ",task_index=" .. 308 ..",map_name=" .. self.mas
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                paste_text(task_text)
                                api_Sleep(500)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                    poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                    return bret.RUNNING
                                end
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                self.raw_time = api_GetTickCount64()
                                env.raw = { "瓦卡帕努島", 308 }
                            end
                            env.update = { "瓦卡帕努島", 308 }
                            if not deep_equal_unordered(env.raw, env.update) then
                                env.raw = {}
                                poe2_api.dbgp("[Query_Current_Task_Information]瓦卡帕努島-RUNNING2")
                                return bret.RUNNING
                            end
                            env.map_name = self.mas
                            poe2_api.dbgp("[Query_Current_Task_Information]-瓦卡帕努島-SUCCESS3")
                            poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                            return bret.SUCCESS
                        end
                    elseif self.mas == "G4_5_1" then
                        poe2_api.dbgp("[Query_Current_Task_Information]获取-G4_5_1-地图任务信息")
                        if poe2_api.get_team_info(team_info, config, player_info, 2) ~= "大號名" then
                            if not next(env.raw) or (self.raw_time ~= 0 and api_GetTickCount64() - self.raw_time > max_time) then
                                -- 发送任务信息
                                local task_text = "task_name=" .. "廢棄監獄" .. ",task_index=" .. 314 ..",map_name=" .. self.mas
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                paste_text(task_text)
                                api_Sleep(500)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                    poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                    return bret.RUNNING
                                end
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                self.raw_time = api_GetTickCount64()
                                env.raw = { "廢棄監獄", 314 }
                            end
                            env.update = { "廢棄監獄", 314 }
                            if not deep_equal_unordered(env.raw, env.update) then
                                env.raw = {}
                                poe2_api.dbgp("[Query_Current_Task_Information]廢棄監獄-RUNNING2")
                                return bret.RUNNING
                            end
                            env.map_name = self.mas
                            poe2_api.dbgp("[Query_Current_Task_Information]-廢棄監獄-SUCCESS3")
                            poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                            return bret.SUCCESS
                        end
                    elseif self.mas == "G4_7" then
                        poe2_api.dbgp("[Query_Current_Task_Information]获取-G4_7-地图任务信息")
                        if poe2_api.get_team_info(team_info, config, player_info, 2) ~= "大號名" then
                            if not next(env.raw) or (self.raw_time ~= 0 and api_GetTickCount64() - self.raw_time > max_time) then
                                -- 发送任务信息
                                local task_text = "task_name=" .. "伯勞鳥之島" .. ",task_index=" .. 320 ..",map_name=" .. self.mas
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                paste_text(task_text)
                                api_Sleep(500)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                    poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                    return bret.RUNNING
                                end
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                self.raw_time = api_GetTickCount64()
                                env.raw = { "伯勞鳥之島", 320 }
                            end
                            env.update = { "伯勞鳥之島", 320 }
                            if not deep_equal_unordered(env.raw, env.update) then
                                env.raw = {}
                                poe2_api.dbgp("[Query_Current_Task_Information]伯勞鳥之島-RUNNING2")
                                return bret.RUNNING
                            end
                            env.map_name = self.mas
                            poe2_api.dbgp("[Query_Current_Task_Information]-伯勞鳥之島-SUCCESS3")
                            poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                            return bret.SUCCESS
                        end
                    elseif self.mas == "G4_town" then
                        local area_name = "金司馬區"
                        if string.find(player_info.current_map_name_utf8 ,"P1") then
                            self.mas = "P1_Town" 
                            area_name = "庇護所"
                        end
                        poe2_api.dbgp("[Query_Current_Task_Information]获取-G4_town-地图任务信息")
                        if poe2_api.get_team_info(team_info, config, player_info, 2) ~= "大號名" then
                            if not next(env.raw) or (self.raw_time ~= 0 and api_GetTickCount64() - self.raw_time > max_time) then
                                -- 发送任务信息
                                local task_text = "task_name=" .. area_name .. ",task_index=" .. 266 ..",map_name=" .. self.mas
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                paste_text(task_text)
                                api_Sleep(500)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                    poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                    return bret.RUNNING
                                end
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                self.raw_time = api_GetTickCount64()
                                env.raw = { "金司馬區", 266 }
                            end
                            env.update = { "金司馬區", 266 }
                            if not deep_equal_unordered(env.raw, env.update) then
                                env.raw = {}
                                poe2_api.dbgp("[Query_Current_Task_Information]金司馬區-RUNNING2")
                                return bret.RUNNING
                            end
                            env.map_name = self.mas
                            poe2_api.dbgp("[Query_Current_Task_Information]-金司馬區-SUCCESS3")
                            poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                            return bret.SUCCESS
                        end
                    elseif self.mas == "P1_Town" then
                        local area_name = "庇護所"
                        if string.find(player_info.current_map_name_utf8 ,"P2") then
                            self.mas = "P2_Town" 
                            area_name = "卡里市集"
                        end
                        poe2_api.dbgp("[Query_Current_Task_Information]获取-P2_Town-地图任务信息")
                        if poe2_api.get_team_info(team_info, config, player_info, 2) ~= "大號名" then
                            if not next(env.raw) or (self.raw_time ~= 0 and api_GetTickCount64() - self.raw_time > max_time) then
                                -- 发送任务信息
                                local task_text = "task_name=" .. area_name .. ",task_index=" .. 370 ..",map_name=" .. self.mas
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                paste_text(task_text)
                                api_Sleep(500)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                    poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                    return bret.RUNNING
                                end
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                self.raw_time = api_GetTickCount64()
                                env.raw = { "卡里市集", 370 }
                            end
                            env.update = { "卡里市集", 370 }
                            if not deep_equal_unordered(env.raw, env.update) then
                                env.raw = {}
                                poe2_api.dbgp("[Query_Current_Task_Information]卡里市集-RUNNING2")
                                return bret.RUNNING
                            end
                            env.map_name = self.mas
                            poe2_api.dbgp("[Query_Current_Task_Information]-卡里市集-SUCCESS3")
                            poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                            return bret.SUCCESS
                        end
                    elseif self.mas == "P3_4" then
                        poe2_api.dbgp("[Query_Current_Task_Information]获取-P3_4-地图任务信息")
                        if poe2_api.get_team_info(team_info, config, player_info, 2) ~= "大號名" then
                            if not next(env.raw) or (self.raw_time ~= 0 and api_GetTickCount64() - self.raw_time > max_time) then
                                -- 发送任务信息
                                local task_text = "task_name=" .. "找到狂嗥洞穴" .. ",task_index=" .. 417 ..",map_name=" .. self.mas
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                paste_text(task_text)
                                api_Sleep(500)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                    poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                    return bret.RUNNING
                                end
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                self.raw_time = api_GetTickCount64()
                                env.raw = { "狂嗥洞穴", 417 }
                            end
                            env.update = { "狂嗥洞穴", 417 }
                            if not deep_equal_unordered(env.raw, env.update) then
                                env.raw = {}
                                poe2_api.dbgp("[Query_Current_Task_Information]狂嗥洞穴-RUNNING2")
                                return bret.RUNNING
                            end
                            env.map_name = self.mas
                            poe2_api.dbgp("[Query_Current_Task_Information]-狂嗥洞穴-SUCCESS3")
                            poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                            return bret.SUCCESS
                        end
                    elseif self.mas == "G2_Abyss_Hub" then
                        poe2_api.dbgp("[Query_Current_Task_Information]获取-G2_Abyss_Hub-地图任务信息")
                        if poe2_api.get_team_info(team_info, config, player_info, 2) ~= "大號名" then
                            if not next(env.raw) or (self.raw_time ~= 0 and api_GetTickCount64() - self.raw_time > max_time) then
                                -- 发送任务信息
                                local task_text = "task_name=" .. "靈魂深井" .. ",task_index=" .. 425 ..",map_name=" .. self.mas
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                paste_text(task_text)
                                api_Sleep(500)
                                if not poe2_api.find_text({UI_info = env.UI_info, text = "私訊", min_x = 0, max_x = 400, refresh = true}) then
                                    poe2_api.dbgp("[Query_Current_Task_Information]私訊")
                                    return bret.RUNNING
                                end
                                poe2_api.click_keyboard("enter")
                                api_Sleep(500)
                                self.raw_time = api_GetTickCount64()
                                env.raw = { "靈魂深井", 425 }
                            end
                            env.update = { "靈魂深井", 425 }
                            if not deep_equal_unordered(env.raw, env.update) then
                                env.raw = {}
                                poe2_api.dbgp("[Query_Current_Task_Information]靈魂深井-RUNNING2")
                                return bret.RUNNING
                            end
                            env.map_name = self.mas
                            poe2_api.dbgp("[Query_Current_Task_Information]-靈魂深井-SUCCESS3")
                            poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
                            return bret.SUCCESS
                        end
                    end
                end
                self.mas = nil
                poe2_api.dbgp("[Query_Current_Task_Information]RUNNING10")
                return bret.RUNNING
            end
            poe2_api.time_p("[Query_Current_Task_Information]",(api_GetTickCount64() - current_time))
            return bret.SUCCESS
        end
    },

    -- 是否队伍中存在死亡队友
    Is_Exception_Team = {
        run = function(self, env)
            poe2_api.print_log("判断是否队伍中存在死亡队友...")
            poe2_api.dbgp("=== 开始判断是否队伍中存在死亡队友 ===")
            if self.bool == nil then
                self.bool = false
            end
            local team_info_data = env.team_info_data
            local range_info = env.range_info
            local player_info = env.player_info
            local boss_name = env.boss_name
            local team_info = env.team_info
            local user_config = env.user_config
            local task_name = env.task_name
            local function is_death(range_info, team_info)
                poe2_api.dbgp("[Is_Exception_Team]判断是否存在死亡队友...")
                -- 将 team_info 转换为字典，以 name_utf8 作为键
                local team_dict = {}
                for _, member in ipairs(team_info) do
                    team_dict[member.name_utf8] = member
                end

                -- 遍历 range_info，查找生命值为 0 的友好成员
                for _, i in ipairs(range_info) do
                    if i.is_friendly and i.life == 0 and team_dict[i.name_utf8] then
                        return i
                    end
                end

                return false
            end

            local function is_monster(range_info, mate)
                poe2_api.dbgp("[Is_Exception_Team]判断死亡队友是否存在撕裂者...")
                local mx, my = mate.grid_x, mate.grid_y
                -- 查找符合条件的怪物
                for _, i in ipairs(range_info) do
                    if not i.is_friendly and i.life > 1 and i.name_utf8 ~= "" and i.isActive
                        and poe2_api.table_contains(i.name_utf8 ,{"撕裂者","白之亞瑪","擊殺死亡之謠．黛莫拉","酋長．塔瓦凱","墮落者．塔瓦凱","被吞噬者．塔瓦凱"})
                        and poe2_api.get_point_distance(mate.grid_x, mate.grid_y, i.grid_x, i.grid_y) < 200 then
                        return i
                    end
                    if i.name_utf8 == "迷霧之刃．希奧拉" and i.life > 1 and i.stateMachineList and i.stateMachineList["active"] == 1 then
                        return i
                    end
                end
                return false
            end

            local function check_pos_dis(names, range_info, player_info)
                poe2_api.dbgp("[Is_Exception_Team]判断指定名称与主角的距离")
                if range_info ~= nil then
                    for _, point in ipairs(range_info) do
                        if point.name_utf8 == names then
                            local l = poe2_api.point_distance(point.grid_x, point.grid_y, player_info)
                            return l
                        end
                    end
                end
                return nil
            end
            if task_name == "伯勞鳥之島" then
                poe2_api.dbgp("特殊任務不復活")
                return bret.SUCCESS
            end
            if not next(team_info_data) or not next(range_info) then
                poe2_api.dbgp("[Is_Exception_Team]没组队")
                env.monster_info = nil
                self.bool = false
                env.relife_stuck_monsters = {}
                return bret.SUCCESS
            end
            local mate = is_death(range_info, team_info_data)
            -- poe2_api.printTable(mate)
            if not mate then
                poe2_api.dbgp("[Is_Exception_Team]不存在死亡队友")
                self.bool = false
                env.relife_stuck_monsters = {}
                env.life_time = nil
                env.monster_info = nil
                return bret.SUCCESS
            end
            if player_info.life == 0 then
                poe2_api.dbgp("[Is_Exception_Team]玩家已死亡")
                env.life_time = nil
                env.relife_stuck_monsters = {}
                env.monster_info = nil
                return bret.RUNNING
            end
            if (boss_name or player_info.isInBossBattle) and not poe2_api.table_contains(player_info.current_map_name_utf8,{"G4_4_1","G4_4_2","G4_11_2","P1_2"})  then
                local boss_info = poe2_api.is_have_boss_distance(range_info, player_info, boss_name, 180)
                if boss_info or player_info.isInBossBattle then
                    poe2_api.dbgp("[Is_Exception_Team]当前处于BOSS战斗中")
                    env.life_time = nil
                    env.relife_stuck_monsters = {}
                    env.monster_info = nil
                    return bret.SUCCESS
                end
            end
            if is_monster(range_info, player_info) then
                poe2_api.dbgp("[Is_Exception_Team]玩家当前有撕裂者或白之亞瑪")
                env.life_time = nil
                env.relife_stuck_monsters = {}
                env.monster_info = nil
                return bret.SUCCESS
            end
            if not self.bool then
                env.end_point             = nil
                env.path_list             = {}
                env.empty_path            = nil
                env.relife_stuck_monsters = {}
                self.bool                 = true
                return bret.RUNNING
            end
            if not poe2_api.table_contains(poe2_api.get_team_info(team_info, user_config, player_info, 2), { "大號名", "未知" })
                and check_pos_dis(poe2_api.get_team_info(team_info, user_config, player_info, 3), range_info, player_info) == nil then
                env.monster_info = nil
                return bret.SUCCESS
            end
            env.mate_info = mate
            return bret.FAIL
        end
    },

    -- 是否需要移动
    Is_Move = {
        run = function(self, env)
            poe2_api.dbgp("===[Is_Move]是否需要移动 ===")
            poe2_api.print_log("判断是否需要移动...")
            local range_info = env.range_info
            local range_sorted = poe2_api.get_sorted_list(env.range_info, env.player_info)
            local player_info = env.player_info
            local range_info_sorted = poe2_api.get_sorted_list(range_info, player_info)
            local UI_info = env.UI_info
            local user_config = env.user_config
            local team_info = env.team_info
            local boss_name = env.boss_name
            local mate = env.mate_info
            local away_monster_info = nil
            local arena_list = poe2_api.get_sorted_obj("競技場", range_info, player_info)
            local relife_stuck_monsters = env.relife_stuck_monsters
            local stuck_monsters = env.stuck_monsters
            if stuck_monsters == nil then
                stuck_monsters = {}
            end
            local function reset_navigation_state()
                -- 重置导航相关状态
                env.end_point = nil
                env.path_list = {}
                env.empty_path = nil
            end

            local function is_monster(range_info)
                -- 使用循环代替生成器表达式
                for _, i in ipairs(range_info) do
                    if ((i.name_utf8 == "巨像．札爾瑪拉斯" or i.name_utf8 == "玷汙者托爾．谷爾" or i.name_utf8 == "巨型守衛者．瓦斯威德")
                            and i.life > 0 and not i.is_friendly and i.isActive)
                        or ((i.name_utf8 == '多里亞尼的凱旋' or i.name_utf8 == '崛起之王．賈嫚拉')
                            and i.hasLineOfSight and i.isActive and i.life > 0)
                        or (not i.is_friendly and i.life > 0
                            and not poe2_api.table_contains(stuck_monsters, i.id)
                            and not string.find(i.name_utf8, "神殿")
                            and not poe2_api.table_contains(my_game_info.not_attact_mons_CN_name, i.name_utf8)
                            and not poe2_api.table_contains(my_game_info.not_attact_mons_path_name, i.name_utf8)
                            and i.isActive and i.rarity ~= 3)
                        and not poe2_api.table_contains(relife_stuck_monsters, i.id) then
                        return i
                    end
                end
                return false
            end

            local function is_point(grid_x, grid_y)
                local point = api_FindNearestReachableInRange(grid_x, grid_y, 50)
                local ralet = api_FindPath(player_info.grid_x, player_info.grid_y, point.x, point.y)
                return ralet
            end

            local function away_monster(range_info, monster_id)
                -- 使用循环代替生成器表达式
                for _, i in ipairs(range_info) do
                    if i.id == monster_id then
                        return i
                    end
                end
                return false
            end

            if mate then
                local distance = poe2_api.point_distance(mate.grid_x, mate.grid_y, player_info)
                local monster = is_monster(range_info_sorted)
                local monster_info = env.monster_info
                local door_list = poe2_api.get_sorted_obj("門", range_info, player_info)
                if door_list and #door_list >0  and poe2_api.point_distance(door_list[1].grid_x, door_list[1].grid_y, player_info) < 15 then
                    poe2_api.dbgp("[Is_Move]门在身边")
                    if poe2_api.find_text({ UI_info = UI_info, text = "門", min_x = 0 }) and door_list[1].is_selectable
                        and not poe2_api.table_contains(player_info.current_map_name_utf8, { "G1_15", "G3_8", "G3_14"}) then
                        api_ClickMove(door_list[1].grid_x, door_list[1].grid_y, 1)
                        reset_navigation_state()
                        return bret.RUNNING
                    end
                end
                
                if monster_info then
                    poe2_api.dbgp("[Is_Move]monster_info存在")
                    away_monster_info = away_monster(range_info_sorted, monster_info.id)
                end
                if monster and poe2_api.table_contains(poe2_api.get_team_info(team_info, user_config, player_info, 2), { "大號名", "未知" }) then
                    monster_distacne = poe2_api.get_point_distance(mate.grid_x, mate.grid_y, monster.grid_x,monster.grid_y)
                    poe2_api.dbgp("[Is_Move]monster存在monster_distacne",monster_distacne)
                    if (monster and monster_distacne < 180) or monster_info then
                        poe2_api.dbgp("[Is_Move]大號打怪")
                        if monster and monster_distacne < 180 then
                            poe2_api.dbgp("[Is_Move]怪物存在且距离小于180")
                            if env.path_list and #env.path_list == 0 then
                                local point = is_point(monster.grid_x, monster.grid_y)
                                if not point or #point == 0 then
                                    poe2_api.dbgp("[Is_Move]怪物坐标非法")
                                    table.insert(relife_stuck_monsters, monster.id)
                                    return bret.RUNNING
                                end
                            end

                            env.monster_info = monster
                            monster_info = monster
                            point_monster = api_FindNearestReachableInRange(monster.grid_x, monster.grid_y, 25)
                            env.end_point = { point_monster.x, point_monster.y }
                        end
                        if monster_info then
                            poe2_api.dbgp("[Is_Move]有黑板参怪物")
                            if not away_monster_info then
                                poe2_api.dbgp("[Is_Move]没有远距离怪物信息")
                                point_monster = api_FindNearestReachableInRange(monster.grid_x, monster.grid_y, 25)
                                env.end_point = { point_monster.x, point_monster.y }
                            else
                                poe2_api.dbgp("[Is_Move]有远距离怪物信息")
                                env.monster_info = away_monster_info
                                point_monster = api_FindNearestReachableInRange(away_monster_info.grid_x,away_monster_info.grid_y, 25)
                                if env.path_list and #env.path_list == 0 then
                                    local point = is_point(away_monster_info.grid_x, away_monster_info.grid_y)
                                    if not point or #point == 0 then
                                        poe2_api.dbgp("[Is_Move]怪物坐标非法")
                                        table.insert(relife_stuck_monsters, monster.id)
                                        return bret.RUNNING
                                    end
                                end
                                env.end_point = { point_monster.x, point_monster.y }
                            end
                            if poe2_api.point_distance(monster_info.grid_x, monster_info.grid_y, player_info) < env.min_attack_dis and monster_info.life <= 0 then
                                env.monster_info = nil
                            end
                        end
                        if point_monster.x ~= -1 and point_monster.y ~= -1 then
                            env.life_time = nil
                            if poe2_api.point_distance(monster_info.grid_x, monster_info.grid_y, player_info) < env.min_attack_dis and monster_info.hasLineOfSight == true then
                                env.is_arrive_end = true
                            end
                            poe2_api.dbgp("[Is_Move]怪物坐标合法")
                            return bret.FAIL
                        end
                    end
                end
                for _, i in ipairs(range_sorted) do
                    if string.find(i.name_utf8, "神殿") and i.isActive and i.is_selectable then
                        api_Sleep(500)
                        api_ClickMove(i.grid_x, i.grid_y, 1)
                        api_Sleep(500)
                        return bret.RUNNING
                    end
                end
                if distance > 100 and poe2_api.is_have_mos({ range_info = range_info_sorted, player_info = player_info, dis = 40 }) and poe2_api.table_contains(poe2_api.get_team_info(team_info, user_config, player_info, 2), { "大號名", "未知" }) then
                    if monster then
                        poe2_api.dbgp("[Is_Move]与死亡队友距离大于100且与怪物距离小于40")
                        point_monster = api_FindNearestReachableInRange(monster.grid_x, monster.grid_y, 25)
                        env.end_point = { point_monster.x, point_monster.y }
                        return bret.FAIL
                    end
                elseif distance > 25 then
                    if player_info.current_map_name_utf8 == "G1_15" then
                        for _,k in ipairs(env.range_info) do
                            if k.name_utf8 == "吉恩諾伯爵" and k.stateMachineList and k.stateMachineList["sitting"] == 0  and env.map_name == "G1_15" then
                                poe2_api.dbgp("[Is_Move]与吉恩諾伯爵战斗不复活")
                                return bret.RUNNING
                            end
                        end 
                    end
                    poe2_api.dbgp("[Is_Move]与队友距离大于25")
                    local boss_info_mate = poe2_api.is_have_boss_distance(range_info, mate, boss_name, 180)
                    if arena_list and #arena_list > 0 and arena_list[1].is_selectable then
                        local arena_list_distance = poe2_api.point_distance(arena_list[1].grid_x, arena_list[1].grid_y, player_info)
                        if distance > arena_list_distance then
                            if poe2_api.find_text({ UI_info = UI_info, text = "競技場", min_x = 0 }) and arena_list[1].hasLineOfSight then
                                poe2_api.find_text({ UI_info = UI_info, text = "競技場", min_x = 0, click = 2 })
                                reset_navigation_state()
                                return bret.RUNNING
                            end
                            local arena_point = api_FindNearestReachableInRange(arena_list[1].grid_x, arena_list[1].grid_y, 25)
                            local arena_path = api_FindPath(player_info.grid_x, player_info.grid_y, arena_point.x, arena_point.y)
                            if arena_path and #arena_path > 0 then
                                poe2_api.dbgp("[Is_Move]与队友距离大于25且与竞技场距离小于180")
                                env.end_point = { arena_list[1].grid_x, arena_list[1].grid_y }
                                return bret.FAIL
                            end
                        end
                    end
                    if boss_info_mate and arena_list and #arena_list > 0 and arena_list[1].is_selectable then
                        poe2_api.dbgp("[Is_Move]与队友距离大于25且与boss距离小于180")
                        local arena_point = api_FindNearestReachableInRange(arena_list[1].grid_x, arena_list[1].grid_y, 25)
                        poe2_api.dbgp(arena_point.x, arena_point.y)
                        env.end_point = { arena_point.x, arena_point.y }
                    else
                        if player_info.current_map_name_utf8 ~= "G4_5_2" then
                            api_RestoreOriginalMap()
                        end
                        local mate_point = api_FindNearestReachableInRange(mate.grid_x, mate.grid_y, 15)
                        env.end_point = { mate_point.x, mate_point.y }
                    end
                    return bret.FAIL
                else
                    poe2_api.dbgp("[Is_Move]与队友距离小于25")
                    return bret.SUCCESS
                end
            else
                return bret.RUNNING
            end
        end
    },

    -- 队友死亡是否需要攻击
    Is_Attack = {
        run = function(self, env)
            poe2_api.dbgp("[Is_Attack]判断是否攻击...")
            poe2_api.print_log("判断是否攻击...")
            local relife_stuck_monsters = env.relife_stuck_monsters
            local range_info = env.range_info
            local player_info = env.player_info
            local range_info_sorted = poe2_api.get_sorted_list(range_info, player_info)
            local UI_info = env.UI_info
            local user_config = env.user_config
            local team_info = env.team_info
            local boss_name = env.boss_name
            local mate = env.mate_info
            if env.stuck_monsters == nil then
                env.stuck_monsters = {}
            end

            local function is_monster(range_info)
                -- Iterate through each item in range_info
                for _, i in ipairs(range_info) do
                    if (((i.name_utf8 == "巨像．札爾瑪拉斯" or i.name_utf8 == "玷汙者托爾．谷爾" or i.name_utf8 == "巨型守衛者．瓦斯威德")
                            and i.life > 0 and not i.is_friendly and i.isActive)
                        or ((i.name_utf8 == '多里亞尼的凱旋' or i.name_utf8 == '崛起之王．賈嫚拉')
                            and i.hasLineOfSight and i.isActive and i.life > 0)
                        or (not i.is_friendly and i.life > 0
                            and not poe2_api.table_contains(env.stuck_monsters, i.id)
                            and not string.find(i.name_utf8, "神殿")
                            and not poe2_api.table_contains(my_game_info.not_attact_mons_CN_name, i.name_utf8)
                            and not poe2_api.table_contains(my_game_info.not_attact_mons_path_name, i.name_utf8)
                            and i.isActive and i.type == 1))
                        and not poe2_api.table_contains(relife_stuck_monsters, i.id) then
                        return i
                    end
                end
                return false
            end
            local monster = is_monster(range_info_sorted)
            if not poe2_api.table_contains(poe2_api.get_team_info(team_info, user_config, player_info, 2), { "大號名", "未知" }) then
                env.monster_info = nil
                return bret.SUCCESS
            end
            local distance = poe2_api.point_distance(mate.grid_x, mate.grid_y, player_info)
            if distance > 100 and poe2_api.is_have_mos({ range_info = range_info_sorted, player_info = player_info, dis = 40 }) then
                poe2_api.dbgp("[Is_Attack]与死亡队友距离大于100且与怪物距离小于40")
                env.monster_info = monster
                return bret.FAIL
            elseif monster and poe2_api.table_contains(poe2_api.get_team_info(team_info, user_config, player_info, 2), { "大號名", "未知" }) and
                poe2_api.get_point_distance(mate.grid_x, mate.grid_y, monster.grid_x, monster.grid_y) < 180 then
                poe2_api.dbgp("[Is_Attack]与怪物距离小于40")
                env.monster_info = monster
                return bret.FAIL
            else
                env.monster_info = nil
                return bret.SUCCESS
            end
        end
    },

    -- 长按点击复活
    Click = {
        run = function(self, env)
            poe2_api.dbgp("点击复活")
            poe2_api.print_log("点击复活")
            local relife_stuck_monsters = env.relife_stuck_monsters
            local range_info = env.range_info
            local player_info = env.player_info
            local range_info_sorted = poe2_api.get_sorted_list(range_info, player_info)
            local UI_info = env.UI_info
            local user_config = env.user_config
            local team_info = env.team_info
            local mate = env.mate_info
            local current_map_info = env.current_map_info
            local function is_monster(range_info)
                -- Iterate through each item in range_info
                for _, i in ipairs(range_info) do
                    if ((i.name_utf8 == "巨像．札爾瑪拉斯" or i.name_utf8 == "玷汙者托爾．谷爾" or i.name_utf8 == "巨型守衛者．瓦斯威德")
                            and i.life > 0 and not i.is_friendly and i.isActive)
                        or ((i.name_utf8 == '多里亞尼的凱旋' or i.name_utf8 == '崛起之王．賈嫚拉')
                            and i.hasLineOfSight and i.isActive and i.life > 0)
                        or (not i.is_friendly and i.life > 0
                            and not string.find(i.name_utf8, "神殿")
                            and not poe2_api.table_contains(env.stuck_monsters, i.id)
                            and not poe2_api.table_contains(my_game_info.not_attact_mons_CN_name, i.name_utf8)
                            and not poe2_api.table_contains(my_game_info.not_attact_mons_path_name, i.name_utf8)
                            and i.isActive and i.type == 1)
                        and not poe2_api.table_contains(relife_stuck_monsters, i.id) then
                        return i
                    end
                end
                return false
            end
            if env.stuck_monsters == nil then
                env.stuck_monsters = {}
            end
            local monster = is_monster(range_info_sorted)
            if monster then
                distance = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
            end
            if monster and distance < 180 and poe2_api.get_team_info(team_info, user_config, player_info, 2) == "大號名" then
                return bret.RUNNING
            end
            local life_time = env.life_time
            if not life_time then
                life_time = api_GetTickCount64()
                env.life_time = life_time
            end
            local function count_gravestones(map_info)
                if not map_info then
                    return false
                end
                local count = 0
                for _, obj in ipairs(map_info) do
                    if obj.name_utf8 == "PlayerGravestone" then
                        count = count + 1
                    end
                end
                return count
            end
            local relife_time = api_GetTickCount64() - life_time
            poe2_api.dbgp(relife_time)
            if relife_time > 90 * 1000 and poe2_api.get_team_info(team_info, user_config, player_info, 2) == "大號名" and count_gravestones(current_map_info) > 0 then
                env.life_time = nil
                env.back_city = true
                return bret.RUNNING
            end
            if not poe2_api.find_text({ UI_info = UI_info, text = "復甦", min_x = 0 }) then
                return bret.RUNNING
            end
            local is_leader = false
            if poe2_api.get_team_info(team_info, user_config, player_info, 2) == "大號名" then
                is_leader = true
            end
            poe2_api.while_click(UI_info, "復甦", player_info, range_info, is_leader)
            return bret.RUNNING
        end
    },

    -- 是否拾取任务或BD
    Is_Pick_Up_Task_Props = {
        run = function(self, env)
            poe2_api.print_log("是否拾取任务和BD")
            poe2_api.dbgp("[Is_Pick_Up_Task_Props]是否拾取任务和BD")
            local range_items = env.range_items
            local player_info = env.player_info
            local user_config = env.user_config
            local current_time = api_GetTickCount64()
            local user_new_item = poe2_api.get_BD_info(user_config["劇情設置"]["職業"], "装备信息")
            local function is_items()
                if range_items then
                    for _, item in ipairs(range_items) do
                        if player_info.current_map_name_utf8 == "G1_1" and user_new_item[item.category_utf8] and item.grid_x ~= 0 then
                            local point = api_FindNearestReachableInRange(item.grid_x, item.grid_y, 20)
                            if not api_FindPath(player_info.grid_x, player_info.grid_y, point.x, point.y) then
                                poe2_api.dbgp("[Is_Pick_Up_Task_Props]无法到达點位")
                                return false
                            end
                            return true
                        elseif poe2_api.table_contains(item.category_utf8, { 'QuestItem', "Active Skill Gem" }) and not poe2_api.table_contains(item.baseType_utf8, { "黃金", "金幣", "紅色蘑菇", "綠色蘑菇", "藍色蘑菇", "龍蜥最後通牒雕刻","獻祭匕首" }) and item.grid_x ~= 0 then
                            local point = api_FindNearestReachableInRange(item.grid_x, item.grid_y, 20)
                            if not api_FindPath(player_info.grid_x, player_info.grid_y, point.x, point.y) then
                                return false
                            end
                            return true
                        end
                    end
                    return false
                end
            end
            if is_items() then
                if poe2_api.find_text({ UI_info = env.UI_info, text = "再會", click = 0}) then
                    poe2_api.find_text({ UI_info = env.UI_info, text = "再會", click = 2 })
                end
                poe2_api.dbgp("进入[Traverse_and_check_equipment]遍历周围装备")
                poe2_api.time_p("[Is_Pick_Up_Task_Props]FAIL",api_GetTickCount64() - current_time)
                return bret.FAIL
            else
                env.item_name = nil
                poe2_api.dbgp("[Is_Pick_Up_Task_Props]SUCCESS")
                poe2_api.time_p("[Is_Pick_Up_Task_Props]SUCCESS",api_GetTickCount64() - current_time)
                return bret.SUCCESS
            end
        end
    },

    -- 遍历周围装备
    Traverse_and_check_equipment = {
        run = function(self, env)
            poe2_api.dbgp("[Traverse_and_check_equipment]遍历周围装备...")
            poe2_api.print_log("遍历周围装备...")
            local range_items = env.range_items
            local player_info = env.player_info
            local user_config = env.user_config
            local user_new_item = poe2_api.get_BD_info(user_config["劇情設置"]["職業"], "装备信息")
            local function processItem(item, player_info)
                env.item_name = item.baseType_utf8
                env.end_point = { item.grid_x, item.grid_y }
                if poe2_api.point_distance(item.grid_x, item.grid_y, player_info) < 25 and
                    (api_HasObstacleBetween(item.grid_x, item.grid_y) or poe2_api.table_contains(item.baseType_utf8 , {"水之精髓","鍛造工具"})) then
                    return bret.FAIL
                end
                return bret.SUCCESS
            end
            if range_items then
                for _, item in ipairs(range_items) do
                    if player_info.current_map_name_utf8 == "G1_1" and user_new_item[item.category_utf8] and item.grid_x ~= 0 then
                        env.mouse_check = true
                        return processItem(item, player_info)
                    elseif poe2_api.table_contains(item.category_utf8, { 'QuestItem', "Active Skill Gem" }) and not poe2_api.table_contains(item.baseType_utf8, { "黃金", "金幣", "紅色蘑菇", "綠色蘑菇", "藍色蘑菇", "龍蜥最後通牒雕刻","獻祭匕首" }) and item.grid_x ~= 0 then
                        return processItem(item, player_info)
                    end
                end
            end
            return bret.RUNNING
        end
    },

    -- 拾取周围装备
    Pick_Up_Ground_Item = {
        run = function(self, env)
            poe2_api.print_log("拾取地上物品...")
            poe2_api.dbgp("[Pick_Up_Ground_Item]拾取地上物品...")
            local player_info = env.player_info
            local UI_info = env.UI_info
            local item_name = env.item_name
            local bag_info = env.bag_info
            local range_items = env.range_items

            local function check_item_in_round(item_name, inventory)
                if inventory then
                    for _, item in ipairs(inventory) do
                        if item.baseType_utf8 == item_name then
                            return true -- 检查到物品，返回true
                        end
                    end
                end
                return false
            end

            if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                poe2_api.click_keyboard("i")
                poe2_api.dbgp("开背包2")
            end
            if range_items then
                for _, item in ipairs(range_items) do
                    if item.baseType_utf8 == item_name then
                        if poe2_api.find_text({ UI_info = UI_info, text = item.baseType_utf8, sorted = true }) then
                            poe2_api.find_text({ UI_info = UI_info, text = item.baseType_utf8, sorted = true, click = 2 })
                        else
                            api_ClickMove(poe2_api.toInt(item.grid_x), poe2_api.toInt(item.grid_y), 1)
                        end
                        api_Sleep(100)
                    end
                end
            end
            return bret.RUNNING
        end
    },

    -- 需要两次传送
    Need_Twice_Teleport = {
        run = function(self, env)
            poe2_api.dbgp("[Need_Twice_Teleport]需要两次传送...")
            poe2_api.print_log("需要两次传送...")
            local player_info = env.player_info
            local task_area = env.map_name
            local special_map_point = env.special_map_point
            local interaction_object = env.interaction_object
            local team_info = env.team_info
            local user_config = env.user_config
            local current_map_name = player_info.current_map_name_utf8
            local current_time = api_GetTickCount64()
            local my_profession = poe2_api.get_team_info(team_info, user_config, player_info, 2)
            if string.find(player_info.current_map_name_utf8, "own") and special_map_point and not poe2_api.table_contains(my_profession, { "大號名", "未知" }) then
                if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                    poe2_api.click_keyboard("space")
                    return bret.RUNNING
                end
                if special_map_point and poe2_api.find_text({ UI_info = env.UI_info, text = "哈拉妮關口", min_x = 195, refresh = true }) then
                    if poe2_api.find_text({ UI_info = env.UI_info, text = "快行" }) then
                        poe2_api.click_keyboard("space")
                    end
                    poe2_api.find_text({ UI_info = env.UI_info, text = interaction_object[1], click = 2, min_x = 195, refresh = true })
                    return bret.RUNNING
                end
                if special_map_point and not poe2_api.find_text({ UI_info = env.UI_info, text = "哈拉妮關口", min_x = 195, refresh = true }) then
                    if env.waypoint ~= nil and #env.waypoint > 0 then
                        if task_area == "G2_town" then
                            waypoint_screen_text = "G2_town_marker_lockedgates"
                        elseif task_area == "G4_town" then
                            waypoint_screen_text = "G4_ShipMarker_TwilightEnclave_b"
                        end
                        waypoint_screen = poe2_api.waypoint_pos(waypoint_screen_text,env.waypoint)
                        if waypoint_screen[1] == 0 and waypoint_screen[2] == 0 then
                            if task_area == "G2_town" then
                                waypoint_screen_text = "G2_town_marker_gates"
                            end
                            waypoint_screen = poe2_api.waypoint_pos(waypoint_screen_text,env.waypoint)
                        end
                    end
                    if (not waypoint_screen) or (waypoint_screen[1] == 0 and waypoint_screen[2] == 0) then
                        if not poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖",refresh = true}) then
                            api_Sleep(800)
                            poe2_api.click_keyboard("u")
                        end
                        api_Sleep(200)
                        env.waypoint = api_GetTeleportationPoint()
                        api_Sleep(1000)
                        return bret.RUNNING
                    end
                    api_Sleep(300)
                    if string.find(player_info.current_map_name_utf8, "G2_town") then
                        if not poe2_api.find_text({ UI_info = env.UI_info, text = "快行", refresh = true }) then
                            if poe2_api.find_text({ UI_info = env.UI_info, text = "沙漠", min_y = 100, min_x = 195, max_x = 1185, max_y = 880, refresh = true }) then
                                poe2_api.find_text({ UI_info = env.UI_info, text = "沙漠", click = 2, min_y = 100, min_x = 195, max_x = 1185, max_y = 880, refresh = true })
                                env.end_point = nil
                                env.empty_path = false
                                return bret.RUNNING
                            else
                                env.end_point = { 547, 253 }
                                poe2_api.time_p("Need_Twice_Teleport",api_GetTickCount64() - current_time ) 
                                return bret.SUCCESS
                            end
                        else
                            if poe2_api.find_text({ UI_info = env.UI_info, text = "快行", refresh = true }) then
                                api_ClickScreen(poe2_api.toInt(waypoint_screen[1]), poe2_api.toInt(waypoint_screen[2]), 0)
                                api_Sleep(600)
                                api_ClickScreen(poe2_api.toInt(waypoint_screen[1]), poe2_api.toInt(waypoint_screen[2]), 1)
                                api_Sleep(600)
                                if poe2_api.find_text({ UI_info = env.UI_info, text = "快行" }) then
                                    poe2_api.click_keyboard("space")
                                end
                            end
                            return bret.RUNNING
                        end
                    end
                    if string.find(player_info.current_map_name_utf8, "G4_town") then
                        if poe2_api.find_text({ UI_info = env.UI_info, text = "快行", refresh = true }) then
                            api_ClickScreen(poe2_api.toInt(waypoint_screen[1]), poe2_api.toInt(waypoint_screen[2]), 0)
                            api_Sleep(600)
                            api_ClickScreen(poe2_api.toInt(waypoint_screen[1]), poe2_api.toInt(waypoint_screen[2]), 1)
                            api_Sleep(600)
                            if poe2_api.find_text({ UI_info = env.UI_info, text = "快行" }) then
                                poe2_api.click_keyboard("space")
                            end
                        end
                    end
                end
            else
                if poe2_api.find_text({ UI_info = env.UI_info, text = "快行" }) then
                    poe2_api.click_keyboard("space")
                end
            end
            poe2_api.time_p("Need_Twice_Teleport",api_GetTickCount64() - current_time ) 
            return bret.FAIL
        end
    },

    -- 點擊大號傳送
    Click_Leader_To_Teleport = {
        run = function(self, env)
            poe2_api.print_log("點擊大號傳送...")
            poe2_api.dbgp("[Click_Leader_To_Teleport]點擊大號傳送...")
            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            local actors = env.range_info
            local user_config = env.user_config
            local team_info = env.team_info
            local task_area = env.map_name
            local task_name = env.task_name
            local team_info_data = env.team_info_data
            local interaction_object = env.interaction_object
            local UI_info = env.UI_info
            local bag_info = env.bag_info
            local special_map_point = env.special_map_point
            local team_member_2 = poe2_api.get_team_info(team_info, user_config, player_info, 2)
            local team_member_3 = poe2_api.get_team_info(team_info, user_config, player_info, 3)
            local team_member_4 = poe2_api.get_team_info(team_info, user_config, player_info, 4)
            local current_map = player_info.current_map_name_utf8
            local current_map_info = env.current_map_info
            local num = user_config["劇情設置"]["隊伍人數"]
            if task_area == "G2_Abyss_Hub" then
                env.map_name = "Abyss_Hub"
            end
            if self.time1 == nil then
                poe2_api.dbgp("[Click_Leader_To_Teleport]初始化時間")
                self.time1 = 0
                self.time2 = 0
            end
            local condition_met = (current_map == "C_G1_1" and string.find(task_area, "C")) or
                (current_map ~= "G1_1" and not poe2_api.find_text({ UI_info = UI_info, text = "抵達皆伐" }))
            if not condition_met then
                poe2_api.dbgp("[Click_Leader_To_Teleport]在新手剧情")
                poe2_api.time_p("Click_Leader_To_Teleport",api_GetTickCount64() - current_time ) 
                return bret.SUCCESS
            end
            if poe2_api.table_contains(team_member_2, { "大號名", "未知" }) then
                poe2_api.time_p("Click_Leader_To_Teleport",api_GetTickCount64() - current_time ) 
                return bret.FAIL
            end
            if poe2_api.find_text({ UI_info = UI_info, text = "傳送", min_x = 0 }) then
                poe2_api.find_text({ UI_info = UI_info, text = "傳送", min_x = 0, add_x = 215, click = 2 })
                return bret.RUNNING
            end
            -- 获取队友位置
            local function party_pos(name)
                poe2_api.dbgp("[party_pos]获取队友位置:")
                for _, member in ipairs(team_info_data) do
                    if member["name_utf8"] == name then
                        poe2_api.dbgp("[party_pos]获取队友位置信息:",member["current_map_name_utf8"])
                        return member["current_map_name_utf8"]
                    end
                end
                return nil
            end

            local function check_pos_dis(names)
                poe2_api.dbgp("[check_pos_dis]获取队友位置距离:")
                if not actors then
                    return nil
                end
                local target = nil
                for _, a in ipairs(actors) do
                    if a.name_utf8 == names then
                        target = a
                        break
                    end
                end
                if target then
                    return poe2_api.point_distance(
                            target.grid_x,
                            target.grid_y,
                            player_info
                    )
                else
                    return nil
                end
            end
            local function mini_map_obj(name)
                poe2_api.dbgp("[Click_Leader_To_Teleport]检测地图上是否存在物体：", name)
                for _, item in ipairs(current_map_info) do
                    if item.name_utf8 == name then
                        return item  -- 直接返回第一个匹配项
                    end
                end
                return nil -- 无匹配时返回nil
            end
            local function mini_map_obj_flagStatus(name)
                poe2_api.dbgp("[Is_Team_leader]检测地图上是否存在物体：", name)
                for _, item in ipairs(current_map_info) do
                    if item.name_utf8 == name and item.flagStatus1 == 1 then
                        return item  -- 直接返回第一个匹配项
                    end
                end
                return nil -- 无匹配时返回nil
            end
            local function get_range_pos(name)
                poe2_api.dbgp("[get_range_pos]获取周围位置:")
                local range_info_sorted = poe2_api.get_sorted_list(actors, player_info)
                for _, actor in ipairs(range_info_sorted) do
                    if actor.name_utf8 == name then
                        return { actor.grid_x, actor.grid_y,actor.id }
                    end
                end
                return nil
            end
            -- 获取团队距离
            local function party_dis_memember(actors)
                -- 从黑板中获取团队信息
                local members = team_info_data
                if not members then
                    poe2_api.dbgp("警告：未找到团队信息")
                    return false
                end
            
                -- 将 members 转换为集合（使用表实现）
                local member_names = {}
                for _, member in ipairs(members) do
                    member_names[member.name_utf8] = true
                end
            
                -- 统计匹配的数量
                local match_count = 0
                for _, actor in ipairs(actors) do
                    if actor.name_utf8 ~= player_info.name_utf8 and member_names[actor.name_utf8] then
                        match_count = match_count + 1
                    end
                end
            
                -- 返回结果
                return match_count == num - 1
            end
            if poe2_api.table_contains(current_map, { "G1_12", "G3_7","P3_2" }) then
                local SPECIAL_SKULL_NAMES = { ['寶石花顱骨'] = true, ['寶石殼顱骨'] = true, ['傑洛特顱骨'] = true }
                for _, i in ipairs(actors) do
                    if SPECIAL_SKULL_NAMES[i.name_utf8] then
                        return bret.RUNNING
                    end
                end
            end
            if string.find(player_info.current_map_name_utf8, "own") and env.get_follow_path_time and env.get_follow_path_time > 0 then
                env.get_follow_path_time = 0
                return bret.RUNNING
            end
            if not party_dis_memember(actors) and string.find(current_map, "a") and task_name == "使用貧脊之地的地圖前往哈拉妮關口所在之處" then
                poe2_api.dbgp("等待大号")
                return bret.RUNNING
            end
            if poe2_api.table_contains(current_map, { "G3_12",  "G2_4_3", "G1_15"}) then
                if task_area == "G1_15" then
                    for _,k in ipairs(env.range_info) do
                        if k.name_utf8 == "吉恩諾伯爵" and k.stateMachineList and k.stateMachineList["sitting"] == 0 then
                            poe2_api.dbgp("与吉恩諾伯爵战斗不回城")
                            return bret.RUNNING
                        end
                    end 
                end
                local function check_role_path(names)
                    poe2_api.dbgp("[check_role_path] 检查指定角色是否有可达路径")
                    if not actors or #actors == 0 then -- 提前检查空值
                        poe2_api.api_print("警告：未找到范围内的角色信息")
                        return false
                    end

                    local point = api_FindNearestReachableInRange(player_info.grid_x, player_info.grid_y, 25)

                    -- 遍历所有actor检查是否有符合条件的
                    for _, actor in ipairs(actors) do
                        if actor.name_utf8 == names then
                            local target = api_CollectReachableInCircleSimple(actor.grid_x, actor.grid_y, 25)
                            local sorted_target = poe2_api.sort_recent_point_list(target,point.x, point.y)
                            local result = api_FindPath(point.x, point.y, sorted_target[1].x, sorted_target[1].y)
                            if result and #result > 0 then
                                return true
                            end
                        end
                    end

                    return false
                end
                if not check_role_path(team_member_3) and check_pos_dis(team_member_3) and check_pos_dis(team_member_3) > 30 then
                    if self.time1 == 0 then
                        self.time1 = api_GetTickCount64()
                    end
                    poe2_api.dbgp(api_GetTickCount64() - self.time1 > 30 * 1000)
                    if api_GetTickCount64() - self.time1 > 30 * 1000 then
                        if string.find(current_map, "own") then
                            self.time1 = 0
                            return bret.SUCCESS
                        end
                        for _, name in ipairs(my_game_info.city_map) do
                            if poe2_api.find_text({ UI_info = UI_info, text = name, click = 2 }) then
                                return bret.RUNNING
                            end
                        end
                        api_ClickScreen(1230, 815, 0)
                        api_Sleep(500)
                        api_ClickScreen(1230, 815, 1)
                        api_Sleep(2000)
                        return bret.RUNNING
                    end
                else
                    self.time1 = 0
                end
            else
                self.time1 = 0
            end
            if task_name == "返回城鎮並與瑟維交談" and string.find(task_area, "G3_town")
                and (poe2_api.check_item_in_inventory("寶石殼顱骨", bag_info) or poe2_api.check_item_in_inventory("傑洛特顱骨", bag_info))
                and poe2_api.check_item_in_inventory("尹娜杜克的幽暗長鋒", bag_info) then
                poe2_api.dbgp("返回城鎮並與瑟維交談")
                for _, name in ipairs(my_game_info.city_map) do
                    if string.find(current_map, "own") then
                        return bret.SUCCESS
                    end
                    if poe2_api.find_text({ UI_info = UI_info, text = name, click = 2 }) then
                        return bret.RUNNING
                    end
                end
                api_ClickScreen(1230, 815, 0)
                api_Sleep(500)
                api_ClickScreen(1230, 815, 1)
                api_Sleep(2000)
                return bret.RUNNING
            end
            if (string.find(current_map, "a") and special_map_point) or (string.find(current_map, "own") and task_area and current_map == task_area and task_name ~= "前往東邊") then
                return bret.SUCCESS
            end
            if not special_map_point and poe2_api.find_text({ UI_info = UI_info, text = "快行" }) then
                poe2_api.click_keyboard("space")
                return bret.RUNNING
            end
            if task_name == "自瘋狂中存活" and team_member_2 == "隊長名" then
                local function npc_stateMachineList()
                    for _,k in ipairs(actors) do
                        if k.name_utf8 == "芙雷雅．哈特林" then
                            if k.stateMachineList and k.stateMachineList["activated"] == 1 then
                                poe2_api.dbgp("芙雷雅．哈特林npc")
                                return true
                            end
                        end
                    end
                    return false
                end
                local npc_stateMachineList = npc_stateMachineList()
                if npc_stateMachineList then
                    env.leader_teleport = true
                else
                    env.leader_teleport = false
                end
            end
            if env.leader_teleport then
                if team_member_2 == "隊長名" then
                    poe2_api.dbgp(1111)
                    if task_area == "G4_2_2" then
                        if task_name == "自瘋狂中存活" then
                            local g4_area_name = mini_map_obj("G4_2_1")
                            if g4_area_name then
                                local distance = poe2_api.point_distance(g4_area_name.grid_x, g4_area_name.grid_y, player_info)
                                if distance < 30 then
                                    poe2_api.find_text({UI_info = env.UI_info, text ="凱吉灣", click = 2})
                                    return bret.RUNNING
                                else                    
                                    env.end_point= {g4_area_name.grid_x, g4_area_name.grid_y}
                                    return bret.FAIL
                                end
                            end
                        elseif task_name == "旅程結束" then
                            local g4_area_name = mini_map_obj("G4_2_2")
                            if g4_area_name then
                                local distance = poe2_api.point_distance(g4_area_name.grid_x, g4_area_name.grid_y, player_info)
                                if distance < 30 then
                                    if not poe2_api.find_text({ UI_info = UI_info, text = "副本管理員", click = 0, refresh = true }) then
                                        api_Sleep(500)
                                        poe2_api.find_text({UI_info = env.UI_info, text ="旅程結束", click = 4})
                                        api_Sleep(500)
                                    else
                                        api_Sleep(500)
                                        poe2_api.find_text({ UI_info = UI_info, text = "新副本", click = 2, min_x = 0, refresh = true })
                                        api_Sleep(500)
                                        if poe2_api.click_text_UI({ UI_info = env.UI_info, text = "loading_screen_tip_label" }) then
                                            env.leader_teleport = false
                                        end
                                    end
                                    return bret.RUNNING
                                else                    
                                    env.end_point= {g4_area_name.grid_x, g4_area_name.grid_y}
                                    return bret.FAIL
                                end
                            end
                        end
                    end
                end
                return bret.RUNNING
            end
            if poe2_api.table_contains(current_map, { "G3_1" }) and poe2_api.table_contains(task_area, { "G3_1" }) and task_name =="與黑衣幽魂對話，了解下一步該做什麼" then
                poe2_api.dbgp("检测到任务区域:G3_1")
                return bret.SUCCESS
            end
            if poe2_api.table_contains(current_map, { "G2_1" }) and poe2_api.table_contains(task_area, { "G2_1" }) and task_name == "進入阿杜拉車隊" then
                poe2_api.dbgp("检测到任务:進入阿杜拉車隊")
                return bret.SUCCESS
            end
            if poe2_api.table_contains(current_map, { "G4_2_2" }) and team_member_2 == "隊長名" and poe2_api.table_contains(task_area, { "G4_2_2" }) and task_name =="自瘋狂中存活" then
                poe2_api.dbgp("检测到任务区域:G4_2_2")
                return bret.SUCCESS
            end
            if poe2_api.table_contains(current_map, { "G3_2_2" }) and poe2_api.table_contains(task_area, { "G3_2_2" }) and
                not check_pos_dis(team_member_3) then
                poe2_api.dbgp("特殊地圖，等待大號")
                return bret.RUNNING
            end
            if current_map == "G3_town" and poe2_api.table_contains(task_area, { "G3_14", "G3_16", "G3_17"}) or poe2_api.table_contains(task_name, { "回到過去，進入奧札爾", "穿過城鎮中的時空傳送門以移至殘忍難度" }) then
                local point = get_range_pos("倉庫")
                local waypoint_point = get_range_pos("傳送點")
                local waypoint_pos = get_range_pos("崎點")
                local distance_between = nil
                if not waypoint_pos and not point then
                    local a = poe2_api.get_point_distance(point[1], point[2], waypoint_point[1], waypoint_point[2])
                    local b = poe2_api.point_distance(waypoint_point[1], waypoint_point[2], player_info)
                    if a and b then
                        if a < 120 and b < 50 then
                            poe2_api.find_text({ UI_info = UI_info, text = "崎點", click = 2, min_x = 0 })
                        else
                            if string.find(player_info.current_map_name_utf8, "own") then
                                local towards_point = poe2_api.move_towards({ player_info.grid_x, player_info.grid_y },
                                    waypoint_pos, 20)
                                api_ClickMove(poe2_api.toInt(towards_point[1]), poe2_api.toInt(towards_point[2]), 0)
                                api_Sleep(100)
                                poe2_api.click_keyboard("space")
                            end
                        end
                        return bret.RUNNING
                    end
                elseif not waypoint_pos and point then
                    local towards_point = poe2_api.move_towards({ player_info.grid_x, player_info.grid_y }, point, 20)
                    api_ClickMove(poe2_api.toInt(towards_point[1]), poe2_api.toInt(towards_point[2]),0)
                    api_Sleep(100)
                    poe2_api.click_keyboard("space")
                    return bret.RUNNING
                elseif waypoint_pos and not point then
                    if waypoint_point then
                        distance_between = poe2_api.get_point_distance(waypoint_point[1], waypoint_point[2],
                            waypoint_pos[1], waypoint_pos[2])
                        if not distance_between or (distance_between and distance_between > 100) then
                            local towards_point = poe2_api.move_towards({ player_info.grid_x, player_info.grid_y },
                                waypoint_pos, 20)
                            api_ClickMove(poe2_api.toInt(towards_point[1]), poe2_api.toInt(towards_point[2]),0)
                            api_Sleep(100)
                            poe2_api.click_keyboard("space")
                            return bret.RUNNING
                        end
                    end
                end
            end
            if poe2_api.table_contains(task_area, { "G3_14", "G3_16", "G3_17", "G3_12" }) and not poe2_api.table_contains(party_pos(team_member_3), { "G3_town", "G3_14", "G3_16", "G3_17", "G3_12"}) then
                if check_pos_dis(team_member_3) == nil then
                    if team_member_2 == "小號" then
                        if not poe2_api.find_text({ UI_info = UI_info, text = "你確定要傳送至此玩家的位置？" }) then
                            local x, y = poe2_api.get_member_name_according(UI_info, team_member_4)
                            if y ~= 0 then
                                local rand_x = 14 + math.random(-7, 7)
                                local rand_y = y + 21 + math.random(-7, 7)
                                api_ClickScreen(poe2_api.toInt(rand_x), poe2_api.toInt(rand_y), 0)
                                api_Sleep(500)
                                api_ClickScreen(poe2_api.toInt(rand_x), poe2_api.toInt(rand_y), 1)
                            end
                            return bret.RUNNING
                        else
                            api_ClickScreen(916, 467, 0)
                            api_Sleep(500)
                            api_ClickScreen(916, 467, 1)
                            return bret.SUCCESS
                        end
                    end
                    return bret.RUNNING
                else
                    return bret.SUCCESS
                end
            end
            if string.find(current_map, "G3_12") and check_pos_dis(team_member_3) and ((interaction_object and poe2_api.table_contains(interaction_object, "召瓦尔") and check_pos_dis(team_member_3)) or (check_pos_dis("艾瓦") and check_pos_dis("艾瓦") < 25) or not check_pos_dis("競技場")) then
                poe2_api.dbgp("在G3_12")
                return bret.RUNNING
            end
            local count = 3 
            if party_pos(team_member_3) == "" and task_area ~= "G3_12" then
                if string.find(current_map, "Hideout") then
                    poe2_api.dbgp("在藏身处")
                    return bret.SUCCESS
                end
                if poe2_api.table_contains(current_map, { "G2_3a","G3_2_2" })  then
                    poe2_api.dbgp("在G2_3a或G3_2_2")
                    return bret.SUCCESS
                end
                poe2_api.dbgp("大号没有位置信息或掉线")
                return bret.RUNNING
            end
            local waypoint_name_utf8 = (party_pos(team_member_3) ~="" and poe2_api.task_area_list_data(party_pos(team_member_3)) and poe2_api.task_area_list_data(party_pos(team_member_3))[1][2]) or nil
            if poe2_api.table_contains(task_area, {"G3_12"}) and not waypoint_name_utf8 then
                waypoint_name_utf8  = poe2_api.task_area_list_data(task_area)[1][2]
            end
            if waypoint_name_utf8 and poe2_api.find_text({ UI_info = UI_info, text = waypoint_name_utf8, min_x = 0, min_y = 0, max_x = 195, max_y = 590 }) and not player_info.isInBossBattle then
                for i = 0, count - 1 do
                    if not poe2_api.find_text({ UI_info = UI_info, text = "你確定要傳送至此玩家的位置？" }) then
                        if poe2_api.find_text({ UI_info = UI_info, text = "快行" }) then
                            poe2_api.click_keyboard("space")
                            return bret.RUNNING
                        end
                        local x, y = poe2_api.get_member_name_according(UI_info, team_member_3)
                        poe2_api.dbgp("x,y",x,y)
                        if y ~= 0 then
                            local rand_x = 14 + math.random(-7, 7)
                            local rand_y = y + 21 + math.random(-7, 7)
                            api_ClickScreen(poe2_api.toInt(rand_x), poe2_api.toInt(rand_y), 0)
                            api_Sleep(500)
                            api_ClickScreen(poe2_api.toInt(rand_x), poe2_api.toInt(rand_y), 1)
                        end
                        return bret.RUNNING
                    else
                        api_ClickScreen(916, 467, 0)
                        api_Sleep(500)
                        api_ClickScreen(916, 467, 1)
                        return bret.SUCCESS
                    end
                end
                return bret.RUNNING
            end

            if current_map == task_area and string.find(current_map, "G4") and string.find(task_area, "G4") then 
                local g4_area_name = get_range_pos(poe2_api.task_area_list_data(task_area)[1][2])
                if g4_area_name then
                    if self.time2 == 0 then
                        self.time2 = api_GetTickCount64()
                    end
                    local distance = poe2_api.point_distance(g4_area_name[1], g4_area_name[2], player_info)
                    poe2_api.dbgp(g4_area_name,distance)
                    if distance < 30 then
                        poe2_api.find_text({UI_info = env.UI_info, text = poe2_api.task_area_list_data(task_area)[1][2], click = 2})
                        if api_GetTickCount64() - self.time2 > 8*1000 then
                            self.time2 = 0
                            local handle_point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y,40)
                            api_ClickMove(poe2_api.toInt(handle_point.x),poe2_api.toInt(handle_point.y),0)
                            api_Sleep(300)
                            poe2_api.click_keyboard("space")
                        end
                        return bret.RUNNING
                    else                    
                        env.end_point= {g4_area_name[1], g4_area_name[2]}
                        return bret.FAIL
                    end
                end
            end
            self.time2 = 0
            if current_map == task_area and task_area == "G4_4_1" then
                if poe2_api.find_text({UI_info = env.UI_info, text = "通道", min_x = 0}) and mini_map_obj_flagStatus("Waypoint") then
                    poe2_api.find_text({UI_info = env.UI_info, text = "通道", min_x = 0,click = 2})
                    return bret.RUNNING
                elseif not poe2_api.find_text({UI_info = env.UI_info, text = "通道", min_x = 0}) and mini_map_obj_flagStatus("Waypoint") then
                    env.end_point = {1279, 964}
                    return bret.FAIL
                end
            end
            if check_pos_dis(team_member_3) then
                local point = get_range_pos(team_member_3)
                local arena_list = poe2_api.get_sorted_obj("競技場", env.range_info, player_info)
                
                if poe2_api.find_text({UI_info = env.UI_info, text = "你確定要傳送至此玩家的位置？"}) then
                    poe2_api.click_keyboard("space")
                end
                local check_point = false
                if player_info.current_map_name_utf8 == "G1_15" then
                    if check_pos_dis("記錄點") and check_pos_dis("記錄點") < 100 then
                        check_point = true
                    end
                end
                if arena_list and #arena_list > 0 and arena_list[1].is_selectable and (arena_list[1].hasLineOfSight or check_point) then
                    local area_path = api_FindPath(player_info.grid_x, player_info.grid_y,arena_list[1].grid_x, arena_list[1].grid_y)
                    if area_path and #area_path > 0 then
                        if not poe2_api.find_text({UI_info = env.UI_info, text = "競技場"}) then
                            local arena = get_range_pos("競技場")
                            if arena then
                                local NearestReachablePoint = api_CollectReachableInCircleSimple(arena[1], arena[2], 40)
                                local reachable_sorted = poe2_api.sort_recent_point_list(NearestReachablePoint,player_info.grid_x, player_info.grid_y)
                                env.end_point = {reachable_sorted[1].x, reachable_sorted[2].y}
                                return bret.FAIL
                            end
                        end
                        
                        poe2_api.find_text({UI_info = env.UI_info, text = "競技場",click = 2})
                        env.end_point = nil
                        env.is_arrive_end = false
                        env.path_list = {}
                        env.entrancelist = {}
                        return bret.RUNNING
                    end
                end
            end

            if check_pos_dis(team_member_3) and check_pos_dis(team_member_3) > 30 and poe2_api.table_contains(current_map, { "G1_15", "G2_3"}) then
                local function next_level()
                    local entrance = get_range_pos("樓梯")
                    local checkpoint_pos = get_range_pos("記錄點")
                    -- 提前返回如果任一位置不存在
                    if not entrance or not checkpoint_pos then
                        return false
                    end
                    -- 直接返回距离计算结果
                    local distance = poe2_api.get_point_distance(entrance[1], entrance[2], checkpoint_pos[1],
                        checkpoint_pos[2]) or 100
                    return distance < 80
                end
                if string.find(current_map, "G1_15") then
                    
                    if not mini_map_obj("GargoyleInactive") and mini_map_obj("Waypoint") then
                        poe2_api.dbgp("G1_15-GargoyleInactive")
                        return bret.SUCCESS
                    end
                end
                local ladder = get_range_pos("樓梯")
                if check_pos_dis("崛起之王．賈嫚拉") == nil and string.find(current_map, "G2_3") then
                    return bret.SUCCESS
                elseif poe2_api.find_text({ UI_info = UI_info, text = "樓梯", min_x = 0 }) and poe2_api.find_text({ UI_info = UI_info, text = "記錄點", min_x = 0}) then
                    self.louti = ladder[3]
                    return bret.SUCCESS
                elseif not next_level() and ladder then
                    if self.louti ==  ladder[3] then
                        return bret.SUCCESS
                    end
                    poe2_api.dbgp("点击楼梯")
                    if ladder and (poe2_api.table_contains(current_map, { "G1_15", "C_G1_15" }) or not poe2_api.find_text({ UI_info = UI_info, text = "樓梯", min_x = 0 })) then
                        if check_pos_dis("樓梯") > 50 then
                            local ladder_point = api_FindNearestReachableInRange(ladder[1], ladder[2], 40)
                            env.end_point = { ladder_point.x, ladder_point.y }
                            return bret.FAIL
                        end
                    end
                    poe2_api.find_text({ UI_info = UI_info, text = "樓梯", min_x = 0, click = 2 })
                    env.end_point = nil
                    env.entrancelist = {}
                    env.path_list = {}
                    return bret.RUNNING
                end
            end
            poe2_api.time_p("=== '[Click_Leader_To_Teleport] ===",api_GetTickCount64() - current_time)
            return bret.SUCCESS
        end
    },

    -- 是否为团队大号
    Is_Team_leader = {
        run = function(self, env)
            poe2_api.print_log("是否为团队大号...")
            poe2_api.dbgp("=== '[Is_Team_leader]是否为团队大号 ===")
            local player_info = env.player_info
            local range_info = env.range_info
            local UI_info = env.UI_info
            local user_config = env.user_config
            local team_info = env.team_info
            local task_area = env.map_name
            local arena_list = poe2_api.get_sorted_obj("競技場", range_info, player_info)
            local me_area = player_info.current_map_name_utf8
            local team_member_2 = poe2_api.get_team_info(team_info, user_config, player_info, 2)
            if team_member_2 ~= "大號名" then
                return bret.FAIL
            end
            return bret.SUCCESS
        end
    },

    -- 是否要传送
    Is_Teleport = {
        run = function(self, env)
            poe2_api.print_log("是否要传送...")
            poe2_api.dbgp("=== '[Is_Teleport]是否要传送 ===")
            if self.follow == nil then
                self.time1 = 0
                self.bool = false
                self.bool1 = false
                self.follow = false
                self.back_city = false
                self.click_ke = false
                self.louti_id = nil
            end
            local task_area = env.map_name
            local player_info = env.player_info
            if not poe2_api.task_area_list_data(task_area) or not player_info then
                return bret.RUNNING
            end
            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            local me_area = player_info.current_map_name_utf8
            local range_info = env.range_info
            local UI_info = env.UI_info
            local user_config = env.user_config
            local team_info = env.team_info
            local team_info_data = env.team_info_data
            local team_member_2 = poe2_api.get_team_info(team_info, user_config, player_info, 2)
            local team_member_3 = poe2_api.get_team_info(team_info, user_config, player_info, 3)
            local team_member_4 = poe2_api.get_team_info(team_info, user_config, player_info, 4)
            local boss_name = env.boss_name
            local interaction_object = env.interaction_object
            local task_name = env.task_name
            local special_map_point = env.special_map_point
            local num = user_config["劇情設置"]["隊伍人數"]
            local current_map_info = env.current_map_info
            local arena_list = poe2_api.get_sorted_obj("競技場", range_info, player_info)

            -- 获取队友位置
            local function party_pos(name)
                poe2_api.dbgp("[party_pos]获取队友位置:",name)
                for _, member in ipairs(team_info_data) do
                    if member["name_utf8"] == name then
                        poe2_api.dbgp("[party_pos]获取队友位置:",member["current_map_name_utf8"])
                        return member["current_map_name_utf8"]
                    end
                end
                return nil
            end

            -- 获取团队是否在同一地图
            local function party_pos_memember(map)
                local members = team_info_data
                if not members then
                    poe2_api.api_print("警告：未找到团队信息")
                    return false
                end

                -- 使用计数器统计满足条件的成员数量
                local match_count = 0
                for _, member in ipairs(members) do
                    if member.name_utf8 ~= team_member_3 and member.current_map_name_utf8 == map then
                        match_count = match_count + 1
                    end
                end

                -- 返回结果
                return match_count == num - 1
            end

            -- 获取团队距离
            local function party_dis_memember(actors)
                -- 从黑板中获取团队信息
                local members = team_info_data
                if not members then
                    poe2_api.dbgp("警告：未找到团队信息")
                    return false
                end
            
                -- 将 members 转换为集合（使用表实现）
                local member_names = {}
                for _, member in ipairs(members) do
                    member_names[member.name_utf8] = true
                end
            
                -- 统计匹配的数量
                local match_count = 0
                for _, actor in ipairs(actors) do
                    if actor.name_utf8 ~= team_member_3 and member_names[actor.name_utf8] then
                        match_count = match_count + 1
                    end
                end
            
                -- 返回结果
                return match_count == num - 1
            end

            -- 团队是否有路径
            local function party_path_memember()
                local members = team_info_data
                if not members then
                    poe2_api.api_print("警告：未找到团队信息")
                    return false
                end
                
                -- 将 members 转换为集合（使用表实现），以提高查找效率
                local member_names = {}
                for _, member in ipairs(members) do
                    member_names[member.name_utf8] = true
                end
            
                -- 统计满足条件的角色数量
                local match_count = 0
            
                -- 遍历周围角色
                for _, actor in ipairs(range_info) do
                    -- 检查角色是否在团队中
                    if not member_names[actor.name_utf8] or actor.name_utf8 == team_member_3 then
                        goto continue
                    end

                    -- 检查路径是否可达
                    local point = api_FindNearestReachableInRange(actor.grid_x, actor.grid_y, 25)
                    local path =  api_FindPath(player_info.grid_x, player_info.grid_y, point.x, point.y)
                    if path and #path > 0 then
                        match_count = match_count + 1
                        if match_count == num - 1 then
                            return match_count
                        end
                    end

                    ::continue::
                end
                return match_count == num - 1
            end

            -- 指定对象路径
            local function check_role_path(names)
                -- 获取范围内的角色信息
                local near_point = api_FindNearestReachableInRange(player_info.grid_x, player_info.grid_y, 25)

                if range_info == nil then
                    poe2_api.dbgp("警告：未找到范围内的角色信息")
                    return false
                end

                -- 遍历角色
                for _, actor in ipairs(range_info) do
                    if actor.name_utf8 == names then
                        local near_point_actor = api_CollectReachableInCircleSimple(actor.grid_x, actor.grid_y, 25)
                        local near_sorted = poe2_api.sort_recent_point_list(near_point_actor, player_info.grid_x, player_info.grid_y)

                        local result = api_FindPath(near_point.x, near_point.y, near_sorted[1].x, near_sorted[2].y)
                        if result and #result > 0 then
                            return true
                        end
                    end
                end

                -- 未找到满足条件的角色
                return false
            end
            -- 获取周围指定对象grid_x,grid_y,id
            local function get_range_pos(name)
                local actors = poe2_api.get_sorted_list(range_info, player_info)

                for _, a in ipairs(actors) do
                    if a.name_utf8 == name then
                        return { a.grid_x, a.grid_y, a.id }
                    end
                end
                return nil
            end

            -- 周围楼梯
            local function next_level()
                poe2_api.dbgp("[next_level]检测周围楼梯")
                local entrance = get_range_pos("樓梯")
                local checkpoint_pos = get_range_pos("記錄點")
                -- 提前返回如果任一位置不存在
                if not entrance or not checkpoint_pos then
                    return false
                end
                -- 直接返回距离计算结果
                local distance = poe2_api.get_point_distance(entrance[1], entrance[2], checkpoint_pos[1],
                    checkpoint_pos[2]) or 100
                if distance < 80 then
                    self.louti_id = entrance[3]
                    return true
                end
                return false
            end

            -- 小地图找物品
            local function mini_map_obj(name)
                poe2_api.dbgp("[Is_Team_leader]检测地图上是否存在物体：", name)
                for _, item in ipairs(current_map_info) do
                    if item.name_utf8 == name then
                        return item  -- 直接返回第一个匹配项
                    end
                end
                return nil -- 无匹配时返回nil
            end
            local function mini_map_obj_flagStatus(name)
                poe2_api.dbgp("[Is_Team_leader]检测地图上是否存在物体：", name)
                for _, item in ipairs(current_map_info) do
                    if item.name_utf8 == name and item.flagStatus1 == 1 then
                        return item  -- 直接返回第一个匹配项
                    end
                end
                return nil -- 无匹配时返回nil
            end
            local function check_pos_dis(names)
                poe2_api.dbgp("[check_pos_dis]获取位置距离:", names)
                
                if not range_info then
                    poe2_api.dbgp("[check_pos_dis]range_info 为 nil")
                    return nil
                end
                if names == nil then
                    poe2_api.dbgp("[check_pos_dis]names 为 nil")
                    return nil
                end
                -- 如果 names 是字符串，转换为表
                if type(names) == "string" then
                    names = {names}
                elseif type(names) ~= "table" then
                    return nil
                end
                if #names == 0 then
                    poe2_api.dbgp("[check_pos_dis]names表为空")
                    return nil
                end
                local target = nil
                
                -- 遍历所有可能的名称
                for _, name in ipairs(names) do
                    for _, a in ipairs(range_info) do
                        if a.name_utf8 == name then
                            target = a
                            break
                        end
                    end
                    if target then
                        break  -- 找到目标就跳出循环
                    end
                end
                
                if target then
                    return poe2_api.point_distance(
                        target.grid_x,
                        target.grid_y,
                        player_info
                    )
                else
                    poe2_api.dbgp("[check_pos_dis]未找到目标")
                    return nil
                end
            end
            if task_area == nil or me_area == "G1_1" or (string.find(me_area, "G2_3a") and special_map_point and string.find(task_area, "G2_town")) then
                env.not_move = true
                return bret.SUCCESS
            end
            if string.find(me_area, "own") then
                self.back_city = true
                self.time1 = 0
            end
            if not self.follow and ((special_map_point and interaction_object and string.find(me_area, "G2_town")) or (me_area ~= task_area and poe2_api.table_contains(task_area, { "G3_1", "G3_2_2" }) and not party_dis_memember(range_info))
                    or (me_area ~= task_area and poe2_api.table_contains(task_area, { "G3_12",  "G3_14", "G3_16", "G3_17" })) or poe2_api.table_contains(task_name, { "回到過去，進入奧札爾", "探索科佩克神殿並尋找瓦爾的知識展覽室" }) or (poe2_api.table_contains(party_pos(team_member_4), { "G2_1","G4_2_2" }))) then
                
                poe2_api.dbgp("大号跟随传送")
                if not poe2_api.find_text({ UI_info = env.UI_info, text = "/clear", min_x = 0 })and not self.bool2 then
                    api_Sleep(1000)
                    poe2_api.click_keyboard("enter")
                    api_Sleep(500)
                    poe2_api.click_keyboard("backspace")
                    api_Sleep(500)
                    poe2_api.paste_text("/clear")
                    api_Sleep(500)
                    poe2_api.click_keyboard("enter")
                    api_Sleep(500)
                    self.bool2 = true
                    return bret.RUNNING
                end
                if me_area == "G3_town" and (poe2_api.table_contains(task_area, { "G3_14", "G3_16", "G3_17" }) or poe2_api.table_contains(task_name, { "回到過去，進入奧札爾", "穿過城鎮中的時空傳送門以移至殘忍難度" })) then
                    local point = get_range_pos("倉庫")
                    local waypoint_point = get_range_pos("傳送點")
                    local waypoint_pos = get_range_pos("崎點")
                    local distance_between = nil
                    if waypoint_pos and point then
                        local a = (poe2_api.get_point_distance(point[1], point[2], waypoint_pos[1], waypoint_pos[2]) or nil)
                        local b = poe2_api.point_distance(waypoint_pos[1], waypoint_pos[2], player_info)
                        if a and b then
                            if a < 120 and b < 50 then
                                poe2_api.find_text({ UI_info = UI_info, text = "崎點", click = 2, min_x = 0 })
                            else
                                if string.find(me_area, "own") then
                                    local towards_point = poe2_api.move_towards({ player_info.grid_x, player_info.grid_y },
                                        waypoint_pos, 20)
                                    api_ClickMove(poe2_api.toInt(towards_point[1]), poe2_api.toInt(towards_point[2]),0)
                                    api_Sleep(100)
                                    poe2_api.click_keyboard("space")
                                end
                            end
                        end
                        return bret.RUNNING
                    elseif not waypoint_pos and point then
                        local towards_point = poe2_api.move_towards({ player_info.grid_x, player_info.grid_y }, point, 20)
                        api_ClickMove(poe2_api.toInt(towards_point[1]), poe2_api.toInt(towards_point[2]), 0)
                        api_Sleep(100)
                        poe2_api.click_keyboard("space")
                        return bret.RUNNING
                    elseif waypoint_pos and not point then
                        if waypoint_point then
                            distance_between = (poe2_api.get_point_distance(waypoint_point[1], waypoint_point[2], waypoint_pos[1], waypoint_pos[2]) or nil)
                        end
                        if not distance_between or (distance_between and distance_between > 100) then
                            local towards_point = poe2_api.move_towards({ player_info.grid_x, player_info.grid_y },
                                waypoint_pos, 20)
                            api_ClickMove(poe2_api.toInt(towards_point[1]), poe2_api.toInt(towards_point[2]),0)
                            api_Sleep(100)
                            poe2_api.click_keyboard("space")
                            return bret.RUNNING
                        end
                    else
                        local waypoint_point_mini = mini_map_obj_flagStatus("Waypoint")
                        local point_mini = mini_map_obj_flagStatus("StashPlayer")
                        if waypoint_point_mini and point_mini and not point then
                            env.end_point = {point_mini.grid_x, point_mini.grid_y}
                            return bret.SUCCESS
                        end
                    end
                end
                local count = 3
                local waypoint_name_utf8 = poe2_api.task_area_list_data(task_area)[1][2]
                if not check_pos_dis(team_member_4) and poe2_api.find_text({ UI_info = UI_info, text = waypoint_name_utf8, min_x = 0, min_y = 0, max_x = 195, max_y = 590 }) then
                    for i = 1, count do
                        if not poe2_api.find_text({ UI_info = UI_info, text = "你確定要傳送至此玩家的位置？" }) then
                            local x, y = poe2_api.get_member_name_according(UI_info, team_member_4)
                            poe2_api.dbgp("x,y",x,y)
                            if y ~= 0 then
                                local rand_x = 14 + math.random(-7, 7)
                                local rand_y = y + 21 + math.random(-7, 7)
                                api_ClickScreen(poe2_api.toInt(rand_x), poe2_api.toInt(rand_y), 0)
                                api_Sleep(500)
                                api_ClickScreen(poe2_api.toInt(rand_x), poe2_api.toInt(rand_y), 1)
                            end
                            self.bool2 = nil
                            return bret.RUNNING
                        else
                            api_ClickScreen(916, 467, 0)
                            api_Sleep(500)
                            api_ClickScreen(916, 467, 1)
                            return bret.RUNNING
                        end
                    end
                    return bret.RUNNING
                else
                    if poe2_api.find_text({ UI_info = UI_info, text = "你確定要傳送至此玩家的位置？" }) then
                        poe2_api.click_keyboard("space")
                    end
                end
            end
            poe2_api.time_p("Is_Teleport",(api_GetTickCount64() - current_time))
            if poe2_api.table_contains(me_area, { "G1_15" }) and poe2_api.table_contains(task_area, { "G1_15"}) and next_level() then
                if poe2_api.is_have_mos({ range_info = range_info, player_info = player_info ,dis = 50}) then
                    env.not_move = true
                    return bret.SUCCESS
                end
                if not check_pos_dis(boss_name) and party_dis_memember(range_info) and not party_path_memember() then
                    poe2_api.dbgp("G1_15-小号没下楼梯")
                    env.louti_space = false
                    self.follow = true
                    if not poe2_api.click_text_UI({ text = "respawn_at_checkpoint_button", UI_info = UI_info }) and not self.bool1 then
                        poe2_api.dbgp("向記錄點翻滚")
                        local walkpoint = poe2_api.find_text({ UI_info = UI_info, text = "記錄點", position = 3 })
                        if walkpoint then
                            api_ClickScreen(poe2_api.toInt(walkpoint[1]), poe2_api.toInt(walkpoint[2]),0)
                            api_Sleep(500)
                            poe2_api.click_keyboard("space")
                        end
                        self.bool1 = true
                    end
                    if self.time1 == 0 then
                        self.time1 = api_GetTickCount64()
                    end
                    if api_GetTickCount64() - self.time1 >= 30 * 1000 then
                        for _, name in ipairs(my_game_info.city_map) do
                            if poe2_api.find_text({ UI_info = env.UI_info, text = name, click = 0 }) then
                                self.time1 = 0
                                self.bool1 = false
                                return bret.RUNNING
                            end
                        end
                        api_ClickScreen(1230, 815, 0)
                        api_Sleep(500)
                        api_ClickScreen(1230, 815, 1)
                        api_Sleep(2000)
                    end
                    return bret.RUNNING
                else
                    self.follow = false
                    env.louti_space = true
                end
            end
            poe2_api.time_p("Is_Teleport-G1_15",(api_GetTickCount64() - current_time))
            if poe2_api.table_contains(me_area, { "G2_4_3" }) and poe2_api.table_contains(task_area, { "G2_4_3"}) and poe2_api.find_text({ UI_info = UI_info, text = "掩埋神殿", min_x = 0 }) then
                if poe2_api.is_have_mos({ range_info = range_info, player_info = player_info,dis = 50 }) then
                    env.not_move = true
                    return bret.SUCCESS
                end
                if not party_path_memember() then
                    env.louti_space = false
                    if not poe2_api.click_text_UI({ text = "respawn_at_checkpoint_button", UI_info = UI_info }) and not self.bool1 then
                        poe2_api.dbgp("向記錄點翻滚")
                        local walkpoint = poe2_api.find_text({ UI_info = UI_info, text = "記錄點", position = 3 })
                        if walkpoint then
                            api_ClickScreen(poe2_api.toInt(walkpoint[1]), poe2_api.toInt(walkpoint[2]),0)
                            api_Sleep(500)
                            poe2_api.click_keyboard("space")
                        end
                        self.bool1 = true
                    end
                    if self.time1 == 0 then
                        self.time1 = api_GetTickCount64()
                    end
                    if api_GetTickCount64() - self.time1 >= 30 * 1000 then
                        for _, name in ipairs(my_game_info.city_map) do
                            if poe2_api.find_text({ UI_info = env.UI_info, text = name, click = 0 }) then
                                self.time1 = 0
                                self.bool1 = false
                                return bret.RUNNING
                            end
                        end
                        api_ClickScreen(1230, 815, 0)
                        api_Sleep(500)
                        api_ClickScreen(1230, 815, 1)
                        api_Sleep(2000)
                    end
                    return bret.RUNNING
                else
                    self.follow = false
                    env.louti_space = true
                end
            end
            poe2_api.time_p("Is_Teleport1",(api_GetTickCount64() - current_time))
            if poe2_api.table_contains(me_area, { "G3_12" }) and poe2_api.table_contains(task_area, { "G3_12" }) and not poe2_api.is_have_boss_distance(range_info, player_info, boss_name) then
                if poe2_api.is_have_mos({ range_info = range_info, player_info = player_info,dis = 70 }) then
                    env.not_move = true
                    return bret.SUCCESS
                end
                if next_level() and check_pos_dis(team_member_4) and check_pos_dis(team_member_4) > 30 and not check_role_path(team_member_4) then
                    poe2_api.dbgp("G3_12楼梯")
                    env.louti_space = false
                    self.follow = true
                    poe2_api.find_text({ UI_info = UI_info, text = "競技場", click = 2 })
                    if not poe2_api.click_text_UI({ text = "respawn_at_checkpoint_button", UI_info = UI_info }) and not self.bool1 then
                        poe2_api.dbgp("向記錄點翻滚")
                        local walkpoint = poe2_api.find_text({ UI_info = UI_info, text = "記錄點", position = 3 })
                        if walkpoint then
                            api_ClickScreen(poe2_api.toInt(walkpoint[1]), poe2_api.toInt(walkpoint[2]),0)
                            api_Sleep(500)
                            poe2_api.click_keyboard("space")
                        end
                       
                        self.bool1 = true
                    end
                    if self.time1 == 0 then
                        self.time1 = api_GetTickCount64()
                    end
                    if api_GetTickCount64() - self.time1 >= 30 * 1000 then
                        for _, name in ipairs(my_game_info.city_map) do
                            if poe2_api.find_text({ UI_info = env.UI_info, text = name, click = 0 }) then
                                self.time1 = 0
                                self.bool1 = false
                                return bret.RUNNING
                            end
                        end
                        api_ClickScreen(1230, 815, 0)
                        api_Sleep(500)
                        api_ClickScreen(1230, 815, 1)
                        api_Sleep(2000)
                    end
                    return bret.RUNNING
                elseif not check_pos_dis(team_member_4) then
                    return bret.RUNNING
                else
                    env.louti_space = true
                    self.follow = false
                    if poe2_api.click_text_UI({ text = "respawn_at_checkpoint_button", UI_info = UI_info }) then
                        poe2_api.click_keyboard("space")
                        return bret.RUNNING
                    end
                end
            end
            poe2_api.time_p("Is_Teleport2",(api_GetTickCount64() - current_time))
            if string.find(me_area, "G3_town") then
                if not check_pos_dis("傳送點") then
                    if not check_pos_dis("崎點") and poe2_api.find_text({ UI_info = UI_info, text = "淹沒之城", min_x = 0 })
                        and (not interaction_object or not poe2_api.table_contains(interaction_object, "科佩克")) and task_name ~= "找出控制機關並啟用水道，抽乾該區的水。" then
                        poe2_api.find_text({ UI_info = UI_info, text = "淹沒之城", click = 2 })
                        return bret.RUNNING
                    elseif interaction_object and poe2_api.table_contains(interaction_object, "科佩克") and poe2_api.find_text({ UI_info = UI_info, text = "淹沒之城", min_x = 0 }) and poe2_api.find_text({ UI_info = UI_info, text = "科佩克神殿", min_x = 0 }) then
                        poe2_api.find_text({ UI_info = UI_info, text = "科佩克神殿", min_x = 0, click = 2 })
                        self.click_ke = true
                        return bret.RUNNING
                    end
                    if self.click_ke and string.find(task_area, "G3_12") and not string.find(me_area, "G3_12") and api_HasObstacleBetween(458, 324 ) then
                        poe2_api.find_text({ UI_info = UI_info, text = "科佩克神殿", min_x = 0, click = 2 })
                    else
                        self.click_ke = false
                    end
                end
            end
            if string.find(me_area, "P2_Town") and task_area == "P2_1" then
                if poe2_api.point_distance(451,382,player_info) > 30 then
                    env.end_point = { 451, 382 }
                    return bret.SUCCESS
                else
                    if not poe2_api.find_text({ UI_info = UI_info, text = "副本管理員", click = 0, refresh = true }) then
                        api_Sleep(500)
                        poe2_api.find_text({UI_info = env.UI_info, text ="卡里交匯道", click = 4})
                        api_Sleep(500)
                    else
                        api_Sleep(500)
                        poe2_api.find_text({ UI_info = UI_info, text = "新副本", click = 2, min_x = 0, refresh = true })
                        api_Sleep(500)
                        if poe2_api.click_text_UI({ text = "loading_screen_tip_label", UI_info = UI_info }) then
                            return bret.RUNNING
                        end
                    end
                    return bret.RUNNING
                end
            end
            if string.find(me_area, "P3_Town") and task_area == "P3_1" then
                if not poe2_api.find_text({ UI_info = UI_info, text = "灰燼森林",max_x =1360}) then
                    env.end_point = { 525, 569 }
                    return bret.SUCCESS
                else
                    poe2_api.find_text({ UI_info = UI_info, text = "灰燼森林",click = 2,max_x =1360 })
                    api_Sleep(500)
                    return bret.RUNNING
                end
            end
            if task_name == "科佩克神殿" and string.find(me_area, "G3_12") then
                return bret.RUNNING
            end
            if task_name == "瑪特蘭水道" and string.find(me_area, "G3_2_2") then
                return bret.RUNNING
            end

            if me_area == task_area then
                if string.find(me_area,"G4") then
                    local g4_area_name = get_range_pos(poe2_api.task_area_list_data(task_area)[1][2])
                    if g4_area_name then
                        local distance = poe2_api.point_distance(g4_area_name[1], g4_area_name[2], player_info)
                        if distance < 30 then
                            poe2_api.find_text({UI_info = env.UI_info, text = poe2_api.task_area_list_data(task_area)[1][2], click = 2})
                            return bret.RUNNING
                        else                    
                            env.end_point= {g4_area_name[1], g4_area_name[2]}
                            return bret.SUCCESS
                        end
                    end
                end
                if task_area == "G4_4_1" then
                    if poe2_api.find_text({UI_info = env.UI_info, text = "通道", min_x = 0}) and mini_map_obj_flagStatus("Waypoint") then
                        poe2_api.find_text({UI_info = env.UI_info, text = "通道", min_x = 0,click = 2})
                        return bret.RUNNING
                    elseif not poe2_api.find_text({UI_info = env.UI_info, text = "通道", min_x = 0}) and mini_map_obj_flagStatus("Waypoint")  then
                        env.end_point = {1279, 964}
                        return bret.SUCCESS
                    end
                end
                if not string.find(me_area, "own") then
                    if (not party_pos_memember(me_area) or not party_dis_memember(range_info)) and not self.back_city then
                        if poe2_api.is_have_mos({ range_info = range_info, player_info = player_info }) or player_info.isInBossBattle then
                            env.not_move = true
                            return bret.SUCCESS
                        end
                        if self.time1 == 0 then
                            self.time1 = api_GetTickCount64()
                        end
                        local retime = api_GetTickCount64() - self.time1
                        poe2_api.dbgp("retime",retime)
                        if retime >= 60 * 1000 and player_info.life ~= 0 then
                            for _, name in ipairs(my_game_info.city_map) do
                                if poe2_api.find_text({ UI_info = env.UI_info, text = name, click = 2 }) then
                                    return bret.RUNNING
                                end
                            end
                            api_ClickScreen(1230, 815, 0)
                            api_Sleep(500)
                            api_ClickScreen(1230, 815, 1)
                            api_Sleep(2000)
                        end
                        return bret.RUNNING
                    else
                        self.time1 = 0
                        self.back_city = false
                    end
                else
                    self.time1 = 0
                    if poe2_api.click_text_UI({ text = "respawn_at_checkpoint_button", UI_info = UI_info }) then
                        poe2_api.click_keyboard("space")
                        return bret.RUNNING
                    end
                end
                if poe2_api.find_text({ UI_info = UI_info, text = "傳送", click = 0, min_x = 0 }) then
                    poe2_api.click_keyboard("space")
                    return bret.RUNNING
                end
                if arena_list and #arena_list > 0 and arena_list[1].hasLineOfSight and arena_list[1].is_selectable then
                    local arena_path = api_FindPath(player_info.grid_x, player_info.grid_y, arena_list[1].grid_x, arena_list[1].grid_y)
                    if arena_path and #arena_path > 0 then
                        if poe2_api.is_have_mos({ range_info = range_info, player_info = player_info }) then
                            poe2_api.dbgp("有怪物不点击arena_list")
                            env.not_move = true
                            return bret.SUCCESS
                        end
                        if not poe2_api.find_text({ UI_info = UI_info, text = "競技場" }) then
                            local arena = get_range_pos("競技場")
                            if arena then
                                local near_point = api_CollectReachableInCircleSimple(arena[1], arena[2], 40)
                                local near_sorted = poe2_api.sort_recent_point_list(near_point,player_info.grid_x, player_info.grid_y)
                                env.end_point = { near_sorted[1].x, near_sorted[1].y }
                                return bret.SUCCESS
                            end
                        end
                        poe2_api.find_text({ UI_info = UI_info, text = "競技場", click = 2 })
                        env.end_point = nil
                        env.entrancelist = {}
                        env.end_point = {}
                        return bret.RUNNING
                    end
                end
                if poe2_api.table_contains(me_area, { "G1_15", "G2_3", "G3_12"}) then
                    local louti = get_range_pos("樓梯")
                    if poe2_api.table_contains(me_area, { "G1_15" }) then
                        if not mini_map_obj("GargoyleInactive") and mini_map_obj("Waypoint") then
                            env.not_move = true
                            return bret.SUCCESS
                        end
                    end
                    if not check_pos_dis(team_member_4) and team_member_2 ~= "未知" then
                        return bret.RUNNING
                    end
                    if not check_pos_dis("崛起之王．賈嫚拉") and string.find(me_area, "G2_3$") then
                        env.is_arrive_end = true
                        return bret.SUCCESS
                    elseif poe2_api.find_text({ UI_info = UI_info, text = "樓梯", min_x = 0 }) and poe2_api.find_text({ UI_info = UI_info, text = "記錄點", min_x = 0}) then
                        poe2_api.dbgp("已在下一层")
                        self.louti_id = louti[3]
                        env.not_move = true
                        return bret.SUCCESS
                    elseif not next_level() and louti then
                        poe2_api.dbgp("进入点击楼梯操作")
                        if self.louti_id and self.louti_id == louti[3] then
                            poe2_api.dbgp("樓梯id相同")
                            env.not_move = true
                            return bret.SUCCESS
                        end
                        if poe2_api.is_have_mos({ range_info = range_info, player_info = player_info }) then
                            poe2_api.dbgp("有怪物不点击樓梯")
                            env.not_move = true
                            return bret.SUCCESS
                        end
                        if louti and (not poe2_api.table_contains(me_area, { "G2_3" }) or not poe2_api.find_text({ UI_info = UI_info, text = "樓梯", min_x = 0 })) then
                            if check_pos_dis("樓梯") > 50 then
                                poe2_api.dbgp("樓梯距离太远")
                                local nearest_point = api_FindNearestReachableInRange(louti[1], louti[2], 40)
                                env.end_point = { nearest_point.x, nearest_point.y }
                                return bret.SUCCESS
                            end
                        end
                        poe2_api.find_text({ UI_info = UI_info, text = "樓梯", min_x = 0, click = 2 })
                        env.end_point = nil
                        env.entrancelist = {}
                        env.end_point = {}
                        return bret.RUNNING
                    end
                end
                poe2_api.time_p("Is_Telepor3",(api_GetTickCount64() - current_time))
                env.not_move = true
                return bret.SUCCESS
            end
            if poe2_api.is_have_mos({ range_info = range_info, player_info = player_info }) or player_info.isInBossBattle then
                env.not_move = true
                return bret.SUCCESS
            end
            poe2_api.dbgp("=== 进入传送判断 ===")
            poe2_api.time_p("Is_Telepor4",(api_GetTickCount64() - current_time))
            return bret.FAIL
        end
    },

    -- 传送点是否打开
    Is_Open_Task_Wayoint = {
        run = function(self, env)
            local task_area = env.map_name
            local player_info = env.player_info
            local task_area_name = poe2_api.task_area_list_data(task_area)[1][1]
            local waypoint = env.waypoint
            local current_map = player_info.current_map_name_utf8
            if current_map == task_area then
                return bret.RUNNING
            end
            if task_area == "G4_10" then
                task_area = "G4_10_1"
                env.map_name = "G4_10_1"
            end
            if task_area == "Abyss_Hub" then
                task_area = "G2_Abyss_Hub"
                env.map_name = "G2_Abyss_Hub"
            end
            if poe2_api.task_area_list_data(task_area)[2] == "有" and poe2_api.Waypoint_is_open(task_area, waypoint) then
                if string.find(task_area, "G2") and not string.find(current_map, "G2") and task_area~="G2_1" then
                    env.teleport_area = "G2_town"
                    return bret.SUCCESS
                end

                if string.find(task_area, "G3") and not string.find(current_map, "G3") then
                    env.teleport_area = "G3_town"
                    return bret.SUCCESS
                end

                env.teleport_area = task_area
                return bret.SUCCESS
            else
                if task_area == "G3_12" then
                    env.teleport_area = task_area
                    return bret.SUCCESS
                end
                if task_area == "P2_1" then
                    env.teleport_area = "P2_Town"
                    task_area = "P2_Town"
                end
                if task_area == "P3_1" then
                    env.teleport_area = "P3_Town"
                    task_area = "P3_Town"
                end
                if waypoint and poe2_api.Waypoint_is_open("G3_14", waypoint) and not poe2_api.table_contains(task_area, { "G3_14", "G3_16", "G3_17" })  then
                    env.teleport_area = task_area
                    return bret.SUCCESS
                end
                if not poe2_api.Waypoint_is_open(task_area, waypoint) and task_area ~= "G3_2_2"  then
                    if not poe2_api.find_text({UI_info = env.UI_info, text = "世界地圖",refresh = true}) then
                        api_Sleep(800)
                        poe2_api.click_keyboard("u")
                    end
                    api_Sleep(200)
                    if string.find(task_area, "G1") then
                        api_Sleep(500)
                        poe2_api.find_text({ UI_info = env.UI_info, text = "第 1 章", click = 2, refresh = true })
                        api_Sleep(500)
                        env.waypoint = api_GetTeleportationPoint()
                    elseif string.find(task_area, "G2") then
                        api_Sleep(500)
                        poe2_api.find_text({ UI_info = env.UI_info, text = "第 2 章", click = 2, refresh = true })
                        api_Sleep(500)
                        env.waypoint = api_GetTeleportationPoint()
                    elseif string.find(task_area, "G3") then
                        api_Sleep(500)
                        poe2_api.find_text({ UI_info = env.UI_info, text = "第 3 章", click = 2, refresh = true })
                        api_Sleep(500)
                        env.waypoint = api_GetTeleportationPoint()
                    elseif string.find(task_area, "G4") then
                        api_Sleep(500)
                        poe2_api.find_text({ UI_info = env.UI_info, text = "第 4 章", click = 2, refresh = true })
                        api_Sleep(500)
                        env.waypoint = api_GetTeleportationPoint()
                    elseif string.find(task_area, "P") then
                        api_Sleep(500)
                        poe2_api.find_text({ UI_info = env.UI_info, text = "間歇", click = 2, refresh = true })
                        api_Sleep(500)
                        env.waypoint = api_GetTeleportationPoint()
                    end
                    api_Sleep(200)
                    poe2_api.click_keyboard("u")
                    poe2_api.print_log("任务地区" .. task_area_name .. "传送点未打开")
                    return bret.RUNNING
                end
                return bret.SUCCESS
            end
        end
    },

    -- 传送点是否在附近
    Teleport_Is_Near = {
        run = function(self, env)
            local player_info = env.player_info
            local task_area = env.map_name
            local current_map = player_info.current_map_name_utf8
            local teleport_area = env.teleport_area
            local range_info = env.range_info
            local UI_info = env.UI_info
            local current_map_info = env.current_map_info

            local function get_actor_pos(name)
                for _, a in ipairs(range_info) do
                    if string.find(a.name_utf8 , name) then
                        return { a.grid_x, a.grid_y, a.id }
                    end
                end
                return nil
            end

            local function get_current_map_info_pos(name)
                for _, a in ipairs(current_map_info) do
                    if a.name_utf8 == name then
                        return { a.grid_x, a.grid_y }
                    end
                end
                return nil
            end

            local function check_pos_dis(names)
                poe2_api.dbgp("[Teleport_Is_Near]判断指定名称与主角的距离")
                if range_info ~= nil then
                    for _, point in ipairs(range_info) do
                        if string.find(point.name_utf8 , names) then
                            local l = poe2_api.point_distance(point.grid_x, point.grid_y, player_info)
                            return l
                        end
                    end
                end
                return nil
            end
            local function check_current_map_info_dis(names)
                poe2_api.dbgp("[Teleport_Is_Near]判断指定小地图与主角的距离")
                if current_map_info ~= nil and #current_map_info > 0  then
                    for _, point in ipairs(current_map_info) do
                        if point.name_utf8 == names then
                            local l = poe2_api.point_distance(point.grid_x, point.grid_y, player_info)
                            return l
                        end
                    end
                end
                return nil
            end
            if poe2_api.find_text({ UI_info = UI_info, text = "記錄點", click = 0 }) then
                if not check_pos_dis("記錄點") then
                    api_Sleep(8 * 1000)
                    return bret.RUNNING
                end
            end
            if string.find(task_area, "G3_12") then
                poe2_api.dbgp("[task_area]G3_12")
                if string.find(current_map, "G3_town") then
                    poe2_api.dbgp("[task_area]G3_12,在城镇")
                    local target_pos = { 458, 324 }

                    local foundPath = api_FindPath(player_info.grid_x, player_info.grid_y, target_pos[1], target_pos[2])
                    if foundPath then
                        env.end_point = { target_pos[1], target_pos[2] }
                        return bret.SUCCESS
                    end

                    -- ==== 传送点距离检测 ====
                    local point = get_actor_pos("傳送點")
                    local distance = check_pos_dis("傳送點")
                    if distance > 30 then
                        env.end_point = { point[1], point[2] }
                        return bret.SUCCESS
                    end

                    -- ====处理区域前缀 ====
                    local area_prefix = ""
                    if string.find(current_map or "", "C_") then
                        area_prefix = "C_"
                    end
                    env.teleport_area = area_prefix .. "G3_12"
                    return bret.FAIL
                else
                    poe2_api.dbgp("[task_area]G3_12,回到城镇")
                    if poe2_api.find_text({ UI_info = UI_info, text = "傳送", click = 0 }) then
                        poe2_api.click_keyboard("space")
                        return bret.RUNNING
                    end

                    for _, name in ipairs(my_game_info.city_map) do
                        if poe2_api.find_text({ UI_info = UI_info, text = name, click = 2 }) then
                            return bret.RUNNING
                        end
                    end
                    api_ClickScreen(1230, 815, 0)
                    api_Sleep(500)
                    api_ClickScreen(1230, 815, 1)
                    api_Sleep(2000)
                    return bret.RUNNING
                end
            end
            if not string.find(teleport_area, "G3_1$") and string.find(current_map, "G3_1$") then
                poe2_api.dbgp("[teleport_area]G3_town")
                local has_teleport = check_pos_dis("傳送點")
                if not has_teleport then
                    if poe2_api.find_text({ UI_info = env.UI_info, text = "城鎮傳送門", click = 2 }) then
                        if check_pos_dis("傳送點") then
                            return bret.FAIL
                        end
                        return bret.RUNNING
                    end
                    api_ClickScreen(1230, 815, 0)
                    api_Sleep(500)
                    api_ClickScreen(1230, 815, 1)
                    api_Sleep(2000)
                    return bret.RUNNING
                else
                    local point = get_actor_pos("傳送點")
                    if check_pos_dis("傳送點") > 30 then
                        env.end_point = { point[1], point[2] }
                        return bret.SUCCESS
                    end
                    return bret.FAIL
                end
            end
            if (teleport_area == "G2_town" and current_map == "G2_1") or not check_current_map_info_dis("Waypoint") or (not check_pos_dis("傳送點") and check_current_map_info_dis("Waypoint") > 200) then
                poe2_api.dbgp("非常规传送点处理")
                if string.find(current_map, "G2_1$") and not check_pos_dis("札卡") then
                    poe2_api.dbgp("[teleport_area]G2_1札卡")
                    if poe2_api.find_text({ UI_info = UI_info, text = "城鎮傳送門", click = 2 }) then
                        if check_pos_dis("傳送點") then
                            local point = get_actor_pos("傳送點")
                            if check_pos_dis("傳送點") > 30 then
                                env.end_point = { point[1], point[2] }
                                return bret.SUCCESS
                            end
                            return bret.FAIL
                        end
                        return bret.RUNNING
                    end
                    api_ClickScreen(1230, 815, 0)
                    api_Sleep(500)
                    api_ClickScreen(1230, 815, 1)
                    api_Sleep(2000)
                    return bret.RUNNING
                elseif string.find(current_map, "G2_1$") and check_pos_dis("札卡") then
                    local point = get_actor_pos("阿杜拉車隊")
                    if point and check_pos_dis("阿杜拉車隊") > 30 then
                        env.end_point = { point[1], point[2] }
                        return bret.SUCCESS
                    end
                    poe2_api.find_text({ UI_info = UI_info, text = "阿杜拉車隊", click = 2 })
                    return bret.SUCCESS
                end

                if not string.find(current_map, "own") then
                    poe2_api.dbgp("[Teleport_Is_Near]非城区处理")
                    if poe2_api.find_text({ UI_info = UI_info, text = "傳送", click = 0 }) then
                        poe2_api.click_keyboard("space")
                        return bret.RUNNING
                    end
                    for _, name in ipairs(my_game_info.city_map) do
                        if poe2_api.find_text({ UI_info = UI_info, text = name, click = 2 }) then
                            if string.find(current_map, "own") then
                                env.teleport_area = task_area
                                return bret.FAIL
                            end
                            return bret.RUNNING
                        end
                    end
                    api_ClickScreen(1230, 815, 0)
                    api_Sleep(500)
                    api_ClickScreen(1230, 815, 1)
                    api_Sleep(2000)
                    return bret.RUNNING
                end

                if string.find(current_map, "G3_town") and not check_pos_dis("傳送點") then
                    env.end_point = { 434, 299 }
                    return bret.SUCCESS
                end
                if string.find(current_map, "G2_town") then
                    env.end_point = { 345, 192 }
                    return bret.SUCCESS
                end
                return bret.FAIL
            else
                poe2_api.dbgp("常规传送点处理")
                local point = get_actor_pos("傳送點")
                local map_info_point = get_current_map_info_pos("Waypoint")
                local waypoint_pos = get_actor_pos("崎點")
                if point then
                    if current_map == "G3_town" and waypoint_pos and not poe2_api.table_contains(task_area, { "G3_14", "G3_16", "G3_17" }) then
                        local distance_between = poe2_api.get_point_distance(point[1], point[2], waypoint_pos[1],
                            waypoint_pos[2])
                        local distance_to_player = poe2_api.point_distance(waypoint_pos[1], waypoint_pos[2], player_info)      
                        if distance_between < 100 then
                            if distance_to_player > 30 then
                                env.end_point = { waypoint_pos[1], waypoint_pos[2] }
                                return bret.SUCCESS
                            else
                                poe2_api.find_text({ UI_info = UI_info, text = "崎點", click = 2 })
                                return bret.RUNNING
                            end
                        end
                    end
                    if (point and check_pos_dis("傳送點") > 30) or (map_info_point and not point and check_current_map_info_dis("Waypoint") <= 300 ) then
                        if not point then
                            point = map_info_point
                        end
                        env.end_point = { point[1], point[2] }
                        return bret.SUCCESS
                    end
                    return bret.FAIL
                end
            end
            return bret.RUNNING
        end
    },

    -- 地区传送
    Click_Map_To_Area_Teleport = {
        run = function(self, env)
            poe2_api.print_log("地区传送模块开始执行...")
            poe2_api.dbgp("[Click_Map_To_Area_Teleport]地区传送模块开始执行...")
            local teleport_area = env.teleport_area
            local task_area_name = poe2_api.task_area_list_data(teleport_area)[1][1]
            local UI_info = env.UI_info
            local player_info = env.player_info
            local current_map = player_info.current_map_name_utf8
            local waypoint = env.waypoint
            local waypoint_screen = poe2_api.waypoint_pos(teleport_area,waypoint)
            if self.s_time == nil then
                self.s_time = 0
                self.last_click_time = 0
                self.click_cooldown = 1
            end
            if self.s_time == 0 then
                self.s_time = api_GetTickCount64()
            end
            -- 获取地面UI层级
            local function switch_ground()
                poe2_api.dbgp("获取地面UI层级...")
                local controls = poe2_api.get_game_control_by_rect({
                    UI_info = env.UI_info, 
                    min_x = 1525, 
                    max_x = 1600,
                    max_y = 560,
                    refresh = true
                })
                
                -- 使用表来筛选符合条件的控件
                local filtered_controls = {}
                for _, control in ipairs(controls) do
                    if control.name_utf8 == "" and control.left == 1544.625 then
                        table.insert(filtered_controls, control)
                    end
                end
                
                if #filtered_controls == 0 then
                    poe2_api.dbgp("未找到符合条件的UI控件")
                    return false
                end
                
                -- 使用排序方法找到最小top值
                table.sort(filtered_controls, function(a, b)
                    return a.top < b.top
                end)
                
                local min_top = filtered_controls[1].top
                poe2_api.dbgp("最小top值:", min_top)
                return min_top
            end
            if current_map ~= teleport_area then
                if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81,refresh = true}) then
                    poe2_api.click_keyboard("i")
                end
                if poe2_api.find_text({ UI_info = UI_info, text = "傳送點", refresh = true,min_x = 0 }) then
                    local ctime = api_GetTickCount64()
                    if ctime - self.s_time > 30 * 1000 then
                        poe2_api.click_keyboard("space")
                        self.s_time = 0
                    end
                    if self.last_click_time == 0 then
                        self.last_click_time = api_GetTickCount64()
                    end
                    if api_GetTickCount64() - self.last_click_time > self.click_cooldown * 1000 then
                        poe2_api.find_text({ UI_info = UI_info, text = "傳送點", click = 2, refresh = true })
                        self.last_click_time = 0
                    end
                    return bret.RUNNING
                else
                    local mini_top = switch_ground()
                    if not mini_top then
                        return bret.RUNNING
                    end
                    self.s_time = 0
                    if string.find(teleport_area, "G1") and not poe2_api.find_text({UI_info = env.UI_info, text = "奧格姆郡，約恆曆", min_x = 0, match = 2, refresh = true}) then
                        poe2_api.find_text({ UI_info = UI_info, text = "第 1 章", click = 2, refresh = true })
                        api_Sleep(600)
                        poe2_api.dbgp("切层级")
                        api_Sleep(600)
                        api_ClickScreen(1567, poe2_api.toInt(mini_top) + 22, 0)
                        api_Sleep(600)
                        api_ClickScreen(1567, poe2_api.toInt(mini_top) + 22, 1)
                        api_Sleep(600)
                        return bret.RUNNING
                    elseif string.find(teleport_area, "G2") and not poe2_api.find_text({UI_info = env.UI_info, text = "七大水域之地", min_x = 0, match = 2, refresh = true}) then
                        poe2_api.find_text({ UI_info = UI_info, text = "第 2 章", click = 2, refresh = true })
                        api_Sleep(600)
                        poe2_api.dbgp("切层级")
                        api_Sleep(600)
                        api_ClickScreen(1567, poe2_api.toInt(mini_top) + 22, 0)
                        api_Sleep(600)
                        api_ClickScreen(1567, poe2_api.toInt(mini_top) + 22, 1)
                        api_Sleep(600)
                        return bret.RUNNING
                    elseif string.find(teleport_area, "G3") and not poe2_api.find_text({UI_info = env.UI_info, text = "奧札爾區域草稿 #", min_x = 0, match = 2, refresh = true}) and not poe2_api.find_text({UI_info = env.UI_info, text = "古奧札爾草稿", min_x = 0, match = 2, refresh = true}) then
                        poe2_api.find_text({ UI_info = UI_info, text = "第 3 章", click = 2, refresh = true })
                        api_Sleep(600)
                        poe2_api.dbgp("切层级")
                        api_Sleep(600)
                        api_ClickScreen(1567, poe2_api.toInt(mini_top) + 22, 0)
                        api_Sleep(600)
                        api_ClickScreen(1567, poe2_api.toInt(mini_top) + 22, 1)
                        api_Sleep(600)
                        return bret.RUNNING
                    elseif string.find(teleport_area, "G4") and not poe2_api.find_text({UI_info = env.UI_info, text = "金司馬區港", min_x = 0, match = 2, refresh = true}) then
                        api_Sleep(600)
                        poe2_api.find_text({ UI_info = UI_info, text = "第 4 章", click = 2, refresh = true })
                        api_Sleep(600)
                        return bret.RUNNING
                    elseif string.find(teleport_area, "P") then
                        api_Sleep(600)
                        poe2_api.find_text({ UI_info = UI_info, text = "間歇", click = 2, refresh = true })
                        api_Sleep(600)
                        if not string.find(current_map, "P") then
                            env.waypoint = api_GetTeleportationPoint()
                            api_Sleep(600)
                            if not poe2_api.Waypoint_is_open("P1_Town", env.waypoint) then
                                return bret.RUNNING
                            end
                        end
                    end
                    if poe2_api.find_text({UI_info = env.UI_info, text = "奧格姆郡，約恆曆", min_x = 0, match = 2}) or 
                        poe2_api.find_text({UI_info = env.UI_info, text = "七大水域之地", min_x = 0, match = 2}) or 
                        poe2_api.find_text({UI_info = env.UI_info, text = "奧札爾區域草稿 #", min_x = 0, match = 2}) or 
                        poe2_api.find_text({UI_info = env.UI_info, text = "古奧札爾草稿", min_x = 0, match = 2}) or
                        poe2_api.find_text({UI_info = env.UI_info, text = "金司馬區港", min_x = 0, match = 2}) or
                        string.find(teleport_area, "P") then
                        if not poe2_api.find_text({ UI_info = UI_info, text = task_area_name, click = 0, refresh = true }) then
                            if #(poe2_api.task_area_list_data(teleport_area)) < 3 then
                                waypoint_screen = poe2_api.waypoint_pos(teleport_area,env.waypoint)
                                if waypoint_screen[1] <= 0 or waypoint_screen[2] <= 0  then
                                    poe2_api.dbgp("获取传送点失败，重新获取传送点")
                                    api_Sleep(1000)
                                    env.waypoint = api_GetTeleportationPoint()
                                    api_Sleep(1000)
                                    return bret.RUNNING
                                end
                                if teleport_area == "G2_town" then
                                    api_Sleep(1000)
                                    env.waypoint = api_GetTeleportationPoint()
                                    api_Sleep(1000)
                                    waypoint_screen = poe2_api.waypoint_pos(teleport_area,env.waypoint)
                                end
                                api_ClickScreen(poe2_api.toInt(waypoint_screen[1]), poe2_api.toInt(waypoint_screen[2]), 0)
                                api_Sleep(1000)
                                if teleport_area ~= "G3_town" and not poe2_api.find_text({ UI_info = UI_info, text = task_area_name, click = 0,min_x = 0, refresh = true }) then
                                    api_Sleep(300)
                                    poe2_api.click_keyboard("space")
                                    return bret.RUNNING
                                end
                                api_Sleep(300)
                                if string.find(teleport_area, "own") or poe2_api.table_contains(teleport_area, {"G1_7","G2_1"}) then
                                    poe2_api.dbgp("回城镇或者去G1_7")
                                    api_ClickScreen(poe2_api.toInt(waypoint_screen[1]), poe2_api.toInt(waypoint_screen[2]), 1)
                                    return bret.RUNNING
                                end
                                if not string.find(teleport_area, "own") and not poe2_api.table_contains(teleport_area, {"G1_7","G2_1"}) and
                                    not poe2_api.find_text({ UI_info = UI_info, text = "副本管理員", click = 0, refresh = true }) then
                                    poe2_api.ctrl_left_click(waypoint_screen[1],waypoint_screen[2])
                                    api_Sleep(2000)
                                end
                                local point = poe2_api.find_text({ UI_info = UI_info, text = "新副本", min_x = 0, position = 3, refresh = true })
                                poe2_api.find_text({ UI_info = UI_info, text = "新副本", click = 2, min_x = 0, refresh = true })
                                if point and #point > 0  then
                                    api_ClickScreen(poe2_api.toInt(point[1]), poe2_api.toInt(point[2]), 1)
                                elseif teleport_area == "G1_7" then
                                    api_ClickScreen(poe2_api.toInt(waypoint_screen[1]), poe2_api.toInt(waypoint_screen[2]), 1)
                                end
                                return bret.RUNNING
                            else
                                poe2_api.dbgp("切地下层级")
                                api_ClickScreen(1567, poe2_api.toInt(mini_top) + 22, 0)
                                api_Sleep(300)
                                api_ClickScreen(1567, poe2_api.toInt(mini_top) + 22, 1)
                                api_Sleep(2000)
                            end
                        end
                    elseif #(poe2_api.task_area_list_data(teleport_area)) < 3 then
                        poe2_api.dbgp("切地上层级")
                        api_ClickScreen(1567, poe2_api.toInt(mini_top) + 22, 0)
                        api_Sleep(300)
                        api_ClickScreen(1567, poe2_api.toInt(mini_top) + 22, 1)
                        api_Sleep(2000)
                    end
                   
                    if #(poe2_api.task_area_list_data(teleport_area)) > 2 then
                        env.waypoint = api_GetTeleportationPoint()
                        local task_two_area_name = poe2_api.task_area_list_data(teleport_area)[3]
                        teleport_area = teleport_area.."_Underground"
                        waypoint_screen = poe2_api.waypoint_pos(teleport_area,env.waypoint)
                        api_Sleep(1000)
                        api_ClickScreen(poe2_api.toInt(waypoint_screen[1]), poe2_api.toInt(waypoint_screen[2]), 0)
                        api_Sleep(1000)
                        if not poe2_api.find_text({ UI_info = UI_info, text = task_two_area_name, click = 0, min_x = 0, refresh = true }) then
                            api_Sleep(300)
                            poe2_api.click_keyboard("space")
                            return bret.RUNNING
                        end
                        if not string.find(teleport_area, "own") and
                            not poe2_api.find_text({ UI_info = UI_info, text = "副本管理員", click = 0, refresh = true }) then
                            poe2_api.ctrl_left_click(waypoint_screen[1],waypoint_screen[2])
                            api_Sleep(2000)
                        end
                        local point = poe2_api.find_text({ UI_info = UI_info, text = "新副本", min_x = 0, position = 3, refresh = true })
                        poe2_api.find_text({ UI_info = UI_info, text = "新副本", click = 2, min_x = 0, refresh = true })
                        if point then
                            api_ClickScreen(poe2_api.toInt(point[1]), poe2_api.toInt(point[2]), 1)
                        end
                    end
                    env.map_name = nil
                    return bret.RUNNING
                end
            else
                return bret.SUCCESS
            end
        end
    },

    -- 是否在新手剧情（技能）
    Not_In_New_Area_Skill = {
        run = function(self, env)
            poe2_api.print_log("是否在新手剧情（技能）模块开始执行...")
            poe2_api.dbgp("=== 是否在新手剧情（技能） ===")
            local player_info = env.player_info
            local UI_info = env.UI_info
            local user_config = env.user_config
            local items = env.bag_info
            local current_time = api_GetTickCount64()
            if player_info.current_map_name_utf8 == "G1_1" then
                poe2_api.dbgp('全部技能信息')
                env.allskill_info = api_GetAllSkill()
                poe2_api.dbgp('获取可选技能控件')
                env.selectable_skills = api_GetSelectableSkillControls()
                local selectable_skills = env.selectable_skills
                poe2_api.dbgp('技能槽信息')
                env.skill_slots = api_GetSkillSlots()
                local skill_slots = env.skill_slots
                local function check_skill_in_pos(name)
                    poe2_api.dbgp("[check_skill_in_pos] 检查技能是否在技能栏上: " .. tostring(name))
                    for _, k in ipairs(skill_slots) do
                        if name == k.name_utf8 then
                            poe2_api.dbgp("[check_skill_in_pos] 技能在技能栏上: " .. tostring(name))
                            return true
                        end
                    end
                    poe2_api.dbgp("[check_skill_in_pos] 技能不在技能栏上: " .. tostring(name))
                    return false
                end
                
                local function skill_location(skill_name, skill_pos)
                    poe2_api.dbgp("[skill_location] 检查技能位置: " .. tostring(skill_name) .. " 位置: " .. tostring(skill_pos))
                    local point = my_game_info.skill_pos[skill_pos]
                    local skill_names = {}
                    for _, skill_control in ipairs(selectable_skills) do
                        poe2_api.printTable(skill_control)
                        skill_names[skill_control.text_utf8] = true
                    end
                    -- 检查 skill_name 是否在集合中
                    if not skill_names[skill_name] then
                        poe2_api.dbgp("[skill_location] 技能不在可选列表中: " .. tostring(skill_name))
                        return false
                    end
                    -- 遍历所有可选择的技能控件
                    for _, skill_control in ipairs(selectable_skills) do
                        if skill_name == skill_control.text_utf8 then
                            -- 计算中间位置
                            local center_x = (skill_control.left + skill_control.right) / 2
                            local center_y = (skill_control.top + skill_control.bottom) / 2
                            
                            -- 检查位置是否在指定范围内
                            if (point[1] - 5 < center_x and center_x < point[1] + 5) and 
                            (point[2] - 5 < center_y and center_y < point[2] + 5) then
                                poe2_api.dbgp("[skill_location] 技能位置正确: " .. tostring(skill_name))
                                return true
                            else
                                poe2_api.dbgp("[skill_location] 技能位置不正确: " .. tostring(skill_name) .. " 坐标: " .. center_x .. "," .. center_y)
                            end
                        end
                    end
                    
                    poe2_api.dbgp("[skill_location] 技能位置检查失败: " .. tostring(skill_name))
                    return false
                end
                
                local function is_skills(name)
                    poe2_api.dbgp("[is_skills] 检查技能是否存在: " .. tostring(name))
                    for k, v in ipairs(env.allskill_info) do
                        if v.name_utf8 == name then
                            poe2_api.dbgp("[is_skills] 技能存在: " .. tostring(name))
                            return true
                        end
                    end
                    poe2_api.dbgp("[is_skills] 技能不存在: " .. tostring(name))
                    return false
                end
                
                local function is_adjust_skills()
                    poe2_api.dbgp("[is_adjust_skills] 开始检查是否需要调整技能")
                    local skills = poe2_api.get_BD_info(user_config["劇情設置"]['職業'], "技能")
                    poe2_api.dbgp("skills",skills)
                    poe2_api.printTable(skills)
                    for k, v in pairs(skills) do
                        poe2_api.dbgp("[is_adjust_skills] 检查技能: " .. tostring(k) .. " - " .. tostring(v["skill_name"]))
                        -- 技能列表没有技能
                        if not is_skills(v["skill_name"]) then
                            env.skill_pos = v["skill_pos"]
                            env.skill_name = k
                            poe2_api.dbgp("[is_adjust_skills] 需要调整: 技能不存在")
                            return true
                        
                        -- 技能列表有技能，但是不在技能栏上
                        elseif not check_skill_in_pos(v["skill_name"]) and v["primary_or_secondary"] then
                            env.skill_pos = v["skill_pos"]
                            env.skill_name = k
                            poe2_api.dbgp("[is_adjust_skills] 需要调整: 技能不在技能栏上")
                            return true
                        
                        -- 技能列表有技能，但是不在指定位置
                        elseif not skill_location(v["skill_name"], v["skill_pos"]) and v["primary_or_secondary"] then
                            env.skill_pos = v["skill_pos"]
                            env.skill_name = k
                            poe2_api.dbgp("[is_adjust_skills] 需要调整: 技能位置不正确")
                            return true
                        end
                    end
                    
                    poe2_api.dbgp("[is_adjust_skills] 无需调整技能")
                    return false
                end
                
                local function is_exist(name)
                    poe2_api.dbgp("[is_exist] 检查物品是否存在: " .. tostring(name))
                    local level = poe2_api.get_BD_info(user_config["劇情設置"]['職業'], "技能", env.skill_name, "level_skillstone")
                    poe2_api.dbgp("[is_exist] 所需等级: " .. tostring(level))
                    if items and #items > 0 then
                        for _, item in ipairs(items) do
                            if item.name_utf8 == name and item.skillGemLevel == level then
                                poe2_api.dbgp("[is_exist] 物品存在: " .. tostring(name) .. " 等级: " .. tostring(level))
                                return true
                            end
                        end
                    end
                    poe2_api.dbgp("[is_exist] 物品不存在: " .. tostring(name))
                    return false
                end

                
                -- 判断武器技能是否存在
                local function is_weapon_skill()
                    poe2_api.dbgp("[is_weapon_skill] 检查武器技能")
                    for _, skill_info in pairs(env.allskill_info) do
                        if skill_info.name_utf8 ~= "" and not skill_info.name_utf8:find("WeaponGrantedSummon") then
                            if skill_info.name_utf8:find("WeaponGranted") or poe2_api.table_contains(skill_info.name_utf8, {"FireboltPlayer","MeleeBowPlayer","MeleeCrossbowPlayer","MeleeSpearOffHandPlayer","Melee1HMacePlayer","MeleeQuarterstaffPlayer"}) then
                                poe2_api.dbgp("[is_weapon_skill] 找到武器技能: " .. tostring(skill_info.name_utf8))
                                return skill_info.name_utf8
                            end
                        end
                    end
                    poe2_api.dbgp("[is_weapon_skill] 未找到武器技能")
                    return false
                end
                
                -- 判断技能列表中有无自定义技能 背包有无技能石
                local function get_skill_names()
                    poe2_api.dbgp("[get_skill_names] 开始获取技能名称")
                    
                    local function get_skill()
                        poe2_api.dbgp("[get_skill] 获取角色技能")
                        local skills = poe2_api.get_BD_info(user_config["劇情設置"]['職業'], "技能")
                        for k, v in pairs(skills) do
                            local name = k:gsub(" ", "") .. "Player"
                            poe2_api.dbgp("[get_skill] 检查技能: " .. tostring(name))
                            for _, skill_info in pairs(env.allskill_info) do
                                if skill_info.name_utf8 ~= "" and not skill_info.name_utf8:find("WeaponGranted") and skill_info.name_utf8:find(name) then
                                    poe2_api.dbgp("[get_skill] 找到自定义技能: " .. tostring(skill_info.name_utf8))
                                    return true
                                end
                            end
                        end
                        poe2_api.dbgp("[get_skill] 未找到自定义技能")
                        return false
                    end
                
                    local function get_backpack()
                        poe2_api.dbgp("[get_backpack] 检查背包技能石")
                        if items then
                            for _, item in ipairs(items) do
                                if item.baseType_utf8 == "技能寶石" then
                                    poe2_api.dbgp("[get_backpack] 找到技能石: " .. tostring(item.name_utf8))
                                    return true
                                end
                            end
                        end
                        poe2_api.dbgp("[get_backpack] 未找到技能石")
                        return false
                    end
                
                    local function get_paskill(name)
                        poe2_api.dbgp("[get_paskill] 检查技能位置: " .. tostring(name))
                        local skill_slots = env.skill_slots
                        if not skill_slots then
                            poe2_api.dbgp("[get_paskill] 技能槽信息为空")
                            return false
                        else
                            for _, slot in ipairs(skill_slots) do
                                if slot.name_utf8 == name then
                                    poe2_api.dbgp("[get_paskill] 找到技能: " .. tostring(name))
                                    if not skill_location(name, "Q") then
                                        poe2_api.dbgp("[get_paskill] 技能位置不正确")
                                        return false
                                    end
                                    poe2_api.dbgp("[get_paskill] 技能位置正确")
                                    return true
                                end
                            end
                            poe2_api.dbgp("[get_paskill] 未找到技能: " .. tostring(name))
                            return false
                        end
                    end
                
                    if not get_skill() and not get_backpack() then
                        poe2_api.dbgp("[get_skill_names] 需要检查武器技能")
                        local name = is_weapon_skill()
                        if not name then
                            name = "MeleeUnarmedPlayer"
                            poe2_api.dbgp("[get_skill_names] 使用默认武器技能: " .. tostring(name))
                        end
                        if not get_paskill(name) then
                            poe2_api.dbgp("[get_skill_names] 武器技能检查失败")
                            return false
                        end
                    end
                    poe2_api.dbgp("[get_skill_names] 技能检查完成")
                    return true
                end

                local bool = get_skill_names()
                -- 移动装备 and 技能列表有自定义技能或者有技能石才调自定义技能
                if  bool then
                    if not is_adjust_skills() then
                        if poe2_api.find_text({UI_info = env.UI_info, text = "技能", min_x = 0, min_y = 32, max_x = 381, max_y = 81}) then
                            poe2_api.click_keyboard("space")
                            return bret.RUNNING
                        end
                        if poe2_api.find_text({UI_info = env.UI_info, text = "點擊  <N>{<normal>{I}} 查看背包。", min_x = 450, min_y = 600}) then
                            poe2_api.click_keyboard("i")
                        end
                        if poe2_api.find_text({UI_info = env.UI_info, text = "按下<normal>{<n>{W}}來使用你的新技能", min_x = 0}) then
                            poe2_api.click_keyboard("w")
                        end
                        return bret.SUCCESS
                    end
                    
                    local skill = poe2_api.get_BD_info(user_config["劇情設置"]['職業'], "技能", env.skill_name, "skill_name")
                    if skill and not is_skills(skill) and not poe2_api.check_item_in_inventory(env.skill_name,items) and not is_exist("技能寶石") then
                        if poe2_api.find_text({UI_info = env.UI_info, text = "技能", min_x = 0, min_y = 32, max_x = 381, max_y = 81}) then
                            poe2_api.click_keyboard("space")
                            return bret.RUNNING
                        end
                        if poe2_api.find_text({UI_info = env.UI_info, text = "點擊  <N>{<normal>{I}} 查看背包。", min_x = 450, min_y = 600}) then
                            poe2_api.click_keyboard("w")
                        end
                        if poe2_api.find_text({UI_info = env.UI_info, text = "按下<normal>{<n>{W}}來使用你的新技能", min_x = 0}) then
                            poe2_api.click_keyboard("w")
                        end
                        return bret.SUCCESS
                    end
                else
                    if not bool then
                        local skill_name = is_weapon_skill()
                        env.skill_pos = "Q"
                        if skill_name then
                            env.skill_name = skill_name
                        else
                            env.skill_name = "MeleeUnarmedPlayer"
                        end
                    end
                end
                poe2_api.dbgp("[is_fast_skill] 检查技能: " .. tostring(env.skill_name))
                return bret.FAIL
            end
            if poe2_api.find_text({ UI_info = env.UI_info, text = "技能", min_x = 0, min_y = 32, max_x = 381, max_y = 81 }) then
                poe2_api.click_keyboard("esc")
                return bret.RUNNING
            end
            poe2_api.time_p("Not_In_New_Area_Skill",api_GetTickCount64() - current_time ) 
            return bret.SUCCESS
        end
    },

    Is_Fast_Skill = {
        run = function(self, env)
            local function check_skill_in_pos()
                local skill_name = env.skill_name
                
                -- 检查是否是武器技能
                if string.find(skill_name, "WeaponGranted") or poe2_api.table_contains(skill_name, {"FireboltPlayer", "MeleeBowPlayer", "MeleeCrossbowPlayer", "MeleeSpearOffHandPlayer", "Melee1HMacePlayer", "MeleeQuarterstaffPlayer"}) then
                    return true
                end
                
                -- 检查技能是否在技能栏上
                local shortcut_skill_info = env.skill_slots or {}
                for _, k in ipairs(shortcut_skill_info) do
                    if skill_name == k.name_utf8 then
                        poe2_api.dbgp("[check_skill_in_pos] 技能在技能栏上: " .. tostring(skill_name))
                        return true
                    end
                end
                
                poe2_api.dbgp("[check_skill_in_pos] 技能不在技能栏上: " .. tostring(skill_name))
                return false
            end
            
            local function skill_location()
                local skill_name = env.skill_name
                local skill_pos = env.skill_pos
                
                poe2_api.dbgp("[skill_location] 检查技能位置: " .. tostring(skill_name) .. " 位置: " .. tostring(skill_pos))
                
                local point = my_game_info.skill_pos[skill_pos]
                local selectable_skills = env.selectable_skills or {}
                
                -- 检查技能是否在可选列表中
                local skill_names = {}
                for _, skill in ipairs(selectable_skills) do
                    skill_names[skill.text_utf8] = true
                end
                
                if not skill_names[skill_name] then
                    poe2_api.dbgp("[skill_location] 技能不在可选列表中: " .. tostring(skill_name))
                    return false
                end
                
                -- 检查技能位置
                for _, skill_control in ipairs(selectable_skills) do
                    if skill_name == skill_control.text_utf8 then
                        -- 计算中间位置
                        local center_x = (skill_control.left + skill_control.right) / 2
                        local center_y = (skill_control.top + skill_control.bottom) / 2
                        
                        -- 检查位置是否在指定范围内
                        if (point[1] - 5 < center_x and center_x < point[1] + 5) and 
                           (point[2] - 5 < center_y and center_y < point[2] + 5) then
                            poe2_api.dbgp("[skill_location] 技能位置正确: " .. tostring(skill_name))
                            return true
                        else
                            poe2_api.dbgp("[skill_location] 技能位置不正确: " .. tostring(skill_name) .. " 坐标: " .. center_x .. "," .. center_y)
                        end
                    end
                end
                
                poe2_api.dbgp("[skill_location] 技能位置检查失败: " .. tostring(skill_name))
                return false
            end
            
            -- 主逻辑
            if not check_skill_in_pos() then
                return bret.FAIL
            end
            
            if not skill_location() then
                return bret.SUCCESS
            end
            
            return bret.RUNNING
        end
    },

    Adjust_Skills = {
        run = function(self, env)
            local user_config = env.user_config 
            local function set_pos()
                local selectable_skills = env.selectable_skills or {}
                local skill_name = env.skill_name
                
                poe2_api.dbgp("[set_pos] 开始设置技能位置，技能名称: " .. tostring(skill_name))
                poe2_api.dbgp("[set_pos] 可选技能数量: " .. tostring(#selectable_skills))
                
                for _, k in ipairs(selectable_skills) do
                    poe2_api.dbgp("[set_pos] 检查技能: " .. tostring(k.text_utf8) .. " 坐标: (" .. k.left .. "," .. k.top .. ")")
                    
                    if skill_name == "" then
                        poe2_api.dbgp("[set_pos] 处理空技能名称情况")
                        if 1104 <= k.left and k.left <= 1597 and 562 <= k.top and k.top <= 841 and skill_name == k.text_utf8 then
                            local center_x = (k.left + k.right) / 2
                            local center_y = (k.top + k.bottom) / 2
                            poe2_api.dbgp("[set_pos] 找到空技能位置，点击坐标: (" .. math.floor(center_x) .. "," .. math.floor(center_y) .. ")")
                            api_ClickScreen(math.floor(center_x), math.floor(center_y), 0)
                            api_Sleep(500)
                            api_ClickScreen(math.floor(center_x), math.floor(center_y), 1)
                            api_Sleep(2000)
                            return true
                        end
                        
                    elseif skill_name == "MeleeUnarmedPlayer" or string.find(skill_name or "", "WeaponGranted") or poe2_api.table_contains(skill_name, {"FireboltPlayer", "MeleeBowPlayer", "MeleeCrossbowPlayer", "MeleeSpearOffHandPlayer", "Melee1HMacePlayer", "MeleeQuarterstaffPlayer"}) then
                        poe2_api.dbgp("[set_pos] 处理武器技能: " .. tostring(skill_name))
                        if skill_name == "MeleeUnarmedPlayer" then
                            poe2_api.dbgp("[set_pos] 处理徒手技能")
                            if 1104 <= k.left and k.left <= 1597 and 562 <= k.top and k.top <= 841 and skill_name == k.text_utf8 then
                                local center_x = (k.left + k.right) / 2
                                local center_y = (k.top + k.bottom) / 2
                                poe2_api.dbgp("[set_pos] 找到徒手技能位置，点击坐标: (" .. math.floor(center_x) .. "," .. math.floor(center_y) .. ")")
                                api_ClickScreen(math.floor(center_x), math.floor(center_y), 0)
                                api_Sleep(500)
                                api_ClickScreen(math.floor(center_x), math.floor(center_y), 1)
                                api_Sleep(2000)
                                return true
                            end
                        else
                            poe2_api.dbgp("[set_pos] 处理其他武器技能")
                            if 1104 <= k.left and k.left <= 1597 and 562 <= k.top and k.top <= 841 and skill_name == k.text_utf8 then
                                local center_x = (k.left + k.right) / 2
                                local center_y = (k.top + k.bottom) / 2
                                poe2_api.dbgp("[set_pos] 找到武器技能位置，点击坐标: (" .. math.floor(center_x) .. "," .. math.floor(center_y) .. ")")
                                api_ClickScreen(math.floor(center_x), math.floor(center_y), 0)
                                api_Sleep(500)
                                api_ClickScreen(math.floor(center_x), math.floor(center_y), 1)
                                api_Sleep(2000)
                                return true
                            end
                        end
                        
                    else
                        poe2_api.dbgp("[set_pos] 处理普通技能")
                        -- 检查位置是否在指定范围内 FallingThunderPlayer MeleeQuarterstaffPlayer
                        local skill = poe2_api.get_BD_info(user_config["劇情設置"]['職業'], "技能", env.skill_name, "skill_name")
                        poe2_api.dbgp("[set_pos] 从配置获取的技能名称: " .. tostring(skill))
                        
                        if skill and 1104 <= k.left and k.left <= 1597 and 562 <= k.top and k.top <= 841 and string.find(k.text_utf8 or "", skill) then
                            local center_x = (k.left + k.right) / 2
                            local center_y = (k.top + k.bottom) / 2
                            poe2_api.dbgp("[set_pos] 找到普通技能位置，点击坐标: (" .. math.floor(center_x) .. "," .. math.floor(center_y) .. ")")
                            api_ClickScreen(math.floor(center_x), math.floor(center_y), 0)
                            api_Sleep(500)
                            api_ClickScreen(math.floor(center_x), math.floor(center_y), 1)
                            api_Sleep(2000)
                            return true
                        end
                    end
                end
                
                poe2_api.dbgp("[set_pos] 未找到匹配的技能位置")
                return false
            end
            
            poe2_api.dbgp("开始设置技能位置流程")
            if not set_pos() then
                poe2_api.dbgp("[set_pos] 使用默认技能位置: " .. tostring(env.skill_pos))
                local point = my_game_info.skill_pos[env.skill_pos]
                if point then
                    poe2_api.dbgp("[set_pos] 点击默认位置坐标: (" .. math.floor(point[1]) .. "," .. math.floor(point[2]) .. ")")
                    api_ClickScreen(math.floor(point[1]), math.floor(point[2]), 0)
                    api_Sleep(100)
                    api_ClickScreen(math.floor(point[1]), math.floor(point[2]), 1)
                    api_Sleep(2000)
                else
                    poe2_api.dbgp("[set_pos] 错误: 未找到技能位置 " .. tostring(env.skill_pos) .. " 的坐标点")
                end
            else
                poe2_api.dbgp("[set_pos] 成功设置技能位置")
            end
            return bret.RUNNING
        end
    },

    Is_Skill_In_Skill_List = {
        run = function(self, env)
            local skill_name = env.skill_name
            poe2_api.dbgp("[技能检查] 开始检查技能，技能名称: " .. tostring(skill_name))
            local function is_skills(name)
                poe2_api.dbgp("[is_skills] 检查技能是否存在: " .. tostring(name))
                for k, v in ipairs(env.allskill_info) do
                    if v.name_utf8 == name then
                        poe2_api.dbgp("[is_skills] 技能存在: " .. tostring(name))
                        return true
                    end
                end
                poe2_api.dbgp("[is_skills] 技能不存在: " .. tostring(name))
                return false
            end
            -- 检查空技能名、徒手技能或武器技能
            if skill_name == "" or skill_name == "MeleeUnarmedPlayer" or string.find(skill_name or "", "WeaponGranted") then
                poe2_api.dbgp("[技能检查] 满足条件（空技能/徒手技能/武器技能），返回成功")
                return bret.SUCCESS
            end

            poe2_api.dbgp("[技能检查] 不是空技能/徒手技能/武器技能，继续检查配置")

            -- 检查技能是否存在
            local skill_config_name = poe2_api.get_BD_info(env.user_config["劇情設置"]['職業'], "技能", skill_name, "skill_name")
            poe2_api.dbgp("[技能检查] 从配置获取的技能名称: " .. tostring(skill_config_name))

            local skill_exists = false

            if skill_config_name then
                poe2_api.dbgp("[技能检查] 调用 is_skills 函数检查技能是否存在")
                -- 调用 is_skills 函数检查技能是否存在
                skill_exists = is_skills(skill_config_name)
                poe2_api.dbgp("[技能检查] is_skills 返回结果: " .. tostring(skill_exists))
            else
                poe2_api.dbgp("[技能检查] 未从配置中找到技能名称")
            end

            if skill_exists then
                poe2_api.dbgp("[技能检查] 技能存在，返回成功")
                return bret.SUCCESS
            end

            poe2_api.dbgp("[技能检查] 技能不存在，返回失败")
            return bret.FAIL
        end
    },

    Is_Bag_Have_Skill_Stone = {
        run = function(self, env)
            local skill_name = env.skill_name
            local bag_info = env.bag_info

            poe2_api.dbgp("[背包检查] 开始检查背包物品，技能名称: " .. tostring(skill_name))
            poe2_api.dbgp("[背包检查] 背包信息: " .. tostring(bag_info and #bag_info or 0) .. " 个物品")

            -- 检查背包中是否有指定物品
            local has_item = poe2_api.check_item_in_inventory(skill_name, bag_info)

            poe2_api.dbgp("[背包检查] backpack_items 返回结果: " .. tostring(has_item))

            if has_item then
                poe2_api.dbgp("[背包检查] 背包中存在物品，返回成功")
                return bret.SUCCESS
            end

            poe2_api.dbgp("[背包检查] 背包中不存在物品，返回失败")
            return bret.FAIL
        end
    },

    Put_Skill_In_Skill_List = {
        run = function(self, env) 
            
            poe2_api.dbgp("开始检查背包和技能文本")

            -- 检查背包文本
            if not poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                poe2_api.dbgp("未找到背包文本，按下I键打开背包")
                poe2_api.click_keyboard("i")
                return bret.RUNNING
            else
                poe2_api.dbgp("已找到背包文本")
            end

            -- 检查技能文本
            if not poe2_api.find_text({UI_info = env.UI_info, text = "技能", min_x = 0}) then
                poe2_api.dbgp("未找到技能文本，开始检查背包物品")
                local items = env.bag_info
                if items then
                    poe2_api.dbgp("背包物品数量: " .. tostring(#items))
                    for _, item in ipairs(items) do
                        poe2_api.dbgp("检查物品: " .. tostring(item.name_utf8) .. " (类型: " .. tostring(item.baseType_utf8) .. ")")
                        if item.baseType_utf8 == env.skill_name then
                            poe2_api.dbgp("找到匹配的技能物品: " .. tostring(item.name_utf8))
                            -- 计算中心坐标
                            local start_cell = {item.start_x, item.start_y}
                            local end_cell = {item.end_x, item.end_y}
                            local center_position = poe2_api.get_center_position(start_cell, end_cell)
                            poe2_api.dbgp("物品坐标: 起始(" .. item.start_x .. "," .. item.start_y .. ") 结束(" .. item.end_x .. "," .. item.end_y .. ")")
                            poe2_api.dbgp("中心坐标: (" .. math.floor(center_position[1]) .. "," .. math.floor(center_position[2]) .. ")")

                            api_ClickScreen(math.floor(center_position[1]), math.floor(center_position[2]), 0)
                            api_Sleep(500)
                            api_ClickScreen(math.floor(center_position[1]), math.floor(center_position[2]), 2)
                            poe2_api.dbgp("已右键点击物品")
                        end
                    end
                else
                    poe2_api.dbgp("背包信息为空")
                end
                return bret.RUNNING
            else
                poe2_api.dbgp("已找到技能文本")
            end

            poe2_api.dbgp("开始处理背包中的技能物品")
            local items = env.bag_info
            if items then
                poe2_api.dbgp("背包物品数量: " .. tostring(#items))
                for _, item in ipairs(items) do
                    poe2_api.dbgp("检查物品: " .. tostring(item.name_utf8) .. " (类型: " .. tostring(item.baseType_utf8) .. ")")
                    if item.baseType_utf8 == env.skill_name then
                        poe2_api.dbgp("找到匹配的技能物品: " .. tostring(item.name_utf8))
                        -- 计算中心坐标
                        local start_cell = {item.start_x, item.start_y}
                        local end_cell = {item.end_x, item.end_y}
                        local center_position = poe2_api.get_center_position(start_cell, end_cell)
                        poe2_api.dbgp("物品坐标: 起始(" .. item.start_x .. "," .. item.start_y .. ") 结束(" .. item.end_x .. "," .. item.end_y .. ")")
                        poe2_api.dbgp("中心坐标: (" .. math.floor(center_position[1]) .. "," .. math.floor(center_position[2]) .. ")")

                        api_ClickScreen(math.floor(center_position[1]), math.floor(center_position[2]), 0)
                        api_Sleep(500)
                        poe2_api.ctrl_left_click(center_position[1], center_position[2])
                        poe2_api.dbgp("已Ctrl+左键点击物品")
                        poe2_api.sleep(1000)
                    end
                end
            else
                poe2_api.dbgp("背包信息为空")
            end

            poe2_api.dbgp("处理完成，返回运行状态")
            return bret.RUNNING
        end
    },
    -- 是否需要攻击
    Check_Is_Need_Attack = {
        run = function(self, env)
            poe2_api.dbgp("Check_Is_Need_Attack是否需要攻击模块开始执行...")
            poe2_api.print_log("Check_Is_Need_Attack是否需要攻击模块开始执行...")
            local player_info = env.player_info
            local UI_info = env.UI_info
            local current_time = api_GetTickCount64()
            local range_info = env.range_info
            local boss_name = env.boss_name
            local stuck_monsters = env.stuck_monsters
            local not_attack_mos = env.not_attack_mos
            local team_info = env.team_info
            local user_config = env.user_config
            local attack_dis_map = 100
            local team_member_2 = poe2_api.get_team_info(team_info, user_config, player_info, 2)
            if player_info.current_map_name_utf8 == "G4_8b" and team_member_2 == "大號名" then
                for _, v in ipairs(range_info) do
                    if v.name_utf8 == "骨牆" and v.hasLineOfSight and v.isActive and v.life > 0 then
                        poe2_api.dbgp("[Check_Is_Need_Attack] G4_8b-发现骨牆，需要攻击")
                        env.space = false
                        return bret.FAIL
                    end
                end
            end
            if (poe2_api.is_have_boss_distance(range_info, player_info,boss_name, 180) 
                or poe2_api.is_have_mos({range_info = range_info, player_info = player_info, dis = attack_dis_map, stuck_monsters = stuck_monsters,not_attack_mos = not_attack_mos}))
                and (team_member_2 == "大號名" or player_info.current_map_name_utf8 == "G1_1") then
                poe2_api.dbgp("需要攻击")
                poe2_api.time_p("[Check_Is_Need_Attack]",(api_GetTickCount64() - current_time))

                return bret.FAIL        
            else
                poe2_api.dbgp("不需要攻击")
                poe2_api.time_p("[Check_Is_Need_Attack]",(api_GetTickCount64() - current_time))

                return bret.SUCCESS        
            end
        end
    },

    -- 释放技能动作
    ReleaseSkillAction = {
        run = function(self, env)
            poe2_api.dbgp("ReleaseSkillAction释放技能动作模块开始执行...")
            poe2_api.print_log("ReleaseSkillAction释放技能动作模块开始执行...")
            local current_time_ms = api_GetTickCount64()
            --- 辅助函数
            -- 根据稀有度获取可释放的技能
            local available_skills = {}
            local function _get_available_skills(monster_rarity)
                -- 根据怪物稀有度获取可用技能
                local current_time = api_GetTickCount64()
                
                for _, skill in ipairs(self.skills) do
                    
                    -- 检查冷却
                    poe2_api.dbgp("current_time --> ",current_time)
                    poe2_api.dbgp("skill.name --> ",skill.name)
                    poe2_api.dbgp("self.skill_cooldowns[skill.name] --> ",self.skill_cooldowns[skill.name])
                    if current_time < (self.skill_cooldowns[skill.name] or 0) then
                        goto continue
                    end
                    
                    -- 检查技能是否适合攻击该稀有度怪物
                    if monster_rarity == 3 then  -- Boss
                        if not skill.target_targets["Boss"] then
                            goto continue
                        end
                    elseif monster_rarity == 2 then  -- 黄怪
                        if not skill.target_targets["黃怪"] then
                            goto continue
                        end
                    elseif monster_rarity == 1 then  -- 蓝怪
                        if not skill.target_targets["藍怪"] then
                            goto continue
                        end
                    elseif monster_rarity == 0 then  -- 白怪
                        if not skill.target_targets["白怪"] then
                            goto continue
                        end
                    end
                    
                    table.insert(available_skills, skill)
                    
                    ::continue::
                end
                return available_skills
            end

            -- 取可释放的单个技能
            local function _select_skill(available_skills)
                local current_time = api_GetTickCount64()
                
                -- 参数检查
                if type(available_skills) ~= "table" or #available_skills == 0 then
                    error("Invalid skills list: " .. tostring(available_skills))
                end
                
                -- 筛选有效技能（有数字间隔的技能）
                local valid_skills = {}
                for _, skill in ipairs(available_skills) do
                    if type(skill.interval) == "number" then
                        table.insert(valid_skills, skill)
                    end
                end
                
                if #valid_skills == 0 then
                    error("No valid skills with numeric intervals")
                end
                
                -- 排序技能（先按interval降序，再按priority升序）
                table.sort(valid_skills, function(a, b)
                    if a.interval ~= b.interval then
                        return a.interval > b.interval  -- 降序
                    else
                        return (a.priority or 0) < (b.priority or 0)  -- 升序
                    end
                end)
                
                -- 获取最大间隔值
                local max_interval = valid_skills[1].interval
                local candidates = {}
                for _, skill in ipairs(valid_skills) do
                    if skill.interval == max_interval then
                        table.insert(candidates, skill)
                    else
                        break  -- 因为已排序，可以提前退出
                    end
                end
                
                -- 随机选择一个候选技能
                if #candidates > 0 then
                    return candidates[math.random(#candidates)]
                else
                    return nil
                end
            end

            -- 获取技能设置
            local function parse_skill_config()
                local skill_setting = env.user_config["技能設置"]
                local new_skills = {}
                local preserved_cooldowns = {}
                local current_time = api_GetTickCount64()
                
                -- 确保skill_cooldowns表存在
                if not self.skill_cooldowns then
                    self.skill_cooldowns = {}
                end
                
                -- 遍历技能设置
                for key, skill_data in pairs(skill_setting) do
                    -- 只处理启用技能
                    if skill_data["启用"] then
                        -- 处理攻击技能
                        if skill_data["技能屬性"] == "攻击技能"then
                            local skill = {
                                name = key,
                                key = key,
                                interval = (tonumber(skill_data["釋放間隔"]) or 0) / 1000,
                                priority = 1,  -- 默认值
                                weight = 1.0,  -- 默认值
                                attack = skill_data["釋放對象"],
                                attack_range = tonumber(skill_data["攻擊距離"]) or 100,
                                target_targets = {
                                    ["白怪"] = skill_data["白怪"] or false,
                                    ["藍怪"] = skill_data["藍怪"] or false,
                                    ["黃怪"] = skill_data["黃怪"] or false,
                                    ["Boss"] = skill_data["Boss"] or false
                                }
                            }
                            
                            -- 保留原有冷却时间
                            if self.skill_cooldowns[skill.name] then
                                preserved_cooldowns[skill.name] = self.skill_cooldowns[skill.name]
                            else
                                preserved_cooldowns[skill.name] = 0
                            end
                            
                            table.insert(new_skills, skill)
                        end
                    end
                end
                
                self.skills = new_skills
                poe2_api.printTable(self.skills)
                self.skill_cooldowns = preserved_cooldowns
                
                -- 提取技能权重
                self._skill_weights = {}
                for _, skill in ipairs(self.skills) do
                    table.insert(self._skill_weights, skill.weight)
                end
                
            end
            
            -- 计算释放距离
            local function _calculate_intermediate_position(start_x, start_y, end_x, end_y, ratio)
                local current_time = api_GetTickCount64()
                ratio = ratio or 0.8  -- 默认比例0.8
                
                -- 计算方向向量
                local dx = end_x - start_x
                local dy = end_y - start_y
                
                -- 添加随机扰动（避免完全直线移动）
                if ratio > 0.5 then  -- 靠近目标时增加随机性
                    dx = dx * (0.9 + math.random() * 0.2)  -- 0.9-1.1
                    dy = dy * (0.9 + math.random() * 0.2)
                end
                
                -- 计算中间点
                local mid_x = start_x + dx * ratio
                local mid_y = start_y + dy * ratio
                
                return mid_x, mid_y
            end

            -- 选择释放对象
            local function _calculate_movement(skill, monster, player_info)
                local current_time = api_GetTickCount64()
                local target_type = skill.target or "敵對"
                local move_x, move_y, move_z = nil, nil, nil
                
                -- 根据技能目标类型计算基础位置
                if target_type == "敵對" then
                    -- 对敌人释放：向怪物方向移动，但保持一定距离
                    local angle = math.random() * 2 * math.pi  -- 随机角度
                    local distance = 2 + math.random() * 3    -- 随机距离2-5
                    move_x = monster.grid_x
                    move_y = monster.grid_y
                    move_z = monster.world_z
                    
                elseif target_type == "自身" then
                    -- 对自身释放：小范围随机移动
                    move_x = player_info.grid_x + (math.random() * 4 - 2)  -- -2到2
                    move_y = player_info.grid_y + (math.random() * 4 - 2)
                    move_z =poe2_api.toInt(player_info.world_z)
                    
                elseif target_type == "敵對尸體" then
                    -- 对尸体释放：查找最近的尸体
                    local death_em = poe2_api.enemy_death_target_object({env.range_info,env.player_info})
                    if death_em then
                        move_x = death_em.grid_x + (math.random() * 6 - 3)  -- -3到3
                        move_y = death_em.grid_y + (math.random() * 6 - 3)
                    end
                    
                elseif target_type == "友方召喚物" then
                    -- 对友方召唤物释放
                    local fr_ob = poe2_api.friendly_target_object({env.range_info,env.player_info})
                    if fr_ob then
                        move_x, move_y = api_FindNearestReachableInRange(fr_ob.grid_x,fr_ob.grid_y,20)
                    end
                end
                
                -- 默认位置（如果前面未计算）
                if move_x == nil or move_y == nil then
                    move_x = monster.grid_x
                    move_y = monster.grid_y
                    move_z = monster.world_z
                end
                
                -- 特殊技能处理（如传送类技能）
                if skill.key == '`' then
                    -- 计算玩家到怪物的中间位置
                    move_x, move_y = _calculate_intermediate_position(
                        player_info.grid_x,
                        player_info.grid_y,
                        monster.grid_x,
                        monster.grid_y,
                        0.70  -- ratio
                    )
                end
                
                -- poe2_api.dbgp(777777777777777777)
                -- 
                return move_x, move_y, move_z
            end

            -- 释放技能
            local function _execute_skill(skill, monster, player_info)
                poe2_api.dbgp("释放技能=-=-=-->>>>")
                poe2_api.printTable(skill)
                local current_time = api_GetTickCount64()
                
                -- 计算移动位置
                local move_x, move_y, move_z =  _calculate_movement(skill, monster, player_info)

                if self.attack_last_time == nil then
                    self.attack_last_time = api_GetTickCount64()
                end
                if monster.name_utf8 == "巨像．札爾瑪拉斯" then
                    poe2_api.dbgp("巨像．札爾瑪拉斯")
                    api_ClickMove(math.floor(move_x), math.floor(move_y), 0,math.floor(player_info.world_z))
                else
                    api_ClickMove(math.floor(move_x), math.floor(move_y), 0)
                end
                
                -- 设置冷却时间
                local skill_start = api_GetTickCount64()
                local base_cd = skill.interval
                poe2_api.dbgp("base_cd =-=-=-->>>>", base_cd)
                local actual_cd = (math.max(base_cd * (1 + math.random() * 0.2), 0.1)) * 1000
                self.skill_cooldowns[skill.name] = skill_start + actual_cd
                
                -- 释放技能
                poe2_api.click_keyboard(skill.key)
                poe2_api.dbgp("释放技能=-=-=-->>>>", skill.key)
            end
            
            -- 特殊boss处理
            local function _handle_special_boss_movement(boss, player_info)
                local current_time = api_GetTickCount64()
                
                -- 使用pcall进行错误处理（替代try-catch）
                -- 计算安全距离（30单位）
                local safe_distance = 30
                local angle = math.atan2(
                    boss.grid_y - player_info.grid_y,
                    boss.grid_x - player_info.grid_x
                )
                
                -- 计算目标位置（保持安全距离）
                local target_x = boss.grid_x - safe_distance * math.cos(angle)
                local target_y = boss.grid_y - safe_distance * math.sin(angle)
                
                -- 寻找可达点
                local reachable_x, reachable_y = api_FindNearestReachableInRange(target_x, target_y,safe_distance * 0.7 )
                
                -- 设置移动目标
                env.attack_move = true
                env.end_point = {reachable_x, reachable_y}
            
            end

            

            --- 主要动作
            poe2_api.dbgp("释放技能...")
            nearest_distance_sq = math.huge

            -- 加载技能设置
            if not self.is_have_skills then
                poe2_api.dbgp("加载技能设置...")
                self.stuck_monsters = {}
                
                parse_skill_config()
                self.is_have_skills = true
                return bret.RUNNING
            end

            local player_info = env.player_info
            if not self.skills or #self.skills == 0 then
                poe2_api.dbgp("主动攻击无技能")
                return bret.FAIL
            end

            -- 是否激活
            local is_active = true

            local valid_monsters = nil
            local boss_name = env.boss_name
            local current_map_info = env.current_map_info
            local not_attact_mons_CN_name = my_game_info.not_attact_mons_CN_name
            if player_info.current_map_name_utf8 == "G4_8b" then
                poe2_api.dbgp("移除 骨牆")
                for i, name in ipairs(not_attact_mons_CN_name) do
                    if name == "骨牆" then
                        table.remove(not_attact_mons_CN_name, i)
                        break
                    end
                end
            end
            local range_info = env.range_info
            -- 怪物筛选和处理逻辑
            for _, monster in ipairs(env.range_info) do
                if player_info.current_map_name_utf8 == "G4_8b" and monster.name_utf8 == "骨牆" then
                    monster.is_selectable = true
                end
                -- 快速失败条件检查（按计算成本从低到高排序）
                if not monster.is_selectable or          -- 可选性检查
                monster.is_friendly or                -- 友方检查
                monster.life <= 0 or                  -- 生命值检查
                monster.name_utf8 == "" or              -- 名称检查
                poe2_api.table_contains(not_attact_mons_CN_name, monster.name_utf8) or
                poe2_api.table_contains(my_game_info.not_attact_mons_path_name , monster.path_name_utf8) then  -- 路径名检查
                    goto continue
                end
                -- 检查是否在中心点半径范围内
                if  #env.center_point > 0 and env.center_radius > 0 then
                    local distance_to_center = math.sqrt(
                        (monster.grid_x - env.center_point[1])^2 + 
                        (monster.grid_y - env.center_point[2])^2
                    )
                    if distance_to_center > env.center_radius then
                        goto continue  -- 超出范围则跳过
                    end
                else
                    if self.stuck_monsters and poe2_api.table_contains(self.stuck_monsters, monster.id) then
                        goto continue
                    end
                end
                -- 是否激活  
                if (not monster.isActive) and is_active then
                    goto continue
                end

                -- 稀有度检查
                if env.not_attack_mos and env.not_attack_mos[monster.rarity] then
                    goto continue
                end

                -- 计算距离平方
                local distance_sq = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
                -- poe2_api.dbgp("当前怪物：",monster.name_utf8,"，距离：",distance_sq,"米") q

                if (boss_name and poe2_api.table_contains(monster.name_utf8, boss_name)) or monster.rarity == 3 then
                    if distance_sq < nearest_distance_sq then
                        nearest_distance_sq = distance_sq
                        valid_monsters = monster
                    end
                else
                    if monster.hasLineOfSight and distance_sq < nearest_distance_sq then
                        nearest_distance_sq = distance_sq
                        valid_monsters = monster

                    end
                    
                end
                ::continue::
            end

            if valid_monsters then
                -- 获取当前目标ID
                local current_target_id = valid_monsters and valid_monsters.id or nil
                poe2_api.dbgp("a valid_monsters ------------------------------------------------------->")
                poe2_api.dbgp("a valid_monsters name -->" ,valid_monsters.name_utf8)
                poe2_api.dbgp("a valid_monsters path_name -->" ,valid_monsters.path_name_utf8)
                poe2_api.dbgp("a valid_monsters: ",tostring(string.format("%x",valid_monsters.obj)))
                poe2_api.dbgp("a life -->" ,valid_monsters.life)
                poe2_api.dbgp("a grid_x -->" ,valid_monsters.grid_x)
                poe2_api.dbgp("a grid_y -->" ,valid_monsters.grid_y)


                if not (#env.center_point > 0 and env.center_radius > 0) then
                    -- 第二次遍历进行卡住检测和其他处理
                    for _, monster in ipairs(env.range_info) do
                        local current_time = api_GetTickCount64()
                        if player_info.current_map_name_utf8 == "G4_8b" and monster.name_utf8 == "骨牆" then
                            monster.is_selectable = true
                        end
                        -- 快速失败条件检查
                        if not monster.is_selectable or 
                        poe2_api.table_contains(self.stuck_monsters,monster.id) or 
                        monster.is_friendly then
                            goto continue_second
                        end

                        if monster.name_utf8 == "" then
                            goto continue_second
                        end

                        -- 黑名单检查
                        if poe2_api.table_contains(not_attact_mons_CN_name, monster.name_utf8) or
                            poe2_api.table_contains(my_game_info.not_attact_mons_path_name, monster.path_name_utf8) or
                        string.find(monster.name_utf8 or "", "神殿") then
                            goto continue_second
                        end
                        
                        --- 基础状态检查       
                        if (not monster.isActive) and is_active then
                            goto continue_second
                        end

                        if not (monster.life > 0) then
                            goto continue_second
                        end
                        
                        -- 死亡怪物处理
                        if monster.life <= 0 then
                            self.monster_tracker[monster.id] = nil
                            self.stuck_monsters = {}
                            goto continue_second
                        end
                        
                        -- 卡住检测（仅对当前目标）
                        if monster.id == current_target_id then
                            -- 目标切换时重置所有数据
                            if current_target_id ~= self.last_target_id then
                                self.current_target_data = {
                                    first_seen = current_time,
                                    last_seen = current_time,
                                    initial_life = monster.life,
                                    grid_x = monster.grid_x,
                                    grid_y = monster.grid_y,
                                    rarity = monster.rarity
                                }
                                self.last_target_id = current_target_id
                            else
                                -- 仅更新时间戳
                                self.current_target_data.last_seen = current_time
                            end
                            
                            -- 计算存活时间和生命比例
                            local time_elapsed = current_time - self.current_target_data.first_seen
                            local life_ratio = monster.life / math.max(self.current_target_data.initial_life, 1)
                            
                            -- 获取稀有度对应的时间阈值
                            local rarity_index = math.min(monster.rarity, 3) + 1  -- Lua数组从1开始
                            local time_thresholds = {45, 60, 120, 180}
                            local time_threshold = (time_thresholds[rarity_index]) * 1000

                            -- 综合判断条件
                            if time_elapsed > time_threshold and life_ratio > 0.95 then
                                table.insert(self.stuck_monsters, monster.id)
                                poe2_api.dbgp(string.format("%s 卡住（%.1f秒未击杀）", monster.name_utf8 or "未知怪物", time_elapsed / 1000))
                                valid_monsters = nil
                                goto continue_second
                            end
                        end
                        ::continue_second::
                    end
                end
            end

            -- 更新黑板数据
            if self.stuck_monsters then
                env.stuck_monsters = self.stuck_monsters
                -- poe2_api.printTable(self.stuck_monsters)
            end

            env.valid_monsters = valid_monsters

            if valid_monsters then
                -- 计算距离
                local distance = math.sqrt((valid_monsters.grid_x - player_info.grid_x)^2 + 
                                        (valid_monsters.grid_y - player_info.grid_y)^2)

                poe2_api.dbgp("++++++++++++++++++++++++++++++++++")
                poe2_api.dbgp(string.format("攻击 %s(稀有度:%d) | 距离: %.1f",valid_monsters.name_utf8 or "未知怪物", valid_monsters.rarity or 0, distance))
                poe2_api.dbgp("is_friendly: ", tostring(valid_monsters.is_friendly))
                poe2_api.dbgp("hasLineOfSight: ", tostring(valid_monsters.hasLineOfSight))
                poe2_api.dbgp("isActive: ", tostring(valid_monsters.isActive))
                -- poe2_api.dbgp("isActive: ", tostring(valid_monsters.isActive))
                -- poe2_api.dbgp("rarity: ", tostring(valid_monsters.rarity))
                -- poe2_api.dbgp("path_name_utf8: ", tostring(valid_monsters.path_name_utf8))
                poe2_api.dbgp("obj: ", tostring(string.format("%x",valid_monsters.obj)))
                poe2_api.dbgp("grid_x: ", tostring(string.format("%x",valid_monsters.grid_x)))
                poe2_api.dbgp("grid_y: ", tostring(string.format("%x",valid_monsters.grid_y)))
                -- api_ClickMove(valid_monsters.grid_x, valid_monsters.grid_y, player_info.world_z, 0)
                poe2_api.dbgp("magicProperties: ", tostring(valid_monsters.magicProperties))
                poe2_api.printTable(valid_monsters.magicProperties)
                -- poe2_api.dbgp("stateMachineList: ", tostring(valid_monsters.stateMachineList))
                poe2_api.dbgp("血量：", valid_monsters.life )
                -- poe2_api.print_log("type --> ", type(valid_monsters))
                poe2_api.dbgp("++++++++++++++++++++++++++++++++++")
                if poe2_api.table_contains(valid_monsters.name_utf8, {'吉恩諾伯爵','巨像．札爾瑪拉斯','崛起之王．賈嫚拉',"擊殺死亡之謠．黛莫拉"}) and not valid_monsters.isActive then
                    return bret.SUCCESS
                end
                if string.find(valid_monsters.name_utf8, "多里亞尼") and valid_monsters.stateMachineList and valid_monsters.stateMachineList["boss_life_bar"] == 0 then
                    return bret.SUCCESS
                end
                if string.find(valid_monsters.name_utf8, "白之亞瑪") and valid_monsters.stateMachineList and valid_monsters.stateMachineList["dead"] == 1 then
                    return bret.SUCCESS
                end
                if valid_monsters.name_utf8 == '異界．干擾女王．卡巴拉' then
                    if distance > 50 then
                        env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                        env.attack_move = true
                        return bret.FAIL
                    end
                end
                if valid_monsters.name_utf8 == "撕裂者" then
                    for _,v in ipairs(current_map_info) do
                        if v.name_utf8 == "RathbreakerActive" and math.sqrt((v.grid_x - player_info.grid_x) * 2 + (v.grid_y - player_info.grid_y) * 2)>25 then
                            env.attack_move = true
                            env.end_point = {v.grid_x, v.grid_y}
                            return bret.FAIL
                        end
                    end
                end
                if valid_monsters.name_utf8 == "憎惡者．賈嫚拉" or valid_monsters.name_utf8 == "國王的侍從" then
                    for _,k in ipairs(env.range_info) do
                        if k.name_utf8 == "絲克瑪．阿薩拉" and k.stateMachineList and k.stateMachineList["sandstorm_defence"] == 1 then
                            if poe2_api.point_distance(k.grid_x,k.grid_y,player_info) > 25 then
                                env.attack_move = true
                                env.end_point = {k.grid_x, k.grid_y}
                                return bret.FAIL
                            elseif poe2_api.point_distance(k.grid_x,k.grid_y,player_info) > 20 then
                                return bret.RUNNING
                            end
                        end
                    end
                end
                if valid_monsters.name_utf8 == "白之亞瑪" then
                    for _,k in ipairs(env.range_info) do
                        if string.find(k.animated_name_utf8,"Metadata/Characters/Dex/DexFourB") and k.stateMachineList and k.stateMachineList["chosen_one"] == 1 then
                            if poe2_api.point_distance(k.grid_x,k.grid_y,player_info) > 25 then
                                env.attack_move = true
                                env.end_point = {k.grid_x, k.grid_y}
                                return bret.FAIL
                            elseif poe2_api.point_distance(k.grid_x,k.grid_y,player_info) > 20 then
                                return bret.RUNNING
                            end
                        end
                    end
                end
                if valid_monsters.name_utf8 == "烏托邦的第一使者．本篤特斯" then
                    env.space = false
                end
                if valid_monsters.name_utf8 == "最終之刺．艾克提" and valid_monsters.stateMachineList and valid_monsters.stateMachineList["first_aggro"] == 0 then
                    if poe2_api.point_distance(valid_monsters.grid_x,valid_monsters.grid_y,player_info) >35 then
                        env.end_point = {valid_monsters.grid_x,valid_monsters.grid_y}
                        env.space = false
                        return bret.FAIL
                    else
                        local range_sorted = poe2_api.get_sorted_obj("沙蟲．艾能德",env.range_info, env.player_info)
                        if range_sorted and #range_sorted > 0 then
                            if poe2_api.point_distance(range_sorted[1].grid_x,range_sorted[1].grid_y,player_info) > 35 then
                                env.attack_move = true
                                env.end_point = {range_sorted[1].grid_x,range_sorted[1].grid_y}
                                env.space = false
                                return bret.FAIL
                            end
                        end
                    end
                end
                if valid_monsters.name_utf8 == "囚犯" then
                    local range_sorted = poe2_api.get_sorted_obj("砲塔",env.range_info, env.player_info)
                    if range_sorted and #range_sorted > 0 then
                        if poe2_api.point_distance(range_sorted[1].grid_x,range_sorted[1].grid_y,player_info) > 35 then
                            env.attack_move = true
                            env.end_point = {range_sorted[1].grid_x,range_sorted[1].grid_y}
                            env.space = false
                            return bret.FAIL
                        end
                        if valid_monsters and valid_monsters.stateMachineList and valid_monsters.stateMachineList["kneeling"] == 1 then
                            api_Sleep(500)
                            poe2_api.find_text({UI_info = env.UI_info, text = "砲塔", min_x = 0,click = 2,refresh = true })
                            api_Sleep(500)
                            env.space = false
                            return bret.RUNNING
                        end
                    end
                end
                -- 特殊Boss处理
                local special_bosses = {'巨蛇女王．瑪娜莎', '被遺忘的囚犯．帕拉薩'}
                if poe2_api.table_contains(valid_monsters.name_utf8, special_bosses) and distance > 50 and not valid_monsters.isActive then
                    poe2_api.dbgp("special_bosses,或者未激活")
                    _handle_special_boss_movement(valid_monsters, player_info)
                    poe2_api.dbgp("移动到目标附近444")
                    return bret.FAIL
                end
                -- 构建可用技能池

                local available_skills = _get_available_skills(valid_monsters.rarity)

                local min_attack_range = 0
                if available_skills and #available_skills > 0 then
                    for _, skill in ipairs(available_skills) do
                        if skill.attack_range > min_attack_range then
                            min_attack_range = skill.attack_range
                        end
                    end
                end

                env.min_attack_range = min_attack_range
                
                if available_skills and #available_skills > 0 then
                    local selected_skill = _select_skill(available_skills)
                    if distance > 25 then
                        poe2_api.printTable(valid_monsters.magicProperties)
                        -- 检查特殊词缀
                        for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                            if poe2_api.table_contains(valid_monsters.magicProperties, prop) then
                                env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                poe2_api.dbgp("移动到目标附近111")
                                return bret.FAIL
                            end
                            ::continue_prop::
                        end
                    end

                    poe2_api.dbgp("selected_skill.attack_range", selected_skill.attack_range)
                    poe2_api.dbgp("min_attack_range", min_attack_range)
                    poe2_api.dbgp("distance", distance)

                    if valid_monsters.name_utf8 ~= "骨之暴君．札瓦里" then
                        
                        if distance > selected_skill.attack_range and distance > min_attack_range or not valid_monsters.isActive then
                            -- poe2_api.dbgp("移动到目标附近")
                            -- -- 拾取不移动
                            -- if need_item and not env.center_point and not center_radius then
                            --     return bret.SUCCESS
                            -- end
                            
                            if env.afoot_altar then
                                local distance = poe2_api.point_distance(env.afoot_altar.grid_x, env.afoot_altar.grid_y, env.player_info)
                                if distance < 105 then
                                    env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                    poe2_api.dbgp("移动到目标附近222")
                                    return bret.FAIL
                                end
                            end
                            
                            if poe2_api.table_contains(valid_monsters.rarity, {2, 3}) then
                                poe2_api.dbgp("精英怪移动到目标附近")
                                env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                                return bret.FAIL
                            end
                            return bret.SUCCESS
                        end
                    else
                        if distance > 80 then
                            env.end_point = {valid_monsters.grid_x, valid_monsters.grid_y}
                            poe2_api.dbgp("移动到目标附近333")
                            return bret.FAIL
                        end
                    end
                    
                    _execute_skill(selected_skill, valid_monsters, player_info)
                    poe2_api.dbgp("释放：")
                    poe2_api.printTable(selected_skill)
                end
                return bret.RUNNING
            end

            poe2_api.time_p("ReleaseSkillAction 耗时 --> ", api_GetTickCount64() - current_time_ms)
            return bret.RUNNING
        end
    },

    -- 躲避技能
    DodgeAction = {
        run = function(self, env)
            poe2_api.dbgp("DodgeAction")
            local is_initialized  = false
            if self.last_space_time == nil then
                self.last_space_time = 0.0 -- 上次按下空格的时间
                self.space_cooldown = 1500 -- 空格键冷却时间（秒）
                self.last_space_time1 = 0.0
                is_initialized = true
            end

            local is_bird = false
            for _,k in ipairs(env.player_info.buffs) do
                if k.name_en == "on_rhoa_mount" then
                    is_bird = true
                    break
                end
            end
            local space_check_dis = env.space_config["躲避距离"]
            local _handle_space_action = function(monster, space_flag, space_monsters, space_time, player_info)
                poe2_api.dbgp("_handle_space_action")
                -- 处理空格键操作
                if not space_time then
                    space_time = 1500
                else
                    space_time = space_time
                end
                local result_60 = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 100, space_check_dis, 1, 0)
                if ((space_flag and poe2_api.table_contains(space_monsters,monster.rarity))) and
                api_GetTickCount64() - self.last_space_time >= space_time  then
                    local result = nil
                    if not result_60 or (result_60.x == env.player_info.grid_y and result_60.y == env.player_info.grid_y) then
                        result = api_GetNextCirclePosition(monster.grid_x, monster.grid_y, player_info.grid_x, player_info.grid_y, 50,20,0)
                    else
                        result = result_60
                    end
                    api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), 0)
                    api_Sleep(200)
                    poe2_api.dbgp1("_handle_space_action")
                    if is_bird then
                        api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y), 7)
                    else
                        poe2_api.click_keyboard("space")
                    end
                    self.last_space_time = api_GetTickCount64()
                end
            end   

            local _handle_space_action_path_name = function(player_info, space_time)
                -- 处理空格键操作（添加20单位距离限制）
                poe2_api.dbgp("_handle_space_action_path_name")
                space_time = space_time or 1500
                local ret = nil
                local danger = api_IsPointInAnyActive(player_info.grid_x , player_info.grid_y , 100)
                if danger and danger.inside then
                    local safe_point = danger.safeTile

                    if safe_point and safe_point.x ~= -1 and safe_point.y ~= -1 then
                        if not api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y), 7) or not api_HasObstacleBetween(safe_point.x, safe_point.y) then
                            poe2_api.dbgp("安全点过远或有障碍物")
                            env.end_point = {safe_point.x, safe_point.y}
                            return bret.FAIL
                        end
                        api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y), 0)
                        api_Sleep(200)
                        env.end_point = nil
                        env.path_list = nil
                        if not is_bird or danger.action == 2 then
                            poe2_api.click_keyboard("space")
                        end
                        return true
                    end
                end
                return false
            end

            -- 更新方法，执行躲避逻辑
            local monsters = env.range_info
            local player_info = env.player_info
            local space = env.space
            local space_time = env.space_time
            local space_monster = env.space_monster
            if not monsters or not player_info then
                return bret.SUCCESS
            end
            
            local min_attack_range = env.min_attack_range or 70
            if space then
                for _, monster in ipairs(monsters) do
                    dis = poe2_api.point_distance(monster.grid_x, monster.grid_y, player_info)
                    if poe2_api.table_contains(monster.name_utf8, {'多里亞尼','崛起之王．賈嫚拉'}) and monster.life > 0 and dis and dis < space_check_dis then
                        _handle_space_action(monster, space, space_monster, space_time, player_info)
                    end
                    if monster.life > 0 and monster.isActive  and not poe2_api.table_contains(monster.name_utf8, {"","惡魔"}) and dis and dis < space_check_dis and 
                    not monster.is_friendly and monster.hasLineOfSight then
                        if not poe2_api.table_contains(my_game_info.type_3_boss, monster.name_utf8) and monster.type ~= 1 then
                            goto continue
                        end
                        for _, prop in ipairs(my_game_info.first_magicProperties or {}) do
                            if poe2_api.table_contains(monster.magicProperties, prop) then
                                poe2_api.dbgp("特殊词缀怪物,不闪避")
                                goto continue
                            end
                        end
                        _handle_space_action(monster, space, space_monster, space_time, player_info)
                    end
                    ::continue::
                end
            end
            
            _handle_space_action_path_name(player_info)
            return bret.SUCCESS
        end
    },

    -- 是否在新手剧情（攻击和交互）
    Is_In_New_Area = {
        run = function(self, env)
            poe2_api.print_log("是否在新手剧情（攻击和交互）模块开始执行...")

            poe2_api.dbgp("=== 是否在新手剧情（攻击和交互） ===")
            local player_info = env.player_info

            if player_info.current_map_name_utf8 == "G1_1" then
                poe2_api.time_p("[Is_In_New_Area]",(api_GetTickCount64() - current_time))
                return bret.SUCCESS
            end
            poe2_api.time_p("[Is_In_New_Area]",(api_GetTickCount64() - current_time))
            return bret.FAIL
        end
    },

    -- 是否有交互对象
    Is_Have_Interaction_Object = {
        run = function(self, env)
            poe2_api.dbgp("=== 是否有交互对象 ===")
            poe2_api.print_log("是否有交互对象模块开始执行...")
            if self.last_click_time == nil then
                self.last_click_time = 0
                self.click_cooldown = 1 
            end
            local function have_roman_number()
                local ROMAN_NUMERALS = {
                    "I", "II", "III", "IV", "V",
                    "VI", "VII", "VIII", "IX", "X",
                    "XI", "XII", "XIII", "XIV", "XV", "XVI"
                }
                if poe2_api.find_text({ UI_info = env.UI_info, text = ROMAN_NUMERALS, min_x = 520, min_y = 420, max_x = 560, max_y = 470 }) then
                    return true
                else
                    return false
                end
            end
            local player_info = env.player_info
            local range_info = env.range_info
            local interaction_object = env.interaction_object
            local interaction_object_map_name = env.interaction_object_map_name
            local task_area = env.map_name
            local current_time = api_GetTickCount64()
            local me_area = player_info.current_map_name_utf8
            local team_info = env.team_info
            local user_config = env.user_config
            local team_member_2 = poe2_api.get_team_info(team_info,user_config,player_info,2)
            if interaction_object then
                if poe2_api.find_text({ UI_info = env.UI_info, text = "繼續"}) then
                    poe2_api.click_keyboard("space")
                    return bret.RUNNING
                end
                if poe2_api.find_text({ UI_info = env.UI_info, text = "獎勵", min_x = 100}) then
                    poe2_api.dbgp("领取任务奖励")
                    if not me_area == "G4_2" then
                        poe2_api.find_text({ UI_info = env.UI_info, text = "獎勵", min_x = 100, add_y = 100 , click = 2 })
                    end
                    poe2_api.find_text({ UI_info = env.UI_info, text = "獎勵", min_x = 100, add_y = 100 , click = 2 })
                    api_Sleep(500)
                    if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81,refresh = true}) then
                        if have_roman_number() then
                            poe2_api.get_space_point({ width = 1, height = 1, click = 1 })
                        else
                            poe2_api.get_space_point({ width = 4, height = 2, click = 1 })
                        end
                    else
                        poe2_api.click_keyboard("i")
                        return bret.RUNNING
                    end
                    poe2_api.get_space_point({ width = 4, height = 2, click = 1 })
                    if not poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                        poe2_api.click_keyboard("i")
                        return bret.RUNNING
                    end
                end
                if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                    poe2_api.click_keyboard("i")
                    api_Sleep(600)
                    return bret.RUNNING
                end
                if poe2_api.find_text({ UI_info = env.UI_info, text = "繼續"}) then
                    poe2_api.click_keyboard("space")
                    return bret.RUNNING
                end 
            end
            if team_member_2 == "大號名" and string.find(me_area, "own") and me_area ~= "G3_town" then
                return bret.SUCCESS
            end
            if me_area == "G1_1" then
                if poe2_api.find_text({ UI_info = env.UI_info, text = "大箱子",min_x = 0}) then
                    env.end_point = nil
                    env.is_arrive_end = false
                    env.path_list = {}
                    if self.last_click_time == 0 then
                        self.last_click_time = api_GetTickCount64()
                    end
                    if api_GetTickCount64() - self.last_click_time > self.click_cooldown then
                        poe2_api.find_text({ UI_info = env.UI_info, text = "大箱子",min_x = 0, click = 2})
                        self.last_click_time = 0
                    end
                    return bret.RUNNING
                end
                local career = user_config["劇情設置"]["職業"]
                local setinfo = my_game_info.newbie_gear[career]
                local skilltext = setinfo["skill"]
                if skilltext then
                    if poe2_api.find_text({ UI_info = env.UI_info, text = skilltext,min_x = 0}) then
                        env.end_point = nil
                        env.is_arrive_end = false
                        env.path_list = {}
                        poe2_api.find_text({ UI_info = env.UI_info, text = skilltext,min_x = 0, click = 2})
                        return bret.RUNNING
                    end
                end
                local geartext = setinfo["gear"]
                if geartext and me_area == "G1_1" then
                    if poe2_api.find_text({ UI_info = env.UI_info, text = geartext,min_x = 0}) then
                        env.end_point = nil
                        env.is_arrive_end = false
                        env.path_list = {}
                        poe2_api.find_text({ UI_info = env.UI_info, text = geartext,min_x = 0, click = 2})
                        return bret.RUNNING
                    end
                end
            end
            poe2_api.dbgp(me_area == task_area)
            poe2_api.printTable(interaction_object)
            if (interaction_object or interaction_object_map_name ) and me_area == task_area then
                if env.modify_interaction then
                    poe2_api.dbgp("修改交互对象")
                    env.interaction_object = env.interaction_object_copy
                    env.interaction_object_map_name = env.interaction_object_map_name_copy
                    env.modify_interaction = false
                end
                if env.is_not_ui then
                    env.is_not_ui = false
                    poe2_api.time_p("[Is_Have_Interaction_Object]",(api_GetTickCount64() - current_time))
                    return bret.SUCCESS
                end
                if env.not_need_active then
                    env.not_need_active = false
                    poe2_api.time_p("[Is_Have_Interaction_Object]",(api_GetTickCount64() - current_time))
                    return bret.SUCCESS
                end
                poe2_api.dbgp("进入周围是否有交互对象")
                poe2_api.time_p("[Is_Have_Interaction_Object]",(api_GetTickCount64() - current_time))
                return bret.FAIL
            end
            poe2_api.time_p("[Is_Have_Interaction_Object]",(api_GetTickCount64() - current_time))
            return bret.SUCCESS
        end
    }, 

    -- 周围是否有交互对象 
    The_Interactive_Object_Exist = {
        run = function(self, env)
            poe2_api.dbgp("=== 周围是否有交互对象 ===")
            poe2_api.print_log("=== 周围是否有交互对象 ===")
            local bag_info = env.bag_info
            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            local range_info = env.range_info
            local UI_info = env.UI_info
            local interaction_object = env.interaction_object
            local task_name = env.task_name
            local grid_x = env.grid_x
            local grid_y = env.grid_y
            local record_map = env.record_map
            local range_items = env.range_items
            local map_result = env.map_result
            local current_map_info = api_GetMinimapActorInfo()
            local sorted_range_info = poe2_api.get_sorted_list(range_info, player_info)
            local boss_name = env.boss_name
            local interaction_object_map_name = env.interaction_object_map_name
            local team_member_2 = poe2_api.get_team_info(env.team_info,env.user_config,player_info,2)
            if not env.object_exist then
                env.object_exist = true
                self.time1 = 0
                self.path_result = nil
                self.task_time = 0
                self.map_task_time = 0
                env.pick_up_fire = false
                env.pick_up_ice = false
                env.pick_up_Electricity = false
            end
            -- 小地图是否有指定对象
            local function mini_map_obj(name)
                local result = {}
                for _, item in ipairs(current_map_info) do
                    if item.name_utf8 == name then
                        table.insert(result, item)
                    end
                end
                return result
            end
            -- 小地图是否有指定对象距离
            local function min_map_dis(name)
                local function target_distance(actor)
                    -- 计算与玩家的平方距离
                    return (actor.grid_x - player_info.grid_x) ^ 2 + (actor.grid_y - player_info.grid_y) ^ 2
                end
                
                local targets = {}
                for _, item in ipairs(current_map_info) do
                    if item.name_utf8 == name and item.flagStatus1 == 1 then
                        table.insert(targets, item)
                    end
                end
                
                table.sort(targets, function(a, b)
                    return target_distance(a) < target_distance(b)
                end)
                
                return targets
            end
            if interaction_object or interaction_object_map_name then
                local interaction_object_set = interaction_object
                local local_x = player_info.grid_x
                local local_y = player_info.grid_y
                -- 公共函数
                local function get_distance(x,y)
                    return poe2_api.point_distance(x,y,player_info)
                end
                local function should_break_mos()
                    return (poe2_api.is_have_mos({range_info = range_info, player_info = player_info}) and team_member_2 == "大號名" )
                end
                if task_name == "在吉卡尼的機械迷城尋找小型靈魂核心以開啟大門" and player_info.current_map_name_utf8 == "G3_6_1" then
                    if self.task_time == 0 then
                        self.task_time = api_GetTickCount64()
                    end
                    local ttime =  api_GetTickCount64() - self.task_time
                    poe2_api.dbgp("G3_6_1-超时",ttime)
                    if ttime > 1000*60*60 then
                        poe2_api.dbgp("任务超时")
                        env.back_city = true
                        return bret.RUNNING
                    end
                else
                    self.task_time = 0
                end
                if poe2_api.table_contains("門",interaction_object_set) then
                    local door_list = poe2_api.get_sorted_obj("門",range_info,player_info)
                    if door_list and #door_list > 0 and (poe2_api.find_text({ UI_info = UI_info, text = "門", min_x = 0}) or env.door_path ) then
                        for _,door in ipairs(door_list) do
                            if should_break_mos() then 
                                poe2_api.dbgp("打怪，不开门")
                                env.door_path = nil
                                env.not_need_active = true
                                return bret.RUNNING
                            end
                            if door.is_selectable then
                                local door_point = api_CollectReachableInCircleSimple(door.grid_x, door.grid_y,10)
                                local door_sorted = poe2_api.sort_recent_point_list(door_point,local_x,local_y)
                                if get_distance(door.grid_x,door.grid_y) < 25 then
                                    poe2_api.dbgp("距离门小于25，点击门")
                                    env.door_path = nil
                                    api_ClickMove(poe2_api.toInt(door.grid_x),poe2_api.toInt(door.grid_y),1)
                                    return bret.RUNNING
                                else
                                    poe2_api.dbgp("距离门大于25，找门")
                                    if not env.door_path or #env.door_path == 0 then
                                        env.door_path = api_FindPath(local_x,local_y,door_sorted[1].x,door_sorted[1].y)
                                    end
                                    if env.door_path and #env.door_path > 0 then
                                        poe2_api.dbgp("找到门的路径")
                                        env.end_point = {door_sorted[1].x,door_sorted[1].y}
                                        if poe2_api.table_contains(player_info.current_map_name_utf8,{"G3_6_1"}) then
                                            env.interaction_object = {'門'}
                                        end
                                        return bret.SUCCESS
                                    end
                                end
                            end
                            env.door_path = nil
                        end
                    end
                end
                if poe2_api.table_contains("壓桿",interaction_object_set) then
                    poe2_api.dbgp("检测到压杆")
                    if team_member_2 ~= "大號名" then
                        env.is_not_ui = true
                        return bret.RUNNING
                    end
                    local target = min_map_dis("WaterwaysLever")
                    local range_target = poe2_api.get_sorted_obj("壓桿",range_info,player_info)
                    if target and #target > 0 then
                        local target_point = api_FindNearestReachableInRange(target[1].grid_x, target[1].grid_y,20)
                        if get_distance(target[1].grid_x, target[1].grid_y) < 30 then
                            poe2_api.dbgp("距离压杆小于30，点击压杆")
                            poe2_api.find_text({ UI_info = UI_info, text = "壓桿", min_x = 200, click = 2})
                            api_Sleep(5000)
                            api_UpdateMapObstacles(100)
                            return bret.RUNNING
                        else
                            local target_point_path = api_FindPath(local_x,local_y,target_point.x,target_point.y)
                            if target_point_path and #target_point_path > 0 then
                                poe2_api.dbgp("找到压杆的路径",get_distance(target[1].grid_x, target[1].grid_y))
                                env.end_point = {target_point.x,target_point.y}
                                return bret.SUCCESS
                            else
                                poe2_api.dbgp("未找到压杆的路径")
                                target_point = api_FindRandomWalkablePosition(target[1].grid_x, target[1].grid_y,50)
                                api_ClickMove(poe2_api.toInt(target_point.x),poe2_api.toInt(target_point.y),0)
                                poe2_api.click_keyboard("space")
                                env.not_need_active = true
                                return bret.RUNNING
                            end
                        end
                    else
                        local point = {}
                        poe2_api.dbgp("未找到压杆设置探索范围40")
                        point = api_GetUnexploredArea(40)
                        if point.x == -1 and point.y == -1 then
                            for _,target in ipairs(range_target) do
                                if should_break_mos() then 
                                    break
                                end
                                if target.stateMachineList and target.stateMachineList.water_level ~= 2 then
                                    api_UpdateMapObstacles(100)
                                    if get_distance(target.grid_x,target.grid_y) < 25 then
                                        poe2_api.dbgp("距离压杆小于25，点击压杆")
                                        poe2_api.find_text({ UI_info = UI_info, text = "壓桿", min_x = 200, click = 2})
                                        api_Sleep(5000)
                                        api_UpdateMapObstacles(100)
                                        return bret.RUNNING
                                    end
                                    local target_point = api_FindNearestReachableInRange(target.grid_x, target.grid_y,20)
                                    local target_path = api_FindPath(local_x,local_y,target_point.x,target_point.y)
                                    if target_path and #target_path > 0 then
                                        env.end_point = {target_point.x,target_point.y}
                                        return bret.SUCCESS
                                    end
                                    env.is_not_ui = true
                                    return bret.RUNNING
                                end
                            end
                        end
                    end
                end
                
                if poe2_api.table_contains("<questitem>{發電機}",interaction_object_set) then
                    poe2_api.dbgp("检测到发电机")
                    local target = interaction_object[1]
                    if (not bag_info or #bag_info == 0) or ((not poe2_api.check_item_in_inventory("中型靈魂核心",bag_info)) or poe2_api.find_text({ UI_info = UI_info, text = target, max_x=1347, min_x=200}))
                        and not poe2_api.find_text({ UI_info = UI_info, text = "<questitem>{大型靈魂核心}", max_x=1550, min_x=0}) then
                        local core_list = poe2_api.get_sorted_obj("中型靈魂核心", range_items, player_info)
                        if core_list and #core_list > 0 then
                            local core = core_list[1]
                            if get_distance(core.grid_x,core.grid_y) < 25 then
                                poe2_api.find_text({ UI_info = UI_info, text = target, max_x=1347, min_x=200, click = 2})
                                env.end_point = nil
                                env.is_arrive_end = false
                                env.path_list = {}
                                return bret.RUNNING
                            else
                                poe2_api.dbgp("距离核心大于25，找核心")
                                env.end_point = {core.grid_x,core.grid_y}
                                return bret.SUCCESS
                            end
                        end
                        env.is_not_ui = true
                        return bret.RUNNING
                    else
                        local core_list = poe2_api.get_sorted_obj("<questitem>{大型靈魂核心}", range_info, player_info)
                        if core_list and #core_list > 0 and core_list[1].stateMachineList and core_list[1].stateMachineList.powered == 1 and core_list[1].stateMachineList.fight_ready == 2 then
                            local core = core_list[1]
                            if get_distance(core.grid_x,core.grid_y) < 30 then
                                poe2_api.find_text({ UI_info = UI_info, text = "<questitem>{大型靈魂核心}", max_x=1347, min_x=200, click = 2})
                                env.end_point = nil
                                env.is_arrive_end = false
                                env.path_list = {}
                                env.is_not_ui = true
                                return bret.RUNNING
                            elseif get_distance(core.grid_x,core.grid_y) < 150 then
                                local core_point = api_CollectReachableInCircleSimple(core.grid_x, core.grid_y,20)
                                local core_sorted = poe2_api.sort_recent_point_list(core_point,local_x,local_y)
                                env.end_point = {core_sorted[1].x,core_sorted[1].y}
                                return bret.SUCCESS
                            end
                        end
                        local generator_list = poe2_api.get_sorted_obj("<questitem>{發電機}", range_info, player_info)
                        if generator_list and #generator_list > 0 then
                            for _,generator in ipairs(generator_list) do
                                if generator.stateMachineList and  generator.stateMachineList.activate == 0 then
                                    if get_distance(generator.grid_x,generator.grid_y) < 30 then
                                        if team_member_2 ~="大號名" then
                                            env.is_not_ui = true
                                            return bret.RUNNING
                                        end
                                        poe2_api.find_text({ UI_info = UI_info, text = "<questitem>{發電機}", max_x=1347, min_x=200, click = 2})
                                        env.end_point = nil
                                        env.is_arrive_end = false
                                        env.path_list = {}
                                        return bret.RUNNING
                                    else
                                        local generator_point = api_CollectReachableInCircleSimple(generator.grid_x, generator.grid_y,20)
                                        local generator_sorted = poe2_api.sort_recent_point_list(generator_point,local_x,local_y)
                                        env.end_point = {generator_sorted[1].x,generator_sorted[1].y}
                                        return bret.SUCCESS
                                    end
                                end
                            end
                        end
                    end
                end
                if poe2_api.table_contains("石陣祭壇",interaction_object_set) and #interaction_object > 1 then
                    poe2_api.dbgp("检测到石陣祭壇")
                    local target = "小型靈魂核心"
                    if (not bag_info or #bag_info == 0) or ((not poe2_api.check_item_in_inventory(target,bag_info)) or poe2_api.find_text({ UI_info = UI_info, text = target, max_x=1347, min_x=200}))
                        and not poe2_api.find_text({ UI_info = UI_info, text = "吉卡尼的聖域", max_x=1550, min_x=0}) then
                        local core_list = poe2_api.get_sorted_obj(target, range_items, player_info)
                        if core_list and #core_list > 0 then
                            local core = core_list[1]
                            if get_distance(core.grid_x,core.grid_y) < 25 then
                                poe2_api.dbgp("小型靈魂核心距离小于25，点击小型靈魂核心")
                                poe2_api.find_text({ UI_info = UI_info, text = target, max_x=1347, min_x=200, click = 2})
                                env.end_point = nil
                                env.is_arrive_end = false
                                env.path_list = {}
                                return bret.RUNNING
                            else
                                poe2_api.dbgp("小型靈魂核心距离大于25，点击小型靈魂核心")
                                env.end_point = {core.grid_x,core.grid_y}
                                return bret.SUCCESS
                            end
                        end
                        env.is_not_ui = true
                        poe2_api.dbgp("無小型靈魂核心")
                        return bret.RUNNING
                    end
                end
                if poe2_api.table_contains("卡洛翰的姐妹",interaction_object_set) then
                    poe2_api.dbgp("检测到卡洛翰的姐妹")
                    local sister = poe2_api.get_sorted_obj("卡洛翰的姐妹", range_info, player_info)
                    if sister and #sister > 0 then
                        if sister[1].stateMachineList and sister[1].stateMachineList.active == 0 then
                            if get_distance(sister[1].grid_x,sister[1].grid_y) < 30 then
                                poe2_api.find_text({ UI_info = UI_info, text = "卡洛翰的姐妹", max_x=1347, min_x=200, click = 2})
                                env.end_point = nil
                                env.is_arrive_end = false
                                env.path_list = {}
                                return bret.RUNNING
                            else
                                local sister_point = api_FindNearestReachableInRange(sister[1].grid_x, sister[1].grid_y,20)
                                env.end_point = {sister_point.x,sister_point.y}
                                return bret.SUCCESS
                            end 
                        end
                        env.is_not_ui = true
                        env.record_map = nil
                    end
                end
                if poe2_api.table_contains("召喚瑟維",interaction_object_set) then
                    poe2_api.dbgp("检测到召喚瑟維")
                    local servi = poe2_api.get_sorted_obj("召喚瑟維", range_info, player_info)
                    if servi and #servi > 0 then
                        local sister_toward = poe2_api.move_towards({local_x,local_y},{servi[1].grid_x,servi[1].grid_y}, 50)
                        api_ClickMove(poe2_api.toInt(sister_toward[1]),poe2_api.toInt(sister_toward[2]),0)
                        poe2_api.click_keyboard("space")
                        api_Sleep(300)
                        poe2_api.find_text({UI_info = UI_info, text = "召喚瑟維", min_x=160, click = 2})
                    end
                end
                if player_info.current_map_name_utf8 == "G2_3" then
                    local npc = poe2_api.get_sorted_obj("絲克瑪．阿薩拉", range_info, player_info)
                    if npc and #npc > 0 then
                        if not npc[1].isActive then
                            poe2_api.dbgp("检测到絲克瑪．阿薩拉未激活，将执行点击操作")
                            return bret.RUNNING
                        end
                    end
                end
                if player_info.current_map_name_utf8 == "G2_2" and task_name == "返回車隊，與芮蘇討論封閉的古老關口" then
                    poe2_api.dbgp("芭芭拉的巨靈之幣")
                    local seals = poe2_api.get_sorted_obj("古代封印", range_info, player_info)
                    local runes = poe2_api.get_sorted_obj("符文之印", range_info, player_info)
                    if seals and #seals > 0  and runes and #runes > 0 then
                        if seals[1].stateMachineList and seals[1].stateMachineList.open == 0 then
                            poe2_api.dbgp("古代封印未開")
                            if get_distance(seals[1].grid_x,seals[1].grid_y) < 30 then
                                poe2_api.find_text({ UI_info = UI_info, text = "古代封印", max_x=1347, min_x=200, click = 2})
                                env.end_point = nil
                                env.is_arrive_end = false
                                env.path_list = {}
                                return bret.RUNNING
                            else
                                local seals_point = api_CollectReachableInCircleSimple(seals[1].grid_x, seals[1].grid_y,20)
                                local seals_sorted = poe2_api.sort_recent_point_list(seals_point,local_x,local_y)
                                env.end_point = {seals_sorted[1].x,seals_sorted[1].y}
                                return bret.SUCCESS
                            end
                        end
                        for _, rune in ipairs(runes) do
                            if rune.stateMachineList and rune.stateMachineList.open == 0 then
                                poe2_api.dbgp("符文之印未開")
                                if get_distance(rune.grid_x,rune.grid_y) < 30 then
                                    if team_member_2 ~="大號名" then
                                        env.is_not_ui = true
                                        return bret.RUNNING
                                    end
                                    poe2_api.find_text({ UI_info = UI_info, text = "符文之印", max_x=1347, min_x=200, click = 2})
                                    env.end_point = nil
                                    env.is_arrive_end = false
                                    env.path_list = {}
                                    return bret.RUNNING
                                else
                                    local rune_point = api_CollectReachableInCircleSimple(rune.grid_x, rune.grid_y,20)
                                    local rune_sorted = poe2_api.sort_recent_point_list(rune_point,local_x,local_y)
                                    env.end_point = {rune_sorted[1].x,rune_sorted[1].y}
                                    return bret.SUCCESS
                                end
                            end
                        end
                    end
                    if (not bag_info or #bag_info == 0) or (not poe2_api.check_item_in_inventory("芭芭拉的巨靈之幣",bag_info) and team_member_2 ~="大號名") or team_member_2 == "大號名" then
                        local boss = poe2_api.get_sorted_obj("叛徒芭芭拉", range_info, player_info)
                        if boss and #boss > 0 and boss[1].life > 0 and player_info.isInBossBattle then
                            env.interaction_object = nil 
                            env.record_map = nil
                            if get_distance(boss[1].grid_x,boss[1].grid_y) < 30 then
                                poe2_api.dbgp("叛徒芭芭拉距离<30")
                                return bret.RUNNING
                            end
                            env.end_point ={boss[1].grid_x,boss[1].grid_y}
                            return bret.SUCCESS
                        end
                        env.is_not_ui = true
                        env.interaction_object_copy = nil
                        env.interaction_object_map_name_copy = nil 
                        env.modify_interaction = true
                        return bret.RUNNING
                    end
                end
                if player_info.current_map_name_utf8 == "G4_5_2" and team_member_2 =="大號名" then
                    local turret = poe2_api.get_sorted_obj("砲塔", range_info, player_info)
                    if turret and #turret > 0  and player_info.isInBossBattle then
                        env.record_map = nil
                        if get_distance(turret[1].grid_x,turret[1].grid_y) < 40 then
                            poe2_api.dbgp("砲塔距离<40")
                            return bret.RUNNING
                        else
                            env.end_point = {turret[1].grid_x,turret[1].grid_y}
                            return bret.SUCCESS
                        end
                    end
                    local boss = poe2_api.get_sorted_obj("囚犯", range_info, player_info)
                    if boss and #boss > 0  and not player_info.isInBossBattle then
                        env.record_map = nil
                        if get_distance(boss[1].grid_x,boss[1].grid_y) < 35 then
                            poe2_api.dbgp("boss距离<35")
                            return bret.RUNNING
                        else
                            env.end_point = {boss[1].grid_x,boss[1].grid_y}
                            return bret.SUCCESS
                        end
                    end
                end
                if poe2_api.table_contains("瘋狂讚美詩",interaction_object_set) then
                    poe2_api.dbgp("瘋狂讚美詩")
                    local handle = poe2_api.get_sorted_obj("瘋狂讚美詩", range_info, player_info)
                    local boss = poe2_api.get_sorted_obj("存活儀式．燭光",range_info,player_info)
                    if handle and #handle > 0 and boss and #boss > 0 then
                        for _,h in ipairs(handle) do
                            if boss[1] and boss[1].life > 0 then
                                if get_distance(h.grid_x,h.grid_y) < 30 then
                                    if not boss[1].isActive then
                                        poe2_api.find_text({ UI_info = UI_info, text = "瘋狂讚美詩", max_x=1347, min_x=200, click = 2})
                                        env.end_point = nil
                                        env.is_arrive_end = false
                                        env.path_list = {}
                                        return bret.RUNNING
                                    end
                                else
                                    local handle_point = api_CollectReachableInCircleSimple(h.grid_x, h.grid_y,20)
                                    local handle_sorted = poe2_api.sort_recent_point_list(handle_point,local_x,local_y)
                                    env.end_point = {handle_sorted[1].x,handle_sorted[1].y}
                                    return bret.SUCCESS
                                end
                            else
                                env.record_map = nil
                                env.is_not_ui = true
                                return bret.RUNNING
                            end
                        end
                    end
                end
                if grid_x and grid_y then
                    local distacne = poe2_api.point_distance(grid_x,grid_y,player_info)
                    poe2_api.dbgp("固定点grid_x, grid_y",distacne)
                    if distacne> 25 then
                        if api_FindPath(local_x,local_y,grid_x,grid_y) then
                            env.end_point = {grid_x,grid_y}
                            return bret.SUCCESS
                        end
                    else
                        env.is_arrive_end = true
                        return bret.SUCCESS
                    end
                end
                if poe2_api.table_contains("把手",interaction_object_set) then
                    local handle = poe2_api.get_sorted_obj("把手", range_info, player_info)
                    if handle and #handle > 0 and player_info.current_map_name_utf8 == "G1_13_2" then
                        for _,h in ipairs(handle) do
                            if h.stateMachineList and h.stateMachineList.helper_state ~= 2 then
                                if get_distance(h.grid_x,h.grid_y) < 30 then
                                    poe2_api.find_text({ UI_info = UI_info, text = "把手", max_x=1347, min_x=200, click = 1})
                                    api_Sleep(500)
                                    poe2_api.find_text({ UI_info = UI_info, text = "把手", max_x=1347, min_x=200, click = 2})
                                    api_Sleep(2000)
                                    env.end_point = nil
                                    env.is_arrive_end = false
                                    env.path_list = {}
                                    local handle_point = api_FindRandomWalkablePosition(h.grid_x, h.grid_y,40)
                                    api_ClickMove(poe2_api.toInt(handle_point.x),poe2_api.toInt(handle_point.y),0)
                                    api_Sleep(300)
                                    poe2_api.click_keyboard("space")
                                    env.not_need_active = true
                                    return bret.RUNNING
                                else
                                    local handle_point = api_CollectReachableInCircleSimple(h.grid_x, h.grid_y,30)
                                    local handle_sorted = poe2_api.sort_recent_point_list(handle_point,local_x,local_y)
                                    env.end_point = {handle_sorted[1].x,handle_sorted[1].y}
                                    return bret.SUCCESS
                                end
                            end
                        end
                    end
                end
                if not sorted_range_info or #sorted_range_info == 0 then
                    poe2_api.dbgp("没有检测到周围对象")
                    return bret.RUNNING
                end
                if player_info.current_map_name_utf8 == "G1_2" then
                    if  #mini_map_obj("CroneInactive") == 0 then
                        poe2_api.dbgp("G1_2-小地图没有-CroneInactive")
                        interaction_object_set = nil 
                        env.interaction_object = nil
                        interaction_object_map_name = {"CroneActive"}
                        env.interaction_object_map_name = {"CroneActive"}
                        env.interaction_object_copy = nil
                        env.interaction_object_map_name_copy = {"CroneActive"}
                        env.modify_interaction = true
                    end
                elseif player_info.current_map_name_utf8 == "G2_4_1" then
                    if #mini_map_obj("KabalaInactive") == 0 then
                        poe2_api.dbgp("G2_4_1小地图没有KabalaInactive")
                        interaction_object_set = nil 
                        env.interaction_object = nil
                        interaction_object_map_name = {"KabalaActive"}
                        env.interaction_object_map_name = {"KabalaActive"}
                        env.interaction_object_copy = nil
                        env.interaction_object_map_name_copy = {"KabalaActive"}
                        env.modify_interaction = true
                    end
                elseif player_info.current_map_name_utf8 == "G3_3" then
                    if #mini_map_obj("SilverbackBlackfistBossInactive") == 0 then
                        poe2_api.dbgp("G3_3小地图没有SilverbackBlackfistBossInactive")
                        interaction_object_set = nil 
                        env.interaction_object = nil
                        interaction_object_map_name = {"SilverbackBlackfistBossActive"}
                        env.interaction_object_map_name = {"SilverbackBlackfistBossActive"}
                        env.interaction_object_copy = nil
                        env.interaction_object_map_name_copy = {"SilverbackBlackfistBossActive"}
                        env.modify_interaction = true
                    end
                elseif player_info.current_map_name_utf8 == "G3_6_1" and not poe2_api.table_contains("艾瓦",interaction_object_set) then
                    if #mini_map_obj("BlackjawBossInactive") == 0 then
                        poe2_api.dbgp("G3_6_1地图没有BlackjawBossInactive")
                        interaction_object_set = {"門", "小型靈魂核心", "石陣祭壇"} 
                        env.interaction_object = {"門", "小型靈魂核心", "石陣祭壇"} 
                        interaction_object_map_name = {"BlackjawBossActive"}
                        env.interaction_object_map_name = {"BlackjawBossActive"}
                        env.interaction_object_copy = {"門", "小型靈魂核心", "石陣祭壇"}
                        env.interaction_object_map_name_copy = {"BlackjawBossActive"}
                        env.modify_interaction = true
                    end
                elseif player_info.current_map_name_utf8 == "G4_1_1" then
                    if #mini_map_obj("IsleOfKinBossInactive") == 0 then
                        poe2_api.dbgp("G4_1_1-地图没有-IsleOfKinBossInactive")
                        interaction_object_set = nil
                        env.interaction_object = nil 
                        interaction_object_map_name = {"IsleOfKinBossActive"}
                        env.interaction_object_map_name = {"IsleOfKinBossActive"}
                        env.interaction_object_copy = nil
                        env.interaction_object_map_name_copy = {"IsleOfKinBossActive"}
                        env.modify_interaction = true
                    end
                elseif player_info.current_map_name_utf8 == "G4_4_1" and task_name == "找出亡者之殿" then
                    if team_member_2 == "大號名" then
                        if #mini_map_obj("G4_4_2BossActive") == 0 and not self.complete_task then
                            poe2_api.dbgp("G4_4_1-地图没有-G4_4_2BossActive")
                            interaction_object_set = nil
                            env.interaction_object = nil
                            interaction_object_map_name = {"娜瓦莉"}
                            env.interaction_object_map_name ={"娜瓦莉"}
                            env.interaction_object_copy = nil
                            env.interaction_object_map_name_copy = {"娜瓦莉"}
                            env.modify_interaction = true
                        end
                    else
                        if #mini_map_obj("G4_4_2BossInactive") == 0 then
                            poe2_api.dbgp("G4_4_1-地图没有-G4_4_2BossInactive")
                            interaction_object_set = {"表示敬意"} 
                            env.interaction_object = {"表示敬意"}  
                            interaction_object_map_name = {"娜瓦莉"}
                            env.interaction_object_map_name ={"娜瓦莉"}
                            env.interaction_object_copy = {"表示敬意"} 
                            env.interaction_object_map_name_copy = {"娜瓦莉"}
                            env.modify_interaction = true
                        end
                    end
                elseif player_info.current_map_name_utf8 == "P2_6" then
                    if #mini_map_obj("P2_6_SevenSekhemasActive") == 0 then
                        poe2_api.dbgp("P2_6-地图没有-P2_6_SevenSekhemasActive")
                        interaction_object_set = {"塔巴納的恩惠"}
                        env.interaction_object = {"塔巴納的恩惠"} 
                        interaction_object_map_name = {"P2_6_SevenSekhemasInactive"}
                        env.interaction_object_map_name = {"P2_6_SevenSekhemasInactive"}
                        env.interaction_object_copy = {"塔巴納的恩惠"}
                        env.interaction_object_map_name_copy = {"P2_6_SevenSekhemasInactive"}
                        env.modify_interaction = true
                    end
                elseif player_info.current_map_name_utf8 == "G4_4_2" then
                    poe2_api.dbgp("G4_4_2 拿刺青")
                    poe2_api.dbgp(env.pick_up_fire)
                    poe2_api.dbgp(env.pick_up_ice)
                    poe2_api.dbgp(env.pick_up_Electricity)
                    if #mini_map_obj("G4_4_2_Encounter_ValakoTribeInactive") ~= 0 then
                        poe2_api.dbgp("G4_4_2-地图有-G4_4_2_Encounter_ValakoTribeInactive")
                        env.pick_up_fire = true
                    end
                    if #mini_map_obj("G4_4_2_Encounter_TasalioTribeInactive") ~= 0 then
                        poe2_api.dbgp("G4_4_2-地图有-G4_4_2_Encounter_TasalioTribeInactive")
                        env.pick_up_ice = true
                    end
                    if #mini_map_obj("G4_4_2_Encounter_NgamahuTribeInactive") ~= 0 then
                        poe2_api.dbgp("G4_4_2-地图有-G4_4_2_Encounter_NgamahuTribeInactive")
                        env.pick_up_Electricity = true
                    end
                    local task_text = {"將塔赫亞的空白紋身交給悉妮蔻拉圖騰","將塔薩里的空白紋身交給悉妮蔻拉圖騰","將拿馬乎的空白紋身交給悉妮蔻拉圖騰"}
                    if #mini_map_obj("G4_4_2_Encounter_ValakoTribeInactive") == 0 and not env.pick_up_fire then   
                        if min_map_dis("G4_4_2_Encounter_ValakoTribeActive") and #min_map_dis("G4_4_2_Encounter_ValakoTribeActive") > 0 then
                            local map_info = min_map_dis("G4_4_2_Encounter_ValakoTribeActive")[1]
                            local dis = poe2_api.point_distance(map_info.grid_x , map_info.grid_y, player_info)
                            if dis < 30 then
                                env.pick_up_fire = true
                                return bret.RUNNING
                            end
                        end 
                        poe2_api.dbgp("G4_4_2-地图没有-G4_4_2_Encounter_ValakoTribeInactive")
                        interaction_object_set = nil
                        env.interaction_object = nil
                        env.interaction_object_copy = nil
                        interaction_object_map_name = {"G4_4_2_Encounter_ValakoTribeActive"}
                        env.interaction_object_map_name = {"G4_4_2_Encounter_ValakoTribeActive"}
                        env.interaction_object_map_name_copy = {"G4_4_2_Encounter_ValakoTribeActive"}
                        env.modify_interaction = true
                    elseif #mini_map_obj("G4_4_2_Encounter_TasalioTribeInactive") == 0 and not env.pick_up_ice then
                        if min_map_dis("G4_4_2_Encounter_TasalioTribeActive") and #min_map_dis("G4_4_2_Encounter_TasalioTribeActive") > 0 then
                            local map_info = min_map_dis("G4_4_2_Encounter_TasalioTribeActive")[1]
                            local dis = poe2_api.point_distance(map_info.grid_x , map_info.grid_y, player_info)
                            if dis < 30 then
                                env.pick_up_ice = true
                                return bret.RUNNING
                            end
                        end 
                        poe2_api.dbgp("G4_4_2-地图没有-G4_4_2_Encounter_TasalioTribeInactive")
                        interaction_object_set = nil
                        env.interaction_object = nil
                        env.interaction_object_copy = nil
                        interaction_object_map_name = {"G4_4_2_Encounter_TasalioTribeActive"}
                        env.interaction_object_map_name = {"G4_4_2_Encounter_TasalioTribeActive"}
                        env.interaction_object_map_name_copy = {"G4_4_2_Encounter_TasalioTribeActive"}
                        env.modify_interaction = true
                    elseif #mini_map_obj("G4_4_2_Encounter_NgamahuTribeInactive") == 0 and not env.pick_up_Electricity then
                        if min_map_dis("G4_4_2_Encounter_NgamahuTribeActive") and #min_map_dis("G4_4_2_Encounter_NgamahuTribeActive") > 0 then
                            local map_info = min_map_dis("G4_4_2_Encounter_NgamahuTribeActive")[1]
                            local dis = poe2_api.point_distance(map_info.grid_x , map_info.grid_y, player_info)
                            if dis < 30 then
                                env.pick_up_Electricity = true
                                return bret.RUNNING
                            end
                        end 
                        poe2_api.dbgp("G4_4_2-地图没有-G4_4_2_Encounter_NgamahuTribeInactive")
                        interaction_object_set = nil
                        env.interaction_object = nil
                        env.interaction_object_copy = nil
                        interaction_object_map_name = {"G4_4_2_Encounter_NgamahuTribeActive"}
                        env.interaction_object_map_name = {"G4_4_2_Encounter_NgamahuTribeActive"}
                        env.interaction_object_map_name_copy = {"G4_4_2_Encounter_NgamahuTribeActive"}
                        env.modify_interaction = true
                    end
                    if poe2_api.table_contains(task_name,task_text) then
                        interaction_object_set = {"悉妮蔻拉圖騰"}
                        env.interaction_object = {"悉妮蔻拉圖騰"}
                        env.interaction_object_copy = {"悉妮蔻拉圖騰"}
                    end 
                    if task_name == '向悉妮蔻拉圖騰領取獎勵' then
                        interaction_object_set = {"悉妮蔻拉圖騰","塔赫亞的考驗獎勵","努葛瑪呼的考驗獎勵","拿馬乎的考驗獎勵","塔薩里奧的考驗獎勵"}
                        env.interaction_object = {"悉妮蔻拉圖騰","塔赫亞的考驗獎勵","努葛瑪呼的考驗獎勵","拿馬乎的考驗獎勵","塔薩里奧的考驗獎勵"}
                        env.interaction_object_copy = {"悉妮蔻拉圖騰","塔赫亞的考驗獎勵","努葛瑪呼的考驗獎勵","拿馬乎的考驗獎勵","塔薩里奧的考驗獎勵"}
                    end                  
                elseif player_info.current_map_name_utf8 == "G3_12" and poe2_api.table_contains("艾瓦",interaction_object_set) and team_member_2 ~="大號名" then
                    poe2_api.dbgp("G3_12地图")
                    interaction_object_set = nil
                    env.interaction_object = nil
                    interaction_object_map_name = {"艾瓦"}
                    env.interaction_object_map_name = {"艾瓦"}
                    env.interaction_object_copy = nil
                    env.interaction_object_map_name_copy = {"艾瓦"}
                    env.modify_interaction = true
                elseif player_info.current_map_name_utf8 == "G4_8b" and task_name == "詢問某人關於武器的事" then
                    if not min_map_dis("傳道士羅蘭迪斯") or #min_map_dis("傳道士羅蘭迪斯") == 0 then
                        poe2_api.dbgp("G4_8b-地图")
                        interaction_object_set = {"門"}
                        env.interaction_object = {"門"}
                        interaction_object_map_name = nil
                        env.interaction_object_map_name = nil
                        env.interaction_object_copy = {"門"}
                        env.interaction_object_map_name_copy = nil
                        env.modify_interaction = true
                    end
                elseif player_info.current_map_name_utf8 == "P1_2" and task_name == "擊敗迷霧之刃．希奧拉" then
                    for _,obj in ipairs(sorted_range_info) do
                        if obj.animated_name_utf8 == "Metadata/Effects/Spells/monsters_effects/Act4_FOUR/Verona/ao/rune_light.ao" then
                            if get_distance(obj.grid_x,obj.grid_y) > 25 then
                                local rune_point = api_FindNearestReachableInRange(obj.grid_x, obj.grid_y,15)
                                env.end_point = {rune_point.x,rune_point.y}
                                return bret.SUCCESS 
                            else
                                env.is_arrive_end = true
                                return bret.SUCCESS
                            end
                        end
                    end
                end
                if interaction_object_set and not poe2_api.table_contains("Per",interaction_object_set) then
                    for _,obj in ipairs(sorted_range_info) do
                        if poe2_api.table_contains(' 祭祀神壇',interaction_object_set) then 
                            if poe2_api.table_contains({"Metadata/Terrain/Leagues/Ritual/RitualRuneLight"},obj.path_name_utf8) and poe2_api.find_text({ UI_info = UI_info, text = " 祭祀神壇", min_x=200}) and obj.hasLineOfSight then
                                if get_distance(obj.grid_x,obj.grid_y) > 30 then
                                    local rune_point = api_FindNearestReachableInRange(obj.grid_x, obj.grid_y,15)
                                    env.end_point = {rune_point.x,rune_point.y}
                                    return bret.SUCCESS 
                                else
                                    env.is_arrive_end = true
                                    return bret.SUCCESS
                                end
                            end   
                        end
                        if poe2_api.table_contains('塔巴納的恩惠',interaction_object_set) then 
                            if poe2_api.table_contains({"Metadata/Terrain/Gallows/Act4_Interlude/Part2/P2_6/Objects/SekhemaShrine_01"},obj.path_name_utf8)  then
                                poe2_api.dbgp(get_distance(obj.grid_x,obj.grid_y))
                                if get_distance(obj.grid_x,obj.grid_y) > 30 then
                                    local rune_point = api_FindNearestReachableInRange(obj.grid_x, obj.grid_y,15)
                                    env.end_point = {rune_point.x,rune_point.y}
                                    return bret.SUCCESS 
                                else
                                    poe2_api.find_text({ UI_info = UI_info, text = "塔巴納的恩惠", min_x=200,click = 2})
                                    api_Sleep(5000)
                                    return bret.RUNNING
                                end
                            end   
                        end 
                        if not obj.name_utf8 then
                            goto continue
                        end
                        if poe2_api.table_contains(obj.name_utf8,interaction_object_set) then
                            poe2_api.dbgp(obj.name_utf8)
                            if player_info.current_map_name_utf8 == "G4_8b" and obj.name_utf8 == "門" and task_name == "詢問某人關於武器的事" then
                                if not obj.is_selectable then
                                    local door_toward = poe2_api.move_towards({local_x,local_y},{obj.grid_x,obj.grid_y},40)
                                    if  door_toward and #door_toward > 0 then
                                        api_ClickMove(door_toward[1],door_toward[2],0)
                                        poe2_api.click_keyboard("space")
                                        api_Sleep(500)
                                        return bret.RUNNING
                                    end
                                end
                            end
                            if obj.name_utf8 == "悉妮蔻拉圖騰" then
                                if get_distance(obj.grid_x,obj.grid_y) < 25 then
                                    api_ClickMove(poe2_api.toInt(obj.grid_x),poe2_api.toInt(obj.grid_y),1)
                                    api_Sleep(500)
                                    env.is_arrive_end = true
                                    return bret.SUCCESS
                                end
                            end
                            if player_info.current_map_name_utf8 == "P2_7" and obj.name_utf8 == "宏偉巨靈之幣" then
                                if get_distance(obj.grid_x,obj.grid_y) > 30 then
                                    local rune_point = api_FindNearestReachableInRange(obj.grid_x, obj.grid_y,50)
                                    env.end_point = {rune_point.x,rune_point.y}
                                    return bret.SUCCESS 
                                else
                                    env.is_arrive_end = true
                                    return bret.SUCCESS
                                end
                            end
                            if player_info.current_map_name_utf8 == "G4_10" and obj.name_utf8 == "塔瓦凱" and task_name == "進入挖掘場遺址" then
                                if obj.is_selectable then
                                    local door_toward = poe2_api.move_towards({local_x,local_y},{obj.grid_x,obj.grid_y},40)
                                    if  door_toward and #door_toward > 0 then
                                        api_ClickMove(door_toward[1],door_toward[2],0)
                                        poe2_api.click_keyboard("space")
                                        api_Sleep(500)
                                        return bret.RUNNING
                                    end
                                end
                            end
                            if task_name == "擊敗憎惡者．賈嫚拉" and player_info.current_map_name_utf8 == "G2_12_2" and not poe2_api.find_text({ UI_info = UI_info, text = obj.name_utf8, min_x=200}) then
                                if get_distance(obj.grid_x,obj.grid_y) > 30 then
                                    local interaction_point = api_CollectReachableInCircleSimple(obj.grid_x, obj.grid_y,29)
                                    local interaction_sorted = poe2_api.sort_recent_point_list(interaction_point,local_x,local_y)
                                    env.end_point = {interaction_sorted[1].x,interaction_sorted[1].y}
                                    return bret.SUCCESS
                                else
                                    env.is_arrive_end = true
                                    return bret.SUCCESS
                                end
                            end
                            if obj.name_utf8 == "符文之印" then
                                if obj.stateMachineList and obj.stateMachineList.ready ==1 and obj.stateMachineList.stabbed == 0 then
                                    if get_distance(obj.grid_x,obj.grid_y) < 25 then
                                        api_ClickMove(poe2_api.toInt(obj.grid_x),poe2_api.toInt(obj.grid_y),1)
                                        if self.time1 == 0 then
                                            self.time1 = api_GetTickCount64()
                                        end
                                        if api_GetTickCount64() - self.time1 > 6*1000 then
                                            local obj_walk_point = api_FindRandomWalkablePosition(obj.grid_x, obj.grid_y,30)
                                            api_ClickMove(obj_walk_point.x,obj_walk_point.y,0)
                                            poe2_api.click_keyboard("space")
                                            self.time1 = 0
                                        end
                                        return bret.RUNNING
                                    else
                                        self.time1 = 0
                                        local obj_reach_point = api_FindNearestReachableInRange(obj.grid_x, obj.grid_y,10)
                                        env.end_point = {obj_reach_point.x,obj_reach_point.y}  
                                        return bret.SUCCESS
                                    end
                                end
                                goto continue
                            end
                            if obj.name_utf8 == "傳承之井" then
                                if get_distance(obj.grid_x,obj.grid_y) < 25 then
                                    api_ClickMove(poe2_api.toInt(obj.grid_x),poe2_api.toInt(obj.grid_y),1)
                                    if self.time1 == 0 then
                                        self.time1 = api_GetTickCount64()
                                    end
                                    if api_GetTickCount64() - self.time1 > 6*1000 then
                                        local obj_walk_point = api_FindRandomWalkablePosition(obj.grid_x, obj.grid_y,30)
                                        api_ClickMove(obj_walk_point.x,obj_walk_point.y,0)
                                        poe2_api.click_keyboard("space")
                                        self.time1 = 0
                                    end
                                    return bret.RUNNING
                                else
                                    self.time1 = 0
                                    local obj_reach_point = api_FindNearestReachableInRange(obj.grid_x, obj.grid_y,10)
                                    env.end_point = {obj_reach_point.x,obj_reach_point.y}  
                                    return bret.SUCCESS
                                end
                            end
                            if obj.name_utf8 == "石陣祭壇" and poe2_api.find_text({ UI_info = UI_info, text = obj.name_utf8, min_x=0}) then
                                if get_distance(obj.grid_x,obj.grid_y) < 25 then
                                    api_ClickMove(poe2_api.toInt(obj.grid_x),poe2_api.toInt(obj.grid_y),1)
                                    if self.time1 == 0 then
                                        self.time1 = api_GetTickCount64()
                                    end
                                    if api_GetTickCount64() - self.time1 > 6*1000 then
                                        local obj_walk_point = api_FindRandomWalkablePosition(obj.grid_x, obj.grid_y,30)
                                        api_ClickMove(obj_walk_point.x,obj_walk_point.y,0)
                                        poe2_api.click_keyboard("space")
                                        self.time1 = 0
                                    end
                                    return bret.RUNNING
                                else
                                    self.time1 = 0
                                    local obj_reach_point = api_FindNearestReachableInRange(obj.grid_x, obj.grid_y,10)
                                    env.end_point = {obj_reach_point.x,obj_reach_point.y}  
                                    return bret.SUCCESS
                                end
                            end
                            if obj.name_utf8 == "卡魯圖騰" then
                                if get_distance(obj.grid_x,obj.grid_y) < 25 and poe2_api.find_text({UI_info = UI_info,text = "卡魯圖騰", min_x = 160,refresh = true}) then
                                    api_ClickMove(poe2_api.toInt(obj.grid_x),poe2_api.toInt(obj.grid_y),1)
                                    if self.time1 == 0 then
                                        self.time1 = api_GetTickCount64()
                                    end
                                    if api_GetTickCount64() - self.time1 > 6*1000 then
                                        local obj_walk_point = api_FindRandomWalkablePosition(obj.grid_x, obj.grid_y,30)
                                        api_ClickMove(obj_walk_point.x,obj_walk_point.y,0)
                                        poe2_api.click_keyboard("space")
                                        self.time1 = 0
                                    end
                                    return bret.RUNNING
                                else
                                    self.time1 = 0
                                    local obj_reach_point = api_FindNearestReachableInRange(obj.grid_x, obj.grid_y,10)
                                    env.end_point = {obj_reach_point.x,obj_reach_point.y}  
                                    return bret.SUCCESS
                                end
                            end
                            if poe2_api.table_contains(obj.name_utf8,{"受傷的男人", "水之女神", "水之女神．哈拉妮","表示敬意","娜瓦莉"}) and get_distance(obj.grid_x,obj.grid_y) > 25 and get_distance(obj.grid_x,obj.grid_y) < 150 then
                                local obj_reach_point = api_FindNearestReachableInRange(obj.grid_x, obj.grid_y,15)
                                if obj_reach_point.x ~= -1 then
                                    env.end_point = {obj_reach_point.x,obj_reach_point.y}
                                else
                                    env.end_point = {obj.grid_x,obj.grid_y}
                                end
                                return bret.SUCCESS
                            end
                            if poe2_api.find_text({ UI_info = UI_info, text = obj.name_utf8, min_x=0}) and ( obj.hasLineOfSight or poe2_api.table_contains(obj.type,{-1,4}) or (obj.type == 3 and obj.is_selectable) or poe2_api.table_contains(obj.name_utf8, {"受傷的男人", "水之女神", "水之女神．哈拉妮"})) then
                                poe2_api.dbgp("找到目标UI")
                                if get_distance(obj.grid_x,obj.grid_y) > 30 then
                                    local interaction_point = api_FindNearestReachableInRange(obj.grid_x, obj.grid_y,15)
                                    env.end_point = {interaction_point.x,interaction_point.y}
                                    return bret.SUCCESS
                                else
                                    if obj.name_utf8 == "把手" and player_info.current_map_name_utf8 == "G4_5_1" then
                                        api_ClickMove(poe2_api.toInt(obj.grid_x),poe2_api.toInt(obj.grid_y),1,poe2_api.toInt(obj.world_z))
                                        api_Sleep(500)
                                        return bret.RUNNING
                                    end
                                    env.is_arrive_end = true
                                    return bret.SUCCESS
                                end
                            end
                            if poe2_api.table_contains(player_info.current_map_name_utf8,{"G2_10_2","G4_1_2","G4_4_2"}) and poe2_api.table_contains(obj.name_utf8, {"法里登叛變者．芮蘇","馬提奇","悉妮蔻拉圖騰"}) then
                                if get_distance(obj.grid_x,obj.grid_y) < 30 then
                                    if obj.name_utf8 == "馬提奇" then
                                        api_ClickMove(poe2_api.toInt(obj.grid_x),poe2_api.toInt(obj.grid_y),1,poe2_api.toInt(obj.world_z))
                                        env.is_arrive_end = true
                                        return bret.SUCCESS
                                    end
                                    api_ClickMove(poe2_api.toInt(obj.grid_x),poe2_api.toInt(obj.grid_y),1)
                                    env.is_arrive_end = true
                                    return bret.SUCCESS
                                else
                                    env.end_point = {obj.grid_x,obj.grid_y}
                                    return bret.SUCCESS
                                end
                                
                                
                            end
                            if obj.hasLineOfSight and obj.is_selectable and get_distance(obj.grid_x,obj.grid_y) < 30 then
                                api_ClickMove(poe2_api.toInt(obj.grid_x),poe2_api.toInt(obj.grid_y),1)
                                return bret.RUNNING
                            end
                        end
                        ::continue::
                    end
                end
                if interaction_object_map_name then
                    poe2_api.dbgp("小地图")
                    for _,map_obj in ipairs(current_map_info) do
                        local name = map_obj.name_utf8
                        if task_name == "找出亡者之殿" and name == "娜瓦莉" then
                            if map_obj.flagStatus1 ~= 0 then
                                goto continue
                            end
                            if get_distance(map_obj.grid_x, map_obj.grid_y) < 35 then
                                if self.map_task_time ==0 then
                                    self.map_task_time = api_GetTickCount64()
                                end
                                if api_GetTickCount64() - self.map_task_time > 60*1000 then
                                    self.complete_task = true
                                    return bret.RUNNING
                                end
                            else
                                self.map_task_time = 0
                            end
                        end
                        if (not name or not poe2_api.table_contains(name,interaction_object_map_name)) and not record_map then
                            goto continue 
                        end
                        if not record_map then
                            env.record_map = map_obj
                        end
                        record_map = env.record_map
                        if record_map and name and poe2_api.table_contains(name,interaction_object_map_name) and record_map.grid_x ~= map_obj.grid_x and record_map.grid_y ~= map_obj.grid_y then
                            poe2_api.dbgp("未找到目标地图")
                            env.record_map = nil
                            env.map_result = nil
                            return bret.RUNNING
                        end
                        local map_distance = 30
                        if team_member_2 ~= "大號名" and poe2_api.table_contains(player_info.current_map_name_utf8,{"G3_12"}) then
                            map_distance = 25
                        end
                        if record_map and record_map.name_utf8 == "G4_3_1_BossActive" and record_map.flagStatus1 == 1 then
                            poe2_api.dbgp("G4_3_1_BossActive")
                            local player_position = api_FindNearestReachableInRange(record_map.grid_x, record_map.grid_y, 50)
                            if not env.prestore_boss_list or not next(env.prestore_boss_list) then
                                local result_list = api_GetCalculateCircleGridPoints(poe2_api.toInt(player_position.x),poe2_api.toInt(player_position.y),100,math.floor(15))
                                if result_list then
                                    poe2_api.dbgp("22222:",#result_list)
                                    env.prestore_boss_list = result_list
                                    poe2_api.dbgp("获取圆点列表")
                                    return "刷新"
                                else
                                    local point = api_FindRandomWalkablePosition(math.floor(player_position.x),math.floor(player_position.y),80)
                                    if point then
                                        env.end_point = {point.x,point.y}
                                    else
                                        poe2_api.dbgp("获取圆形范围内均匀分布的网格点失败,随机移动")
                                        return "刷新"
                                    end
                                    
                                end
                            else
                                local distance = poe2_api.point_distance(env.prestore_boss_list[1].x,env.prestore_boss_list[1].y,player_info)
                                if distance and distance < 25 then
                                    table.remove(env.prestore_boss_list,1)
                                    if #env.prestore_boss_list == 0 then
                                        env.record_map = nil
                                    end
                                    poe2_api.dbgp("移动到圆点列表第一个点完成")
                                    return "刷新"
                                end
                                poe2_api.dbgp("移动到圆形范围内第一个点")
                                env.end_point = {env.prestore_boss_list[1].x,env.prestore_boss_list[1].y}
                            end
                            return bret.SUCCESS
                        end
                        if get_distance(record_map.grid_x, record_map.grid_y) < map_distance then
                            if team_member_2 ~= "大號名" and poe2_api.table_contains(player_info.current_map_name_utf8,{"G3_12"}) then
                                return bret.SUCCESS
                            end
                            env.record_map = nil
                            if boss_name and #boss_name > 0 then
                                local boss_list = poe2_api.get_sorted_obj(boss_name,range_info,player_info)
                                if boss_list and #boss_list > 0 and boss_list[1].life >0 then
                                    local boss = boss_list[1]
                                    local toward_boss = poe2_api.move_towards({local_x,local_y},{boss.grid_x,boss.grid_y},20)
                                    api_ClickMove(poe2_api.toInt(toward_boss[1]),poe2_api.toInt(toward_boss[2]),0)
                                    api_Sleep(100)
                                    poe2_api.click_keyboard("space")
                                end
                                local toward_record_map = poe2_api.move_towards({local_x,local_y},{record_map.grid_x, record_map.grid_y},20)
                                api_ClickMove(poe2_api.toInt(toward_record_map[1]),poe2_api.toInt(toward_record_map[2]),0)
                                api_Sleep(100)
                                poe2_api.click_keyboard("space")
                            end
                            env.is_arrive_end = true
                            return bret.SUCCESS
                        end
                        local record_map_near_point = api_FindNearestReachableInRange(record_map.grid_x, record_map.grid_y, 30)
                        local player_near_point = api_FindNearestReachableInRange(local_x, local_y, 30)
                        if not map_result then
                            map_result = true
                            env.map_result = true
                            self.path_result = api_FindPath(player_near_point.x, player_near_point.y, record_map_near_point.x, record_map_near_point.y)
                        end
                        if self.path_result and #self.path_result > 0 then
                            env.end_point = {record_map_near_point.x,record_map_near_point.y}
                            return bret.SUCCESS
                        else
                            env.not_need_active = true
                            return bret.RUNNING
                        end
                        ::continue::
                    end
                end
                env.record_map = nil
                map_result = nil
                env.map_result = nil
                self.path_result = nil
            end
            env.not_need_active = true
            poe2_api.time_p("[The_Interactive_Object_Exist]",(api_GetTickCount64() - current_time))
            return bret.RUNNING
        end
    },

    -- 交互
    Interactive = {
        run = function(self, env)
            poe2_api.dbgp("交互Interactive")
            poe2_api.print_log("交互")
            local interaction_object = env.interaction_object
            local player_info = env.player_info
            local range_info = env.range_info
            local current_map_info = env.current_map_info
            local UI_info = env.UI_info
            local team_member_2 = poe2_api.get_team_info(env.team_info,env.user_config,player_info,2)
            local function party_dis(actors, mini_map_name)
                local members = env.team_info_data
                if not members then
                    poe2_api.api_print("警告：未找到团队信息")
                    return false
                end
            
                local member_names = {}
                for _, m in ipairs(members) do
                    if m.name_utf8 ~= player_info.name_utf8 then
                        member_names[m.name_utf8] = true
                    end
                end
            
                local target = nil
                for _, o in ipairs(current_map_info) do
                    if o.name_utf8 == mini_map_name then
                        target = o
                        break
                    end
                end
            
                if not target then
                    return false
                end
            
                for _, actor in ipairs(actors) do
                    if member_names[actor.name_utf8] then
                        local distance = poe2_api.get_point_distance(actor.grid_x, actor.grid_y,target.grid_x, target.grid_y)
                        if distance > 25 then
                            return false
                        end
                    end
                end
            
                return true
            end
            if self.last_click_time == nil then
                self.last_click_time = 0
            end 
            if not interaction_object or #interaction_object == 0 then
                env.is_not_ui = true
                return bret.RUNNING 
            end
            if team_member_2 == "大號名" and poe2_api.table_contains("黑衣幽魂", interaction_object) then
                return bret.RUNNING
            end
            if team_member_2 == "小號名" and poe2_api.table_contains(interaction_object[1],{"石陣祭壇"}) then
                env.is_not_ui = true
                return bret.RUNNING
            end
            if team_member_2 == "大號名" and poe2_api.table_contains(interaction_object,"調查平台") then
                if not party_dis(range_info,"艾瓦") then
                    poe2_api.dbgp("小号未到調查平台")
                    return bret.RUNNING
                end
            end
            if #interaction_object > 1 then
                api_Sleep(500)
                if interaction_object[2] == "艾瓦" then  -- Lua 索引从1开始
                    if poe2_api.find_text({UI_info = UI_info,text = interaction_object[1], min_x = 160,refresh = true}) then
                        api_Sleep(500)
                        poe2_api.find_text({UI_info = UI_info,text = interaction_object[1], click = 2, min_x = 160,refresh = true})
                        api_Sleep(500)
                    end
                end
                if interaction_object[2] == "把手" and player_info.current_map_name_utf8 == "G4_5_2" then
                    if poe2_api.find_text({UI_info = UI_info,text = interaction_object[2], min_x = 160,refresh = true}) then
                        poe2_api.find_text({UI_info = UI_info,text = interaction_object[2], click = 2, min_x = 160,refresh = true})
                        if poe2_api.find_text({UI_info = UI_info,text = "記錄點",  min_x = 160,refresh = true}) then
                            api_Sleep(12000)
                            api_UpdateMapObstacles(100)
                        else
                            api_Sleep(5000)
                        end
                        return bret.RUNNING
                    end         
                end
                if poe2_api.find_text({UI_info = UI_info,text = interaction_object[2], min_x = 160,refresh = true}) then
                    api_Sleep(500)
                    poe2_api.find_text({UI_info = UI_info,text = interaction_object[2], click = 2, min_x = 160,refresh = true})
                    api_Sleep(500)
                end
                if #interaction_object > 2 then
                    if poe2_api.find_text({UI_info = UI_info,text = interaction_object[3], min_x = 160,refresh = true}) then
                        api_Sleep(500)
                        poe2_api.find_text({UI_info = UI_info,text = interaction_object[3], click = 2, min_x = 160,refresh = true})
                        api_Sleep(500)
                    end
                    if #interaction_object > 3 then
                        if poe2_api.find_text({UI_info = UI_info,text = interaction_object[4], min_x = 160,refresh = true}) then
                            api_Sleep(500)
                            poe2_api.find_text({UI_info = UI_info,text = interaction_object[4], click = 2, min_x = 160,refresh = true})
                            api_Sleep(500)
                        end
                        if #interaction_object > 4 then
                            if poe2_api.find_text({UI_info = UI_info,text = interaction_object[5], min_x = 160,refresh = true}) then
                                api_Sleep(500)
                                poe2_api.find_text({UI_info = UI_info,text = interaction_object[5], click = 2, min_x = 160,refresh = true})
                                api_Sleep(500)
                            end
                        end
                        if #interaction_object > 5 then
                            if poe2_api.find_text({UI_info = UI_info,text = interaction_object[6], min_x = 160,refresh = true}) then
                                api_Sleep(500)
                                poe2_api.find_text({UI_info = UI_info,text = interaction_object[6], click = 2, min_x = 160,refresh = true})
                                api_Sleep(500)
                            end
                        end
                        if #interaction_object > 6 then
                            if poe2_api.find_text({UI_info = UI_info,text = interaction_object[7], min_x = 160,refresh = true}) then
                                api_Sleep(500)
                                poe2_api.find_text({UI_info = UI_info,text = interaction_object[7], click = 2, min_x = 160,refresh = true})
                                api_Sleep(500)
                            end
                        end
                    end
                end
            end
            if poe2_api.find_text({UI_info = UI_info,text = "繼續", min_x = 160,refresh = true,click = 2}) then
                poe2_api.click_keyboard("space")
                env.interaction_object = nil
                api_Sleep(500)
                return bret.SUCCESS
            end
            if poe2_api.find_text({UI_info = UI_info,text = "接受任務", min_x = 160,refresh = true,click = 2}) then
                api_Sleep(500)
                return bret.RUNNING
            end
            local ac = poe2_api.find_text({UI_info = UI_info,text = interaction_object[1], max_x=1347,min_x=160,position = 3,refresh = true})
            if ac and #ac > 0 then
                if poe2_api.table_contains(interaction_object[1],{"符文之印","壓桿"}) then
                    return bret.RUNNING
                end
                if self.last_click_time == 0 then
                    self.last_click_time = api_GetTickCount64()
                end
                if poe2_api.table_contains(interaction_object[1], {"石陣祭壇"}) and api_GetTickCount64() - self.last_click_time > 15*1000 then
                    self.last_click_time = 0
                    api_ClickScreen(poe2_api.toInt(ac[1].x),poe2_api.toInt(ac[1].y),0)
                    api_Sleep(200)
                    api_ClickScreen(poe2_api.toInt(ac[1].x),poe2_api.toInt(ac[1].y),1)
                    api_Sleep(500)
                    poe2_api.click_keyboard("space")
                elseif not poe2_api.table_contains(interaction_object[1], {"石陣祭壇"}) then
                    self.last_click_time = 0
                end
                poe2_api.find_text({UI_info = UI_info,text = interaction_object[1], click = 2, max_x=1347,max_y=775,min_x=160,refresh = true})
                api_Sleep(500)
                return bret.RUNNING
            end
            self.last_click_time = 0
            return bret.RUNNING
        end
    },

    Is_Follow_Move = {
        run = function(self, env)
            poe2_api.dbgp("跟随移动模块开始执行...")
            poe2_api.print_log("跟随移动模块开始执行...")
            local player_info = api_GetLocalPlayer()
            local me_area = player_info.current_map_name_utf8
            local team_member_2 = poe2_api.get_team_info(env.team_info,env.user_config,player_info,2)
            if poe2_api.table_contains(team_member_2,{"大號名", "未知"}) or me_area == "G1_1" or poe2_api.find_text({ UI_info = env.UI_info,text = "抵達皆伐"}) then
                poe2_api.dbgp("大号不跟随")
                return bret.SUCCESS
            elseif string.find(me_area, "own") then
                poe2_api.dbgp("城镇不跟随")
                return bret.RUNNING
            elseif poe2_api.table_contains(me_area,{"G2_3a"}) then
                poe2_api.dbgp("特殊地图不跟随")
                return bret.SUCCESS
            elseif not poe2_api.table_contains(team_member_2,{"大號名", "未知"}) and player_info.isInBossBattle and me_area == "G4_4_2" then
                poe2_api.dbgp("Boss地區不跟随")
                return bret.SUCCESS
            else
                poe2_api.dbgp("跟随移动模块开始执行")
                return bret.FAIL
            end
        end
    },

    -- 是否与隊長距离过远
    Is_Far_Away_From_Capital = {
        run = function(self, env)
            poe2_api.dbgp("是否与队长距离过远模块开始执行...")
            poe2_api.print_log("是否与队长距离过远模块开始执行...")
            local player_info = env.player_info
            local range_info = env.range_info
            local team_member_3 = poe2_api.get_team_info(env.team_info,env.user_config,player_info,3)
            local point = nil
            for _, actor in ipairs(range_info) do
                if actor.name_utf8 == team_member_3 then
                    point = actor
                    break
                end
            end 
            if point and poe2_api.point_distance(point.grid_x, point.grid_y, player_info) < 70 then
                poe2_api.dbgp("与队长距离小与80")
                env.path_list_follow = {}
                env.end_point_follow = nil
                env.roll_time = nil
                env.exit_time = nil
                return bret.SUCCESS
            else
                poe2_api.dbgp("与队长距离过远")
                return bret.FAIL
            end
        end
    },

    -- 移动到近点大号位置
    Move_To_Near_Leader_Point = {
        run = function(self, env)
            poe2_api.dbgp("移动到近点大号位置模块开始执行...")
            poe2_api.print_log("移动到近点大号位置模块开始执行...")
            local player_info = env.player_info
            local range_info = env.range_info
            local team_member_3 = poe2_api.get_team_info(env.team_info,env.user_config,player_info,3)
            if self.timeout == nil then
                self.timeout = 8*1000
                self.bool = false
                self.current_time = 0
            end
            if self.current_time == 0 then
                self.current_time = api_GetTickCount64()
            end
            if api_GetTickCount64() - self.current_time > self.timeout and not player_info.isMoving then
                poe2_api.dbgp("移动到近点大号位置模块执行超时")
                local safe_point = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 60, 10, 0, 0.5)
                api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y) , 0)
                api_Sleep(200)
                poe2_api.click_keyboard("space")
                self.current_time = 0
                return bret.RUNNING
            end

            local function check_pos(names)
                for _, actor in ipairs(range_info) do
                    if actor.name_utf8 == names then
                        return actor
                    end
                end
                return nil
            end
            local a = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 985,min_y = 5,max_x = 1034,max_y = 47})
            if poe2_api.find_text({UI_info = env.UI_info, text="記錄點", add_x = 213, max_y = 50}) and a and next(a) then
                poe2_api.find_text({UI_info = env.UI_info, text="記錄點", click=2, add_x = 213, max_y = 50})
                return bret.RUNNING
            end
            local target = check_pos(team_member_3)
            if target then
                if poe2_api.point_distance(target.grid_x, target.grid_y, player_info) <= 20 then
                    poe2_api.dbgp("与队长距离小于20")
                    env.path_list_follow = {}
                    local player_walk_point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 30)
                    local dis = poe2_api.point_distance(player_walk_point.x, player_walk_point.y, player_info)
                    if dis >= 20 then
                        api_ClickMove(poe2_api.toInt(player_walk_point.x), poe2_api.toInt(player_walk_point.y) , 0)
                        api_Sleep(200)
                        poe2_api.click_keyboard("space")
                        return bret.RUNNING
                    end
                    self.bool = false
                    self.current_time = 0
                    return bret.RUNNING
                elseif poe2_api.point_distance(target.grid_x, target.grid_y, player_info) <= 30 then
                    poe2_api.dbgp("与队长距离小于30")
                    env.path_list_follow = {}
                    local safe_point = api_GetSafeAreaLocation(env.player_info.grid_x, env.player_info.grid_y, 60, 10, 0, 0.5)
                    api_ClickMove(poe2_api.toInt(safe_point.x), poe2_api.toInt(safe_point.y) , 7)
                    self.bool = false
                    api_Sleep(200)
                    self.current_time = 0
                    return bret.RUNNING
                elseif poe2_api.point_distance(target.grid_x, target.grid_y, player_info) <= 60 then
                    poe2_api.dbgp("与队长距离小于60")
                    env.path_list_follow = {}
                    if not self.bool then
                        self.bool = true
                        poe2_api.click_keyboard("shift")
                    end
                    self.current_time = 0
                    return bret.RUNNING
                elseif poe2_api.point_distance(target.grid_x, target.grid_y, player_info) <= 70 then
                    poe2_api.dbgp("与队长距离小于70")
                    self.bool = false
                    self.current_time = 0
                    api_ClickMove(poe2_api.toInt(target.x), poe2_api.toInt(target.y) , 0)
                    api_Sleep(200)
                    api_ClickMove(poe2_api.toInt(target.x), poe2_api.toInt(target.y) , 7)
                    api_Sleep(200)
                    return bret.RUNNING
                end
            end
            return bret.RUNNING
        end
    },

    -- 跟随移动获取路径
    GET_Path_Follow = {
        run = function(self, env)
            poe2_api.dbgp("跟随移动获取路径模块开始执行...")
            poe2_api.print_log("跟随移动获取路径模块开始执行...")
            local player_info = env.player_info
            local range_info = env.range_info
            local current_time = api_GetTickCount64()
            local path_list_follow = env.path_list_follow
            if not env.get_follow_path_time then
                env.get_follow_path_time = 0
            end
            if path_list_follow and #path_list_follow > 0 then
                poe2_api.dbgp("跟随移动有路径")
                poe2_api.time_p("GET_Path_Follow",api_GetTickCount64()-current_time)
                return bret.SUCCESS
            end
            local team_member_3 = poe2_api.get_team_info(env.team_info,env.user_config,player_info,3)
            local function check_pos(names)
                for _, actor in ipairs(range_info) do
                    if actor.name_utf8 == names then
                        return actor
                    end
                end
                return nil
            end
            local target = check_pos(team_member_3)
            if not target then
                poe2_api.dbgp("没有目标：大号")
                return bret.RUNNING
            end
            local reachable_point = api_FindNearestReachableInRange(player_info.grid_x, player_info.grid_y,50)
            local target_reachable_point = api_FindNearestReachableInRange(target.grid_x, target.grid_y,40)
            local result = api_FindPath(reachable_point.x, reachable_point.y, target_reachable_point.x, target_reachable_point.y)
            if result and #result > 0 then
                poe2_api.dbgp("跟随移动获取路径成功")
                local coordinates = poe2_api.extract_coordinates(result, 22)
                env.path_list_follow = coordinates
                table.remove(coordinates, 1)
                env.target_point_follow = {coordinates[1].x, coordinates[1].y}
            else
                poe2_api.dbgp("跟随移动获取路径失败")
                local arena_list =poe2_api.get_sorted_obj("競技場",range_info,player_info)
                if arena_list and #arena_list > 0 then
                    if arena_list[1].hasLineOfSight and arena_list[1].is_selectable then
                        local arena_list_path = api_FindPath(reachable_point.x, reachable_point.y, arena_list[1].grid_x, arena_list[1].grid_y)
                        if arena_list_path and #arena_list_path > 0 then
                            local coordinates = poe2_api.extract_coordinates(arena_list_path, 22)
                            env.path_list_follow = coordinates
                            if #coordinates > 1 then
                                table.remove(coordinates, 1)
                            end
                            env.target_point_follow = {coordinates[1].x, coordinates[1].y}
                        end
                    elseif not arena_list[1].hasLineOfSight then
                        api_RestoreOriginalMap()
                    end
                    api_ClickMove(poe2_api.toInt(reachable_point.x), poe2_api.toInt(reachable_point.y) , 7)
                    api_RestoreOriginalMap()
                    return bret.RUNNING
                end
                if env.get_follow_path_time == 0 then
                    env.get_follow_path_time = api_GetTickCount64()
                end
                local ctime = api_GetTickCount64() - env.get_follow_path_time
                poe2_api.dbgp("ctime:", ctime)
                if ctime > 60 * 1000 then
                    poe2_api.dbgp("[GET_Path_Follow] 未找到路径 60 秒，回城")
                    for _, k in ipairs(env.range_info) do
                        if k.name_utf8 ~= '' and k.type == 5 and poe2_api.table_contains(k.name_utf8, my_game_info.city_map) then
                            dis = poe2_api.point_distance(k.grid_x, k.grid_y, player_info)
                            if dis and dis < 50 then
                                if not poe2_api.find_text({UI_info = env.UI_info, text = k.name_utf8, click = 2}) then
                                    api_ClickMove(poe2_api.toInt(k.grid_x), poe2_api.toInt(k.grid_y), 1)
                                end
                                api_Sleep(2000)
                                return bret.RUNNING
                            end
                        end
                    end
                    api_ClickScreen(1230, 815, 0)
                    api_Sleep(500)
                    api_ClickScreen(1230, 815, 1)
                    api_Sleep(2000)
                    return bret.RUNNING
                end
                local player_walk_point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 30)
                api_ClickMove(poe2_api.toInt(player_walk_point.x), poe2_api.toInt(player_walk_point.y) , 7)
                api_RestoreOriginalMap()
                return bret.RUNNING
            end
            poe2_api.time_p("GET_Path_Follow",api_GetTickCount64()-current_time)
            return bret.SUCCESS
        end
    }, 

    -- 移动到远点大号位置
    Move_To_Far_Leader_Point = {
        run = function(self, env)
            poe2_api.dbgp("移动到远点大号位置模块开始执行...")
            poe2_api.print_log("移动到远点大号位置模块开始执行...")
            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            local range_info = env.range_info
            local path_list_follow = env.path_list_follow
            local team_member_3 = poe2_api.get_team_info(env.team_info, env.user_config, player_info, 3)
            local point = env.target_point_follow
            local move_interval = math.random() * 0.2 + 0.2

            poe2_api.dbgp(string.format("玩家信息: 地图=%s, 生命=%d, 坐标=(%d,%d)", 
                player_info.current_map_name_utf8 or "未知", 
                player_info.life or 0, 
                player_info.grid_x or 0, 
                player_info.grid_y or 0))
            poe2_api.dbgp(string.format("目标点: %s", point and string.format("(%d,%d)", point[1], point[2]) or "无"))
            poe2_api.dbgp(string.format("队伍成员3: %s", team_member_3 or "无"))
            poe2_api.dbgp(string.format("移动间隔: %.2f秒", move_interval))

            if self.timeout == nil then
                poe2_api.dbgp("初始化超时参数")
                self.last_move_time = api_GetTickCount64()
                self.timeout = 6 * 1000
                self.current_time = 0
                self.last_point_time = 0
                self.movement_threshold = 15
                self.special_maps = {"G1_6", "G3_2_2", "G3_12"}
                poe2_api.dbgp(string.format("超时设置: timeout=%dms, threshold=%d", self.timeout, self.movement_threshold))
            end

            if env.roll_time == nil or self.current_time == 0 then
                poe2_api.dbgp("设置翻滚时间基准")
                self.current_time = api_GetTickCount64()
            end

            if env.exit_time == nil or self.last_point_time == 0 then
                poe2_api.dbgp("设置退出时间基准")
                self.last_point_time = api_GetTickCount64()
            end

            local function check_pos(names)
                poe2_api.dbgp(string.format("在范围信息中查找角色: %s", names))
                for _, actor in ipairs(range_info) do
                    if actor.name_utf8 == names then
                        poe2_api.dbgp(string.format("找到角色: %s, 坐标=(%d,%d)", names, actor.grid_x or 0, actor.grid_y or 0))
                        return actor
                    end
                end
                poe2_api.dbgp(string.format("未找到角色: %s", names))
                return nil
            end

            env.roll_time = math.abs(current_time - self.current_time)
            env.exit_time = math.abs(current_time - self.last_point_time)

            if env.roll_time > self.timeout and not player_info.isMoving and player_info.life > 0 then
                poe2_api.dbgp("移动到远点大号位置模块超时翻滚")
                
                local function get_range()
                    local valid_objects = {
                        "甕", "壺", "屍體", "巢穴", "籃子", "小雕像", "石塊",
                        "鬆動碎石", "瓶子", "盒子", "腐爛木材", "保險箱", "腐爛木材","祕寶"
                    }
                    
                    poe2_api.dbgp("开始查找可交互对象")
                    local sorted_range = poe2_api.get_sorted_list(env.range_info, env.player_info)
                    if not sorted_range then
                        poe2_api.dbgp("警告: 无法获取排序后的范围列表")
                        return false
                    end

                    poe2_api.dbgp(string.format("检查 %d 个范围内的对象", #sorted_range))
                    
                    for _, obj in ipairs(sorted_range) do
                        poe2_api.dbgp(string.format("检查对象: %s (类型: %s, 激活: %s, 可选: %s, 坐标=(%d,%d))", 
                            obj.name_utf8 or "无名", 
                            obj.type or "未知", 
                            tostring(obj.isActive), 
                            tostring(obj.is_selectable),
                            obj.grid_x or 0,
                            obj.grid_y or 0))
                        
                        if obj.name_utf8 and 
                        poe2_api.table_contains(valid_objects, obj.name_utf8) and
                        obj.isActive and 
                        obj.is_selectable and
                        obj.grid_x and obj.grid_y then
                            
                            local obj_distance = poe2_api.point_distance(obj.grid_x, obj.grid_y, player_info)
                            if obj_distance then
                                poe2_api.dbgp(string.format("对象 %s 距离: %.2f", obj.name_utf8, obj_distance))
                                
                                if obj_distance <= 20 then
                                    poe2_api.dbgp("找到符合条件的交互对象: " .. obj.name_utf8)
                                    return obj
                                end
                            end
                        end
                    end
                    
                    poe2_api.dbgp("未找到符合条件的交互对象")
                    return false
                end
                
                local target = get_range()
                if target then
                    poe2_api.dbgp(string.format("与对象交互: %s, 坐标=(%d,%d)", target.name_utf8, target.grid_x, target.grid_y))
                    api_ClickMove(poe2_api.toInt(target.grid_x), poe2_api.toInt(target.grid_y),  0)
                    api_Sleep(500)
                    api_ClickMove(poe2_api.toInt(target.grid_x), poe2_api.toInt(target.grid_y),  1)
                    api_Sleep(500)
                    poe2_api.find_text({UI_info = env.UI_info, text = target.name_utf8, click = 2, refresh = true, min_x = 0})
                    api_Sleep(500)
                else
                    poe2_api.dbgp("没有找到可交互对象，尝试向队长移动")
                end
                
                local leader = check_pos(team_member_3)
                if leader then
                    local leader_point = poe2_api.move_towards({player_info.grid_x, player_info.grid_y}, {leader.grid_x, leader.grid_y}, 20)
                    api_ClickMove(poe2_api.toInt(leader_point[1]), poe2_api.toInt(leader_point[2]),  0)
                    api_Sleep(500)
                    poe2_api.click_keyboard("space")
                end
                
                env.path_list_follow = {}
                env.target_point_follow = nil
                return bret.RUNNING
                
            elseif player_info.isMoving or player_info.life == 0 then
                poe2_api.dbgp("重置翻滚时间: 移动距离超过阈值或玩家死亡")
                env.roll_time = nil                
            end

            if env.exit_time > 60 * 1000 and not player_info.isMoving and player_info.life > 0 then
                poe2_api.dbgp("移动到远点大号位置模块超时小退")
                env.exit_time = nil
                if not poe2_api.table_contains(self.special_maps, player_info.current_map_name_utf8) and 
                    player_info.life > 0 and 
                    not poe2_api.is_have_mos({range_info = range_info, player_info = player_info}) and 
                    not player_info.isInBossBattle then
                    poe2_api.dbgp("满足小退条件，执行小退")
                    env.is_timeout_exit = true
                    return bret.RUNNING
                else
                    poe2_api.dbgp("不满足小退条件")
                end
            elseif player_info.isMoving or player_info.life == 0 then
                poe2_api.dbgp("重置退出时间: 移动距离超过阈值或玩家死亡")
                env.exit_time = nil    
            end

            -- 执行移动（按时间间隔）
            if current_time - self.last_move_time >= move_interval * 1000 then
                poe2_api.dbgp("执行移动检查")
                if point then
                    local dis = poe2_api.point_distance(point[1], point[2], player_info)
                    poe2_api.dbgp(string.format("目标点距离: %.2f, 坐标=(%d,%d)", dis or 0, point[1], point[2]))
                    
                    if dis and dis > 70 then
                        poe2_api.print_log("清路径10101")
                        poe2_api.dbgp("距离过远，清除路径并寻找再会点")
                        poe2_api.find_text({ UI_info = env.UI_info, text = "再會", click = 2 })
                        env.target_point_follow = nil
                        env.path_list_follow = {}
                        return bret.RUNNING
                    end
                    poe2_api.dbgp("----点击移动----")
                    if not api_ClickMove(poe2_api.toInt(point[1]), poe2_api.toInt(point[2]), 7) then
                        env.path_list_follow = {}
                        env.target_point_follow = nil
                        poe2_api.time_p("执行移动(RUNNING4) 耗时 -->", api_GetTickCount64() - current_time)
                        return bret.RUNNING
                    end
                    self.last_move_time = current_time
                else
                    poe2_api.dbgp("无目标点，无法移动")
                end
            end

            if point then
                poe2_api.dbgp("检查是否到达目标点")
                local reach_point = api_CollectReachableInCircleSimple(point[1], point[2], 15)
                local reach_sorted = poe2_api.sort_recent_point_list(reach_point,player_info.grid_x,player_info.grid_y)
                if not reach_sorted or #reach_sorted == 0 then
                    poe2_api.dbgp("未找到可达点")
                    return bret.RUNNING
                end
                local reach_distance = poe2_api.point_distance(reach_sorted[1].x, reach_sorted[1].y, player_info)
                poe2_api.dbgp(string.format("最近可达点距离: %.2f", reach_distance or 0))
                
                if reach_distance < 25 then
                    poe2_api.dbgp("已接近目标点，更新路径")
                    if env.path_list_follow and #env.path_list_follow > 0 then
                        local new_point = {env.path_list_follow[1].x, env.path_list_follow[1].y}
                        env.target_point_follow = new_point
                        table.remove(env.path_list_follow, 1)
                        poe2_api.dbgp(string.format("新目标点: (%d,%d)", new_point[1], new_point[2]))
                    end
                    poe2_api.time_p("[Move_To_Far_Leader_Point]",(api_GetTickCount64() - current_time))
                    return bret.RUNNING
                end
                env.last_position_story = {player_info.grid_x, player_info.grid_y}
            end

            poe2_api.dbgp("移动模块执行完成")
            poe2_api.time_p("[Move_To_Far_Leader_Point]",(api_GetTickCount64() - current_time))
            return bret.RUNNING
        end
    },

    -- 区域移动
    Check_Target_Point = {
        run = function(self, env)
            poe2_api.dbgp("区域移动模块开始执行...")
            poe2_api.print_log("区域移动模块开始执行...")
            local player_info = env.player_info
            local current_map_info = env.current_map_info
            local current_map = player_info.current_map_name_utf8
            local entrancelist = env.entrancelist
            local interaction_object = env.interaction_object
            local interaction_object_map_name = env.interaction_object_map_name
            local range_info = env.range_info
            local boss_name = env.boss_name
            local path_list = env.path_list
            local current_time = api_GetTickCount64()
            local team_member_2 = poe2_api.get_team_info(env.team_info,env.user_config,player_info,2)
            local special_maps_1 = {"3_17" }
            local special_maps_2 = current_map
            local special_maps_3 = {"G3_2_2"}
            local exclude_items = {"門", "中型靈魂核心", "壓桿","瘋狂讚美詩"}
            local exclude_items_map = {"RitualRune",'娜瓦莉'}
            local point = nil
            local UI_info = env.UI_info

            -- 检查两个表 t1 和 t2 是否有共同的元素
            local function has_common_element(t1, t2)
                if t1 == nil or t2 == nil or type(t1) ~= "table" or type(t2) ~= "table" then
                    return false
                end
                for _, v1 in ipairs(t1) do
                    for _, v2 in ipairs(t2) do
                        if v1 == v2 then return true end
                    end
                end
                return false
            end
            if path_list and #path_list > 1 then
                poe2_api.dbgp("[Check_Target_Point] path_list有路径")
                return bret.SUCCESS
            end
            if player_info.isInBossBattle and poe2_api.is_have_boss_distance(range_info, player_info,boss_name,100) then
                poe2_api.dbgp("检测到boss")
                return bret.RUNNING
            end
            if poe2_api.table_contains(current_map,my_game_info.hideout) then
                poe2_api.dbgp("在城镇")
                return bret.RUNNING
            end
            if interaction_object and not has_common_element(exclude_items, interaction_object) then
                poe2_api.dbgp("[check_target_point]检测到交互对象")
                if poe2_api.find_text({ UI_info = UI_info, text = interaction_object[1] }) and (team_member_2 == "大號名" or current_map == "G1_1") then
                    env.end_point = nil
                    env.is_arrive_end = true
                    return bret.SUCCESS
                end
            end
            if interaction_object_map_name and not has_common_element(exclude_items_map, interaction_object_map_name) then
                poe2_api.dbgp("[check_target_point]检测到小地图对象")
                for _,actor in ipairs(current_map_info) do
                    if actor.name_utf8 and poe2_api.table_contains(actor.name_utf8, interaction_object_map_name) then
                        if poe2_api.point_distance(actor.grid_x, actor.grid_y, player_info) < 50 then
                            env.end_point = nil
                            env.is_arrive_end = true
                            return bret.SUCCESS
                        end
                    end
                end
            end
            if poe2_api.table_contains(team_member_2,{"大號名","未知"}) then
                poe2_api.dbgp("设置大号探索范围")
                special_map = {"G1_2","G1_12","G1_13_1","G1_13_2","G1_15","G2_3",
                        "G2_2","G2_4_1","G2_6","G2_8","G2_9_2",
                        "G3_2_2","G3_3","G3_6_1","G3_7","G3_12","G3_17",
                }
                if poe2_api.table_contains(special_map,current_map) then
                    if poe2_api.table_contains(current_map,{"G3_2_2","G3_6_1"}) then
                        poe2_api.dbgp("大号探索范围50")
                        point = api_GetUnexploredArea(50)
                    else
                        poe2_api.dbgp("大号探索范围70")
                        point = api_GetUnexploredArea(70)
                    end
                else
                    poe2_api.dbgp("大号探索范围100")
                    point = api_GetUnexploredArea(100)
                end
            else
                poe2_api.dbgp("设置小号探索范围")
                point = api_GetUnexploredArea(100)
            end
            if not point then
                poe2_api.dbgp("没有找到未探索区域")
                return bret.RUNNING
            end
            if point.x == -1 and point.y == -1 then
                poe2_api.dbgp("探索区域已探索完毕")
                if poe2_api.table_contains(current_map, special_maps_3) then
                    api_RestoreOriginalMap()
                    local walk_point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 200)
                    if walk_point and walk_point.x ~= -1 then
                        api_ClickMove(poe2_api.toInt(walk_point.x), poe2_api.toInt(walk_point.y),7)
                    end 
                    local point = api_GetUnexploredArea(50)
                    if point and point.x == -1 then
                        api_InitExplorationArea()
                    end
                    api_Sleep(100)
                    return bret.RUNNING
                end
                -- 石碑处理
                if interaction_object and poe2_api.table_contains(interaction_object, "鐵鏽方尖碑") then
                    if not entrancelist or #entrancelist == 0 then
                        -- 初始化入口列表
                        poe2_api.dbgp("初始化鐵鏽方尖碑入口列表")
                        entrancelist = {}
                        for _, a in ipairs(current_map_info) do
                            if a.name_utf8 == "RustObeliskInactive" then
                                table.insert(entrancelist, {a.grid_x, a.grid_y})
                            end
                        end
                        
                        -- 过滤距离玩家太近的点
                        poe2_api.dbgp("过滤距离玩家过近的入口点")
                        local filtered_list = {}
                        for _, p in ipairs(entrancelist) do
                            if poe2_api.point_distance(p[1], p[2], player_info) >= 100 then
                                table.insert(filtered_list, p)
                            end
                        end
                        entrancelist = filtered_list
                    end
                    
                    -- 处理每个入口点
                    for i = #entrancelist, 1, -1 do
                        local entrance = entrancelist[i]
                        if not entrance then
                            poe2_api.dbgp("入口点为空，跳过")
                            goto continue
                        end
                        
                        -- 查找路径
                        poe2_api.dbgp(string.format("查找路径到入口点 (%d, %d)", entrance[1], entrance[2]))
                        local path_result = api_FindPath(player_info.grid_x, player_info.grid_y, entrance[1], entrance[2])
                        
                        if path_result and #path_result > 0 then
                            -- 设置终点
                            env.end_point = {entrance[1], entrance[2]}
                            env.is_arrive_end = false
                            
                            -- 检查距离和UI
                            local dist_check = poe2_api.point_distance(entrance[1], entrance[2], player_info) < 50
                            local ui_check = false
                            
                            -- 检查UI文本
                            local ui_texts = {"鐵鏽方尖碑"}
                            for _, text in ipairs(ui_texts) do
                                if poe2_api.find_text({UI_info = UI_info, text = text}) then
                                    ui_check = true
                                    break
                                end
                            end
                            
                            if dist_check and ui_check then
                                -- 到达目标点且有UI显示，移除该入口
                                poe2_api.dbgp("到达目标点且检测到UI，移除入口点")
                                table.remove(entrancelist, i)
                                if #entrancelist == 0 then
                                    api_InitExplorationArea()
                                end
                                env.entrancelist = entrancelist
                                return bret.RUNNING
                            elseif dist_check and not ui_check then
                                -- 到达目标点但无UI显示，移除该入口
                                poe2_api.dbgp("到达目标点但未检测到UI，移除入口点")
                                table.remove(entrancelist, i)
                                if #entrancelist == 0 then
                                    api_InitExplorationArea()
                                end
                                env.entrancelist = entrancelist
                                return bret.RUNNING
                            else
                                -- 未到达目标点，继续移动
                                poe2_api.dbgp("继续向目标点移动")
                                env.entrancelist = entrancelist
                                return bret.SUCCESS
                            end
                        else
                            -- 无法找到路径，尝试寻找附近可达点
                            poe2_api.dbgp("无法直接到达目标点，寻找附近可达点")
                            local round_pos = api_FindNearestReachableInRange(entrance[1], entrance[2], 50)
                            
                            if round_pos then
                                local rx, ry = round_pos.x, round_pos.y
                                local round_result = api_FindPath(player_info.grid_x, player_info.grid_y, rx, ry)
                                
                                if not round_result then
                                    -- 无法到达附近点，移除该入口
                                    poe2_api.dbgp("无法到达附近点，移除入口点")
                                    table.remove(entrancelist, i)
                                    if #entrancelist == 0 then
                                        api_InitExplorationArea()
                                    end
                                    env.entrancelist = entrancelist
                                    return bret.RUNNING
                                else
                                    -- 设置附近点为终点
                                    poe2_api.dbgp("设置附近点为终点")
                                    bb.set("end_point", {rx, ry})
                                    return bret.SUCCESS
                                end
                            else
                                -- 找不到附近点，移除该入口
                                poe2_api.dbgp("找不到附近可达点，移除入口点")
                                table.remove(entrancelist, i)
                            end
                        end
                        
                        ::continue::
                    end
                    
                    return bret.RUNNING
                end
                if poe2_api.table_contains(current_map, special_maps_1) then
                    api_RestoreOriginalMap()
                end
                if current_map == special_maps_2 then
                    -- 寻找随机可行走位置
                    local rand_pos = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 50)
                    if rand_pos then
                        poe2_api.dbgp("找到随机可行走位置，执行移动")
                        
                        -- 点击移动到随机位置
                        api_ClickMove(poe2_api.toInt(rand_pos.x), poe2_api.toInt(rand_pos.y),  7)
                        
                        -- 按下空格键（可能用于交互或确认）
                        poe2_api.click_keyboard("space")
                        -- 更新地图信息
                        api_InitExplorationArea()
                        api_UpdateMapObstacles(100)
                        -- 记录时间信息并返回运行状态
                        return bret.RUNNING
                    end
                end
            else
                poe2_api.dbgp(point.x, point.y)
                env.end_point = {point.x, point.y}
                poe2_api.dbgp(env.is_arrive_end)
                poe2_api.time_p("check_target_point",(api_GetTickCount64()-current_time))
                return bret.SUCCESS
            end
        end
    },

    -- 清理遮挡页面
    Game_Block = {
        run = function(self, env)
            poe2_api.print_log("游戏阻挡处理模块开始执行...")
            poe2_api.dbgp("=== 开始处理游戏阻挡 ===")

            local current_time = api_GetTickCount64()

            local player_info = env.player_info

            -- 检查交易拒绝情况
            local refuse_click = { "等待玩家接受交易請求..." }
            if poe2_api.find_text({ UI_info = env.UI_info, text = refuse_click, min_x = 0, add_x = 253, click = 2 }) then
                poe2_api.dbgp("检测到交易请求等待，将执行拒绝操作")
                return bret.RUNNING
            end

            ---常驻
            local all_check = {
                { UI_info = env.UI_info, text = "繼續遊戲", add_x = 0, add_y = 0, click = 2 },
                { UI_info = env.UI_info, text = "寶石切割", add_x = 280, add_y = 17, click = 2 },
                { UI_info = env.UI_info, text = "技能", min_x = 0, max_y = 81,add_x = 253, click = 2 },
            }
            -- 检查单个按钮
            for _, check in ipairs(all_check) do
                if poe2_api.find_text(check) then
                    poe2_api.dbgp(string.format("检测到按钮: %s，将执行点击操作", check.text))
                    return bret.RUNNING
                end
            end


            if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                poe2_api.click_keyboard("i")
                api_Sleep(500)
                return bret.RUNNING
            end

            if poe2_api.find_text({ UI_info = env.UI_info, text = "私訊", add_x = 265, min_x = 0, max_x = 400, click = 2 }) then
                return bret.RUNNING
            end
            if poe2_api.find_text({ UI_info = env.UI_info, text = "天賦技能", min_x = 0, add_x = 215, click = 2 }) then
                return bret.RUNNING
            end
            -- 检查顶部中间页面按钮
            local top_mid_page = { "傳送" }
            if poe2_api.find_text({ UI_info = env.UI_info, text = top_mid_page, min_x = 0,max_y=30, add_x = 215, click = 2 }) then
                return bret.RUNNING
            end
            local a = poe2_api.get_game_control_by_rect({UI_info = env.UI_info,min_x = 985,min_y = 5,max_x = 1034,max_y = 47})
            if poe2_api.find_text({UI_info = env.UI_info, text="記錄點", add_x = 213, max_y = 50}) and a and next(a) then
                poe2_api.find_text({UI_info = env.UI_info, text="記錄點", click=2, add_x = 213, max_y = 50})
                return bret.RUNNING
            end
            -- 按键
            if not self.once_check then
                api_Log("检查是否在主页面11111")
                local once_check = {
                    { UI_info = env.UI_info, text = "精選", add_x = 677, min_x = 0, add_y = 10, click = 2 },
                    { UI_info = env.UI_info, text = "角色", min_x = 0, add_x = 253, click = 2 },
                    { UI_info = env.UI_info, text = "活動", min_x = 0, add_x = 253, click = 2 },
                    { UI_info = env.UI_info, text = "選項", min_x = 0, add_x = 253, click = 2 },
                    { UI_info = env.UI_info, text = "重置天賦點數", min_x = 0, add_x = 215, click = 2 },
                    { UI_info = env.UI_info, text = "黯幣", min_x = 0, min_y = 0, max_y = 81, add_x = 673, add_y = 4, click = 2 },
                    { UI_info = env.UI_info, text = "願望清單", min_x = 0, min_y = 0, max_y = 81, add_x = 673, add_y = 4, click = 2 },

                }
                -- 检查单个按钮
                for _, check in ipairs(once_check) do
                    if poe2_api.find_text(check) then
                        poe2_api.dbgp(string.format("检测到按钮: %s，将执行点击操作", check.text))
                        return bret.RUNNING
                    end
                end
                self.once_check = true
            end

            -- 藏身处特殊处理
            local current_map_info = env.current_map_info
            local function is_map_device(obj_list)
                if not obj_list or #obj_list == 0 then
                    return false
                end
                for _, i in ipairs(obj_list) do
                    if i.name_utf8 == "MapDevice" then
                        return true
                    end
                end
                return false
            end
            local map = is_map_device(current_map_info)
            if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) and map then
                poe2_api.dbgp("当前位于藏身处")

                -- 检测地图启动失败情况
                if poe2_api.find_text({ UI_info = env.UI_info, text = "啟動失敗。地圖無法進入。" }) then
                    poe2_api.dbgp("检测到地图启动失败提示，设置need_SmallRetreat为true")
                    env.need_SmallRetreat = true
                    return bret.RUNNING
                end

                local reward_click = { "任務獎勵", "獎勵" }
                if poe2_api.find_text({ UI_info = env.UI_info, text = reward_click, min_x = 100 }) then
                    poe2_api.dbgp("检测到奖励提示，将执行点击操作")
                    poe2_api.find_text({ UI_info = env.UI_info, text = reward_click, min_x = 0, add_y = 100, click = 2 })
                    if poe2_api.find_text({text = "背包",UI_info = env.UI_info, min_x = 1020,min_y=32,max_x=1600,max_y=81}) then
                        local point = poe2_api.get_space_point({ width = 2, height = 2, index = 1 })
                        if point then
                            api_ClickScreen(poe2_api.toInt(point[1]), poe2_api.toInt(point[2]), 1)
                            return bret.RUNNING
                        else
                            return bret.SUCCESS
                        end
                    else
                        poe2_api.click_keyboard("i")
                        return bret.RUNNING
                    end
                end

                --- 藏身处
                local in_safe = {
                    { UI_info = env.UI_info, text = "購買或販賣", add_x = 270, add_y = -9, click = 2 },
                    { UI_info = env.UI_info, text = "選擇藏身處", add_x = 516, click = 2 },
                    { UI_info = env.UI_info, text = "通貨交換", add_x = 300, click = 2 },
                    { UI_info = env.UI_info, text = "重組", add_x = 210, add_y = -50, click = 2 },
                    { UI_info = env.UI_info, text = "摧毀三個相似的物品，重鑄為一個新的物品", add_x = 240, min_x = 0, click = 2 },
                    { UI_info = env.UI_info, text = "回收具有品質或插槽的裝備，以獲得品質通貨和工匠碎片", add_x = 160, add_y = -60, min_x = 0, click = 2 },
                    { UI_info = env.UI_info, text = "世界地圖", min_x = 0, add_x = 215, click = 2 },
                }
                -- 检查单个按钮
                for _, check in ipairs(in_safe) do
                    if poe2_api.find_text(check) then
                        poe2_api.dbgp(string.format("检测到按钮: %s，将执行点击操作", check.text))
                        return bret.RUNNING
                    end
                end
                -- 检查背包保存提示
                local save_click = { "你無法將此背包丟置於此。請問要摧毀它嗎？" }
                if poe2_api.find_text({ UI_info = env.UI_info, text = save_click, min_x = 0, click = 2 }) then
                    poe2_api.dbgp("检测到背包保存提示，将执行保留操作")
                    return bret.RUNNING
                end
                -- 检查仓库页面
                local warehouse_page = { "倉庫", "聖域鎖櫃", "公會倉庫" }
                if poe2_api.find_text({ UI_info = env.UI_info, text = small_page, min_x = 0, add_x = 253 }) and
                    poe2_api.find_text({ UI_info = env.UI_info, text = "強調物品", min_x = 0 }) then
                    poe2_api.dbgp("检测到仓库页面，将执行点击操作")
                    poe2_api.find_text({ UI_info = env.UI_info, text = small_page, min_x = 0, click = 2, add_x = 253 })
                    return bret.RUNNING
                end

                local item = api_Getinventorys(0xd, 0)
                if item and next(item) then
                    local width = item[1].end_x - item[1].start_x
                    local height = item[1].end_y - item[1].start_y
                    local point = poe2_api.get_space_point({width=width, height=height})

                    poe2_api.dbgp(string.format("物品尺寸: 宽%d, 高%d", width, height))

                    if point then
                        poe2_api.dbgp(string.format("获取到空间点: (%d, %d)", point[1], point[2]))

                        if poe2_api.find_text("背包") then
                            poe2_api.dbgp("检测到背包文字，将执行点击操作")
                            api_ClickScreen(point[1], point[2])
                            api_Sleep(100)
                            api_ClickScreen(point[1], point[2], 1)
                            api_Sleep(500)
                        else
                            poe2_api.dbgp("未检测到背包文字，将按I键打开背包")
                            poe2_api.click_keyboard("i")
                        end
                        return bret.RUNNING
                    else
                        poe2_api.dbgp("警告: 无法获取物品空间点")
                    end
                else
                    poe2_api.dbgp("警告: 无法获取背包物品信息")
                end
            end

            poe2_api.dbgp("未检测到任何阻挡情况，模块返回SUCCESS状态")
            poe2_api.time_p("Game_Block 耗时 --> ", api_GetTickCount64() - current_time)
            return bret.SUCCESS
        end
    },

    -- 点击交互文本
    Click_Item_Text = {
        run = function(self, env)
            poe2_api.print_log("点击交互文本...")
            poe2_api.dbgp("点击交互文本...")
            local current_time = api_GetTickCount64()
            local interactive_object = env.interactive
            local player_info = env.player_info
            local current_map_info = env.current_map_info

            local path_list = env.path_list
            local need_item = env.need_item

            if not self.bool then
                self.is_click_z = false
                self.bool = true
            end

            -- 辅助函数定义
            local function check_in_map()
                if not current_map_info then
                    return nil
                end
                for _, k in ipairs(current_map_info) do
                    if k.name_utf8 == interactive_object and k.flagStatus == 0 and k.flagStatus1 == 1 and k.grid_x ~= 0 and k.grid_y ~= 0 then
                        return k
                    end
                end
                return nil
            end

            local function check_in_range(object)
                for _, k in ipairs(env.range_info) do
                    if object then
                        if k.name_utf8 == object or k.path_name_utf8 == object then
                            return k
                        end
                    end
                    if interactive_object == "MapDevice" then
                        if k.name_utf8 == "黃金製圖儀" or k.name_utf8 == "地圖裝置" then
                            return k
                        end
                    end
                    if (k.name_utf8 == interactive_object or k.path_name_utf8 == interactive_object) and k.grid_x ~= 0 and k.grid_y ~= 0 and k.is_selectable then
                        return k
                    end
                end
                return nil
            end

            local function need_move(obj, dis)
                local text = obj.baseType_utf8 or obj.name_utf8
                local x, y
                local point
                if text == "門" then
                    point = api_CollectReachableInCircleSimple(obj.grid_x, obj.grid_y, 15)
                    local point_sorted = poe2_api.sort_recent_point_list(point, player_info.grid_x, player_info.grid_y)
                    local ralet = api_FindPath(player_info.grid_x, player_info.grid_y, point_sorted[1].x, point_sorted[1].y)
                    if not ralet then
                        point = api_FindRandomWalkablePosition(obj.grid_x, obj.grid_y, 15)
                        x, y = point.x, point.y
                    else
                        x, y = point_sorted[1].x, point_sorted[1].y
                    end
                else
                    if not need_item then
                        point = api_FindNearestReachableInRange(obj.grid_x, obj.grid_y, 50)
                        x, y = point.x, point.y
                    else
                        poe2_api.dbgp("dgdvjinbvdijsknvijbiihjbjkdv")
                        x, y = obj.grid_x, obj.grid_y
                    end
                end
                poe2_api.dbgp("移动目标点:", x, y)
                local distance = poe2_api.point_distance(x, y, player_info)
                poe2_api.dbgp("距离:", distance)
                if distance and distance > dis then
                    env.end_point = { x, y }
                    return { x, y }
                end
                return false
            end

            -- 主逻辑
            if type(interactive_object) == "string" then
                local map_obj = check_in_map()
                local range_obj = check_in_range()

                local target_obj = map_obj or range_obj
                if not target_obj then
                    poe2_api.dbgp("未找到对象")
                    return bret.FAIL
                end

                local distance = poe2_api.point_distance(target_obj.grid_x, target_obj.grid_y, player_info)
                poe2_api.dbgp("交互对象: " ..
                    target_obj.name_utf8 .. " | 位置: " .. target_obj.grid_x .. "," .. target_obj.grid_y .. " | 距离: " ..
                    distance)

                if need_move(target_obj, 15) then
                    poe2_api.dbgp("移动交互对象")
                    return bret.FAIL
                end

                poe2_api.dbgp("点击交互对象")

                if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) then
                    api_Sleep(1000)
                end

                if target_obj.name_utf8 == "MapDevice" then
                    local m_list = { "黃金製圖儀", "地圖裝置" }
                    api_Sleep(800)
                    local maps = check_in_range(
                        'Metadata/Terrain/Missions/Hideouts/Objects/MapDeviceVariants/ZigguratMapDevice')
                    if poe2_api.find_text({ UI_info = env.UI_info, text = '地圖裝置', click = 2, refresh = true }) then
                        api_Sleep(100)
                        return bret.RUNNING
                    end
                    if maps then
                        -- api_ClickMove(maps.grid_x, maps.grid_y, maps.world_z + 110, 0)
                        api_ClickMove(poe2_api.toInt(maps.grid_x), poe2_api.toInt(maps.grid_y), 0)
                        api_Sleep(800)
                    end
                    for _, i in ipairs(m_list) do
                        if poe2_api.find_text({ UI_info = env.UI_info, text = i, click = 2, refresh = true }) then
                            api_Sleep(100)
                            return bret.RUNNING
                        end
                    end
                end

                if poe2_api.table_contains(my_game_info.hideout, player_info.current_map_name_utf8) and target_obj.name_utf8 ~= '傳送點' and not map_obj then
                    poe2_api.find_text({ UI_info = env.UI_info, text = interactive_object, click = 2, refresh = true })
                    api_Sleep(100)
                    return bret.RUNNING
                end

                if player_info.isMoving then
                    poe2_api.dbgp("等待静止")
                    api_Sleep(1000)
                    return bret.RUNNING
                end

                if not poe2_api.find_text({ UI_info = env.UI_info, text = interactive_object, click = 2, max_x = 1200, refresh = true }) then
                    api_ClickMove(poe2_api.toInt(target_obj.grid_x), poe2_api.toInt(target_obj.grid_y),1)
                end
                api_Sleep(100)
            else
                poe2_api.dbgp1("交互对象: " ..
                    interactive_object.name_utf8 .. " | 位置: " .. interactive_object.grid_x .. "," ..
                    interactive_object.grid_y)
                poe2_api.dbgp("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
                local a = poe2_api.point_distance(interactive_object.grid_x, interactive_object.grid_x, env.player_info)
                poe2_api.dbgp("a:", a)
                local text = ""
                local ok, value = pcall(function()
                    return interactive_object.baseType_utf8
                end)
                if ok and value ~= nil then
                    text = interactive_object.baseType_utf8
                    -- text = ""
                else
                    text = interactive_object.name_utf8
                end
                poe2_api.dbgp("text:", text)
                local point = need_move(interactive_object, 30)
                if point then
                    poe2_api.dbgp("text1:", text)
                    -- poe2_api.dbgp("移动交互对象")
                    if env.path_list and next(env.path_list) then
                        local distence = poe2_api.point_distance(env.path_list[#env.path_list].x,
                            env.path_list[#env.path_list].y, point)
                        if distence and distence > 20 and text ~= "門" then
                            poe2_api.dbgp("交互目标点，不一致，清空路径")
                            poe2_api.print_log("清路径555")
                            env.path_list = {}
                        end
                    end
                    poe2_api.dbgp("text2:", text)
                    -- poe2_api.printTable(point)
                    return bret.FAIL
                end
                if player_info.isMoving then
                    poe2_api.dbgp("等待静止")
                    api_Sleep(200)
                    return bret.RUNNING
                end
                if interactive_object and (not text or text == "" or poe2_api.table_contains(text, { "門", "聖潔神殿" }) or not poe2_api.find_text({ text = text, UI_info = env.UI_info, min_x = 200, max_y = 750, match = 2, max_x = 1200, sorted = true, click = 2 })) then
                    if poe2_api.table_contains(text, { "門", "聖潔神殿" }) then
                        if text == "門" and poe2_api.find_text({ text = "出土遺物", UI_info = env.UI_info, min_x = 200, max_y = 750, match = 2, max_x = 1200, sorted = true }) then
                            poe2_api.click_keyboard("z")
                            self.is_click_z = true
                            return bret.RUNNING
                        end
                        api_ClickMove(poe2_api.toInt(interactive_object.grid_x),poe2_api.toInt(interactive_object.grid_y), 1)
                    else
                        if env.need_item and env.need_item == interactive_object then
                            api_ClickMove(poe2_api.toInt(interactive_object.grid_x),poe2_api.toInt(interactive_object.grid_y),  1)
                        else
                            local ok, value = pcall(function()
                                return interactive_object.path_name_utf8
                            end)
                            if ok and value ~= nil then
                                if string.find("Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable", interactive_object.path_name_utf8) then
                                    poe2_api.find_text({ text = "點擊以開始祭祀", UI_info = env.UI_info, min_x = 200, max_y = 750, match = 2, max_x = 1200, sorted = true, click = 2 })
                                else
                                    api_ClickMove(poe2_api.toInt(interactive_object.grid_x),poe2_api.toInt(interactive_object.grid_y),1)
                                end
                            else
                                api_ClickMove(poe2_api.toInt(interactive_object.grid_x),poe2_api.toInt(interactive_object.grid_y), 1)
                            end
                        end
                    end
                end
                if text == "門" then
                    api_Sleep(400)
                    if self.is_click_z then
                        poe2_api.click_keyboard("z")
                        self.is_click_z = false
                    end
                    api_UpdateMapObstacles(100)
                end
                if poe2_api.table_contains(text, { "水閘門控制桿", "把手" }) then
                    api_Sleep(500)
                    poe2_api.dbgp1("点击水闸门控制杆,等待目标")
                    poe2_api.dbgp1("wait_target: ", wait_target)
                    env.wait_target = true
                end
                local ok, value = pcall(function()
                    return interactive_object.path_name_utf8
                end)
                if ok and value ~= nil then
                    if string.find("Metadata/Terrain/Leagues/Ritual/RitualRuneInteractable", interactive_object.path_name_utf8) then
                    end
                end
                poe2_api.print_log("清路径666")
                env.path_list = {}
                env.need_item = nil
                env.interactive = nil
                env.interaction_object = nil
                env.interactiontimeout = api_GetTickCount64()
                return bret.RUNNING
            end
            return bret.RUNNING
        end
    },

    -- 是否需要移动
    Is_Path_Move = {
        run = function(self, env)
            poe2_api.dbgp("是否需要移动(Is_Path_Move)...")
            poe2_api.print_log("是否需要移动(Is_Path_Move)...")
            if env.not_move then
                env.not_move = false
                return bret.SUCCESS
            end
            if env.is_arrive_end == true then
                env.end_point = nil
                poe2_api.dbgp("Is_Path_Move-清空路径")
                env.path_list = {}
                env.is_arrive_end = false
                return bret.SUCCESS
            end
            if not env.is_arrive_end then
                return bret.FAIL
            end
        end
    },

    -- 检查是否到达点(别名)
    Is_Arrive = {
        run = function(self, env)
            poe2_api.print_log("检查是否到达目标点(Is_Arrive)...")
            local current_time = api_GetTickCount64()
            local player_info = env.player_info
            local is_arrive_end_dis = 25 -- 默认值
            if player_info.life == 0 then
                poe2_api.dbgp("Is_Arrive-玩家死亡，清空路径")
                env.end_point = nil
                env.run_point = nil
                env.path_list = {}
                env.is_arrive_end = false
                env.target_point = {}
                -- return bret.FAIL
                poe2_api.dbgp("正在前往目标点...111222")
                return bret.RUNNING
            end

            -- 检查空路径
            if env.empty_path then
                env.is_arrive_end = true
                env.empty_path = false
                -- return bret.SUCCESS
                poe2_api.dbgp("正在前往目标点...111111")
                return bret.RUNNING
            end
            -- 检查是否到达终点
            local point = env.end_point
            poe2_api.printTable(point)
            if point and #point > 0 then
                dis = poe2_api.point_distance(point[1], point[2], player_info)
                poe2_api.dbgp("dis:", dis)
                poe2_api.dbgp("api_HasObstacleBetween:", api_HasObstacleBetween(point[1], point[2]))
                if api_HasObstacleBetween(point[1], point[2]) and dis and (dis < is_arrive_end_dis) then
                    poe2_api.dbgp1("有路径，有射线")
                    env.is_arrive_end = true
                    env.end_point = nil
                    env.path_list = {}
                    env.run_point = nil
                    poe2_api.time_p("检查是否到达目标点(Is_Arrive)(RUNNING1)... 耗时 --> ", api_GetTickCount64() - current_time)
                    return bret.RUNNING
                end
                env.is_arrive_end = false
                poe2_api.time_p("检查是否到达目标点(Is_Arrive)(SUCCESS2)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.SUCCESS
            else
                poe2_api.dbgp("没有路径，没有射线")
                env.is_arrive_end = false
                env.path_list = {}
                poe2_api.time_p("检查是否到达目标点(mydian)(RUNNING)... 耗时 --> ", api_GetTickCount64() - current_time)
                return bret.RUNNING
            end
        end
    },

    -- 获取路径
    GET_Path = {
        run = function(self, env)
            poe2_api.print_log("获取路径...")
            poe2_api.dbgp("获取路径...")
            local start_time = api_GetTickCount64()
            if not self.time1  then
                poe2_api.dbgp("[GET_Path] 初始化：失败次数")
                self.FAIL_count = 0
                self.time1 = 0
            end
            local start_current_time = api_GetTickCount64()

            local player_info = env.player_info
            local range_info = env.range_info
            -- 检查终点是否存在
            local point = env.end_point
            poe2_api.dbgp("终点")
            poe2_api.printTable(env.end_point)
            if not point or not next(point) then
                poe2_api.dbgp("[GET_Path] 错误：未设置终点")
                return bret.FAIL
            end

            -- 如果已有路径，使用下一个路径点
            local path_list = env.path_list

            if path_list and #path_list > 1 then
                poe2_api.dbgp("路径点数env.path_list: " .. #env.path_list)

                local dis = poe2_api.point_distance(path_list[1].x, path_list[1].y, player_info)
                if dis and dis < 20 then
                    env.target_point = { path_list[1].x, path_list[1].y }
                    -- poe2_api.dbgp("len 5465 移除已使用的点")
                    -- table.remove(path_list, 1) -- 移除已使用的点
                end
                poe2_api.dbgp(path_list[1].x, path_list[1].y)
                poe2_api.time_p("已有路径(SUCCESS) 耗时 -->", api_GetTickCount64() - start_current_time)
                return bret.SUCCESS
            end

            -- 计算最近可到达的点
            local arrive_point = api_FindNearestReachableInRange(point[1], point[2], 40)
            poe2_api.dbgp("计算最近可到达的点")
            poe2_api.dbgp(arrive_point.x, arrive_point.y)
            poe2_api.dbgp(env.end_point[1], env.end_point[2])
            if arrive_point.x == -1 and arrive_point.y == -1 then
                arrive_point.x = env.end_point[1]
                arrive_point.y = env.end_point[2]
            end
            -- 计算起点
            poe2_api.dbgp("计算起点",player_info.grid_x, player_info.grid_y)

            poe2_api.dbgp(player_info.grid_x, player_info.grid_y)
            local player_position = api_FindNearestReachableInRange(player_info.grid_x, player_info.grid_y, 50)

            local result = api_FindPath(player_position.x, player_position.y, arrive_point.x, arrive_point.y)
            poe2_api.time_p("计算路径成功 耗时 -->", api_GetTickCount64() - start_current_time,
                "两点：{" .. player_position.x .. "," .. player_position.y .. "} -> {" .. arrive_point.x .. "," .. arrive_point.y .. "}")

            if result and #result > 0 then
                -- 处理路径结果
                local result_start_current_time = api_GetTickCount64()
                result = poe2_api.extract_coordinates(result, 22)
                self.time1 = 0
                if #result > 1 then
                    table.remove(result, 1) -- 移除起点
                    poe2_api.dbgp("移除起点")
                    env.path_list = result
                    env.target_point = { result[1].x, result[1].y }
                    -- table.insert(result, {x = env.end_point[1], y = env.end_point[2]}) -- 替换end_x,end_y为实际坐标
                    table.insert(result, { x = env.end_point[1], y = env.end_point[2] }) -- 替换end_x,end_y为实际坐标

                    poe2_api.dbgp("[GET_Path] 路径计算成功，点数: " .. #result)
                end
                poe2_api.time_p("处理路径结果 耗时 -->", api_GetTickCount64() - result_start_current_time)
                return bret.SUCCESS
            else
                -- 路径计算失败处理
                poe2_api.dbgp("[GET_Path] 计算路径失败")
                if self.time1 == 0 then
                    self.time1 = api_GetTickCount64()
                end
                env.map_result = nil
                local ctime = start_time - self.time1
                poe2_api.dbgp("ctime:", ctime)
                if ctime > 30 * 1000 then
                    poe2_api.dbgp("[GET_Path] 未找到路径 45 秒，恢复初始地图")
                    api_RestoreOriginalMap()
                    if ctime > 60 * 1000 then
                        poe2_api.dbgp("[GET_Path] 未找到路径 60 秒，回城")
                        if string.find(player_info.current_map_name_utf8, "own") then
                            self.time1 = 0
                            return bret.RUNNING
                        end
                        for _, name in ipairs(my_game_info.city_map) do
                            if poe2_api.find_text({ UI_info = env.UI_info, text = name, click = 2 }) then
                                return bret.RUNNING
                            end
                        end
                        api_ClickScreen(1230, 815, 0)
                        api_Sleep(500)
                        api_ClickScreen(1230, 815, 1)
                        api_Sleep(2000)
                        return bret.RUNNING
                    end
                end
                -- 竞技场处理
                -- 获取周围指定对象grid_x,grid_y,id
                local function get_range_pos(name)
                    local actors = poe2_api.get_sorted_list(range_info, player_info)

                    for _, a in ipairs(actors) do
                        if a.name_utf8 == name then
                            return { a.grid_x, a.grid_y, a.id }
                        end
                    end
                    return nil
                end
                local arena_list = poe2_api.get_sorted_obj("競技場", range_info, player_info)
                if poe2_api.find_text({ UI_info = env.UI_info, text = "競技場" }) and arena_list and #arena_list > 0 and arena_list[1].hasLineOfSight and arena_list[1].is_selectable then
                    local arena_path = api_FindPath(player_info.grid_x, player_info.grid_y, arena_list[1].grid_x, arena_list[1].grid_y)
                    if  arena_path and #arena_path > 0 then
                        poe2_api.dbgp("競技場")
                        if poe2_api.is_have_mos({ range_info = range_info, player_info = player_info }) then
                            poe2_api.dbgp("有怪物不点击arena_list")
                            return bret.SUCCESS
                        end
                        poe2_api.find_text({ UI_info = env.UI_info, text = "競技場", click = 2 })
                        env.end_point = nil
                        env.entrancelist = {}
                        env.end_point = {}
                        return bret.RUNNING
                    end
                end
                -- 城镇处理
                if poe2_api.table_contains(player_info.current_map_name_utf8, "own") then
                    local result = api_FindNearestReachableInRange(point.x, point.y, 50)
                    api_ClickMove(poe2_api.toInt(result.x), poe2_api.toInt(result.y),0)
                    poe2_api.click_keyboard("space")
                end
                return bret.RUNNING
            end
        end
    },

    -- 点击移动
    Move_To_Target_Point = {
        run = function(self, env)
            -- 初始化逻辑直接放在 run 函数开头
            poe2_api.dbgp("点击移动 节点...")
            local start_time = api_GetTickCount64()

            if not self.last_move_time then
                poe2_api.dbgp("初始化 Move_To_Target_Point 节点...")
                self.last_move_time = api_GetTickCount64()
                self.last_point = nil
                self.movement_threshold = 15
                return bret.RUNNING -- 初始化后返回 RUNNING，等待下一帧继续执行
            end
            if env.roll_time == nil or self.current_time == nil then
                self.current_time = api_GetTickCount64()
            end

            -- 正常执行移动逻辑
            poe2_api.dbgp("移动到目标点...")
            local point = env.target_point
            if not point then
                poe2_api.dbgp("[Move_To_Target_Point] 错误：未设置目标点")
                return bret.RUNNING
            end

            local player_info = env.player_info
            if not player_info then
                poe2_api.dbgp("[Move_To_Target_Point] 错误：未设置玩家信息")
                return bret.RUNNING
            end
            local range_info = env.range_info
            env.roll_time = start_time - self.current_time
            local roll_time = env.roll_time

            -- 检查终点是否变化
            local end_point = env.end_point
            if not self.last_point and end_point then
                poe2_api.dbgp("设置last_point")
                self.last_point = end_point
            end

            -- 超时翻滚逻辑
            if roll_time > 5 * 1000 and not player_info.isMoving and player_info.life > 0 then
                poe2_api.dbgp("超时翻滚")
                -- 获取可交互对象
                local function get_range()
                    if not player_info then
                        poe2_api.dbgp("错误:player_info 为空")
                        return false
                    end

                    local valid_objects = {
                        "甕", "壺", "屍體", "巢穴", "籃子", "小雕像", "石塊",
                        "鬆動碎石", "瓶子", "盒子", "腐爛木材", "保險箱", "腐爛木材","祕寶"
                    }

                    -- 对范围对象进行排序
                    local sorted_range = poe2_api.get_sorted_list(range_info, player_info)
                    if not sorted_range then
                        poe2_api.dbgp("警告: 无法获取排序后的范围列表")
                        return false
                    end

                    poe2_api.dbgp(string.format("检查 %d 个范围内的对象", #sorted_range))

                    -- 遍历查找符合条件的对象
                    for _, obj in ipairs(sorted_range) do
                        -- 调试输出当前对象信息
                        poe2_api.dbgp(string.format("检查对象: %s (类型: %s, 激活: %s, 可选: %s)",
                            obj.name_utf8 or "无名",
                            obj.type or "未知",
                            tostring(obj.isActive),
                            tostring(obj.is_selectable)))

                        if obj.name_utf8 and
                            poe2_api.table_contains(valid_objects, obj.name_utf8) and
                            obj.isActive and
                            obj.is_selectable and
                            obj.grid_x and obj.grid_y then
                            local distance = poe2_api.point_distance(obj.grid_x, obj.grid_y, player_info)
                            poe2_api.dbgp(string.format("对象 %s 距离: %.2f", obj.name_utf8, distance))

                            if distance <= 20 then
                                poe2_api.dbgp("找到符合条件的交互对象: " .. obj.name_utf8)
                                return obj
                            end
                        end
                    end

                    poe2_api.dbgp("未找到符合条件的交互对象")
                    return false
                end
                local target = get_range()
                if target and next(target) then
                    api_ClickMove(poe2_api.toInt(target.grid_x), poe2_api.toInt(target.grid_y),0)
                    api_Sleep(300)
                    api_ClickMove(poe2_api.toInt(target.grid_x), poe2_api.toInt(target.grid_y),1)
                    api_Sleep(300)
                end
                -- 竞技场处理
                local arena_list = poe2_api.get_sorted_obj("競技場", range_info, player_info)
                if poe2_api.find_text({ UI_info = env.UI_info, text = "競技場", min_x = 0 }) and arena_list and #arena_list > 0 and arena_list[1].hasLineOfSight and arena_list[1].is_selectable then 
                    local arena_path = api_FindPath(player_info.grid_x, player_info.grid_y, arena_list[1].grid_x, arena_list[1].grid_y)
                    if  arena_path and #arena_path > 0 then
                        poe2_api.find_text({ UI_info = env.UI_info, text = "競技場", min_x = 0, click = 2 })
                        env.end_point = nil
                        poe2_api.dbgp("超时翻滚-競技場-清理path_list")
                        env.path_list = {}
                    end
                end
                if point then
                    local player_point = api_FindRandomWalkablePosition(player_info.grid_x, player_info.grid_y, 50)
                    if player_point then
                        api_ClickMove(poe2_api.toInt(player_point.x), poe2_api.toInt(player_point.y), 7)
                    end
                end
                poe2_api.click_keyboard("space")
                poe2_api.dbgp("超时翻滚-清理path_list")
                env.end_point = nil
                env.path_list = {}
                env.target_point = nil
                return bret.RUNNING
            elseif player_info.isMoving or player_info.life == 0 then
                env.roll_time = nil
            end

            local current_time = api_GetTickCount64()
            local move_interval = math.random() * 0.2 + 0.2 -- 随机间隔 0.1~0.2 秒

            -- 执行移动（按时间间隔）
            if current_time - self.last_move_time >= move_interval * 1000 then
                if point then
                    poe2_api.dbgp("----点击移动----")
                    if not api_ClickMove(poe2_api.toInt(point[1]), poe2_api.toInt(point[2]),  7) then
                        poe2_api.dbgp("点击移动失败")
                        env.path_list = {}
                        env.target_point = nil
                        env.is_arrive_end = true
                        env.end_point = nil
                        poe2_api.time_p("执行移动(RUNNING4) 耗时 -->", api_GetTickCount64() - start_time)
                        return bret.RUNNING
                    end
                    self.last_move_time = current_time
                end
            end

            -- 检查是否到达目标点
            if point then
                local dis = poe2_api.point_distance(point[1], point[2], player_info)
                -- poe2_api.dbgp("距离：" .. dis)
                if dis and dis < 25 then
                    if env.path_list and #env.path_list > 0 then
                        env.target_point = { env.path_list[1].x, env.path_list[1].y }
                        -- poe2_api.dbgp("len 5604 移除已使用的点")
                        table.remove(env.path_list, 1)  
                    end
                    poe2_api.time_p("执行移动(RUNNING5) 耗时 -->", api_GetTickCount64() - start_time)
                    return bret.RUNNING
                end
                env.last_position_story = { player_info.grid_x, player_info.grid_y }
                return bret.RUNNING
            else
                poe2_api.dbgp("没有point清理路径")
                env.end_point = nil
                env.path_list = {}
                poe2_api.time_p("执行移动 耗时 -->", api_GetTickCount64() - start_time)
                return bret.RUNNING
            end
        end
    },

}

local all_nodes = {}
for k, v in pairs(base_nodes) do all_nodes[k] = v end
if config["劇情設置"]["是否启用剧情"] then
    for k, v in pairs(plot_nodes) do all_nodes[k] = v end
else
    for k, v in pairs(custom_nodes) do all_nodes[k] = v end
end



-- 注册自定义节点
local behavior_node = require 'script.lualib.behavior3.behavior_node'
behavior_node.process(all_nodes)

-- 创建行为树环境
local env_params = {
    -- 可以在这里添加需要的环境变量
    user_config = nil, -- 用户配置
    user_info = nil, -- 用户信息
    user_map = nil, -- 地图
    player_class = nil, -- 職業
    player_spec = nil, -- 专精
    space = nil, -- 躲避
    space_monster = nil, -- 躲避怪物
    space_time = nil, -- 躲避时间
    protection_settings = nil, -- 普通保護設置
    emergency_settings = nil, -- 紧急設置
    login_state = nil, -- 登录状态，初始值为nil
    speel_ip_number = 0, -- 設置当前IP地址的数量，初始值为0
    is_game_exe = false, -- 游戏是否正在执行，初始值为false
    shouting_number = 0, -- 喊话次数，初始值为0
    area_list = {}, -- 存储区域列表，初始值为空列表
    account_state = nil, -- 账户状态，初始值为nil
    switching_lines = 0, -- 线路切换状态，初始值为0
    time_out = 0, --  超时时间，初始值为0
    skill_name = nil, -- 当前技能名称，初始值为nil
    skill_pos = nil, -- 当前技能位置，初始值为nil
    is_need_check = false, -- 是否需要检查，初始值为false
    item_name = nil, -- 当前物品名称，初始值为nil
    item_pos = nil, -- 当前物品位置，初始值为nil
    -- blackboard.set("user_config", parser)  # 用户配置
    check_all_points = false, -- 是否检查所有点，初始值为false
    path_list = {}, -- 存储路径列表，初始值为空列表
    empty_path = false, -- 路径是否为空，初始值为false
    boss_name = nil,  -- 当前boss名称，初始值为nil
    map_name = nil, -- 当前地图名称，初始值为nil
    interaction_object = nil, -- 交互对象，初始值为nil
    item_move = false, -- 物品是否移动，初始值为false
    item_end_point = {}, -- 物品的终点位置，初始值为[0, 0]
    ok = false, -- 是否确认，初始值为false
    not_need_wear = false, -- 是否不需要装备，初始值为false
    currency_check = false, -- 是否进行货币检查，初始值为false
    sell_end_point = {}, -- 卖物品的终点位置，初始值为[0,0]
    is_better = false, -- 是否更好，初始值为false
    mos_out = 0, -- 显示的数量，初始值为0
    is_arrive_end = false, -- 是否到达终点，初始值为false
    not_need_pick = false, -- 是否不需要拾取，初始值为false
    is_not_ui = false, -- 是否不是UI界面，初始值为false
    entrancelist = {}, -- 入口位置列表
    creat_new_role = false, -- 新角色
    Level_reach = false, -- 是否要刷级
    changer_leader = false, -- 是否要换队长
    send_message = false, -- 是否要发信息
    obtain_message = false, -- 是否要换接收信息
    no_item_wear = false,
    my_role = nil,
    is_set = false,
    end_point = {},
    teleport_area = nil,
    follow_role = nil,
    map_count = 0,
    task_name = nil,
    subtask_name = nil,
    special_map_point = nil, -- 第二章任务地圖特殊點
    mate_info = nil, -- 已死队员信息信息
    monster_info = nil, -- 怪物信息
    range_info = nil, -- 周围对象信息信息
    bag_info = nil, -- 背包信息
    range_item_info = nil, -- 周围装备信息
    shortcut_skill_info = nil, -- 快捷栏技能信息
    allskill_info = nil, -- 全部技能信息
    selectableskill_info = nil, -- 可选技能技能控件信息
    skill_gem_info = nil, -- 技能宝石列表信息
    team_info = nil, -- 获取队伍信息
    team_info_data = nil,-- 获取队伍数据信息
    player_info = nil, -- 人物信息
    UI_info = nil,-- UI控件信息
    skill_number = 0, -- 放技能次数
    path_bool = false, -- 跟隨超距離判斷
    interaction_object_map_name = nil,
    not_need_active = false,
    target_point = {},
    grid_x = nil,
    grid_y = nil,
    target_point_follow = nil,
    is_timeout = false,
    special_relife_point = false,
    need_identify = false,
    one_other_map = nil,
    current_map_info = nil,
    need_item = false, -- 异界可拾取对象
    discard_item = nil, -- 丢弃对象
    store_item = nil, -- 存储对象
    interactive = nil, -- 交互对象
    is_shop = false, -- 是否购买
    is_map_complete = false, -- 是否是地图完成
    pick_up_timeout = {}, -- 拾取物品超时
    wait_target = false, -- 等待交互
    start_time = nil, -- 設置黑板变量 开始时间，初始化为 nil
    life_time = nil, -- 設置黑板变量 復活时间，初始化为 nil
    last_end_point = {},-- 設置黑板变量 終點，初始化为 0
    priority_map = nil, -- 優先打地圖詞綴,
    last_exception_time = nil,
    need_ReturnToTown = false,
    need_SmallRetreat = false,
    retry_count = 0,
    error_back = false,         -- 意外退出
    map_recorded = false,       -- 地图状态记录
    mouse_check = true,         -- 检查鼠标技能
    click_grid_pos = false,     -- 补丁视角处理
    current_pair_index = 0,     -- 初始化当前兑换索引
    last_execution_time = 0,    -- 初始化当前兌換時間
    not_more_ritual = true,     -- 取消后续祭坛
    warehouse_full = nil,       -- 个仓某页是否已满
    exchange_status = false,    -- 是否兌換完成（存仓用）
    not_items_buy = false,      -- 祭祀无物品购买
    open_map_UI = false,        -- 地图ui是否打开
    is_public_warehouse = true, --共倉點金是否存儲
    is_get_plaque_node = true,  --取碑牌节点，专用是否需要取碑牌
    is_public_warehouse_plaque = true,
    last_retreat_time = 0,
    path_list_follow = nil,
    hard_chapter = false,
    map_level_dis = nil,
    is_arrive_end_dis = nil,
    end_point_attack = nil,
    path_list_attack = nil,
    target_point_attack = nil,
    is_arrive_end_attack = false,
    is_have_map = nil,
    is_strengthened_map = true, -- 是否需要强化地图
    strengthened_map_obj = nil, -- 地图强化对象22
    chapter_name = nil, -- 章节名称
    target_chapter_name = nil, -- 传送地图名
    tar_clear_name = nil,
    radius = nil, -- 范围
    target_map_name = nil,
    is_find_boss = false,
    not_interactive = nil,
    -- 是否需要滴注
    dist_ls  = false, --- 是否需要滴注
    dizhu_end = false, -- 滴注操作
    is_need_strengthen = false, -- 是否需要合成
    is_over = false , -- 是否完成滴注
    refining_list = {}, --精炼列表
    key_level = nil, -- 钥匙等级
    check_map_key = false, -- 点击地图钥匙
    exists_key = false, -- 存在地图钥匙
    map_key_name = nil, -- 地图钥匙名
    missing_refinement = {},-- # 缺少的精炼
    is_refinement = nil, --是否精炼
    key_ok = false, -- 钥匙是否可用
    warehouse_type = nil, -- 仓库类型（滴注）
    formula_list = {}, -- 配方列表（滴注）
    sorted_map = nil,
    stone_order = nil,
    is_insert_stone = nil,

    is_initialized = true,-- 初始化躲避

    not_exist_stone = {}, -- 不存在的碑牌
    is_have_stone = true, -- 是否有可插入的塔
    stone_info = nil, -- 塔信息
    not_use_stone = {}, -- 无用之塔
    -- is_insert_stone = nil,
    enter_map_click_counter = 0,
    is_get_plaque = false, -- 是否需要取碑牌
    is_timeout_exit = false, --超时小退
    afoot_altar = nil, -- 进行中的祭坛
    center_point = {}, -- 中心点
    center_radius = 0, -- 半径
    run_point = nil, -- 逃跑點
    valid_monsters = nil, -- 最近怪物
    launch_timeout = 0,
    stuck_monsters = nil,
    -- 人物自身装备 --
    item2 = nil,
    item3 = nil,
    item4 = nil,
    item5 = nil,
    item6 = nil,
    item7 = nil,
    item8 = nil,
    item9 = nil,
    item0xa = nil,
    item0xb = nil,
    not_attack_mos = nil,
    min_attack_range = nil,
    back_city = false, --回城
    click_traverse = nil,
    afoot_box = nil, -- 进行中的保险箱
    entry_length_take_map = false,
    the_update_map = nil,
    map_update_to = nil,
    amplification_use_count = 0, -- 增幅使用次数
    supreme_use_count = 0, -- 崇高使用次数
    map_up = false,
    sacrificial_refresh = 0,
    have_ritual = false,
    last_position_time = nil,
    last_position = nil,
    boss_drop = false, -- 等待boss掉落
    esc_click = 0,
    error_kill = false,
    kill_process = false,
    last_position_story = { 0, 0 },
    error_other_map = {},
    available_oils = nil,
    missing_oils = nil,
    oil_map = nil,
    last_exp_check_move = api_GetTickCount64(),
    last_exp_check = api_GetTickCount64(),
    last_exp_value_move = 0,
    last_exception_time_move = 0,

    interactiontimeout = 0, -- 记录交互超时时间
    available_configs = nil,
    find_path_FAIL = 0,

    false_times = 0,
    not_have_stackableCurrency = false,
    is_update_plaque = false, -- 是否强化碑牌
    boss_drop_time = 0, -- 等待boss掉落时间
    is_dizhu = false,
    take_rest = false,
    minimap_info = nil, -- 小地图对象记录
    buy_items = false,
    roll_time = nil,                   --翻滚时间
    exit_time = nil,                   -- 小退时间
    relife_stuck_monsters = {},        --复活队友跳怪
    map_result = nil,                  --小地图路径
    tasks_data = main_task.tasks_data, --任务列表
    npc_names = nil,                   --NPC名稱
    waypoint = nil,                    --传送点
    waypoint_screen_point = nil,       --传送点屏幕坐标
    record_map = nil,                  --记录小地图
    log_path = nil,                    --日志路径
    interaction_object_copy = nil,     --交互对象copy
    interaction_object_map_name_copy = nil, -- 交互对象所在地图名称copy
    modify_interaction = false,
    not_move = false, -- 不移动
    leader_teleport = false, --队长传送
    louti_space = true , -- 特殊情况长时间不动不移动
    boss_id_list = {}, -- 已等bossID列表
    drop_items = false, -- 回城时丢弃
    exchange_ratio = nil, -- 通货兑换组
    currency_ratios = {}, -- 物品对应数量组
    enough_currency = true, -- 是否足够兑换
    -- 兑换列表
    owned_currencies = {}, -- 拥有
    needed_currencies = {}, -- 需要
    E_D_ratio = nil, -- E_D比例
    prestore_list = {}, -- 预存列表
    C_D_ratio = nil, -- C_E
    return_town = false, -- 回城
    map_start_time = nil, -- 地图开始时间

    warehouse_type_interactive = nil,  -- 仓库类型交互（个仓/公仓/nil）
    hwrd_time = 0, -- 获取窗口句柄间隔
    game_window = 0,  -- 暂存的窗口句柄
    streng_map_flushed_switch = false, -- 强化地图刷新开关
    currency_name = nil, -- 使用通货物品名称
    need_sale_map = false, -- 是否需要卖地图
    full_map = false, -- 地图是否已满
    min_attack_dis = nil,
    in_exchange = false, --在兑换状态
    raw = {},                          -- 任务原始数据
    update = {},                       -- 任务更新数据
    operated_plaque = false, -- 是否操作过碑牌
    lack_of_currency = {}, -- 缺少通货

    clear_bool = false, -- 清除节点的状态记录
    not_match_id = nil,
    interactive_id = nil,
    interactive_id_list = {},
    interactive_replytime = 0,
    interactive_permanent_id_list = {},
    obj_color = nil,
    map_page_full = nil,
    interactive_timeout = nil,
    not_need_take = false,
    is_bird = false, -- 骑鸟
    is_abyss_complete = false,  -- 深渊地图是否完成
    is_abyss_time = false,  -- 是否需要等待深渊掉落
    abyss_time = 0, -- 深渊掉落时间
    page_full_list = {},
    abyss_point_list = {}, -- 深渊坐标列表
    plaque_upgrade = true,  -- 碑牌鉴定升级
    target_point_sort_list = {},  -- 目标排序列表
    is_church_completed = false, -- 教堂是否完成
    plaque_page = nil,  -- 碑牌页码
    plaque_type = nil,  -- 碑牌类型
    not_dark_gold_plaque_list = {}, -- 不存在暗金碑牌列表
    not_box_list = {}, -- 排除保险箱列表
    not_minimap_obj_list = {}, -- 小地图排除对象列表
    -- 新增性能监控配置
    debug_tree_time = true,      -- 打印整棵树耗时
    debug_all_nodes = false,     -- 不打印所有节点调试信息(避免日志过多)
    suppress_node_debug = true   -- 抑制节点调试输出
}

-- 导出模块接口 
local otherworld_bt = {}

-- 创建行为树
function otherworld_bt.create()

    local missions = nil

    -- local file = io.open(json_path, "r") -- 打开文件
    -- -- if not file then error("Failed to open config file: " .. path) end
    -- local content = file:read("*a") -- 读取全部内容 
    -- file:close()
    -- local config = json.decode(content)

    if config then
        if config["全局設置"] then
            if not config["劇情設置"]["是否启用剧情"] then
                if config["全局設置"]["剧情地图设置"] and config["全局設置"]["剧情地图设置"]["是否開啟"] then
                    missions = "main_story_map"
                elseif config["全局設置"]["跟随设置"] and config["全局設置"]["跟随设置"]["是否開啟"] then
                    missions = "follows"
                else
                    if config["全局設置"]["内存模式"] then
                        if config["全局設置"]["界域之门"] and config["全局設置"]["界域之门"]["是否開啟"] then
                            missions = "attack_target_inside_sp"
                        else
                            missions = "attack_target_inside"
                        end
                    else
                        if config["全局設置"]["界域之门"] and config["全局設置"]["界域之门"]["是否開啟"] then
                            missions = "attack_target_sp"
                        else
                            missions = "attack_target"
                        end
                    end
                end
            else
                missions = "story_complete"
            end
            
        else
            if config["全局設置"]["内存模式"] then
                if config["全局設置"]["界域之门"] and config["全局設置"]["界域之门"]["是否開啟"] then
                    missions = "attack_target_inside_sp"
                else
                    missions = "attack_target_inside"
                end
            else
                if config["全局設置"]["界域之门"] and config["全局設置"]["界域之门"]["是否開啟"] then
                    missions = "attack_target_sp"
                else
                    missions = "attack_target"
                end
            end
        end
    end
    -- local bt = behavior_tree.new("attack_target 2", env_params)
    local bt = behavior_tree.new(missions, env_params)
    -- local bt = behavior_tree.new("out_id", env_params)
    return bt
end

-- 辅助函数
local function Sleep(n)
    if n > 0 then
        os.execute("ping -n " .. tonumber(n + 1) .. " localhost > NUL")
    end
end

return otherworld_bt